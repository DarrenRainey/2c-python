# Introduction #

# Details #

День добрый.

Представляю Вам пре-релиз транслятора с питона на С.

Транслирует код питона 2.6 в соответствующий сишный,  и позволяет , тем самым, транслировать одиночные питоновские модули в binary dll и shared library.
Полученные двоичные файлы можно использовать в проектах со стандартным 2.6 питоном.

Переваривает все конструкции языка, но имеются и некоторые несовместимости:
  * Не поддерживает профилировку и отладку скомпилированного кода штатными средствами Питона - используйте сишный инструментарий для полученного Си кода
  * type() скомпилированных функций и кодовых объектов отличается от type() интерпретируемых функций и кодовых объектов при тех же атрибутах и методах
  * Не отрабатывается конструкция .copy() от скомпилированной функции, соответственно для них не работает deepcopy и нельзя сохранить в pickle скомпилированную в машинный код функцию.
  * Сейчас не поддерживается threading - это просто еще не написано
  * Также, безусловно, имеется некоторое количество багов.

Использование:
<pre>
<pre><code>	python 2c.py [options] filename.py<br>
</code></pre>
</pre>

После успешной трансляции создается файл `_c_filename.dll` или `_c_filename.so` в `site-packages` директории. Префикс `_c_` используется потому, что если .py и бинарный файл имеют одно и тоже имя (без суффикса), то запускается на интерпретацию именно .py файл. Поэтому для использования скомпилированных модулей приходится применять  конструкцию вида
```

```
import _c_filename as filename
```
```

Это сомнительное решение, кому не нравится --  def compile\_c в исходнике транслятора (комментариев нет). Сам понимаю, что по уму надо доделать систему импорта, чтобы в случае наличия бинарника более позднего, чем исходник - вызывался бы бинарник, но других необходимых доделок куча, а возня с импортом отнимет массу времени.

Не выводит никаких предупреждений. Если же при компиляции выясняется, что какая-либо конструкция выдаст ошибку -- просто генерится код, который динамически создает такую ошибку.

Не выдает подробных сообщений о синтаксических ошибках. Чтобы узнать, что именно не так - запустите под стандартным питоном.
Фактически, это просто дополнительный генератор двоичного кода к обычному питону.

Дает некоторый выигрыш в производительности (от 2 до 4.5 раз) ☺.
Если хотите получить скорость - не забывайте опцию -O3 (-O0 - O1 - O2 -O опции также доступны). Эти опции непосредственно передаются Си-шному транслятору (я использовал только GCC, так что если кто желает испытать новые грабли - попробуйте с Питоном, собранным другим транслятором). Также, используя двойные кавычки, можно передать несколько опций.