"""2c.py  -- Python-to-C compiler"""
Author = "Bulatov Vladislav"

## 2c.py is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## 2c.py is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

import types
import sys
import glob
import traceback
import gc
import os
import time
#from distutils.command import build_ext
from distutils.ccompiler import new_compiler
from optparse import OptionParser
is_pypy = 'PyPy' in sys.version

try:
    import android
    sys.argv.extend(['-c -e ', \
        '/mnt/sdcard/sl4a/scripts/zipfile.py']) # = sys.argv + [sys.argv[0]]
    sys.stdout = open(sys.argv[0] + '.log', 'w')
except:
    pass    

import warnings

from cStringIO import StringIO as _StringIO

def pprint(object, stream=None, indent=1, width=80, depth=None):
    printer = PrettyPrinter(
        stream=stream, indent=indent, width=width, depth=depth)
    printer.pprint(object)

##def pformat(object, indent=1, width=80, depth=None):
##    return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)

class PrettyPrinter:
    def __init__(self, indent=1, width=80, depth=None, stream=None):
        indent = int(indent)
        width = int(width)
        assert indent >= 0, "indent must be >= 0"
        assert depth is None or depth > 0, "depth must be > 0"
        assert width, "width must be != 0"
        self._depth = depth
        self._indent_per_level = indent
        self._width = width
        if stream is not None:
            self._stream = stream
        else:
            self._stream = sys.stdout

    def pprint(self, object):
        self._format(object, self._stream, 0, 0, {}, 0)
        self._stream.write("\n")

    def pformat(self, object):
        sio = _StringIO()
        self._format(object, sio, 0, 0, {}, 0)
###        print self._width, ' ??? '
        return sio.getvalue()

    def isrecursive(self, object):
        return self.format(object, {}, 0, 0)[2]

    def isreadable(self, object):
        s, readable, recursive = self.format(object, {}, 0, 0)
        return readable and not recursive

    def _format(self, object, stream, indent, allowance, context, level):
        level = level + 1
        objid = id(object)
        if objid in context:
            stream.write(_recursion(object))
            self._recursive = True
            self._readable = False
            return
        rep = self._repr(object, context, level - 1)
        typ = type(object)
        sepLines = len(rep) > (self._width - 1 - indent - allowance)

        if self._depth and level > self._depth:
            stream.write(rep)
            return

        r = getattr(typ, "__repr__", None)
        if issubclass(typ, dict) and r is dict.__repr__:
            stream.write('{')
            if self._indent_per_level > 1:
                stream.write((self._indent_per_level - 1) * ' ')
            length = len(object)
            if length:
                context[objid] = 1
                indent = indent + self._indent_per_level
                items = object.items()
                key, ent = items[0]
                rep = self._repr(key, context, level)
                stream.write(rep)
                stream.write(': ')
                self._format(ent, stream, indent + len(rep) + 2,
                              allowance + 1, context, level)
                if length > 1:
                    for key, ent in items[1:]:
                        rep = self._repr(key, context, level)
                        if sepLines:
                            stream.write(',\n%s%s: ' % (' '*indent, rep))
                        else:
                            stream.write(', %s: ' % rep)
                        self._format(ent, stream, indent + len(rep) + 2,
                                      allowance + 1, context, level)
                indent = indent - self._indent_per_level
                del context[objid]
            stream.write('}')
            return

        if ((issubclass(typ, list) and r == list.__repr__) or
            (issubclass(typ, tuple) and r == tuple.__repr__) or
            (issubclass(typ, set) and r == set.__repr__) or
            (issubclass(typ, frozenset) and r == frozenset.__repr__)
           ):
            length = len(object)
            if issubclass(typ, list):
                stream.write('[')
                endchar = ']'
            elif issubclass(typ, set):
                if not length:
                    stream.write('set()')
                    return
                stream.write('set([')
                endchar = '])'
##                object = sorted(object)
                indent += 4
            elif issubclass(typ, frozenset):
                if not length:
                    stream.write('frozenset()')
                    return
                stream.write('frozenset([')
                endchar = '])'
##                object = sorted(object)
                indent += 10
            else:
                stream.write('(')
                endchar = ')'
            if self._indent_per_level > 1 and sepLines:
                stream.write((self._indent_per_level - 1) * ' ')
            if length:
                context[objid] = 1
                indent = indent + self._indent_per_level
                self._format(object[0], stream, indent, allowance + 1,
                             context, level)
                if length > 1:
                    for ent in object[1:]:
                        if sepLines:
                            stream.write(',\n' + ' '*indent)
                        else:
                            stream.write(', ')
                        self._format(ent, stream, indent,
                                      allowance + 1, context, level)
                indent = indent - self._indent_per_level
                del context[objid]
            if issubclass(typ, tuple) and length == 1:
                stream.write(',')
            stream.write(endchar)
            return

        stream.write(rep)

    def _repr(self, object, context, level):
        repr, readable, recursive = self.format(object, context.copy(),
                                                self._depth, level)
        if not readable:
            self._readable = False
        if recursive:
            self._recursive = True
        return repr

    def format(self, object, context, maxlevels, level):
        return _safe_repr(object, context, maxlevels, level)


# Return triple (repr_string, isreadable, isrecursive).

def _safe_repr(object, context, maxlevels, level):
    typ = type(object)
    assert type(context) is dict
    if type(object) is str:
        if 'locale' not in sys.modules:
            return repr(object), True, False
        if "'" in object and '"' not in object:
            closure = '"'
            quotes = {'"': '\\"'}
        else:
            closure = "'"
            quotes = {"'": "\\'"}
        sio = _StringIO()
        for char in object:
            if char.isalpha():
                sio.write(char)
            else:
                sio.write(quotes.get(char, repr(char)[1:-1]))
        return ("%s%s%s" % (closure, sio.getvalue(), closure)), True, False

    r = getattr(typ, "__repr__", None)
    if issubclass(typ, dict) and r == dict.__repr__:
        if not object:
            return "{}", True, False
        objid = id(object)
        if maxlevels and level >= maxlevels:
            return "{...}", False, objid in context
        if objid in context:
            return _recursion(object), False, True
        context[objid] = 1
        readable = True
        recursive = False
        components = []
        level += 1
        for k, v in object.items():
            krepr, kreadable, krecur = _safe_repr(k, context, maxlevels, level)
            vrepr, vreadable, vrecur = _safe_repr(v, context, maxlevels, level)
            components.append("%s: %s" % (krepr, vrepr))
            readable = readable and kreadable and vreadable
            if krecur or vrecur:
                recursive = True
        del context[objid]
        return "{%s}" % ", ".join(components), readable, recursive

    if (issubclass(typ, list) and r == list.__repr__) or \
       (issubclass(typ, tuple) and r == tuple.__repr__):
        if issubclass(typ, list):
            if not object:
                return "[]", True, False
            format = "[%s]"
        elif len(object) == 1:
            format = "(%s,)"
        else:
            if not object:
                return "()", True, False
            format = "(%s)"
        objid = id(object)
        if maxlevels and level >= maxlevels:
            return format % "...", False, objid in context
        if objid in context:
            return _recursion(object), False, True
        context[objid] = 1
        readable = True
        recursive = False
        components = []
        level += 1
        for o in object:
            orepr, oreadable, orecur = _safe_repr(o, context, maxlevels, level)
            components.append(orepr)
            if not oreadable:
                readable = False
            if orecur:
                recursive = True
        del context[objid]
        return format % ", ".join(components), readable, recursive

    rep = repr(object)
    return rep, (rep and not rep.startswith('<')), False

def saferepr(object):
    return _safe_repr(object, {}, None, 0)[0]

def isreadable(object):
    return _safe_repr(object, {}, None, 0)[1]

def isrecursive(object):
    return _safe_repr(object, {}, None, 0)[2]

def _recursion(object):
    return ("<Recursion on %s with id=%s>"
            % (type(object).__name__, id(object)))

d_built = {'ArithmeticError': ArithmeticError,
'AssertionError': AssertionError,
'AttributeError': AttributeError,
'BaseException': BaseException,
#'BufferError': BufferError,
#'BytesWarning': BytesWarning,
'DeprecationWarning': DeprecationWarning,
'EOFError': EOFError,
'Ellipsis': Ellipsis,
'EnvironmentError': EnvironmentError,
'Exception': Exception,
'False': False,
'FloatingPointError': FloatingPointError,
'FutureWarning': FutureWarning,
'GeneratorExit': GeneratorExit,
'IOError': IOError,
'ImportError': ImportError,
'ImportWarning': ImportWarning,
'IndentationError': IndentationError,
'IndexError': IndexError,
'KeyError': KeyError,
'KeyboardInterrupt': KeyboardInterrupt,
'LookupError': LookupError,
'MemoryError': MemoryError,
'NameError': NameError,
'None': None,
'NotImplemented': NotImplemented,
'NotImplementedError': NotImplementedError,
'OSError': OSError,
'OverflowError': OverflowError,
'PendingDeprecationWarning': PendingDeprecationWarning,
'ReferenceError': ReferenceError,
'RuntimeError': RuntimeError,
'RuntimeWarning': RuntimeWarning,
'StandardError': StandardError,
'StopIteration': StopIteration,
'SyntaxError': SyntaxError,
'SyntaxWarning': SyntaxWarning,
'SystemError': SystemError,
'SystemExit': SystemExit,
'TabError': TabError,
'True': True,
'TypeError': TypeError,
'UnboundLocalError': UnboundLocalError,
'UnicodeDecodeError': UnicodeDecodeError,
'UnicodeEncodeError': UnicodeEncodeError,
'UnicodeError': UnicodeError,
'UnicodeTranslateError': UnicodeTranslateError,
'UnicodeWarning': UnicodeWarning,
'UserWarning': UserWarning,
'ValueError': ValueError,
'Warning': Warning,
'ZeroDivisionError': ZeroDivisionError,
##'__debug__': __debug__,
##'__doc__': __doc__,
'__import__': __import__,
##'__name__': __name__,
##'__package__': __package__,
'abs': abs,
'all': all,
'any': any,
'apply': apply,
'basestring': basestring,
#'bin': bin,
'bool': bool,
'buffer': buffer,
#'bytearray': bytearray,
#'bytes': bytes,
'callable': callable,
'chr': chr,
'classmethod': classmethod,
'cmp': cmp,
'coerce': coerce,
'compile': compile,
'complex': complex,
'copyright': copyright,
'credits': credits,
'delattr': delattr,
'dict': dict,
'dir': dir,
'divmod': divmod,
'enumerate': enumerate,
'eval': eval,
'execfile': execfile,
'exit': exit,
'file': file,
'filter': filter,
'float': float,
#'format': format,
'frozenset': frozenset,
'getattr': getattr,
'globals': globals,
'hasattr': hasattr,
'hash': hash,
'help': help,
'hex': hex,
'id': id,
'input': input,
'int': int,
'intern': intern,
'isinstance': isinstance,
'issubclass': issubclass,
'iter': iter,
'len': len,
'license': license,
'list': list,
'locals': locals,
'long': long,
'map': map,
'max': max,
'min': min,
##'next': next,
'object': object,
'oct': oct,
'open': open,
'ord': ord,
'pow': pow,
##'print': print,
'property': property,
'quit': quit,
'range': range,
'raw_input': raw_input,
'reduce': reduce,
'reload': reload,
'repr': repr,
'reversed': reversed,
'round': round,
'set': set,
'setattr': setattr,
'slice': slice,
'sorted': sorted,
'staticmethod': staticmethod,
'str': str,
'sum': sum,
'super': super,
'tuple': tuple,
'type': type,
'unichr': unichr,
'unicode': unicode,
'vars': vars,
'xrange': xrange,
'zip': zip}
if tuple(sys.version_info)[:2] > (2,5):
    d_built['BufferError'] = BufferError
    d_built['BytesWarning'] = BytesWarning
    d_built['bin'] = bin
    d_built['bytearray'] = bytearray
    d_built['bytes'] = bytes
    d_built['format'] = format
    d_built['next'] = next


if tuple(sys.version_info)[:2] > (2,6):
    d_built['memoryview'] = memoryview
#    d_built['print'] = print
d_built_inv = dict([(y,x) for x,y in d_built.iteritems()])

import math
import StringIO
import operator
import csv
import distutils.core

out = -1
out3 = -1
debug = False
filename = ""

global Pass
global Prev_Time
global Prev_Pass
global Pass_Exit 
Pass = {}
Prev_Time = None
Prev_Pass = None
Pass_Exit = None

tags_one_step_expr = ('CONST', 'FAST', 'BUILTIN', 'TYPED_TEMP', \
                      'LOAD_CLOSURE', 'PY_TEMP', \
#                      'CODEFUNC', \
                      'f->f_locals', \
                      'bdict', 'CALC_CONST', 'PY_TYPE')

TRUE = ('CONST', True) #True #cmd2mem(('LOAD_CONST', True))

pos__a = pos__b = pos__c = pos__d = pos__e = pos__f = pos__g = pos__h = pos__i = pos__j = pos__k = pos__l = ""

call = ('CALL_FUNCTION_VAR', 'CALL_FUNCTION_KW', 'CALL_FUNCTION_VAR_KW', 'CALL_FUNCTION', 'CALL_METHOD')

set_var = ('STORE_FAST', 'STORE_NAME', 'STORE_GLOBAL', 'STORE_DEREF')
set_any = set_var + ('PyObject_SetAttr', 'PyObject_SetItem','STORE_SLICE_LV+0',\
                     'STORE_SLICE_LV+1', 'STORE_SLICE_LV+2','STORE_SLICE_LV+3',\
                      'SET_VARS')

build_executable = False
no_compiled = {}
detected_attr_type = {}
detected_return_type = {}
default_args = {}
mnemonic_constant = {}
all_calc_const = {}
calc_const_value = {}
val_direct_code = {}
direct_code = {}
list_import = {}
global start_sys_modules
start_sys_modules = None

redefined_builtin = {}
redefined_attribute = True
all_trin = {}

global Line2Addr
Line2Addr = []

global direct_args
direct_args = {}
redefined_all = False
count_define_set = {}
count_define_get = {}
matched_tail_label = ''
self_attr_type = {}
## global is_current & IS_DIRECT
## is_current = IS_CALLABLE_COMPILABLE
## global is_current & IS_CFUNC
## is_current & IS_CFUNC = False
IS_CFUNC = 0x1
IS_DIRECT = 0x2
IS_CODEFUNC = 0x4
IS_PCODE = 0x8
IS_CALLABLE_COMPILABLE = (IS_CFUNC | IS_CODEFUNC )
global is_current
is_current = 0
type_def = {}

list_cname_exe = []

calc_const_old_class = {}
calc_const_new_class = {}

##global generate_declaration
##generate_declaration = False

def _3(nm, attr, value):
    global all_trin
    all_trin[(nm,attr,value)] = True
##    pprint(all_trin.keys())

flag_stat = False

stat_3 = {}

def Val3(nm, attr):
    if flag_stat:
        if not (attr in stat_3):
            stat_3[attr] = 0
        stat_3[attr] += 1    
    for a,b,c in all_trin.keys():
        if nm is not None and a != nm:
            continue
        if attr is not None and b != attr:
            continue
        return c
    return None

def Is3(nm, attr, value=None):
    if flag_stat:
        if not (attr in stat_3):
            stat_3[attr] = 0
        stat_3[attr] += 1    
    for a,b,c in all_trin.keys():
        if nm is not None and a != nm:
            continue
        if attr is not None and b != attr:
            continue
        if value is not None and c != value:
            continue
        return True
    return False

def Iter3(nm, attr, value):
    if flag_stat:
        if not (attr in stat_3):
            stat_3[attr] = 0
        stat_3[attr] += 1
    ret = []
    for a,b,c in all_trin.keys():
        if nm is not None and a != nm:
            continue
        if attr is not None and b != attr:
            continue
        if value is not None and c != value:
            continue
        ret.append((a,b,c))
    return ret

linear_debug = True

def HideDebug(*args):
    pass

uniq_debug_messages = {}

def Debug(*args):
    if hide_debug:
        return
    if linear_debug:
        s = ' '.join([repr(v) for v in args])
        s = s.replace('\"', '\'')
#    if len(s) < 1998:
        uniq_debug_messages[s] = None 
    else:
        stream = StringIO.StringIO()
        for v in args:
            pprint(v, stream, 1, 98)
        ls = stream.getvalue().split('\n')
        if ls[-1] == '':
            del ls[-1]
        stream.close()
        ls.insert(0, '<<<')
        ls.append('>>>')
        for iit in ls:
            print ('-- ' + iit)
    
def FlushDebug():
    l = uniq_debug_messages.keys()
    l.sort()
    for s in l:    
        print ('-- ' + s)
    uniq_debug_messages.clear()   
        
def Fatal(msg, *args):
    FlushDebug()
    print (msg +  ' ' + str(args))
##    Debug(*args)
##    FlushDebug()
    assert False

T_OLD_CL_TYP = 'OldClassType'
T_OLD_CL_INST = 'OldClassInstance'
T_NEW_CL_TYP = 'NewClassType'
T_NEW_CL_INST = 'NewClassInstance'

def is_old_class_inst(t):
    return t[0] == T_OLD_CL_INST

def is_old_class_typ(t):
    return t[0] == T_OLD_CL_TYP

def is_new_class_inst(t):
    return t[0] == T_NEW_CL_INST

def is_new_class_typ(t):
    return t[0] == T_NEW_CL_TYP

def IsModule(t):
    return t is not None and t[0] is types.ModuleType

def IsInt(t):
    return t is not None and t[0] is int

def IsIntOnly(t):
    return t is not None and t[0] is int and t[1] is None

def IsShort(t):
    return t is not None and t[0] is int and t[1] == 'ssize'

def IsStr(t):
    return t is not None and t[0] is str

def IsLong(t):
    return t is not None and t[0] is long

def IsChar(t):
    return t is not None and t[0] is str and t[1] == 1

def IsBool(t):
    return t is not None and t[0] is bool

def IsFloat(t):
    return t is not None and t[0] is float

def IsNoneOrInt(t):
    return t is None or t[0] is int

def IsNoneOrIntOrFloat(t):
    return t is None or t[0] is int or t[0] is float

def IsKlNone(t):
    return t is not None and t[0] is types.NoneType

def IsIntOrFloat(t):
    return t is not None and (t[0] is int or t[0] is float)

def IsIntUndefSize(t):
    return t is not None and (t[0] == 'IntOrLong')

def IsTuple(t):
    return t is not None and t[0] is tuple

def IsInTupleInd(t, ind):
    t2 = t[1]
    assert type(ind) is int and ind >= 0
    if type(t2) is int and ind < t2:
        return True
    if type(t2) is tuple and ind < len(t2):
        return True
    return False

def IsList(t):
    if t is None:
        return False
    if t[0] is list:
        return True
    return False

def IsListAll(t):
    if t is None:
        return False
    if t[0] is list:
        return True
    if t[0] == T_NEW_CL_INST and Is3(t[1], 'Derived', ('!LOAD_BUILTIN', 'list')):
        return True
    return False

def IsDict(t):
    return t is not None and t[0] is dict

## def IsMayBe(t, f=None):
    ## return bool(t is not None and t[0] == 'MayBe' and (f is None or f(t[1])))

def IsNot(t, t2=None):
    if t is not None and t[0] == 'Not':
        if t2 is not None:
            return t2 in t[1]
        else:
            return True
    return False 

Kl_String = (str, None)
Kl_Unicode = (unicode, None)
if tuple(sys.version_info)[:2] > (2,5):
    Kl_ByteArray = (bytearray, None)
Kl_Char = (str, 1)
Kl_IntUndefSize = ('IntOrLong', None)
Kl_Int = (int, None)
Kl_Short = (int, 'ssize')
Kl_Float = (float, None)
Kl_List = (list, None)
Kl_Tuple = (tuple, None)
Kl_Dict = (dict, None)    
Kl_Set = (set, None)    
Kl_FrozenSet = (frozenset, None)    
Kl_Long = (long, None)
Kl_Type = (type, None)
##Kl_TypeType = Kl_Type
Kl_None = (types.NoneType, None)
Kl_File = (types.FileType, None)
Kl_Slice = (types.SliceType, None)
Kl_Buffer = (types.BufferType, None)
Kl_XRange = (types.XRangeType, None)
Kl_Boolean = (bool, None)
Kl_BuiltinFunction = (types.BuiltinFunctionType, None)
Kl_Function = (types.FunctionType, None)
Kl_StaticMethod = (types.MethodType, 'static')
Kl_ClassMethod = (types.MethodType, 'class')
Kl_Method = (types.MethodType, 'instance')
Kl_Generator = (types.GeneratorType, None)
Kl_Complex = (complex, None)
##Kl_Unicode = (unicode, None)
Kl_OldType = (T_OLD_CL_TYP, None)
Kl_OldInst = (T_OLD_CL_INST, None)
Kl_NewType = (T_NEW_CL_TYP, None)
Kl_NewInst = (T_NEW_CL_INST, None)
Kl_RegexObject = (T_OLD_CL_INST, 'RegexObject')
Kl_MatchObject = (T_OLD_CL_INST, 'MatchObject')

## Nm_Klass = {Kl_String : 'Kl_String', Kl_Int : 'Kl_Int', Kl_Float : 'Kl_Float', 
    ## Kl_List : 'Kl_List', Kl_Tuple : 'Kl_Tuple', Kl_Dict : 'Kl_Dict', 
    ## Kl_None : 'Kl_None', Kl_Boolean : 'Kl_Boolean', Kl_OldType : 'Kl_OldType', 
    ## Kl_OldInst : 'Kl_OldInst', Kl_NewType : 'Kl_NewType', Kl_NewInst : 'Kl_NewInst',
    ## Kl_File : 'Kl_File', Kl_Slice : 'Kl_Slice', Kl_XRange : 'Kl_XRange', 
    ## Kl_Buffer: 'Kl_Buffer', Kl_StaticMethod : 'Kl_StaticMethod', 
    ## Kl_ClassMethod : 'Kl_ClassMethod', Kl_Method : 'Kl_Method', 
    ## Kl_Complex : 'Kl_Complex', Kl_Char : 'Kl_Char', Kl_RegexObject : 'Kl_RegexObject',
    ## Kl_MatchObject : 'Kl_MatchObject', Kl_Set : 'Kl_Set', Kl_FrozenSet : 'Kl_FrozenSet', 
    ## Kl_Long : 'Kl_Long', Kl_Type : 'Kl_Type', # Kl_ByteArray : 'Kl_ByteArray', 
    ## Kl_Generator : 'Kl_Generator', Kl_BuiltinFunction: 'Kl_BuiltinFunction', 
    ## Kl_Function: 'Kl_Function', Kl_Short : 'Kl_Short', Kl_Unicode:'Kl_Unicode',
    ## Kl_IntUndefSize: 'Kl_IntUndefSize'}
    
def Kl_Module(a):
    return (types.ModuleType, a)

def Kl_MayBe(a):
    return ('MayBe', a)

_Kl_Simples = frozenset((Kl_List, Kl_Tuple, Kl_Int, Kl_String, Kl_Char, Kl_Dict, 
               Kl_Float, Kl_Boolean, Kl_None, Kl_File, Kl_Complex, Kl_Buffer,
               Kl_Char, Kl_Long, Kl_Type, Kl_RegexObject, Kl_Set,
               Kl_Short, 'Kl_Unicode'))

matched_i = None
matched_p = None
matched_len = -1

jump = ('JUMP', 'JUMP_CONTINUE', 'JUMP_BREAK')
_n2c = {}
global seqcode
all_co = {}
seqcode = []
##nm_attr = {}
#n_seq = 0

def subroutine_can_be_direct(nm, cnt_args):
    co = N2C(nm)
    if not hasattr(co, 'can_be_direct_call'):
        co.can_be_direct_call = can_be_direct_call(co.cmds[1])
    if co.can_be_direct_call == True:
        if co.co_flags & 0x28 == 0 and len(co.co_cellvars) == 0 and len(co.co_freevars) == 0:
            if co.co_flags & 0x4 == 0:
                return match_count_args(nm, cnt_args)
            return True
    return False

def match_count_args(nm, cnt_args):
    c_args = N2C(nm).co_argcount
    if cnt_args > c_args:
        return False
    if cnt_args < c_args:
        if nm in default_args:
            defau = default_args[nm]
            if defau is None or len(defau) == 0:
                pass
            elif defau[0] in ('CONST', '!BUILD_TUPLE'):
                cnt_args += len(defau[1])
            else:
                Fatal('Strange match_count_args', nm, defau)
            if cnt_args < c_args :
                return False
        else:
            return False    
    return True        

calculated_const = {}
pregenerated = []

known_modules = ('math', 'cmath', 'operator', 'string', 
                 'binascii', 'marshal', 're', 'struct', 'sys', 'os', 'types', 
                 'array', 'exceptions', 'Tkinter', 'ctypes', 
                 'code', 'new')

CFuncFloatOfFloat = {('math', 'exp'):'exp', ('math', 'sin'):'sin', ('math', 'cos'):'cos', ('math', 'sqrt'):'sqrt', 
                     ('math', 'sinh'):'sinh', ('math', 'cosh'):'cosh',
                     ('math', 'asin'):'asin', ('math', 'acos'):'acos', ('math', 'tan'):'tan',
                     ('math', 'atan'):'atan', ('math', 'tanh'):'tanh', ('math', 'fabs'):'fabs'}

t_imp = {}

######################(

######################)

def add_math_float(a):
    global t_imp
    for f in a:
        t_imp[('math', f, '()')] = Kl_Float
    
add_math_float(('fabs', 'factorial', 'fmod', 'fsum', 'ldexp', 'exp', 'expm1', \
                'log', 'log1p', 'log10', 'pow', 'sqrt', 'acos', 'asin', 'atan', \
                'atan2', 'hypot', 'cos', 'sin', 'tan', 'degrees', 'radians', \
                'acosh', 'asinh', 'atanh', 'cosh', 'sinh', 'tanh', 'floor',
                'erf', 'erfc', 'ldexp', 'fsum'))
    
t_imp[('math', 'frexp', '()')] = (tuple, (Kl_Float, Kl_Int))               
t_imp[('math', 'isnan', '()')] = Kl_Boolean                
t_imp[('math', 'isinf', '()')] = Kl_Boolean                

t_imp[('types', 'CodeType', 'val')] = Kl_Type
t_imp[('types', 'ModuleType', 'val')] = Kl_Type
t_imp[('types', 'NoneType', 'val')] = Kl_Type
t_imp[('types', 'FunctionType', 'val')] = Kl_Type
t_imp[('types', 'InstanceType', 'val')] = Kl_Type
t_imp[('types', 'EllipsisType', 'val')] = Kl_Type

t_imp[('random', 'random', '()')] = Kl_Float 

t_imp[('re', 'compile', '()')] = Kl_RegexObject 
t_imp[('re', 'sub', '()')] = Kl_String 
t_imp[('re', 'subn', '()')] = Kl_Tuple 
t_imp[('re', 'search', '()')] = None 
t_imp[('re', 'match', '()')] = None 
#t_imp[('array', 'array', 'val')] = Klass(T_OLD_CL_INST, 'array') 
#t_imp[('UserDict', 'UserDict', 'val')] = Klass(T_OLD_CL_INST, 'UserDict') 

t_imp[('tempfile', 'mktemp', '()')] = Kl_String               
#t_imp[('threading', 'Thread', 'val')] = Klass(T_OLD_CL_INST, 'Thread') 

t_imp[('zipfile', 'ZipFile', 'val')] = (T_OLD_CL_TYP, 'ZipFile')             
t_imp[('zipfile', 'ZipFile', '()')] = (T_OLD_CL_INST, 'ZipFile')             

t_imp[('cStringIO', 'StringIO', 'val')] = (T_NEW_CL_TYP, 'StringIO')  
      
t_imp[('inspect', 'getsourcefile', '()')] = Kl_String             
t_imp[('inspect', 'getmembers', '()')] = Kl_List    
t_imp[('inspect', 'getmodule', '()')] = None    
t_imp[('inspect', 'currentframe', '()')] = (types.FrameType, None)

t_imp[('getopt', 'getopt', '()')] = Kl_Tuple    
t_imp[('locale', 'getdefaultlocale', '()')] = Kl_Tuple  
t_imp[('locale', 'getpreferredencoding', '()')] = Kl_String    
t_imp[('codecs', 'lookup', '()')] = (T_NEW_CL_INST, 'CodecInfo')
t_imp[('tarfile', 'open', '()')] = (T_NEW_CL_INST, 'TarFile')

t_imp[('string', 'atoi', '()')] = Kl_Int               
t_imp[('string', 'atof', '()')] = Kl_Float               
t_imp[('string', 'split', '()')] = Kl_List               
t_imp[('string', 'rsplit', '()')] = Kl_List               
t_imp[('string', 'replace', '()')] = Kl_String                
t_imp[('string', 'upper', '()')] = Kl_String                
t_imp[('string', 'lower', '()')] = Kl_String                
t_imp[('string', 'strip', '()')] = Kl_String                
t_imp[('string', 'rstrip', '()')] = Kl_String                
t_imp[('string', 'rfind', '()')] = Kl_Int                
t_imp[('string', 'find', '()')] = Kl_Int                
t_imp[('string', 'rjust', '()')] = Kl_String                
t_imp[('string', 'ljust', '()')] = Kl_String                

t_imp[('code', 'InteractiveInterpreter', 'val')] = (T_NEW_CL_TYP, 'InteractiveInterpreter')               
t_imp[('code', 'InteractiveConsole', 'val')] = (T_NEW_CL_TYP, 'InteractiveConsole')               

t_imp[('cPickle', 'load', '()')] = None  
t_imp[('glob', 'glob', '()')] = Kl_List  

t_imp[('imp', 'load_source', '()')] = None  

t_imp[('copy', 'copy', '()')] = None  
t_imp[('copy', 'deepcopy', '()')] = None  
t_imp[('subprocess', 'Popen', 'val')] = (T_NEW_CL_TYP, 'Popen') 
t_imp[('tempfile', 'gettempprefix', '()')] = Kl_String  
t_imp[('tempfile', 'mkdtemp', '()')] = Kl_String  

t_imp[('doctest', 'testmod', '()')] = Kl_Tuple  

t_imp[('time', 'ctime', '()')] = Kl_String

t_imp[('repr', 'repr', '()')] = Kl_String

t_imp[('os', 'system', '()')] = Kl_Int  
t_imp[('os', 'uname', '()')] = Kl_Tuple  
t_imp[('os', 'listdir', '()')] = Kl_List  
t_imp[('os', 'popen', '()')] = Kl_File  
t_imp[('os', 'getenv', '()')] = None  
t_imp[('os', 'getpid', '()')] = None  
t_imp[('os', 'getcwd', '()')] = Kl_String  
t_imp[('os.path', 'split', '()')] = Kl_Tuple  
t_imp[('os.path', 'join', '()')] = Kl_String  
t_imp[('os.path', 'dirname', '()')] = Kl_String  

t_imp[('urllib', 'urlretrieve', '()')] = Kl_Tuple  

t_imp[('time', 'time', '()')] = Kl_Float   
t_imp[('time', 'clock', '()')] = Kl_Float   
t_imp[('tempfile', 'gettempdir', '()')] = Kl_String   
t_imp[('parser', 'expr', '()')] = None   
t_imp[('parser', 'suite', '()')] = None   
      
t_imp[('ctypes', 'pointer', 'val')] = (T_NEW_CL_TYP, 'ctypes_pointer')   
t_imp[('ctypes', 'POINTER', '()')] = (T_NEW_CL_INST, 'ctypes_pointer')   
t_imp[('ctypes', 'sizeof', '()')] = Kl_Int 
t_imp[('ctypes', 'create_string_buffer', '()')] = None 
t_imp[('ctypes', 'c_void_p', 'val')] = (T_NEW_CL_TYP, 'ctypes_c_c_void_p')   
t_imp[('ctypes', 'c_int', 'val')] = (T_NEW_CL_TYP, 'ctypes_c_int')   
t_imp[('ctypes', 'c_uint', 'val')] = (T_NEW_CL_TYP, 'ctypes_c_uint')   
t_imp[('ctypes', 'CFUNCTYPE', 'val')] = (T_NEW_CL_TYP, 'ctypes_CFUNCTYPE')   
t_imp[('ctypes', 'Structure', 'val')] = (T_NEW_CL_TYP, 'ctypes_Structure')   
      
             
t_imp[('random', 'random', '()')] = Kl_Float                
t_imp[('binascii', 'hexlify', '()')] = Kl_String                
t_imp[('binascii', 'unhexlify', '()')] = Kl_String                
t_imp[('marshal', 'loads', '()')] = None                
t_imp[('struct', 'pack', '()')] = Kl_String                
t_imp[('struct', 'unpack', '()')] = Kl_Tuple                
t_imp[('struct', 'calcsize', '()')] = Kl_Int  
  
t_imp[('sys', 'stdin', 'val')] = Kl_File    
t_imp[('sys', 'stdout', 'val')] = Kl_File    
t_imp[('sys', 'stderr', 'val')] = Kl_File    
t_imp[('sys', 'modules', 'val')] = Kl_Dict    
t_imp[('sys', 'exc_info', '()')] = Kl_Tuple   
 
t_imp[('random', 'choice', '()')] = None
   
t_imp[('math', 'pi', 'val')] = Kl_Float   
t_imp[('exceptions', 'Exception', 'val')] = Kl_NewType   
t_imp[('struct', 'calcsize', '()')] = Kl_Int                


#################
_unjump_cmds = ('.:', '3CMP_BEG_3', 'BASE_LIST_COMPR', 'BUILD_LIST',
 'BUILD_MAP', 'BUILD_TUPLE', 'CALL_FUNCTION_1', 'CALL_FUNCTION_KW_1',
 'CALL_FUNCTION_VAR_1', 'CALL_FUNCTION_VAR_KW_1', 'CHECK_EXCEPTION',
 'COMPARE_OP', 'CONTINUE_LOOP', 'DUP_TOP', 'END_FINALLY', 'GET_ITER',
 'IMPORT_AND_STORE_AS', 'LIST_APPEND', 'LOAD_ATTR_1', 'PyObject_GetAttr',
 'LOAD_CLOSURE', 'LOAD_CODEFUNC', 'LOAD_DEREF', 'LOAD_GLOBAL',
 'LOAD_LOCALS', 'LOAD_NAME', 'MAKE_CLOSURE', 'MAKE_FUNCTION',
 'MK_CLOSURE', 'MK_FUNK', 'POP_BLOCK', 'POP_TOP', 'POP_TOP3',
 'PRINT_ITEM_0', 'PRINT_ITEM_TO_0', 'PRINT_NEWLINE_TO_0', 'ROT_THREE',
 'ROT_TWO', 'SEQ_ASSIGN_0', 'SET_VARS', 'STORE_MAP', 'STORE_SLICE+1',
 'STORE_SLICE+2', 'STORE_SLICE+3', 'STORE_SLICE+0', 'STORE_SUBSCR_0', 'STORE_ATTR_1',
 'UNPACK_SEQ_AND_STORE', 'WITH_CLEANUP', 'CONST', 'FAST', 'PyList_Append',
 'YIELD_VALUE', 'BUILD_SET')                

anagr = {}

def set_anagr(a,b):
    global anagr
    anagr[a] = b
    anagr[b] = a
    
set_anagr('JUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP_CONTINUE')
set_anagr('JUMP_IF_FALSE_POP_CONTINUE', 'JUMP_IF_TRUE_POP_CONTINUE')
set_anagr('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP')
set_anagr('JUMP_IF_FALSE_POP', 'JUMP_IF_TRUE_POP')
set_anagr('JUMP_IF_FALSE', 'JUMP_IF_TRUE')

#collect_stat = False
p2l = {}
used_cmpl = {}
used_cmp = {}
used_line = {}

matched_cmpl = {}
matched_cmp = {}
matched_line = {}

op_2_c_op = {'<':'Py_LT', '<=':'Py_LE', '==':'Py_EQ', '!=':'Py_NE',
             '>':'Py_GT', '>=':'Py_GE'} #, 'is':'Py_IS', 'is not':'Py_IS_NOT'}
c_2_op_op = {'Py_LT':'<', 'Py_LE':'<=', 'Py_EQ':'==', 'Py_NE':'!=',
             'Py_GT':'>', 'Py_GE':'>='} #, 'is':'Py_IS', 'is not':'Py_IS_NOT'}
             
## ##op_2_inv_op = {} #'<':'>=', '<=':'>', '==':'!=', '!=':'==',
             ## #'>':'<=', '>=':'<'}
## op_2_inv_op_ = {} #'<':'>', '<=':'>=', '==':'!=', '!=':'==',
             ## #'>=':'<=', '>':'<'}

recode_binary = {'BINARY_POWER': 'PyNumber_Power+Py_None', 'BINARY_MULTIPLY':'PyNumber_Multiply',
                 'BINARY_DIVIDE':'PyNumber_Divide', 'BINARY_TRUE_DIVIDE':'PyNumber_TrueDivide',
                 'BINARY_FLOOR_DIVIDE':'PyNumber_FloorDivide', 'BINARY_MODULO':'PyNumber_Remainder',
                 'BINARY_ADD':'PyNumber_Add', 'BINARY_SUBTRACT':'PyNumber_Subtract',
                 'BINARY_SUBSCR':'PyObject_GetItem', 'BINARY_LSHIFT':'PyNumber_Lshift',
                 'BINARY_RSHIFT':'PyNumber_Rshift', 'BINARY_AND':'PyNumber_And',
                 'BINARY_XOR':'PyNumber_Xor', 'BINARY_OR':'PyNumber_Or'}

recode_unary = {'UNARY_POSITIVE':'PyNumber_Positive', 'UNARY_NEGATIVE':'PyNumber_Negative',
                'UNARY_CONVERT':'PyObject_Repr', 'UNARY_INVERT':'PyNumber_Invert'}

recode_inplace = {'INPLACE_POWER':'PyNumber_InPlacePower+',
                'INPLACE_MULTIPLY':'PyNumber_InPlaceMultiply',
                'INPLACE_ADD':'PyNumber_InPlaceAdd',
                'INPLACE_SUBTRACT':'PyNumber_InPlaceSubtract',
                'INPLACE_DIVIDE':'PyNumber_InPlaceDivide',
                'INPLACE_TRUE_DIVIDE':'PyNumber_InPlaceTrueDivide',
                'INPLACE_FLOOR_DIVIDE':'PyNumber_InPlaceFloorDivide',
                'INPLACE_MODULO':'PyNumber_InPlaceRemainder',
                'INPLACE_LSHIFT':'PyNumber_InPlaceLshift',
                'INPLACE_RSHIFT':'PyNumber_InPlaceRshift',
                'INPLACE_AND':'PyNumber_InPlaceAnd',
                'INPLACE_XOR':'PyNumber_InPlaceXor',
                'INPLACE_OR':'PyNumber_InPlaceOr'}

from opcode import HAVE_ARGUMENT, hasjrel, opname, EXTENDED_ARG, \
                    hasconst, hasname, haslocal, hascompare, hasfree, cmp_op

# PARAMETERS
detect_float = True
full_pycode = True
print_cline = False
print_pyline = False
print_pycmd = False
opt_flag = []
stat_func = ''
range2for = True
enumerate2for = True
calc_ref_total = False
recalc_refcnt = False
direct_call = True
no_fastlocals = False
##c_line_exceptions = False
no_generate_comment = False
dirty_iteritems = False
hide_debug = True
##simple_generate = False
##fast_instance = True - all
###fast_global = False # It' too early - don't use
check_recursive_call = not is_pypy
expand_BINARY_SUBSCR = False
make_indent = False
line_number = True
no_build = False
inline_flag = False
print_tree_node = False
c_name = '?'
hash_compile = 0
##use_cash_refcnt = False
checkmaxref = 0

try_jump_context = [False]
dropped_temp = []

filename = ""
genfilename = ''
func = ""
current_co = None

tempgen = []
typed_gen = []

labels = []    
labl = ''

CO_GENERATOR = 0x0020

## cfuncs = {}

len_family = ('!PyObject_Size', '!PyString_GET_SIZE', '!PyString_Size', 
              '!PySet_GET_SIZE', '!PySet_Size', '!PyList_GET_SIZE',
              '!PyList_Size', '!PyTuple_GET_SIZE', '!PyTuple_Size', 
              '!PyDict_Size', '!PyUnicode_GET_SIZE', '!PyUnicode_GetSize',
              '!PyByteArray_GET_SIZE', '!PyByteArray_Size')

CFuncNeedINCREF = ('PyDict_GetItem', 'PyObject_GenericGetAttr', 'PyList_GET_ITEM', \
                   'PyTuple_GetItem', 'PyList_GetItem', 'PyTuple_GET_ITEM')
CFuncNotNeedINCREF = ('PyObject_GetAttr', 'PyObject_GetItem', \
                      'PyDict_New', 'PyNumber_Add', \
           'PyCell_Get', \
           'PyNumber_Divide', 'PyNumber_TrueDivide', 'PyNumber_Multiply', 'PyNumber_Negative', \
           'PyNumber_Power', 'PyNumber_Remainder', 'PyNumber_Subtract',\
           'PyNumber_Positive',\
           'PyNumber_Absolute',\
           'PyNumber_And', 'PyNumber_Or', 'PyNumber_Rshift', 'PyNumber_Lshift',\
           'PyNumber_InPlaceSubtract', 'PyNumber_InPlaceAdd', 'PyNumber_InPlaceAnd', \
           'PyNumber_Invert', 'PyNumber_FloorDivide', \
           'PyNumber_InPlaceMultiply', 'PyNumber_FloorDivide', 'PyNumber_Xor',\
           'PyNumber_InPlaceDivide', 'PyNumber_InPlaceTrueDivide',\
           'PyNumber_InPlaceOr', 'PyNumber_InPlaceFloorDivide',\
           'PyNumber_InPlacePower',\
           'PyNumber_InPlaceRshift',\
           'PyNumber_InPlaceLshift',\
           'PyNumber_InPlaceRemainder',\
           'PyNumber_InPlaceXor', '_GET_ITEM_2', '_GET_ITEM_1', '_GET_ITEM_0', '_GET_ITEM_LAST',\
           'PyNumber_Int', 'PyNumber_Long', 'PyNumber_Float',\
           'PyObject_Dir', 'PyObject_Format', \
           'PySlice_New', '_PyEval_ApplySlice', \
           'PyTuple_Pack', 'PyObject_Call', 'PyObject_GetIter', 'PyIter_Next',\
           'Py2CFunction_New_Simple', 'Py2CFunction_New', 'PyFunction_New', \
           'PyObject_RichCompare', 'c_LOAD_NAME',\
           'c_LOAD_GLOBAL', 'PyNumber_InPlaceAdd', '_PyEval_BuildClass',\
           'PyList_GetSlice', 'PyTuple_GetSlice', 'PySequence_GetSlice', \
           'PyInt_FromSsize_t', 'PyEval_CallObject',
           'from_ceval_BINARY_SUBSCR', 'Py_CLEAR', 'Py_BuildValue', \
           '_PyDict_NewPresized', 'PyInt_FromSsize_t', 'PyTuple_New', 'PyList_New',\
           'from_ceval_BINARY_ADD_Int', 'from_ceval_BINARY_SUBTRACT_Int',\
           'PyDict_New', 'PyDict_Copy', 'PyBool_FromLong', 'PyObject_Type', 'PyObject_Repr',\
           'PyObject_Dir', 'PySet_New', 'PyFrozenSet_New', 'PySequence_Tuple', 'PySequence_List',\
           'PyFloat_FromDouble', 'PyObject_Str', 'PyCFunction_Call', \
           'PyLong_FromVoidPtr', 'PyNumber_ToBase', 'PyInt_Type.tp_str', \
           'PyComplex_Type.tp_new',
           'PyInt_Type.tp_new', 'PyLong_Type.tp_new', 'PyFloat_Type.tp_new', \
           'PyBool_Type.tp_new', 'PyBaseObject_Type.tp_new', 'PyUnicode_Type.tp_new', \
           'PyString_FromStringAndSize', 'PyInt_FromLong', 'PyString_Format', \
           'STR_CONCAT2', 'STR_CONCAT3', 'STR_CONCAT', 'STR_CONCAT_N', \
           'PySequence_Repeat', 'FirstCFunctionCall', 'FastCall', 'FastCall0',\
           'UNICODE_CONCAT2', 'UNICODE_CONCAT3', 'c_BINARY_SUBSCR_SUBSCR_Int_Int',\
           '_c_BINARY_SUBSCR_Int', '_c_BINARY_SUBSCR_ADDED_INT',\
           'PyInstance_New', 'PyInstance_NewRaw', '_PyString_Join', '_PyList_Extend', 'PyList_AsTuple',\
           'PyDict_Keys', 'PyDict_Items', 'PyDict_Values', 'PyFile_FromString',\
           '_PyInt_Format', '_PyList_Pop')
# PyObject_Type eq o->ob_type without incref           
           
CFuncVoid =    ('PyFrame_FastToLocals', 'PyFrame_LocalsToFast', 'SETLOCAL', 'LETLOCAL', 'SETSTATIC', \
           'COPYTEMP', 'PyList_SET_ITEM', 'SET_CODE_C_FUNC', \
           '_PyEval_DoRaise', 'printf', 'Py_INCREF', 'Py_CLEAR', \
           'PyTuple_SET_ITEM', 'PyFrame_BlockSetup', 'PyFrame_BlockPop',\
           'PyErr_Restore', 'PyErr_Fetch', 'PyErr_NormalizeException',\
           '_PyEval_set_exc_info', '_PyEval_reset_exc_info', 'PyDict_Clear')      
CFuncNoCheck = ('SETLOCAL', 'LETLOCAL', 'SETSTATIC', 'COPYTEMP', 'PyList_SET_ITEM', 'SET_CODE_C_FUNC',\
            '_PyEval_DoRaise', 'PyIter_Next', 'printf', 'Py_INCREF', 'Py_CLEAR',\
            'PyInt_AsSsize_t', 'PyTuple_SET_ITEM', 'PyObject_HasAttr',\
            'PyFrame_FastToLocals', 'PyFrame_LocalsToFast', 'PyErr_ExceptionMatches',\
            'PyFloat_AS_DOUBLE', 'PyInt_AsLong', 'PyInt_AS_LONG', 'PyFloat_AsDouble',\
            '(double)PyInt_AsLong')
CFuncPyObjectRef = ('FirstCFunctionCall', 'FastCall', 'FastCall0', 'GETLOCAL', 'PyBaseObject_Type.tp_new',\
 'PyBool_FromLong', 'PyBool_Type.tp_new', 'PyCFunction_Call', 'PyCell_Get', \
 'PyDict_GetItem', 'PyDict_Items', 'PyDict_Keys', 'PyDict_New', 'PyDict_Values', 'PyDict_Copy',\
 'PyEval_CallObject', 'PyFile_FromString',\
 'PyFloat_FromDouble', 'PyFloat_Type.tp_new',\
 'PyFrozenSet_New', 'PyFunction_New', 'Py2CFunction_New_Simple', 'Py2CFunction_New', \
 'PyInstance_New', 'PyInstance_NewRaw',\
 'PyInt_FromLong', 'PyInt_FromSsize_t', 'PyInt_Type.tp_new', 'PyComplex_Type.tp_new',\
 'PyList_GET_ITEM', 'PyList_GetItem', 'PyList_New', 'PyList_AsTuple', \
 'PyLong_FromSsize_t', 'PyLong_FromVoidPtr', 'PyLong_Type.tp_new',\
 'PyNumber_Absolute', 'PyNumber_Add', 'PyNumber_And', 'PyNumber_Divide',\
 'PyNumber_FloorDivide', 'PyNumber_InPlaceAdd', 'PyNumber_InPlaceAdd',\
 'PyNumber_InPlaceAnd', 'PyNumber_InPlaceDivide', 'PyNumber_InPlaceFloorDivide',\
 'PyNumber_InPlaceLshift', 'PyNumber_InPlaceMultiply', 'PyNumber_InPlaceOr',\
 'PyNumber_InPlacePower', 'PyNumber_InPlaceRemainder', 'PyNumber_InPlaceRshift',\
 'PyNumber_InPlaceSubtract', 'PyNumber_InPlaceTrueDivide', 'PyNumber_InPlaceXor',\
 'PyNumber_Invert', 'PyNumber_Lshift', 'PyNumber_Multiply', 'PyNumber_Negative',\
 'PyNumber_Or', 'PyNumber_Positive', 'PyNumber_Power', 'PyNumber_Remainder',\
 'PyNumber_Rshift', 'PyNumber_Subtract', 'PyNumber_ToBase', 'PyNumber_TrueDivide',\
 'PyNumber_Xor', '_GET_ITEM_2', '_GET_ITEM_1', '_GET_ITEM_0', '_GET_ITEM_LAST', \
 'PyNumber_Int', 'PyNumber_Long', 'PyNumber_Float',\
 'PyObject_Call', 'PyObject_Dir', 'PyObject_GetAttr', 'PyObject_GenericGetAttr', 'PyObject_GetItem',\
 'PyObject_GetIter', 'PyObject_Repr', 'PyObject_RichCompare', 'PyObject_Str',\
 'PyObject_Type', 'PyObject_Dir', 'PyObject_Format', 'PyInt_Type.tp_str', \
 'PySequence_GetSlice', 'PySequence_List', 'PySequence_Repeat', 'PySequence_Tuple',\
 'PySet_New', 'PySlice_New', 'PyList_GetSlice', 'PyTuple_GetSlice',\
 'PyString_Format',  'PyString_FromStringAndSize',\
 'PyTuple_GET_ITEM',  'PyTuple_GetItem', 'PyTuple_New', 'PyTuple_Pack',\
 'PyUnicode_Type.tp_new', 'Py_BuildValue', \
 'STR_CONCAT2', 'STR_CONCAT3', 'STR_CONCAT', 'STR_CONCAT_N', 'UNICODE_CONCAT2', 'UNICODE_CONCAT3',\
 '_PyDict_NewPresized', '_PyEval_ApplySlice', '_PyEval_BuildClass',\
 '_PyList_Extend',  '_PyString_Join',\
 '_c_BINARY_SUBSCR_ADDED_INT', '_c_BINARY_SUBSCR_Int', 'c_BINARY_SUBSCR_SUBSCR_Int_Int',\
 'from_ceval_BINARY_ADD_Int', 'from_ceval_BINARY_SUBSCR', 'from_ceval_BINARY_SUBTRACT_Int',\
 'c_LOAD_GLOBAL', 'c_LOAD_NAME', '_PyInt_Format', '_PyList_Pop')

CFuncIntCheck = ('PyCell_Set', 'PySequence_DelSlice', \
'PyDict_DelItem', 'PyDict_SetItem', 'PyDict_Size', 'PyDict_Update', 'PyDict_Contains',\
'PyDict_MergeFromSeq2', 'PyDict_DelItem', \
'PyFunction_SetClosure', 'PyFunction_SetDefaults',\
'Py2CFunction_SetClosure', 'Py2CFunction_SetDefaults',\
'PyList_Append', 'PyList_GET_SIZE', 'PyList_Insert', 'PyList_Reverse', \
'PyList_SetItem', 'PyList_SetSlice', 'PyList_Sort', \
'PyObject_DelItem', 'PyObject_IsInstance', 'PyObject_IsSubclass', \
'PyObject_IsTrue', 'PyObject_Not', 'PyObject_RichCompareBool',\
'PyObject_SetAttr', 'PyObject_SetItem', 'PyObject_Size',\
'PySequence_Contains', 'PySet_Contains', \
'PyString_GET_SIZE', 'PyTuple_GET_SIZE', 'PySet_Size', \
'PyUnicode_GetSize', 'PySet_Add', \
'_PyEval_AssignSlice', '_PyEval_ExecStatement', '_PyEval_ImportAllFrom',\
'_PyEval_PRINT_ITEM_1', '_PyEval_PRINT_ITEM_TO_2', '_PyEval_PRINT_NEWLINE_TO_1',\
'c_Py_EQ_Int', 'c_Py_EQ_String', 'c_Py_GE_Int', 'c_Py_GE_String',\
'c_Py_GT_Int', 'c_Py_GT_String', 'c_Py_LE_Int', 'c_Py_LE_String',\
'c_Py_LT_Int', 'c_Py_LT_String', 'c_Py_NE_Int', 'c_Py_NE_String',\
'PyString_AsStringAndSize', 'PyObject_Cmp')

API_cmp_2_PyObject = ('!PySequence_Contains', '!PyObject_HasAttr', \
               '!PyObject_IsSubclass', '!PyObject_IsInstance', '!PyDict_Contains', '!PySet_Contains')

CFuncIntNotCheck = ('PyInt_AsSsize_t', 'PyObject_HasAttr', 'PyErr_ExceptionMatches')
CFuncFloatNotCheck = ('PyFloat_AS_DOUBLE', 'PyFloat_AsDouble', '(double)PyInt_AsLong')
CFuncLongNotCheck = ('PyInt_AsLong', 'PyInt_AS_LONG')
CFuncLongCheck = ('PyObject_Hash', )
               
CFuncIntAndErrCheck = ()                

set_IntCheck = set(CFuncIntCheck + CFuncLongCheck + CFuncIntAndErrCheck)

consts = []
consts_dict = {}
loaded_builtin = []

def nmrecode(n):
    if n == '<genexpr>':
        n = 'genexpr__'
    if n == '<genexp>':
        n = 'genexpr__'
    elif n == '<module>':
        n = 'Init_filename'
    elif n[:8] == '<lambda>':
        n = 'lambda_' + n[8:]
    elif n == '<dictcomp>':
        n = 'dict_comp__'
    elif n == '<setcomp>':
        n = 'set_comp__'
    return n    
    
## def C2N(c):
## #    global n_seq
    ## global _n2c, all_co
    ## if c in all_co:
        ## if hasattr(c, 'c_name'):
            ## n = c.c_name
            ## return n
    ## n = c.co_name
    ## n = nmrecode(n)
    ## if n in _n2c and not c in all_co:
        ## i = 1
        ## n2 = n
        ## while n2 in _n2c:
            ## n2 = n + repr(i)
            ## i = i + 1
        ## n = n2 
    ## if not c in all_co:       
## #        cco.n_seq = n_seq
        ## all_co[c] = True
## #        n_seq += 1
    ## c.c_name = n
    ## _n2c[n] = c   
    ## return n
 
def N2C(n):
    return _n2c[n]    

def dis(x=None):
    """Disassemble classes, methods, functions, or code.
    With no argument, disassemble the last traceback.
    """
    ## if x is None:
        ## distb()
        ## return
#    if type(x) is types.InstanceType:
#        x = x.__class__
    if hasattr(x, 'im_func'):
        x = x.im_func
    if hasattr(x, 'func_code'):
        x = x.func_code
    if hasattr(x, '__dict__'):
        items = x.__dict__.items()
        items.sort()
        for name, x1 in items:
            if type(x1) in (types.MethodType,
                            types.FunctionType,
                            types.CodeType,
                            types.ClassType):
                    dis(x1)
    elif hasattr(x, 'co_code'):
        pre_disassemble(x)
    else:
        raise TypeError ( \
              "don't know how to disassemble %s objects" % \
              type(x).__name__)

from dis import findlabels, findlinestarts
global nm_pass
nm_pass = {}

def line2addr(co):
    pairs = list(findlinestarts(co))
    pairs.sort()
    lines = {}
    for addr, line in pairs:
        if not line in lines:
            lines[line] = addr
    return lines        

prev_refcnt = 0
##t_opt = 0
def SetPass(p):
    global seqcode
##    print p
    global prev_refcnt
    global Pass, Prev_Pass, Prev_Time, Pass_Exit
##    global t_opt
    ## if 'entry_point' in _n2c:
        ## for c, cmds in seqcode:
            ## if c.co_name == 'entry_point':
                ## print p
                ## pprint(cmds)
    if p == Pass_Exit:
        Fatal('Cancelled at pass %s' % p)   
    if p in nm_pass:
        p = nm_pass[p]
    else:
        s = str(len(nm_pass))
        if len(s) < 2:
            s = '0' + s
        nm_pass[p] = s + ':' + p
        p = nm_pass[p]   
    ti = time.clock()
    if Prev_Time is not None:
        Pass[Prev_Pass] = ti - Prev_Time
    if flag_stat and not is_pypy and hasattr(sys, 'gettotalrefcount'):
        refcnt = sys.gettotalrefcount()  
        print ('After ' + str(Prev_Pass) + ' ' + str(refcnt) + ' delta = ' + str(refcnt - prev_refcnt))
        prev_refcnt = refcnt
    Prev_Time = ti
    Prev_Pass = p
    
    ## if t_opt != 0:
        ## print 'Time optimisation', t_optint.pprin
        ## t_opt = 0
     
def disassemble_base(co):
    """Disassemble a code object."""
    code = co.co_code
    labels = findlabels(code)
    linestarts = dict(findlinestarts(co))
    n = len(code)
    i = 0
    extended_arg = 0
    free = None
    cmds = []
    N = co.c_name
    cmds.append(('(BEGIN_DEF', N))
    if type(code) is str:
        while i < n:
            label = -1
            nline = -1
            opcmd, codearg, arg = (None,None,None)
            c = code[i]
            op = ord(c)
            if i in linestarts:
                nline = linestarts[i]
            if i in labels: 
                label = i
            opcmd = opname[op] #.ljust(20),
            i = i+1
            recalc = False
            if op >= HAVE_ARGUMENT:
                ## print ord(code[i]), ord(code[i+1])*256, extended_arg
                oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg
                ## print oparg, extended_arg
                extended_arg = 0
                i = i+2            
                if op == EXTENDED_ARG:
                    extended_arg = oparg*65536
                codearg = oparg  
                recalc = False
                if op in hasconst:
                    arg = co.co_consts[oparg]  
                    recalc = True
                elif op in hasname:
                    arg = co.co_names[oparg]  
                    recalc = True
                elif op in hasjrel:
                    arg = i + oparg  
                    recalc = True
                elif op in haslocal:
                    arg = co.co_varnames[oparg]  
                    recalc = True
                elif op in hascompare:
                    arg = cmp_op[oparg]   
                    recalc = True
                elif op in hasfree:
                    if free is None:
                        free = co.co_cellvars + co.co_freevars
                    arg = free[oparg]  
                    recalc = True
            ## print i, recalc, op, oparg, arg, codearg, opcmd        
            if label != -1:        
                cmds.append(('.:', label))
            if nline != -1:       
                cmds.append(('.L', nline ))
            if opcmd == 'JUMP_ABSOLUTE' or opcmd == 'JUMP_FORWARD':
                opcmd = 'JUMP'
            if opcmd == 'FOR_ITER':
                opcmd = 'J_FOR_ITER'   
            if opcmd == 'SETUP_LOOP':
                opcmd = 'J_SETUP_LOOP'   
            if opcmd == 'SETUP_EXCEPT':
                opcmd = 'J_SETUP_EXCEPT'   
            if opcmd == 'SETUP_FINALLY':
                opcmd = 'J_SETUP_FINALLY'   
            if opcmd == 'PRINT_ITEM':
                opcmd = 'PRINT_ITEM_0'   
            if opcmd == 'PRINT_ITEM_TO':
                opcmd = 'PRINT_ITEM_TO_0'   
            if opcmd == 'PRINT_NEWLINE_TO':
                opcmd = 'PRINT_NEWLINE_TO_0'   
            if opcmd == 'STORE_SUBSCR':
                opcmd = 'STORE_SUBSCR_0'   
            if opcmd == 'STORE_ATTR':
                opcmd = 'STORE_ATTR_1'   
            if opcmd == 'DELETE_ATTR':
                opcmd = 'DELETE_ATTR_1'  
            if opcmd == 'LOAD_ATTR':
                opcmd = 'LOAD_ATTR_1'   
            if opcmd == 'LOOKUP_METHOD':
                opcmd = 'LOAD_ATTR_1'   
                arg = co.co_names[oparg]
                recalc = True
            if opcmd == 'CONTINUE_LOOP':
                opcmd = 'JUMP_CONTINUE'
            if opcmd == 'POP_JUMP_IF_FALSE':
                opcmd = 'JUMP_IF_FALSE_POP'
            if opcmd == 'POP_JUMP_IF_TRUE':
                opcmd = 'JUMP_IF_TRUE_POP'
            if opcmd == 'SETUP_WITH':
                opcmd = 'J_SETUP_WITH'
            ## if opcmd ='BUILD_LIST_FROM_ARG':
                ## opcmd = 'BUILD_LIST'
            ## if type(opcmd) is str and opcmd in codes:
                ## opcmd = codes[opcmd]
            if opcmd == 'JUMP_IF_FALSE_OR_POP': 
                cmds.append(('JUMP_IF_FALSE', codearg))
                cmds.append(('POP_TOP', ))
            elif opcmd == 'JUMP_IF_TRUE_OR_POP': 
                cmds.append(('JUMP_IF_TRUE', codearg))
                cmds.append(('POP_TOP', ))
            elif recalc:
                cmds.append((opcmd, arg))
            elif arg is None and codearg is None:   
                cmds.append((opcmd,))
            elif arg is None: # and opcmd != 'LOAD_CONST':
                if opcmd in call:
                    if opcmd == 'CALL_FUNCTION':
                        opcmd = 'CALL_FUNCTION_1'
                    if opcmd == 'CALL_METHOD':
                        opcmd = 'CALL_FUNCTION_1'
                    cmds.append((opcmd, codearg & 255, (), codearg >> 8, ()))             
                else:     
                    cmds.append((opcmd,codearg))
            else:   
                cmds.append((opcmd, codearg, arg ))
            if len(cmds) > 0 and cmds[-1][0][0] == 'J':
                assert cmds[-1][1] > 0
    ## pprint(cmds)   
    co.cmds[:] = cmds       

def find_redefined_builtin(cmds):
    global redefined_all, count_define_set, count_define_get
    for i,cmd in enumerate(cmds):
        ## if cmd[0] == 'IMPORT_STAR':
            ## redefined_all = True
        if cmd[0] in ('DELETE_GLOBAL', 'STORE_GLOBAL', 'DELETE_NAME', 'STORE_NAME') and \
           cmd[1] in d_built and cmd[1] != '__doc__':
            redefined_builtin[cmd[1]] = True
        if cmd[0] in ('LOAD_GLOBAL', 'LOAD_NAME'): #, 'LOAD_DEREF', 'LOAD_CLOSURE'):
            if not (cmd[1] in count_define_get):
                count_define_get[cmd[1]] = 1
            else:    
                count_define_get[cmd[1]] += 1
            if not (cmd[1] in count_define_set):
                count_define_set[cmd[1]] = 2
        if cmd[0] in ('STORE_GLOBAL', 'STORE_NAME'):
            if cmd[1] in count_define_set:
                count_define_set[cmd[1]] += 1
            else:
                count_define_set[cmd[1]] = 1    
        if cmd[0] in ('DELETE_GLOBAL', 'DELETE_NAME'):
            if cmd[1] in count_define_set:
                count_define_set[cmd[1]] += 2
            else:
                count_define_set[cmd[1]] = 2    
        if cmd == ('IMPORT_NAME', '__builtin__') and __file__ not in ('2c.py', '2c.pyc', '2c.pyo'):
            redefined_all = True
        if cmd[0] == 'IMPORT_NAME' and cmds[i+1][0] == 'IMPORT_STAR':
            CheckExistListImport(cmd[1])
##            li = get_list_names_module_raw(cmd[1])
            if cmd[1] in list_import:
                for x in list_import[cmd[1]]:
                    if x in count_define_set:
                        count_define_set[x] += 1
                    else:
                        count_define_set[x] = 1    

def light_opt_at_cmd_level(cmds):
    for i,cmd in enumerate(cmds):
        if cmd[0] == 'LOAD_CONST' and type(cmd[1]) is types.CodeType:
            cmds[i] = ('LOAD_CODEFUNC', code_extended(cmd[1]).c_name)
    find_redefined_builtin(cmds)        
    NoGoToGo(cmds)
    revert_conditional_jump_over_uncond_jump(cmds)
    NoGoToGo(cmds)

def clear_module(nm):
    assert nm != 'sys'
    assert nm != '__name__'
    if sys.modules[nm] is None:
        del sys.modules[nm]
        return
    v = sys.modules[nm]        
    todel = []
    for k1,v1 in v.__dict__.iteritems():
        if type(v1) is types.ModuleType:
            todel.append(k1)
    for k1 in todel: 
        del v.__dict__[k1]        
    del sys.modules[nm]
    if nm in list_import:
        del list_import[nm]
    if nm in imported_modules:
        del imported_modules[nm]

def clear_after_all_files():
    global start_sys_modules
    clear_one_file()
    list_import.clear()
    self_attr_type.clear()
    if hasattr(sys, '_clear_type_cache'):
        sys._clear_type_cache()
    imported_modules.clear()
 
    start_sys_modules.clear()         
    del list_cname_exe[:]
    
def clear_one_file():
    global redefined_all
    global Pass, Prev_Time, Prev_Pass, start_sys_modules, seqcode

    direct_args.clear()
    all_co.clear()
##    nm_attr.clear()
#    n_seq = 0    
    _n2c.clear()  
    all_trin.clear()
    redefined_all = False
    count_define_set.clear()
    count_define_get.clear()
    del consts[:]
    consts_dict.clear()
    del pregenerated[:]
    del loaded_builtin[:]
    calculated_const.clear()
    Pass.clear()
    Prev_Time = None
    Prev_Pass = None
    no_compiled.clear()
    detected_attr_type.clear()
    detected_return_type.clear()
    default_args.clear()
    mnemonic_constant.clear()
    all_calc_const.clear()
    direct_code.clear()
    val_direct_code.clear()
    calc_const_value.clear()
    redefined_builtin.clear()
    uniq_debug_messages.clear()
    type_def.clear()
    fastglob.clear()
    dict_global_used_at_generator.clear()
    global_type.clear()
    local_type.clear()
    detected_global_type.clear()
    predeclared_chars.clear()
    calc_const_new_class.clear()
    calc_const_old_class.clear()
    attr_instance.clear()
    del try_jump_context[:]
    try_jump_context.append(False)
    del dropped_temp[:]
    del tempgen[:]
    del typed_gen[:]
    del labels[:]
    del g_acc2[:]
    del g_refs2[:]
    del g_len_acc[:]
    del seqcode[:]
    end_sys_modules = sys.modules.copy()
    for k in end_sys_modules:
        if k not in start_sys_modules and not k.startswith('distutils.'):
            clear_module(k)
    
    self_attr_type.clear()
    self_attr_type['object'] = {None:True}
    self_attr_type['am_pm'] = {Kl_List:True}
    self_attr_type['co_flags'] = {Kl_Int:True}
    self_attr_type['co_stacksize'] = {Kl_Int:True}
    self_attr_type['co_nlocals'] = {Kl_Int:True}
    self_attr_type['co_fistlineno'] = {Kl_Int:True}
    self_attr_type['co_argcount'] = {Kl_Int:True}
    self_attr_type['co_name'] = {Kl_String:True}
    self_attr_type['co_filename'] = {Kl_String:True}
    self_attr_type['co_lnotab'] = {Kl_String:True}
    self_attr_type['co_code'] = {Kl_String:True}
    self_attr_type['co_cellvars'] = {Kl_Tuple:True}
    self_attr_type['co_freevars'] = {Kl_Tuple:True}
    self_attr_type['co_consts'] = {Kl_Tuple:True}
    self_attr_type['co_varnames'] = {Kl_Tuple:True}
    self_attr_type['co_names'] = {Kl_Tuple:True}
      
def dump(obj):
    if not print_pycmd:
        return
    print_to(out, 'Code ' + obj.co_name)
    for attr in dir(obj):
        if attr.startswith('co_') and attr not in ( 'co_code', 'co_lnotab'):
            val = getattr(obj, attr)
            if attr == 'co_flags':
                print_to(out,"\t" + attr + ' ' + hex(val))
            elif attr in ('co_consts', 'co_name'):
                pass
            else:    
                print_to(out,"\t" + attr + ' ' + repr(val))
        
class code_extended(object):   
    def __init__(self, co, copy = False):
        if co in all_co and not copy:
            assert type(co) is not code_extended
            self.__dict__ = all_co[co].__dict__
            return
        if copy:
            assert co not in all_co and type(co) is code_extended
            self.__dict__ = co.__dict__.clone()
            return
        self.co_argcount = co.co_argcount
        self.co_nlocals = co.co_nlocals
        self.co_stacksize = co.co_stacksize
        self.co_flags = co.co_flags
        self.co_code = co.co_code
        self.co_consts = co.co_consts
        self.co_names = co.co_names
        self.co_varnames = list(co.co_varnames) ## for .index method at pypy
        self.co_freevars = co.co_freevars
        self.co_cellvars = co.co_cellvars
        self.co_filename = co.co_filename
        self.co_name = co.co_name
        self.co_firstlineno = co.co_firstlineno
        self.co_lnotab = co.co_lnotab        
        self.co_original = co

##        self.self_dict_getattr_used = False
##        self.self_dict_setattr_used = False
        self.method_old_class = False
        self.method_new_class = False
        self.method_class = None
        self.new_stacksize = 0
        self.dict_getattr_used = {}
        self.detected_type = {}
        self.detected_type_may_be = {}
        self.typed_arg_direct = {}
        self.typed_arg_direct_changed = {}
        self.cmds = []
        self.direct_cmds = None
        self.returns_direct = {}
        self.returns_cfunc = {}
        self.return_cnt = 0
        self.used_return_labels = {}    
        self.used_fastlocals = {}   
        self.list_compr_in_progress = False
        self.used_label = {}
        self.is_partly_executed = False
        self.to_exception = {}
        for i in range(co.co_argcount + bool(co.co_flags & 0x4)):
            self.used_fastlocals[co.co_varnames[i]] = True
            self.used_fastlocals[nmvar_to_loc(co.co_varnames[i])] = True
        nm = nmrecode(co.co_name)
        for i in xrange(100000):
            if i == 0:
                nm2 = nm
            else:
                nm2 = nm + repr(i)
            if nm2 not in _n2c:         
                self.c_name = nm2
                _n2c[nm2] = self   
                break
        all_co[co] = self
        seqcode.append((self, self.cmds))
        seqcode.sort()
    def __lt__(self,a):
        return self.co_firstlineno < a.co_firstlineno
    def __gt__(self,a):
        return self.co_firstlineno > a.co_firstlineno
    def __str__(self):
        return 'code_extended('+self.co_name+')'   
    def __repr__(self):
        return 'code_extended('+self.co_name+')'   
    def Use_all_fastlocals(self):
        for i in range(len(self.co_varnames)):
            self.used_fastlocals[self.co_varnames[i]] = True
            self.used_fastlocals[nmvar_to_loc(self.co_varnames[i])] = True
            
    def can_be_codefunc(self):
        n = self.c_name
        if n in no_compiled or n.startswith('__new__')  or n.startswith('__del__'):
            return False
        if self.co_flags & CO_GENERATOR:
            return False
        return True
    
    def can_be_cfunc(self):
        global no_cfunc
        if no_cfunc:
            return False
        n = self.c_name
        if n in no_compiled:
            return False
        if self.co_flags & CO_GENERATOR:
            return False
        if self.co_flags & 0x8:
            return False        
        if can_be_direct_call(self.cmds[1]) != True:
            return False
        if len(self.co_cellvars + self.co_freevars) > 0:
            return False
        ## if n == 'Out':
            ## print self
            ## print self.co_original
            ## print self.__dict__
            ## pprint(self.__dict__)
        ## func = self.c_name
        ## if func in direct_args and direct_call and self.direct_cmds == self.cmds[1] and \
           ## len(self.hidden_arg_direct) == 0 and len(self.typed_arg_direct) == 0:  
            ## return False
        return True
    
    def can_C(self):
        if self.can_be_cfunc():
            return True
        if self.can_be_codefunc():
            return True
        return False
    
    def strip_unused_fast(self):
        if len(self.co_cellvars) == 0 and len(self.co_freevars) == 0:
            cmds = self.cmds[1]
            srepr = repr(cmds)
            if 'STORE_FAST' not in srepr and 'DELETE_FAST' not in srepr:
                i = len(self.co_varnames)
                changed = False
                while i > self.co_argcount:
                    i -= 1
                    nm = self.co_varnames[i]
                    if repr(('FAST', nm)) not in srepr:
                        self.co_nlocals -= 1
                        del self.co_varnames[i]        
                        changed = True
                return changed
        return False
    
    def mark_method_class(self):
        if len(self.co_varnames) > 0 and self.co_varnames[0] == 'self' and \
                IsAnyMethod(self.co_name, self.c_name) and\
                not Is3(None, ('ClassMethod', self.co_name), self.c_name) and\
                not Is3(None, ('StaticMethod', self.co_name), self.c_name) and \
                self.co_argcount > 0 and \
                len(self.co_cellvars) == 0 and \
                len(self.co_freevars) == 0:
            li = IterMethod(self.co_name, self.c_name)
            assert len(li) == 1
            cl = li[0][0]
            self.method_class = cl
            if cl in calc_const_new_class and cl not in calc_const_old_class:
                self.method_new_class = True
            elif cl in calc_const_old_class and cl not in calc_const_new_class:
                self.method_old_class = True

    def TypeVar(self, it):
        typ = None
        if type(it) is tuple and it[0] == 'FAST':
            dete = self.detected_type
            if it[1] in dete:
                typ = dete[it[1]] 
            if it[1] not in self.co_varnames:
                Fatal('', self.co_name, self.c_name, self.co_varnames, it)
            pos = self.co_varnames.index(it[1])
            typed_arg = self.typed_arg_direct
            if pos in typed_arg and is_current & IS_DIRECT:
                typ = typed_arg[pos] 
        return typ

    def IsIntVar(self, it):
        return IsInt(self.TypeVar(it))
    
    def IsBoolVar(self, it):
        return IsBool(self.TypeVar(it))
    
    def IsCharVar(self, it):
        return self.TypeVar(it) == Kl_Char
    
    def IsRealVar(self, it):
        return IsFloat(self.TypeVar(it))
    
    def IsCVar(self, it):
        return IsCType(self.TypeVar(it))

    def ReturnType(self):
        if self.c_name in detected_return_type:
            return detected_return_type[self.c_name]
        return None

    def IsRetVoid(self):
        return self.c_name in detected_return_type and IsKlNone(detected_return_type[self.c_name])

    def IsRetBool(self):
        return self.c_name in detected_return_type and IsBool(detected_return_type[self.c_name])

    def IsRetInt(self):
        return self.c_name in detected_return_type and IsInt(detected_return_type[self.c_name])

    def IsRetFloat(self):
        return self.c_name in detected_return_type and IsFloat(detected_return_type[self.c_name])

    def IsRetChar(self):
        return self.c_name in detected_return_type and IsChar(detected_return_type[self.c_name])
    
def IsCType(t): 
    return IsInt(t) or t == Kl_Char or IsBool(t) or IsFloat(t)    

def Type2CType(t):
    if IsInt(t):
        return 'long'
    if IsBool(t):
        return 'int'
    if IsFloat(t):
        return 'double'
    if t == Kl_Char:
        return 'char'
    assert False
    
def CType2Py(o, ref2, cnm, t):
    if IsInt(t):        
        o.PushInt(ref2, cnm)
    elif IsFloat(t):  
        o.Raw(ref2, ' = PyFloat_FromDouble (', cnm, ');')
    elif IsBool(t):        
        o.Raw(ref2, ' = PyBool_FromLong(', cnm, ');')
    elif t == Kl_Char:        
        o.Raw(ref2, ' = PyString_FromStringAndSize(&', cnm, ', 1);')
    return ref2  

def pre_disassemble(_co):
#    global n_seq
    if not _co in all_co:
        co = code_extended(_co)
    else:
        co = all_co[_co]
    disassemble_base(co)
    light_opt_at_cmd_level(co.cmds)
##    co.cmds = co.cmds[:]
    
def can_be_direct_call(it):
    if tag_in_expr('!IMPORT_NAME', it):
        return 'statement IMPORT_NAME'
    if tag_in_expr('EXEC_STMT', it):
        return 'exec stmt'
    if tag_in_expr('EXEC_STMT_3', it):
        return 'exec stmt'
    if tag_in_expr('IMPORT_FROM_AS', it):
        return 'import from as'
    ## if '_getframe' in s:
        ## return 'probably get frame'
    ## if 'thread' in s:
        ## return 'probably threads'
    ## if 'Thread' in s:
        ## return 'probably threads'
    ## ## ## if tag_in_expr('(TRY', it):
        ## ## ## return 'statement try:'
    ## ## ## if tag_in_expr('(TRY_FINALLY', it):
        ## ## ## return 'statement try finally:'
    if tag_in_expr('(WITH', it):
        return 'statement with:'
    if tag_in_expr('YEILD', it):
        return 'statement yeild'
    if tag_in_expr('LOAD_NAME', it):
        return 'command LOAD_NAME'
    if tag_in_expr('!LOAD_NAME', it):
        return 'command LOAD_NAME'    
    if tag_in_expr('STORE_NAME', it):
        return 'command STORE_NAME'
    return True    

def IsBegEnd(tag):
    return type(tag) is str and tag[0] in ')('

def IsBeg(tag):
    return type(tag) is str and tag[0] == '('

def uniq_list_type(v):
    if len(v) == 1:
        return v
    v_tu = [x for x in v if x is not None and x[0] is tuple]
    v_ntu = [x for x in v if x is None or x[0] is not tuple]
    if len(v_tu) > 1:
        if Kl_Tuple in v_tu:
            v_tu = [Kl_Tuple]
    if len(v_tu) > 1:
        sdsc = [x[1] for x in v_tu]
        ls = []
        for x in sdsc:
            if type(x) is tuple:
                x = len(x)
            ls.append(x)
##        ls = [len(x) for x in sdsc]
        if max(ls) != min(ls):
            if min(ls) > 0:
                v_tu = [(tuple, min(ls))]
            else:
                v_tu = [Kl_Tuple]
        else:   
##            pprint(sdsc) 
            l = ls[0]
            ty = [{} for i in range(l)]
            ## ty = range(l)
            ## for i in range(l):
                ## ty[i] = {}
            for tu in sdsc:
                for i in range(l):
                    ty[i][tu[i]] = None
            ret = []
            for dic in ty: 
               if len(dic) == 1:
                   ret.append(dic.keys()[0])
               else:
                   ret.append(None)    
            ret = tuple(ret)
            v_tu = [(tuple, ret)]
    v = v_tu + v_ntu    
    if len(v) == 3:
        if IsStr(v[0]) and IsStr(v[1]) and IsStr(v[2]):
            return [Kl_String]
        if IsInt(v[0]) and IsInt(v[1]) and IsInt(v[2]):
            return [Kl_Int]
        if IsInt(v[0]) and IsIntUndefSize(v[1]) and IsInt(v[2]):
            return [Kl_IntUndefSize]
        if IsIntUndefSize(v[0]) and IsInt(v[1]) and IsInt(v[2]):
            return [Kl_IntUndefSize]
        if IsInt(v[0]) and IsInt(v[1]) and IsIntUndefSize(v[2]):
            return [Kl_IntUndefSize]
    if len(v) == 2:
        if IsStr(v[0]) and IsStr(v[1]):
            return [Kl_String ]
        if IsInt(v[0]) and IsInt(v[1]):
            return [Kl_Int]
        if IsIntUndefSize(v[0]) and IsInt(v[1]):
            return [Kl_IntUndefSize]
        if IsInt(v[0]) and IsIntUndefSize(v[1]):
            return [Kl_IntUndefSize]
        elif IsKlNone(v[0]) and v[1] is not None:
            return [Kl_MayBe(v[1])]
        elif IsKlNone(v[1]) and v[0] is not None:
            return [Kl_MayBe(v[0])]
    return v

def post_disassemble():
    global no_build, redefined_all, current_co, Line2Addr, detected_global_type, seqcode, is_current
    SetPass('HalfRecompile')
    ## seqcode = [(c, c.cmds) for c in all_co.itervalues()]
    ## seqcode.sort()
    is_current = IS_CALLABLE_COMPILABLE
    for current_co, cmds in seqcode:
        assert cmds is not None
        assert current_co.cmds is not None
        jump_to_continue_and_break(current_co.cmds)
        half_recompile(current_co.cmds, current_co)

    SetPass('ParseClasses-0')

    for current_co, cmds in seqcode:
        if '__metaclass__' in repr(cmds[1]):
            _3(cmds[0][1], 'HaveMetaClass', '???')

    SetPass('FirstRepl')
    single_define = [k for k,v in count_define_set.iteritems() \
                           if v == 1 and (k in count_define_get or k == '__all__')]
    for current_co, cmds in seqcode:         
        cmds[1] = ortogonal(cmds[1], repl) 

    SetPass('FindCalcConst')
    initcod = None
    for _co, cmds in seqcode:
        if cmds[0][1] == 'Init_filename':            
            initcod = cmds[1]
    do_del = []        
 
    if initcod is not None:
        initcod = [st for st in initcod if type(st) is tuple and \
                   len(st) > 0 and not IsBegEnd(st[0])]
        for st in initcod:
            for k in single_define:
                p = find_statement_calculate_const(st, k) 
                if p != False:
                    filter_founded_calc_const(p, k, do_del)
    for k in do_del:       
        if k in single_define:
            del single_define[single_define.index(k)] 
                 
    ## res = False
    SetPass('ImportManipulation')

    ## for k, attr, v in Iter3(None, 'ImportedM',None):
        ## if v in known_modules:
             ## _3(k, 'ImportedKnownM', v)
    for current_co, cmds in seqcode:
        if tag_in_expr('IMPORT_STAR', cmds[1]):
            redefined_all = True

    SetPass('UpgardeOp')
 
    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass(cmds[1], upgrade_op, None, cmds[0][1]) 
    SetPass('UpgardeOp2')

    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass_upgrade_op2(cmds[1], None, cmds[0][1]) 

    global type_def, self_attr_type, self_attr_store, self_attr_use
    type_def.clear()
 
    SetPass('RecursiveTypeDetect-1')

    for current_co, cmds in seqcode:        
        cmds[1] = recursive_type_detect(cmds[1], cmds[0][1]) 

    SetPass('UpgradeRepl-3')
    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass_upgrade_repl(cmds[1],  None, cmds[0][1]) 
    
    SetPass('UpgardeOp3')

    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass_upgrade_op2(cmds[1], None, cmds[0][1]) 
    
    SetPass('CollectTypeReturn')
    pass_detect_return_type()
 
    SetPass('ParseClasses')

    for current_co, cmds in seqcode:        
        if IsAnyClass(cmds[0][1]) and cmds[1][-1] == ('RETURN_VALUE', ('f->f_locals',)): 
            parse_class_def(cmds[0][1], cmds[1][:-1])
        if Is3(cmds[0][1], 'IsClassCreator', None) and \
           cmds[1][-1] == ('RETURN_VALUE', ('f->f_locals',)): 
            parse_for_special_slot_class(cmds[0][1], cmds[1][:-1], Val3(cmds[0][1], 'IsClassCreator'))
        tree_pass(cmds[1], collect_default_args, None, cmds[0][1])

    SetPass('UpgardeRepl-1')
    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass_upgrade_repl(cmds[1], None, cmds[0][1]) 

    SetPass('CollectSetAttr')

    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass(cmds[1], collect_set_attr, None, cmds[0][1]) 
    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass(cmds[1], collect_set_attr, None, cmds[0][1]) 

    for k1, v1 in self_attr_type.iteritems():
        v = v1.keys()
        v = [Kl_Function if x is not None and x[0] == Kl_Function[0] else x for x in v]
        v = dict.fromkeys(v).keys()
        if len(v) == 1 and v[0] is not None and v[0] != Kl_None:
            detected_attr_type[k1] = v[0]
        elif len(v) == 2 and IsInt(v[0]) and IsInt(v[1]):
            detected_attr_type[k1] = Kl_Int
        else:            
            Debug('Not detected attr type', k1, v)    
                   
    SetPass('RecursiveTypeDetect-2')
    for current_co, cmds in seqcode:        
        cmds[1] = recursive_type_detect(cmds[1], cmds[0][1]) 

    SetPass('CollectTypeLocal1')
    pass_local_type_detect()

    SetPass('CollectTypeGlobal')
    pass_global_type_detect()

    SetPass('CollectTypeLocal2')
    pass_local_type_detect() 
    
    SetPass('ReplaceLocalConstDetected')
    for current_co, cmds in seqcode:        
        cmds[1] = replace_local_const_detect(cmds[1], cmds[0][1]) 

    SetPass('UpgradeRepl-4')
    for current_co, cmds in seqcode:        
        cmds[1] = tree_pass_upgrade_repl(cmds[1], None, cmds[0][1]) 

    if direct_call:
        SetPass('ConcretizeDirectCall-1')
        concretize_direct_call()
        
        SetPass('SetCondMethCall-0')
        
        ## d = globals()
        ## dd = {}
        ## for k,v in d.iteritems():
            ## if type(v) == type(SetPass) or k in ('Tx_compiled', 'Tx_fast', 'Tx_pre_compiled'):
                ## pass
            ## ## elif type(v) is code_extended:
                ## ## dd[k] = None
            ## ## elif k == '_n2c':
                ## ## dd[k] = v.keys()
            ## else:
                ## dd[k] = v 
        ## pprint(dd, out)
        for current_co, cmds in seqcode:
            if current_co.can_be_codefunc():                
                is_current = IS_CALLABLE_COMPILABLE
                cmds[1] = tree_pass__(cmds[1], upgrade_repl_if_type_direct_call, None, cmds[0][1]) 
                cmds[1] = tree_pass(cmds[1], upgrade_op, None, cmds[0][1]) 
                
                is_current = IS_DIRECT              
                current_co.direct_cmds = tree_pass__(current_co.direct_cmds, upgrade_repl_if_type_direct_call, None, cmds[0][1])
                current_co.direct_cmds = tree_pass(current_co.direct_cmds, upgrade_op, None, cmds[0][1]) 
        is_current = IS_CALLABLE_COMPILABLE

        SetPass('ConcretizeDirectCall-2')
        concretize_direct_call()
        if build_executable:
            SetPass('SupressUnusedCodefunc')
            supress_unused_codefunc()
            SetPass('ConcretizeDirectCall-3')
            concretize_direct_call()

    SetPass('CollectTypeLocal3')
    pass_local_type_detect()

    SetPass('CollectTypeGlobal3')
    pass_global_type_detect()

    SetPass('CollectTypeLocal4')
    pass_local_type_detect()

    SetPass('CollectTypeReturn-3')
    pass_detect_return_type()

    if direct_call:
        SetPass('ConcretizeDirectCall-5')
        concretize_direct_call()

        SetPass('CollectTypeLocal5')
        pass_local_type_detect()
    
        SetPass('CollectTypeGlobal5')
        pass_global_type_detect()
    
        SetPass('CollectTypeLocal6')
        pass_local_type_detect()
    
        SetPass('CollectTypeReturn-5')
        pass_detect_return_type()

    SetPass('LabelMethod')
    for current_co, cmds in seqcode:
        current_co.mark_method_class()
        
    SetPass('Formire')   
    for current_co, cmds in seqcode:        
##        print 'Code for ', current_co.co_name
        dump(current_co)
        print_cmds(cmds)
        if current_co.direct_cmds is not None:
            if len(current_co.hidden_arg_direct) == 0 and current_co.direct_cmds == cmds[1]:
                pass
            elif print_pycmd:
                print >>out, 'Hidden args', current_co.hidden_arg_direct
                print_cmds([('(DIRECT_DEF', cmds[0][1]), current_co.direct_cmds])
        if not current_co.decompile_fail:
            if hasattr(current_co, 'no_codefunc') and current_co.no_codefunc:
                Line2Addr = line2addr(current_co)
            else:
                generate(cmds, current_co, filename)
            is_current = IS_DIRECT
            generate_direct(cmds, current_co, filename)  
            is_current = IS_CALLABLE_COMPILABLE

            
    c_fname, nmmodule = Pynm2Cnm(filename)
    SetPass('WriteAsC')
    write_as_c(out3, nmmodule)   
    out3.close()
    
    FlushDebug()
    
    if make_indent:
        SetPass('Indent')
        os.system('indent ' + c_fname)
    if no_build:
        pass
    else:    
        SetPass('Compile')
        compile_c(filename, c_fname)
    SetPass('WorkDone')
    global Pass
    global Tx_cnt
    if flag_stat:
        print ('Passess...')
        its = Pass.items()
        its.sort()
        for k,v in its:
            print ('  ' + str(k) + ' ' + str(round(v, 3)))
        print ('Attribute uses...'  )
        its = [(s,k) for k,s in stat_3.iteritems()]
        its.sort()
        for s,k in its:
            print ('  ' + str(k) + ' ' + str(s))
        sta = [(v,k) for k,v in Tx_cnt.iteritems()]
        sta.sort()
        print '--- patterns ---'
        for s,k in sta:
            pprint(k)
            print '  ' , s
        return None

def pass_detect_return_type():
    global current_co, is_current, seqcode
    len_detected_return_type = len(detected_return_type)
##    detected_return_type.clear()
    while True:
        type_def.clear()
        for current_co, cmds in seqcode:
            if current_co.co_flags & CO_GENERATOR:
                detected_return_type[cmds[0][1]] = Kl_Generator 
            else:    
                is_current = IS_CALLABLE_COMPILABLE               
                if hasattr(current_co, 'no_codefunc') and current_co.no_codefunc:
                    pass
                else:
                    tree_pass(cmds[1], collect_type_return, None, cmds[0][1]) 
                is_current = IS_DIRECT                
                tree_pass(current_co.direct_cmds, collect_type_return, None, cmds[0][1])  
                is_current = IS_CALLABLE_COMPILABLE               
    
        for k1, v1 in type_def.iteritems():
            v = v1.keys()
            v = uniq_list_type(v)
            Debug('def %s, return %s' % (k1, v))
            if len(v) == 1 and v[0] is not None:
                detected_return_type[k1] = v[0] 
            elif len(v) == 2:
                if IsStr(v[0]) and IsStr(v[1]):
                    detected_return_type[k1] = Kl_String 
                elif IsKlNone(v[0]) and v[1] is not None:
                    detected_return_type[k1] = Kl_MayBe(v[1]) 
                elif IsKlNone(v[1]) and v[0] is not None:
                    detected_return_type[k1] = Kl_MayBe(v[0])
                else:     
                    Debug('Not detected return type', k1, v)    
            else:
                Debug('Not detected return type', k1, v)   
        if len_detected_return_type == len(detected_return_type):
            break
        len_detected_return_type = len(detected_return_type) 
    type_def.clear()
    

def pass_global_type_detect():
    global global_type, detected_global_type, current_co, is_current, seqcode
    global_type.clear()
    for current_co, cmds in seqcode: 
##        tree_pass(cmds[1], collect_set_global, None, cmds[0][1]) 
        is_current = IS_CALLABLE_COMPILABLE
        if hasattr(current_co, 'no_codefunc') and current_co.no_codefunc:
            pass
        else:
            tree_pass(cmds[1], collect_set_global, None, cmds[0][1]) 
        is_current = IS_DIRECT                
        tree_pass(current_co.direct_cmds, collect_set_global, None, cmds[0][1])          
        is_current = IS_CALLABLE_COMPILABLE               
 
    for k1, v1 in global_type.iteritems():
        v = v1.keys()
        v = uniq_list_type(v)
        if len(v) == 1 and v[0] is not None:
            detected_global_type[k1] = v[0] 
        elif len(v) == 2:
            if IsStr(v[0]) and IsStr(v[1]):
                detected_global_type[k1] = Kl_String 
            elif IsKlNone(v[0]) and v[1] is not None:
                detected_global_type[k1] = Kl_MayBe(v[1]) 
            elif IsKlNone(v[1]) and v[0] is not None:
                detected_global_type[k1] = Kl_MayBe(v[0])
            else:     
                Debug('Not detected global type', k1, v)    
        else:
            Debug('Not detected global type', k1, v)    
    Debug('Detected global type var', detected_global_type)    

def pass_local_type_detect():
    global local_type, current_co, is_current, seqcode
    for current_co, cmds in seqcode: 
        local_type.clear()
        if not current_co.can_be_codefunc():
            continue
        is_current = IS_CALLABLE_COMPILABLE              
        if hasattr(current_co, 'no_codefunc') and current_co.no_codefunc:
            pass
        else:
            collect_set_local( cmds[1], cmds[0][1]) 
        is_current = IS_DIRECT               
        collect_set_local( current_co.direct_cmds, cmds[0][1])  
        is_current = IS_CALLABLE_COMPILABLE              
        for k1, v1 in local_type.iteritems():
            v = v1.keys()
            v = uniq_list_type(v)
            if len(v) == 2:
                if IsStr(v[0]) and IsStr(v[1]):
                    v = [Kl_String ]
                elif IsKlNone(v[0]) and v[1] is not None:
                    v = [Kl_MayBe(v[1])]
                elif IsKlNone(v[1]) and v[0] is not None:
                    v = [Kl_MayBe(v[0])]
            if len(v) != 1 or v[0] is None:
                not_loc_detec(k1, v)   
                continue
            if k1 in current_co.co_varnames and \
               len([True for i, nm in enumerate(current_co.co_varnames) if i < current_co.co_argcount and nm == k1]) > 0:
                current_co.detected_type_may_be[k1] = v[0] 
                continue
            current_co.detected_type[k1] = v[0] 
        changed_arg_type_detect(current_co)             
        if len(current_co.detected_type) > 0:
            for k, v in current_co.detected_type.iteritems():
                Debug('def %s, var %s -- local type detected (%s)' % (current_co.co_name, k, v))
##                Debug('def %s -- local type detected' % co.co_name, k, v)    

def changed_arg_type_detect(co):
    if len(co.detected_type_may_be) > 0 and len(co.typed_arg_direct_changed) > 0:
        todel = {}
        for nm, kl in co.detected_type_may_be.iteritems():
            ind = co.co_varnames.index(nm)
            if ind in co.typed_arg_direct_changed and co.typed_arg_direct_changed[ind] == kl:
                   co.typed_arg_direct[ind] = kl
                   del co.typed_arg_direct_changed[ind]
                   todel[nm] = True
        for nm in todel.iterkeys():
            del co.detected_type_may_be[nm]           

global list_calcconst_codefunc
used_calcconst_codefunc = {}

def supress_unused_codefunc():
    global current_co, seqcode
    initcod = None
    for current_co, initcmds in seqcode:
        if initcmds[0][1] == 'Init_filename':
            initcod = initcmds[1]
            break
 
    if initcod is None:
        return
    used_calcconst_codefunc.clear()
    for st in initcod:
        v = []
        if type(st) is tuple and len(st) == 3 and type(st[0]) is str and st[0] == 'STORE' and\
            TCmp(st, v, ('STORE', \
                           (('STORE_CALC_CONST', \
                                 ('STORE_NAME', '?')),), \
                            (('!MK_FUNK', '?', ('CONST', '?')),))) and v[0] == v[1]:
            used_calcconst_codefunc[v[0]] = False
    for current_co, cmds in seqcode: 
        tree_pass(cmds[1], find_use_calcconst_codefunc, None, cmds[0][1]) 
    for nmcodefunc, used in used_calcconst_codefunc.iteritems():
        if not used:
            co = N2C(nmcodefunc)     
            co.no_codefunc = True
    new_initcod = []
    for st in initcod:
        v = []
        if type(st) is tuple and len(st) == 3 and type(st[0]) is str and st[0] == 'STORE' and\
              TCmp(st, v, ('STORE', \
                           (('STORE_CALC_CONST', \
                                 ('STORE_NAME', '?')),), \
                            (('!MK_FUNK', '?', ('CONST', '?')),))) and \
            v[0] in used_calcconst_codefunc and \
            not used_calcconst_codefunc[v[0]]:
                pass
        else:
            new_initcod.append(st)
    initcmds[1] = new_initcod        

def find_use_calcconst_codefunc(it, nm):
    if type(it) is tuple and len(it) >= 2 and type(it[0]) is str:
        if it[0] in ('!CALL_CALC_CONST', 'STORE_NAME', 'STORE_GLOBAL', '!MK_FUNK', 'FAST'):
            pass
        elif it[1] in used_calcconst_codefunc:
            used_calcconst_codefunc[it[1]] = True
    return it      

def concretize_direct_call():
    global current_co, is_current, seqcode
    global list_cmds, prev_list_cmds
    list_cmds = [None]
    prev_list_cmds = []
    ## if flag_stat and hasattr(sys, 'gettotalrefcount'):  
        ## prev_refcnt = sys.gettotalrefcount()  
    while True:
        direct_args.clear()
        for current_co, cmds in seqcode: 
            if current_co.can_be_codefunc():   
                is_current = IS_CALLABLE_COMPILABLE              
                if hasattr(current_co, 'no_codefunc') and current_co.no_codefunc:
                    pass
                else:
                    tree_pass_readonly(cmds[1], None, cmds[0][1]) 
                is_current = IS_DIRECT               
                tree_pass_readonly(current_co.direct_cmds, None, cmds[0][1]) 
                is_current = IS_CALLABLE_COMPILABLE              

        prev_list_cmds = list_cmds
        list_cmds = [(co,cmds) for co, cmds in seqcode \
                    if cmds[0][1] in direct_args and co.can_be_codefunc()] 
        if list_cmds == prev_list_cmds:
            break            
        for current_co, cmds in list_cmds: 
            concretize_code_direct_call(cmds[0][1], cmds[1], current_co) 
            changed_arg_type_detect(current_co)    
    
        
def is_const_value1(v):
    if v[0] == 'CONST':
        return True
    if v[0] == '!LOAD_NAME' and (type(v[1]) is float or v[1] in ('nan', 'inf')):
        return True
    if v[0] == 'CALC_CONST':
        return True
    if v[0] == '!CLASS_CALC_CONST':
        return True
    if v[0] == '!BUILD_LIST' and all([is_const_value1(x) for x in v[1]]):
        return True
    if v[0] == '!BUILD_TUPLE' and all([is_const_value1(x) for x in v[1]]):
        return True
    if v[0] == '!PyObject_GetAttr' and is_const_value1(v[1]) and is_const_value1(v[2]):
        return True
    if v == ('!PyDict_New',):
        return True
    if v[0] in ('!LOAD_BUILTIN',):
        return True
    if v[0] == '!MK_FUNK' and is_const_value1(v[2]):
        return True
    if v[0] == '!PyObject_Type':
        return is_const_value1(v[1])
    return False
    
def is_const_default_value(v):
    if v[0] == 'CONST':
        return True
    if v[0] == '!BUILD_TUPLE' and all([is_const_value1(x) for x in v[1]]):
        return True
    if v[0] == '!PyDict_New' and len(v) == 1:
        Fatal('??? where ???', v)
        return True    
    Debug('not const', v)
    return False  

def get_default_value1(v):
#    if v[0] == 'CONST':
    return v
#    Fatal('', '')
#    return v[1]  

def is_simple_attr(expr):
    t = TypeExpr(expr)
    if t is not None and (t in _Kl_Simples or t[0] in (types.ModuleType, T_OLD_CL_TYP, T_NEW_CL_TYP)):                 
        return True
    if expr[0].startswith('PyNumber_'):
        if len(expr) == 3 and (is_simple_attr(expr[1]) or is_simple_attr(expr[2])):
            return True
        if len(expr) == 4 and (is_simple_attr(expr[1]) or is_simple_attr(expr[2]) or is_simple_attr(expr[2])):
            return True
        if len(expr) == 2 and is_simple_attr(expr[1]):
            return True
    return False    

def get_nmcode(nmcl, expr):
    nm_code = None
    if expr[0] == '!MK_FUNK':
        nm_code, default_arg = expr[1:3]
        if is_const_default_value(default_arg):
            default = get_default_value1(default_arg)
            default_args[nm_code] = default
            return nm_code
        Debug('*Not const default args  meth|attr', expr)        
    if expr[0] == '!LOAD_NAME':
        nm_prev = expr[1]
        if IsMethod(nmcl, nm_prev):
            nm_code = ValMethod(nmcl, nm_prev)
    if expr[0] == 'PY_TYPE' and expr[3][0] == '!LOAD_NAME':
        nm_prev = expr[3][1]
        if IsMethod(nmcl, nm_prev):
            nm_code = ValMethod(nmcl, nm_prev)
    if nm_code is None: 
        t = TypeExpr(expr)
        if t is not None and t[0] is types.FunctionType and t[1] is not None:
            nm_code = t[1]        
    return nm_code        

def one_store_clause(nmcl, nmslot, expr):
    v2 = []
    if nmslot in ('__doc__', '__module__'):
        return True
    if nmslot in ('__new__', '__del__'):
        nm_code = get_nmcode(nmcl, expr)
        if nm_code is None and expr[0] == '!MK_CLOSURE':
            nm_code = expr[1]
        if nm_code is not None:    
            no_compiled[nm_code] = True
        else:
            Fatal('', expr, 'Is', 'NoCompiled')    
    if is_simple_attr(expr):
        _3(nmcl, ('Attribute', nmslot), expr)
        return True
    nm_code = get_nmcode(nmcl, expr)
    if nm_code is not None:    
        _3(nmcl, ('Method', nmslot), nm_code)  
        if nmslot == '__init__':
            parse_constructor(nmcl, nm_code)          
        return True
    if expr[0] == '!PyObject_Call':
        if TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'property'), '?', '?')):
            _3(nmcl, 'Property', nmslot)  
            return one_store_property_clause(nmcl, nmslot, v2[0], v2[1])
        if TCmp(expr, v2, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'staticmethod'),\
                        ('!BUILD_TUPLE', ('?',)), ('NULL',)) ):
            return one_store_modificator_clause(nmcl, nmslot, 'StaticMethod', v2[0])                
        if TCmp(expr, v2, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'classmethod'),\
                        ('!BUILD_TUPLE', ('?',)), ('NULL',)) ):
            return one_store_modificator_clause(nmcl, nmslot, 'ClassMethod', v2[0])                
    return False

def one_store_modificator_clause(nmcl, nmslot, Modificator, expr):
    nm_code = get_nmcode(nmcl, expr)
    if nm_code is not None:    
        _3(nmcl, ('Method', nmslot), nm_code)            
        _3(nmcl, (Modificator, nmslot), nm_code)            
        return True
    Debug('*Not const default args %s meth|attr' % Modificator, expr)        
    return False

def one_store_property_clause(nmcl, nmslot, tupl, dic):
    getter, setter, deleter, doc = None, None, None, None
    if tupl[0] == '!BUILD_TUPLE':
        _tupl = list(tupl[1])
        while len(_tupl) < 4:
            _tupl.append(None)
        getter, setter, deleter, doc = _tupl
    elif tupl == ('CONST', ()):
        pass    
    else:
        Debug('*Undefined property positional arg', nmcl, nmslot, tupl, dic)       
    if dic == ('NULL',):
        pass
    elif dic[0] == '!BUILD_MAP':
        for (k,v) in dic[1]:
            if k == ('CONST', 'doc'):
                assert doc is None
                doc = v
            elif k == ('CONST', 'fget'):            
                assert getter is None
                getter = v      
            elif k == ('CONST', 'fset'):            
                assert setter is None
                setter = v      
            elif k == ('CONST', 'fdel'):            
                assert deleter is None
                deleter = v      
    else:        
        Debug('*Undefined property key arg', nmcl, nmslot, tupl, dic)   
        return False
    for k,v in (('Getter', getter), ('Setter', setter), ('Deleter', deleter)):
        if v is None or v == ('CONST', None):
            continue
        nm_code = get_nmcode(nmcl, v)
        if nm_code is not None:    
            _3(nmcl, (k, nmslot), nm_code)            
            continue
        Debug('*Access %s property class %s -> %s UNPARSE method %s ' % (k, nmcl, nmslot, nm_code))    
        return False
    return True                
     
def parse_class_def(nm, seq):
    i = -1
    while i < len(seq)-1:
        assert type(i) is int
        i += 1
        v = seq[i]
        if v[0] == '.L':
            continue
        if v[0] == 'UNPUSH':
            Debug('*Ignored stmt in class def', v)
            continue
        v2 = []
        if len(v) > 0 and type(v[0]) is str and v[0] == 'STORE':
            if TCmp(v, v2, ('STORE', (('STORE_NAME', '?'),), ('?',))):
                if not one_store_clause(nm, v2[0], v2[1]):
                    Debug('*Parse store clause illegal', v)
                continue
            if TCmp(v, v2, ('STORE', (('PyObject_SetItem', ('!LOAD_NAME', '?'), '?'),), ('?',))):
                continue
            if TCmp(v, v2, ('STORE', (('PyObject_SetItem', ('PY_TYPE', '?', '?', ('!LOAD_NAME', '?'), None), '?'),), ('?',))):
                continue
            if TCmp(v, v2, ('STORE', (('PyObject_SetAttr', ('!LOAD_NAME', '?'), '?'),), ('?',))):
                continue
            if TCmp(v, v2, ('STORE', (('PyObject_SetAttr', ('PY_TYPE', '?', '?', ('!LOAD_NAME', '?'), None), '?'),), ('?',))):
                continue
        ## if TCmp(v, v2, ('SEQ_ASSIGN', '?', '?')):
            ## for v2_0 in v2[0]:
                ## v2__ = []
                ## if TCmp(v2_0, v2__,  ('STORE_NAME', '?')):
                    ## if not one_store_clause(nm, v2__[0], None):
                        ## Debug('*Parse store clause illegal', v2_0)
                    ## continue
            ## continue
        if IsBeg(v[0]):
            oldi = i
            i = get_closed_pair(seq, i)
            _3(nm, 'ComplcatedClassDef', True)
            Debug('*Complicated meth|attr', seq[oldi:i+1])
            continue
        Debug('*Parse class def error', v) 

def parse_for_special_slot_class(nmcod, seq, nmcl):
    i = -1
    while i < len(seq)-1:
        assert type(i) is int
        i += 1
        v = seq[i]
        if v[0] == '.L':
            continue
        if v[0] == 'UNPUSH':
            continue
        v2 = []
        if len(v) > 0 and type(v[0]) is str and v[0] == 'STORE':
            if TCmp(v, v2, ('STORE', (('STORE_NAME', '?'),), ('?',))) and v2[0] in ('__new__', '__del__'):
                v3 = []
                if TCmp(v2[1], v3, ('!PyObject_Call',('!LOAD_BUILTIN', 'staticmethod'), \
                                    ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                    v2[1] = v3[0]
                elif TCmp(v2[1], v3, ('!PyObject_Call',('!LOAD_NAME', 'staticmethod'), \
                                    ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                    v2[1] = v3[0]            
                nm_code = get_nmcode(nmcl, v2[1])
                if nm_code is None and v2[1][0] == '!MK_CLOSURE':
                    nm_code = v2[1][1]
                if nm_code is not None:    
                    no_compiled[nm_code] = True
                else:
                    Fatal('Can\'t detect code for %s.%s method' % (nmcod, v2[0]), v)
        continue
    
def parse_constructor(nmclass, nmcode):
    seq = N2C(nmcode).cmds[1]   
    for v in seq:
        v2 = []
        if type(v) is tuple and len(v) == 3 and type(v[0]) is str and v[0] == 'STORE' and\
          TCmp(v, v2, ('STORE', (('PyObject_SetAttr', ('?', 'self'), ('CONST', '?')),), ('?',))):
            SetAttrInstance(nmclass, v2[1])
        
def repl_in_if_store(ret, old, new, stor, dele):
    ret = list(ret)
    if not (repr(stor) in repr(ret[0])) and ret[0][0] == '(IF':
        ret[0] = replace_subexpr(ret[0], old, new)
    else:
        return ret    
    if len(ret) == 3 or len(ret) == 2:
        ret[1] = repl_in_list_if_store(ret[1], old, new, stor, dele)
    elif len(ret) == 5 or len(ret) == 4:   
        ret[1] = repl_in_list_if_store(ret[1], old, new, stor, dele)
        ret[3] = repl_in_list_if_store(ret[3], old, new, stor, dele)
    return ret    

def repl_in_list_if_store(ret, old, new, stor, dele):
    j = 0
    s_repr_stor = repr(stor)
    s_repr_dele = repr(dele)
    while j < len(ret):
        if IsBeg(ret[j][0]):
            j1 = get_closed_pair(ret, j)
            srepr = repr(ret[j:j1])
            if s_repr_stor in srepr or s_repr_dele in srepr:
                if ret[j][0] == '(IF':
                    ret[j:j1] = repl_in_if_store(ret[j:j1], old, new, stor, dele)
                break
            ret[j:j1] = replace_subexpr(ret[j:j1], old, new)
            j = j1 + 1
        else:
            srepr = repr(ret[j])
            if s_repr_stor in srepr:
                if ret[j][0] == 'STORE' and len(ret[j][1]) == 1 and \
                    ret[j][1][0] == stor and len(ret[j][2]) == 1:
                    v2 = replace_subexpr(ret[j][2][0], old, new)
                    ret[j] = ('STORE', ret[j][1], (v2,))
                break
            elif s_repr_dele in srepr:
                break
            ret[j] = replace_subexpr(ret[j], old, new)
            j = j + 1
    return ret

def apply_typ(ret, d):
    for old, t in d.iteritems():    
        if t is None: 
            continue
##        t = (typ, None)
        old_old = old
        if old_old[0] == 'PY_TYPE':
            if old_old[1] != t[0]:
                Debug('def %s: change detected type' % current_co.co_name, old_old[1], t[0],ret)
                return ret
            old_old = old[3]
        assert old_old[0] != 'PY_TYPE'
        new = ('PY_TYPE', t[0], t[1], old_old, None) 
        if old != new:  
            ret = replace_subexpr(ret, old, new)
    return ret   
    
def type_in_if(ret, d):
    if ret[0] == '!BOOLEAN':
        return ('!BOOLEAN', type_in_if(ret[1], d))
    if ret[0] in ('!AND_JUMP', '!AND_BOOLEAN'):
        return (ret[0],) + tuple([type_in_if(r, d) for r in ret[1:]])
    if ret[0] in ('!OR_JUMP', '!OR_BOOLEAN'):
        return apply_typ((ret[0],) + tuple([type_in_if(r, {}) for r in ret[1:]]), d)
    v = []
    old, nm, built = None, None, None
    if TCmp(ret, v, ('!_EQ_', ('!PyObject_Type', '?'), \
                                        ('!LOAD_BUILTIN', '?'))):
        old, nm = v
        built = True                                       
    elif TCmp(ret, v, ('!_EQ_', ('!LOAD_BUILTIN', '?'), \
                                            ('!PyObject_Type', '?'))):
        nm, old = v
        built = True
    elif TCmp(ret, v, ('!_EQ_', ('!PyObject_Type', '?'), \
                                        ('CALC_CONST', '?'))):
        old, nm = v
        built = False                                   
    elif TCmp(ret, v, ('!_EQ_', ('CALC_CONST', '?'), \
                                            ('!PyObject_Type', '?'))):
        nm, old = v
        built = False       
    elif TCmp(ret, v, ('!PyObject_RichCompare(', ('!LOAD_BUILTIN', '?'),  \
                ('!PyObject_Type', '?'), 'Py_EQ')): 
        nm, old = v   
        built = True
    elif TCmp(ret, v, ('!PyObject_RichCompare(', ('!PyObject_Type', '?'), \
                        ('!LOAD_BUILTIN', '?'), 'Py_EQ')): 
        old, nm = v     
        built = True
    elif '!LOAD_BUILTIN' in repr(ret):
        Debug('Unhandled builtin (can be type) at condition', ret)
    if nm in d_built and built:
        ret = apply_typ(ret, d)
        if not old in d:
            d[old] = (d_built[nm], None)
        else:
            d[old] = None
        return ret
    else:
        isoldclass = nm in calc_const_old_class
        isnewclass = nm in calc_const_new_class  
        if isoldclass:  
            ret = apply_typ(ret, d)
            if not old in d:
                d[old] = (T_OLD_CL_INST, nm)
            else:
                d[old] = None
            return ret
        elif isnewclass:  
            ret = apply_typ(ret, d)
            if not old in d:
                d[old] = (T_NEW_CL_INST, nm)
            else:
                d[old] = None
            return ret                
        ret = apply_typ(ret, d)
    return apply_typ(ret, d)
        
def only_fast(d):
    d2 = {}
    for k,v in d.iteritems():
        if k[0] == 'FAST':
            d2[k] = v
    return d2
             
def list_typed_var_after_stmt(v, nmdef):             
    if v[0] == 'STORE' and len(v[1]) == 1 and v[1][0][0] in ('STORE_FAST', 'STORE_NAME') and \
        len(v[2]) == 1:
        t = TypeExpr(v[2][0])
        ## if t is not None:
            ## assert t.__class__.__name__ == 'Klass'
        if IsKlNone(t) and v[1][0][0] == 'STORE_NAME' and nmdef == 'Init_filename':
            return []
        elif t is None:
            return []
        stor = v[1][0]
        dele = v[1][0]
        dele = ('DELETE_' + dele[0][6:], dele[1])
        nm1 = v[1][0][1]
        if v[1][0][0] == 'STORE_FAST':
            nm2 = ('FAST', nm1)
        else:      
            nm2 = ('!LOAD_NAME', nm1)
        old = nm2
        if IsList(t):
            t = Kl_List
        assert nm2[0] != 'PY_TYPE'    
        new = ('PY_TYPE', t[0], t[1], nm2, None)             
        if t in _Kl_Simples and v[2][0][0] == 'CONST':
            new = v[2][0]
        if v[2][0][0] == '!CLASS_CALC_CONST':  
            assert v[2][0][1][0] != 'PY_TYPE'  
            new = ('PY_TYPE', t[0], v[2][0][1], nm2, None)
        elif v[2][0][0] == '!CLASS_CALC_CONST_NEW':    
            assert v[2][0][1][0] != 'PY_TYPE'  
            new = ('PY_TYPE', t[0], v[2][0][1], nm2, None)
        v2 = []    
        if TCmp(v[2][0], v2, ('!MK_FUNK', '?', ('CONST', ()))):
            new = v[2][0]

        ## vectorlist = False    
        ## if IsList(t) and v[2][0][0] == '!LIST_COMPR' and \
            ## len(v[2][0][1]) == 1 and IsList(TypeExpr(v[2][0][1][0])):
            ## vectorlist = True
        return [(old, new, stor, dele)]    
    if v[0] == 'STORE' and len(v[1]) == 1 and v[1][0][0] == 'SET_VARS' and len(v[2]) == 1:
        t = TypeExpr(v[2][0])
        ## if t is not None:
            ## assert t.__class__.__name__ == 'Klass'
        if not IsTuple(t):
            return []
        if type(t[1]) is tuple and len(t[1]) == len(v[1][0][1]):
            t_prev = t
            lis = []
            for i,t  in enumerate(t_prev[1]):
                assign = v[1][0][1][i]
                if IsKlNone(t) and assign[0] == 'STORE_NAME' and nmdef == 'Init_filename':
                    continue
                if t is None:
                    continue
                if IsList(t):
                    t = Kl_List
                if assign[0] not in ('STORE_FAST', 'STORE_NAME'):
                    continue
                stor = assign
                dele = assign[:]
                dele = ('DELETE_' + dele[0][6:], dele[1])
                nm1 = assign[1]  
                if stor[0] == 'STORE_FAST':
                    nm2 = ('FAST', nm1)
                else:      
                    nm2 = ('!LOAD_NAME', nm1)
                old = nm2
                assert nm2[0] != 'PY_TYPE'  
                new = ('PY_TYPE', t[0], t[1], nm2, None)             
                lis.append((old, new, stor, dele))
            return lis   
    if v[0] == 'SET_EXPRS_TO_VARS' and len(v[1]) == len(v[2]):
        _v = v
        lis = []
        for i in range(len(_v[1])):
            t = TypeExpr(v[2][i])
            ## if t is not None:
                ## assert t.__class__.__name__ == 'Klass'
            if IsKlNone(t) and v[1][i][0] == 'STORE_NAME' and nmdef == 'Init_filename':
                return []
            elif t is None:
                return []
            if v[1][i][0] != 'STORE_FAST':
                continue
            stor = v[1][i]
            dele = v[1][i]
            dele = ('DELETE_' + dele[0][6:], dele[1])
            nm1 = v[1][i][1]
            nm2 = ('FAST', nm1)
            old = nm2
            if IsList(t):
                t = Kl_List
            assert nm2[0] != 'PY_TYPE'    
            new = ('PY_TYPE', t[0], t[1], nm2, None)             
            if t in _Kl_Simples and v[2][i][0] == 'CONST':
                new = v[2][i]
            if v[2][i][0] == '!CLASS_CALC_CONST':  
                assert v[2][i][1][0] != 'PY_TYPE'  
                new = ('PY_TYPE', t[0], v[2][i][1], nm2, None)
            elif v[2][i][0] == '!CLASS_CALC_CONST_NEW':    
                assert v[2][i][1][0] != 'PY_TYPE'  
                new = ('PY_TYPE', t[0], v[2][i][1], nm2, None)
            v2 = []    
            if TCmp(v[2][i], v2, ('!MK_FUNK', '?', ('CONST', ()))):
                new = v[2][i]
    
            ## vectorlist = False    
            ## if IsList(t) and v[2][0][0] == '!LIST_COMPR' and \
                ## len(v[2][0][1]) == 1 and IsList(TypeExpr(v[2][0][1][0])):
                ## vectorlist = True
            lis.append((old, new, stor, dele))
        return lis
    return []
 
def recursive_type_detect(ret, nmdef):
    if type(ret) != list:
        return ret
    ret = ret[:]
    i = 0
    while i < len(ret):
        assert type(i) is int
        v = ret[i]
        ## head = v[0]
        if v[0] == '(FOR' and len(v[1]) == 1 and v[1][0][0] in ('STORE_FAST', 'STORE_NAME'):
            t = TypeExpr(v[2])
            if t == Kl_File or IsStr(t):
                assign = v[1][0] 
                stor = assign
                dele = assign[:]
                dele = ('DELETE_' + dele[0][6:], dele[1])
                nm1 = assign[1]  
                if stor[0] == 'STORE_FAST':
                    nm2 = ('FAST', nm1)
                else:      
                    nm2 = ('!LOAD_NAME', nm1)
                old = nm2
                assert nm2[0] != 'PY_TYPE'  
                if IsStr(t):
                    new = ('PY_TYPE', str, 1, nm2, None)   
                else:    
                    new = ('PY_TYPE', str, None, nm2, None)   
                j = i + 1          
                s_repr = repr(ret[j])
                if repr(stor) not in s_repr and repr(dele) not in s_repr:
                    ret[j] = replace_subexpr(ret[j], old, new)
                    i = i + 1
                    continue 
        v2 = []
        if type(v) is tuple and len(v) > 0 and type(v[0]) is str and v[0] == '(FOR':
            if len(v[1]) == 1 and len(v[1][0]) == 2 and v[1][0][0] == 'STORE_FAST' and 'range' in repr(v[2]):
                v2 = [v[1][0][1]]
                v3 = []
                if TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int, int)), \
                                ('NULL',))) or \
                TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int, int)), \
                                ('NULL',))) or \
                TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int,)), \
                                ('NULL',))) or \
                TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int,)), \
                                ('NULL',))):
                    stor = ('STORE_FAST', v2[0])
                    dele = ('DELETE_FAST', v2[0])
                    old = ('FAST', v2[0])
                    new = ('PY_TYPE', int, None, old, None)   
                    j = i + 1          
                    s_repr = repr(ret[j])
                    if repr(stor) not in s_repr and repr(dele) not in s_repr:
                        ret[j] = replace_subexpr(ret[j], old, new)
                        i = i + 1
                        continue 
        
                v2 = []
                if ( TCmp(v, v2, ('(FOR', (('STORE_FAST', '?'),), \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('!BUILD_TUPLE', ('?',)), \
                                ('NULL',)))) or \
                    TCmp(v, v2, ('(FOR', (('STORE_FAST', '?'),), \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('!BUILD_TUPLE', ('?',)), \
                                ('NULL',))))) and IsInt(TypeExpr(v2[1])):
                    stor = ('STORE_FAST', v2[0])
                    dele = ('DELETE_FAST', v2[0])
                    old = ('FAST', v2[0])
                    new = ('PY_TYPE', int, None, old, None)   
                    j = i + 1 
                    s_repr = repr(ret[j])         
                    if repr(stor) not in s_repr and repr(dele) not in s_repr:
                        ret[j] = replace_subexpr(ret[j], old, new)
                        i = i + 1
                        continue 
            
        if v[0] == '(IF' and v[1][0] == '!1NOT' and len(ret[i+1]) == 1 and \
                ret[i+1][0] in (('RAISE_VARARGS', 0, (('!LOAD_BUILTIN', 'AssertionError'),)), ('CONTINUE',), ('BREAK',)) and \
                ret[i+2] == (')ENDIF',):
            d = {}
            ret[i] = ('(IF', ('!1NOT', type_in_if(v[1][1], d)))
            d = only_fast(d)
            li = []
            for k, v in d.iteritems():
                li.append((k, ('PY_TYPE', v[0], v[1], k, None), ('STORE_FAST', k[1]), ('DELETE_FAST', k[1])))
 
            for old, new, stor, dele in li:
                j = i+1   
                replace_concretised_at_list_from_pos(ret, i+3, old, new, stor, dele) 
            i += 3    
            continue    
        if v[0] == '(IF':
            d = {}
            ret[i] = ('(IF', type_in_if(v[1], d)) 
            d = only_fast(d)
            li = []
            for k, v in d.iteritems():
                if v is not None:
                    li.append((k, ('PY_TYPE', v[0], v[1], k, None), ('STORE_FAST', k[1]), ('DELETE_FAST', k[1])))
 
            for old, new, stor, dele in li:
                j = i+1   
                replace_concretised_at_list_from_pos(ret[i + 1], 0, old, new, stor, dele) 
            i += 1    
            continue    
                  
        li = list_typed_var_after_stmt(v, nmdef) 
        for old, new, stor, dele in li:
            j = i+1   
            replace_concretised_at_list_from_pos(ret, i + 1, old, new, stor, dele) 
        if type(ret[i]) is list:
            ret[i] = recursive_type_detect(ret[i], nmdef)            
        i += 1 
    return ret    

def replace_concretised_at_list_from_pos(ret, j, old, new, stor, dele):
    ## assert stor[0] == 'STORE_FAST'
    ## s_stor = repr(stor)
    ## s_dele = repr(dele)
    while j < len(ret):
        if IsBeg(ret[j][0]):
            j1 = get_closed_pair(ret, j)
            if (new[0] == 'CONST' and type(new[1]) is int) : 
                v = []
                v2 = []
                if TCmp(ret[j], v, ('(WHILE', ('!BOOLEAN', \
                                             ('!c_Py_LT_Int', old, ('CONST', '?'))))) and\
                    ( TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_Add', old, ('CONST', 1)),))) or \
                       TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_InPlaceAdd', old, ('CONST', 1)),))) ):
                    dic = {}
                    collect_store_and_delete_and_access(ret[j+1][:-1], dic)
                    if not stor in dic and not dele in dic and new[1] < v[0]:   
                        oold = ('PY_TYPE', int, 'ssize', old[:], None)
                        if IsShort(TypeExpr(new)) and IsShort(TypeExpr(('CONST', v[0]))):
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, 'ssize', old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, 'ssize', ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                        else:                
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, None, old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, None, ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                        ret[j+1:j+3] = [ret[j+1], ret[j+2], ('STORE', (stor[:],), (('CONST', v[0]),))]
                        continue
                elif TCmp(ret[j], v, ('(WHILE', ('!BOOLEAN', \
                                             ('!c_Py_LE_Int', old, ('CONST', '?'))))) and\
                    ( TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_Add', old, ('CONST', 1)),))) or \
                      TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_InPlaceAdd', old, ('CONST', 1)),))) ):
                    dic = {}
                    collect_store_and_delete_and_access(ret[j+1][:-1], dic)
                    if not stor in dic and not dele in dic and new[1] <= v[0]:   
                        oold = ('PY_TYPE', int, 'ssize', old[:], None)
                        if IsShort(TypeExpr(new)) and IsShort(TypeExpr(('CONST', v[0]))):
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, 'ssize', old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, 'ssize', ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                        else:                
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, None, old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, None, ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                        ret[j+1:j+3] = [ret[j+1], ret[j+2], ('STORE', (stor[:],), (('CONST', v[0] + 1),))]
                        continue
                elif ( TCmp(ret[j], v, \
                          ('(WHILE', ('!PyObject_RichCompare(', old, \
                                      '?', 'Py_LT'))) or\
                       TCmp(ret[j], v, \
                          ('(WHILE', ('!PyObject_RichCompare(', old, \
                                      '?', 'Py_LE'))) ) \
                                      and\
                    ( TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_Add', old, ('CONST', 1)),))) or\
                      TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_InPlaceAdd', old, ('CONST', 1)),))) ):
                    dic = {}
                    collect_store_and_delete_and_access(ret[j+1][:-1], dic)
                    if not stor in dic and not dele in dic and IsInt(TypeExpr(v[0])):
                        oold = ('PY_TYPE', int, 'ssize', old[:], None)
                        if IsShort(TypeExpr(new)):
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, 'ssize', old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, 'ssize', ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                        else:                
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, None, old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, None, ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                        continue                                      
            ret_j_j1 = ret[j:j1]
            dic = {}
            collect_store_and_delete_and_access(ret_j_j1, dic)
            if stor in dic and not dele in dic:
                if ret[j][0] == '(IF':
                    ret[j:j1] = repl_in_if_store(ret_j_j1, old, new, stor, dele)
                break
            elif stor in dic or dele in dic:
                break
            ret[j:j1] = replace_subexpr(ret_j_j1, old, new)
            j = j1 + 1
            continue
        dic = {}
        collect_store_and_delete_and_access(ret[j], dic)
        if stor in dic:
            if ret[j][0] == 'STORE' and len(ret[j][1]) == 1 and \
                ret[j][1][0] == stor and len(ret[j][2]) == 1:
                v2 = replace_subexpr(ret[j][2][0], old, new)
                ret[j] = ('STORE', ret[j][1], (v2,))
            break
        elif dele in dic:
            break
        ret[j] = replace_subexpr(ret[j], old, new)
        j = j + 1            

def collect_store_and_delete_and_fast(it, dic):
    if type(it) is list:
        for v in it:
            collect_store_and_delete_and_fast(v, dic)
        return
    if type(it) is tuple:
        if len(it) == 2:
            if it[0] in ('STORE_FAST', 'DELETE_FAST', 'FAST'):
                dic[it] = True
        for v in it:
            if type(v) is tuple:
                collect_store_and_delete_and_fast(v, dic)
    return

def collect_store_and_delete_and_access(it, dic):
    if type(it) is list:
        for v in it:
            collect_store_and_delete_and_access(v, dic)
        return
    if type(it) is tuple:
        if len(it) == 2:
            if it[0] in ('STORE_FAST', 'DELETE_FAST', 'FAST', 'STORE_NAME', 'DELETE_NAME', '!LOAD_NAME'):
                dic[it] = True
        for v in it:
            if type(v) is tuple:
                collect_store_and_delete_and_access(v, dic)
    return

def replace_local_const_detect(ret, nmdef):
    if type(ret) != list:
        return ret
    ret = ret[:]
    i = 0
    while i < len(ret):
        assert type(i) is int
        v = ret[i]
        ## head = v[0]
        li1 = list_typed_var_after_stmt(v, nmdef)
        li = [(old, new, stor, dele) for old, new, stor, dele in li1 if old[0] == 'FAST' and new[0] != 'PY_TYPE']
        if len(li) > 0:
            dic = {}
            collect_store_and_delete_and_fast(ret[i+1:], dic)
            for old, new, stor, dele in li:
                if stor in dic or dele in dic:
                    continue
                if not old in dic:
                    if new[0] in ('CONST', '!MK_FUNK') and ret[i] == ('STORE', (stor,), (new,)):
                        del ret[i]
                else:    
                    ret[i+1:] = replace_subexpr(ret[i+1:], old, new)
        i += 1
    return ret                


def join_defined_calls(_calls, argcount, nm, is_varargs):
    l = []
#    if nm == 'HideDebug':
#        print '/1', _calls, argcount, nm, is_varargs
    if is_varargs:
        argcount += 1    
    for c, typs in _calls:
        a = []
        if c[0] == 'CONST':
            for _a in c[1]:
                a.append(('CONST', _a))
#            print '/3', a    
        elif c[0] == '!BUILD_TUPLE':
            for i, _a in enumerate(c[1]):
                if _a[0] == 'CONST':
                    a.append(_a)
                elif _a[0] == 'PY_TYPE':
                    a.append((_a[1], _a[2])) 
                else:
                    t = typs[i]
#                    t = TypeExpr(_a)
                    if t is not None:
                        assert len(t) == 2
                        a.append(t) 
                    else:
                        a.append((None, None))    
#            print '/4', a    
        else:
            Fatal('Can\'t join calls', c, _calls)
#        print '/7', a                
        if argcount != len(a) and not is_varargs:
            if argcount > len(a):
                if nm in default_args:
                    cc = default_args[nm]
                    if cc[0] == 'CONST':
                        _refs2 = [('CONST', x) for x in cc[1]]
                    else:    
                        assert cc[0] == '!BUILD_TUPLE'
                        _refs2 = [x for x in cc[1]]
                    add_args = argcount - len(a)
                    pos_args = len(_refs2) - add_args
                    a = a + _refs2[pos_args:]
#            print '/5', a    
        elif is_varargs:
            if argcount -1 > len(a):
                if nm in default_args:
                    cc = default_args[nm]
                    if cc[0] == 'CONST':
                        _refs2 = [('CONST', x) for x in cc[1]]
                    else:    
                        assert cc[0] == '!BUILD_TUPLE'
                        _refs2 = [x for x in cc[1]]
                    add_args = ( argcount - 1 ) - len(a)
                    pos_args = len(_refs2) - add_args
                    a = a + _refs2[pos_args:]
            new_a = []
            for i in range(argcount-1):
                new_a.append(a[i])
            new_a.append((tuple, None))
            a = new_a  
#            print '/6', a    
        if len(a) != argcount: # or nm == 'HideDebug':
            Fatal('', _calls, a, argcount, nm, is_varargs)
#        print '/8', a    
        assert len(a) == argcount                    
        l.append(a)
    l2 = []     
    for i in range(argcount):
        d = {}
        for ll in l:
            d[ll[i]] = True
        if len(d) > 1:
            d2 = {}
            for k,v in d.iteritems():
                if type(k) is tuple and k[0] == 'CONST':
                    k = TypeExpr(k) 
                d2[k] = v
            d = d2     
        if len(d) > 1:
            if len(d) > 1 and None not in d and (None, None) not in d:
                ts = [(x[0], x[1]) for x in d.keys()]
                ts = uniq_list_type(ts)
                if len(ts) == 1:
                    d = {ts[0]:True}            
        if len(d) > 1:
            d = {None:True}
        l2.append(d.keys()[0])
    l = l2          
    return l

def dotted_name_to_first_name(nm):
    if '.' in nm:
        return nm.split('.')[0]
    return nm

def filter_founded_calc_const(p, k, do_del):
    v = []
    if TCmp(p, v, ('STORE', (('STORE_NAME', '?'),), \
                       (('!IMPORT_NAME', '?', ('CONST', -1), ('CONST', None)),))):
        if v[0] == k:
            all_calc_const[k] = p[2][0]
            _3(k, 'ImportedM', dotted_name_to_first_name(v[1]))
    elif p[0] == 'STORE' and len(p[1]) == len(p[2]) == 1:
        if p[2][0][0] in ('!LOAD_NAME', '!LOAD_GLOBAL') and  p[2][0][1] in all_calc_const:
            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
                ok = p[2][0][1]
                all_calc_const[k] =  all_calc_const[ok]
                if ok in no_compiled:
                    no_compiled[k] = no_compiled[ok]
                if ok in default_args:
                    default_args[k] = default_args[ok]
                if ok in mnemonic_constant:
                    mnemonic_constant[k] = mnemonic_constant[ok]
                if ok in direct_code:
                    direct_code[k] = direct_code[ok]
                if ok in val_direct_code:
                    val_direct_code[k] = val_direct_code[ok]
                if ok in detected_return_type:
                    detected_return_type[k] = detected_return_type[ok]
                if ok in calc_const_value:
                    calc_const_value[k] = calc_const_value[ok]
                for a,b,c in Iter3(ok, None, None):
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    _3(k, b,c)
        elif p[2][0][0] == 'CONST' or\
             TCmp(p[2][0], v, ('!PyObject_GetAttr', ('CONST', '?'), ('CONST', '?'))):
            if p[2][0][1] is not None:
                if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
                    all_calc_const[k] = p[2][0]
                    mnemonic_constant[k] = p[2][0]
                elif p[1][0][0] == 'SET_VARS' and ('STORE_NAME', k) in p[1][0][1] and  p[2][0][0] == 'CONST' and type(p[2][0][1]) is tuple and  p[1][0][1].index(('STORE_NAME', k)) < len(p[2][0][1]):
                    pos_ = p[1][0][1].index(('STORE_NAME', k))
                    all_calc_const[k] = ('CONST', p[2][0][1][pos_])
                    mnemonic_constant[k] = ('CONST', p[2][0][1][pos_])
                elif p[1][0][0] == 'SET_VARS' and ('STORE_GLOBAL', k) in p[1][0][1] and  p[2][0][0] == 'CONST' and type(p[2][0][1]) is tuple and  p[1][0][1].index(('STORE_NAME', k)) < len(p[2][0][1]):
                    pos_ = p[1][0][1].index(('STORE_GLOBAL', k))
                    all_calc_const[k] = ('CONST', p[2][0][1][pos_])
                    mnemonic_constant[k] = ('CONST', p[2][0][1][pos_])
                else:
                    Fatal('--590--', p)
            return    
            
#        elif p[2][0][0] == 'CALC_CONST':
#            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
        
        elif p[2][0][0] == '!IMPORT_NAME':
            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k and\
                p[2][0][2] == ('CONST', -1) and p[2][0][3] == ('CONST', None):
                all_calc_const[k] = p[2][0]
                _3(k, 'ImportedM', dotted_name_to_first_name(p[2][0][1]))
            else:
                Fatal('--597--', p)
            return    
        else:
            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
                all_calc_const[k] = p[2][0]
            return
#        if p[2][0][0][0] == '!':
#            return
    elif p[0] == 'IMPORT_STAR':
        print (p)
    elif p[0] == 'IMPORT_FROM_AS' and\
        TCmp(p, v, ('IMPORT_FROM_AS', '?', ('CONST', '?'), ('CONST', '?'), '?')):
        ## sreti = []
        del v[1] ## Hack !!!!!!!!!!!!!!!!!!!!!!!!!!!
        imp, consts_, stores = v
        for i, reti in enumerate(stores):
            v = []
            if reti[0] in ('STORE_NAME', 'STORE_GLOBAL') and reti[1] == k:
                all_calc_const[k] = '???'
                v = IfConstImp(imp, consts_[i])
                if v is not None:
                    mnemonic_constant[k] = v
                else:
                    _3(k, 'ImportedM', (imp, consts_[i]))                
                    if (imp, consts_[i], 'val') in t_imp:
                        t = t_imp[(imp, consts_[i], 'val')]
                        if is_new_class_typ(t):
                            calc_const_new_class[k] = '???'
##                            _3(k, 'CalcConstNewClass', '???')
                        elif is_old_class_typ(t):
                            calc_const_old_class[k] = '???'
##                            _3(k, 'CalcConstOldClass', '???')
        return
    elif p[0] in (')(EXCEPT', '(FOR'):
        do_del.append(k)    
        return
    elif p[0] == 'SEQ_ASSIGN':
        if ('STORE_NAME', k) in p[1]:
            all_calc_const[k] = p[2]
        else:
            for pi in p[1]:
                if pi[0] == 'SET_VARS':
                    if ('STORE_NAME', k) in pi[1]:
                        all_calc_const[k] = p[2]     
    elif p[0] == 'SEQ_ASSIGN' and ('STORE_NAME', k) in p[1]:
        all_calc_const[k] = p[2]
    elif p[0] == 'SET_EXPRS_TO_VARS' and ('STORE_NAME', k) in p[1]:
        all_calc_const[k] = p[2]    
    elif p[0] == 'UNPUSH':
        return
    elif p[0] == '!LIST_COMPR':
        return
    elif p[0] == 'PRINT_ITEM_1':
        return
    else:
        Fatal('can\'t handle CALC_CONST', p, k)
 
list_ext = []
        
from distutils import sysconfig        
     
cc2 = None     
             
def compile_c(base, cname):
    global cc2
    global list_cname_exe
    optio = [] ## ['-O0']
    if len(opt_flag) > 0:
        optio = opt_flag
    preargs = optio + ['-Wall']  
    if build_executable:
        if cc2 is None:
            cc = distutils.ccompiler.get_default_compiler(os.name, sys.platform)
            cc2 = new_compiler(os.name,cc, 1)    
            cc2.set_include_dirs([sysconfig.get_python_inc()])   
        ## if 'gettotalrefcount' in sys.__dict__ and  sys.platform != 'win32':
            ## preargs += ['-DPy_DEBUG']         
        cc2.compile([cname], output_dir=None, macros=None, include_dirs=None, debug=1, extra_preargs=preargs, extra_postargs=preargs, depends=None)
        link_exe(cname)
        return
    example_mod = distutils.core.Extension(cname[0:-2], sources = [cname], \
                                           extra_compile_args = optio, \
                                           extra_link_args = [])
    distutils.core.setup(name = cname[0:-2],
        version = "1.0",
        description = "Compiled to C Python code " + base,
        ext_modules = [example_mod],
        script_name = 'install' ,
        script_args = ['build_ext']
        )
    list_ext.append(example_mod)    

def link_exe(cname):
    if sys.platform == 'win32':
        optio = []
    else:
        optio = ['-Os']
    if len(opt_flag) > 0:
        optio = opt_flag 
    if sys.platform == 'win32':
        pyver = '%d%d' % sys.version_info[:2]
    else:
        pyver = sysconfig.get_config_var('VERSION')
        ## includes = '-I' + sysconfig.get_python_inc() + ' ' + \
                ## '-I' + sysconfig.get_python_inc(plat_specific=True)
    
        ## ldflags = sysconfig.get_config_var('LIBS') + ' ' + \
                ## sysconfig.get_config_var('SYSLIBS') + ' ' + \
                ## '-lpython'+pyver
        ## if not sysconfig.get_config_var('Py_ENABLE_SHARED'):
            ## ldflags += ' -L' + sysconfig.get_config_var('LIBPL')        
 
#        cc2.set_include_dirs([sysconfig.get_python_inc()]) 
##        sysconfig.customize_compiler(cc2)
    libdir = sysconfig.get_python_lib()
    if sys.platform == 'win32':
        libs = [libdir, sysconfig.PREFIX + '\\bin', \
             sysconfig.PREFIX  + '\\lib',  sysconfig.PREFIX  + '\\libs']
    else:
        libs = [libdir,  sysconfig.PREFIX + '/bin', \
             sysconfig.PREFIX  + '/lib',  sysconfig.PREFIX  + '/config']
    if libdir.endswith('/site-packages'):
        libs.append(libdir[:-14])
        libs = [libdir[:-14]+'/config'] + libs
    if hasattr(sys, 'gettotalrefcount') and sys.platform != 'win32':
        libraries=['python'+pyver + '_d']
    else:
        libraries=['python'+pyver]
    if sys.platform == 'win32':
        cc2.link_executable([cname[:-2]+'.obj'], cname[:-2], output_dir=None, libraries = ['python'+pyver], library_dirs=[sysconfig.get_python_lib()] + libs, runtime_library_dirs=[], debug=0, extra_preargs=[] + optio, extra_postargs=optio, target_lang=None) 
    else:
        cc2.link_executable([cname[:-2]+'.o'], cname[:-2], output_dir=None, libraries = libraries, library_dirs=[sysconfig.get_python_lib()] + libs, runtime_library_dirs=[], debug=1, extra_preargs=['-pg'] + optio, extra_postargs=optio, target_lang=None) 

    return     
    
def link_c():
    if len(list_ext) != 0:    
        distutils.core.setup(name = 'install_all',
            version = "1.0",
            description = "Compiled to C Python code",
            ext_modules = list_ext,
            script_name = 'install' ,
            script_args = ['install']
            )

def unjumpable(cmd):
  if len(cmd) == 1:
      if cmd[0] in ('RETURN_VALUE', 'EXEC_STMT'):
        return False
      if cmd[0][0:6] in ('BINARY', 'UNARY_'):
        return False
  if cmd[0] in set_any:
      return False
  if cmd[0] in _unjump_cmds:              
      return False
  if cmd[0] == 'RAISE_VARARGS' and cmd[1] != 0:
      return False
  if cmd[0] in ('STORE', 'SEQ_ASSIGN', 'SET_EXPRS_TO_VARS', 'UNPUSH'):
      return True
  if cmd[0][0] in ('J', '(', ')')  :
      return False
  if cmd[0] == 'LOAD_CONST':
      return False
  return not type(cmd) is list and \
         cmd[0] is not None and cmd[0][0] != '!' and cmd[0] not in ('LOAD_FAST', 'LOAD_CLOSURE') and \
         cmd[0][0] not in ('J', '(', ')') and cmd[0][0:2] != '.:'

def linear_to_seq(cmds):
    ret = []
    i = 0
    while i < len(cmds):
        assert type(i) is int
        cmd = cmds[i]
        if not unjumpable(cmd):
            ret.append(cmd)
            i = i + 1
            continue
        ret2 = []
        while unjumpable(cmd) or type(cmd) is list:
            if type(cmd) is list:
                ret2.extend(cmd[:])
            else:    
                ret2.append(cmd)
            i = i + 1
            if  i < len(cmds):
              cmd = cmds[i]
            else:
                break  
        if len(ret) > 0 and type(ret[-1]) is list:
            ret[-1] = ret[-1] + ret2
        else:    
            ret.append(ret2)
        continue
    cmds[:] = ret[:]    
        
def jump_to_continue_and_break(cmds):        
    i = 0
    loops = [(i,pos_label(cmds, x[1])) for i,x in enumerate(cmds) if x[0] in ('J_SETUP_LOOP', 'J_SETUP_LOOP_FOR')]
    ## breaks = {}
    continues = {}
    ranges = {}
    for a,b in loops:
        j = a + 1
        while j < len(cmds) and j < b:
            if cmds[j][0] == '.:':
                continues[a] = cmds[j][1]
                break
            if (cmds[j][0][0:4] == 'JUMP' or cmds[j][0][0:7] == 'J_SETUP'):
                break
            j = j + 1 
        ranges[a] = set([i for i in range(a,b) if cmds[i][0][0] == 'J'])
    inter = [(a1,b1, a2,b2) for a1,b1 in loops for a2,b2 in loops if a2 > a1 and b2 < b1]
    for a1,b1,a2,b2 in inter:
        ranges[a1] = ranges[a1] - ranges[a2]
    for a,b in loops:
        for i in ranges[a]:
            cmd = cmds[i]
            if cmd[0] in jump and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF_TRUE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF_TRUE_POP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF_FALSE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF_FALSE_POP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF2_TRUE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF2_TRUE_POP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF2_FALSE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF2_FALSE_POP_CONTINUE',) + cmd[1:]

## def prin(n,cmd,cmds = None):
    ## if not print_pycmd:
        ## return
    ## if isblock(cmd):
        ## print >>out,n, '{'
        ## print_cmds2(cmd, 2)
        ## print >>out,'}'
    ## elif cmd[0] == '.:':
        ## print >>out,n,cmd, CountJumpCache(cmd[1],cmds) 
    ## else:
        ## print >>out,n,cmd 
          
def label(j,l):
    return bool(j[0][0] == 'J' and l[0] == '.:' and l[1] == j[1])

def endlabel(j,l):
    return bool(j[0][0] == 'J' and (l[0] == '.:' or l[0] in jump) and l[1] == j[1])

def cmds_join(i,cmds):
    if i >= len(cmds):
        return
    if i > 0 and type(cmds[i]) is list and type(cmds[i-1]) is list:
        cmds[i-1] = cmds[i-1] + cmds[i]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i < len(cmds)-1 and type(cmds[i]) is list and type(cmds[i+1]) is list:
        cmds[i] = cmds[i] + cmds[i+1]
        del cmds[i+1]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return

    if i < len(cmds)-1 and i > 0 and \
        type(cmds[i-1]) is list and unjumpable(cmds[i]) and type(cmds[i+1]) is list:
        cmds[i] = cmds[i-1] + [cmds[i]] + cmds[i+1]
        del cmds[i-1]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i > 0 and unjumpable(cmds[i]) and type(cmds[i-1]) is list:
        cmds[i-1] = cmds[i-1] + [cmds[i]]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i < len(cmds)-1 and type(cmds[i]) is list and unjumpable(cmds[i+1]):
        cmds[i] = cmds[i] + [cmds[i+1]]
        del cmds[i+1]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i < len(cmds)-1 and type(cmds[i+1]) is list and unjumpable(cmds[i]):
        cmds[i] = [cmds[i]] + cmds[i+1]
        del cmds[i+1]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i > 0 and unjumpable(cmds[i]) and not type(cmds[i]) is list and\
       not type(cmds[i-1]) is list and cmds[i-1][0] == '.L':
        cmds[i-1] = [cmds[i-1],cmds[i]]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)        
        return
    if unjumpable(cmds[i]) and not type(cmds[i]) is list :
        cmds[i] = [cmds[i]]
        return
    
def prin(a,b,c):
    print >>out, a
    print >>out, b
    
def print_pr(cmds):    
    if not print_pycmd:
        return
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l
    prin (1,pos__a, cmds)
    prin (2,pos__b, cmds)
    prin (3,pos__c, cmds)
    prin (4,pos__d, cmds)
    prin (5,pos__e, cmds)
    prin (6,pos__f, cmds)        
    prin (7,pos__g, cmds) 
    prin (8,pos__h, cmds)        
    prin (9,pos__i, cmds) 
    prin (10,pos__j, cmds) 
    prin (11,pos__k, cmds) 
    prin (12,pos__l, cmds) 
    print >>out, ''     
                            
def half_recompile(cmds, co):
    global debug
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l
    i = 0
    totemp = [(None,)] * 12
    oldi = -1
    first = True
    last = False
    added_pass = False
#    debug = False
    only_matched = False
    ClearJumpCache()
    if debug:
        if print_pycmd:
            print >>out, 'Step 0'
            print_cmds(cmds)
        ClearJumpCache()    
    while i <= len(cmds):   
        assert type(i) is int
        if first and i == len(cmds):
            ClearJumpCache()
            if debug and print_pycmd:
                print >>out, 'Step 1'
                print_cmds(cmds)
            linear_to_seq(cmds)
            NoGoToGo(cmds)
            jump_to_continue_and_break(cmds)
            i = 0
            first = False
        elif not first and i == len(cmds) and not last and len(cmds) > 2:   
            ClearJumpCache()
            if debug and print_pycmd:
                print >>out, 'Step 2'
                print_cmds(cmds)
            added_pass = True
            NoGoToGo(cmds)
            NoGoToReturn(cmds)
            jump_to_continue_and_break(cmds)
            i = 0
            first = False
            last = True
            i = 0
            while i < len(cmds):
                assert type(i) is int
                if islineblock(cmds[i]):
                    del cmds[i]
                    continue
                i = i + 1
            i = 0      
        bingo = False    
        assert type(i) is int
        if oldi == i:
            bingo = True
            ClearJumpCache()
            ## prevlen = len(cmds)
            if debug == True:
                tempor = cmds[i:i+12]
                while len(tempor) < 12:
                    tempor.append((None,))
                pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l = tempor
                if print_pycmd:
                    print >>out, '!!!!!!',i, '!!!!!!'
                    print_pr(cmds)
            _len = len(cmds)           
            cmds_join(i,cmds)
            i -= 12
            if len(cmds) < _len:
                i -= _len - len(cmds)
            if i < 0:
                i = 0 
##            del_all_unused_label(cmds, i)
        if i < 0:
            i = 0 
        oldi = i
        tempor = cmds[i:i+12]
        if len(tempor) < 12:
            tempor = (tempor + totemp)[:12]
        pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l = tempor
        if debug == True and print_pycmd and not only_matched:
            if bingo:
                print >>out, '*****',i, '*****'
            else:
                print >>out, '--',i, '--'
            print_pr(cmds)

        begin_cmp()
        if type(pos__a) is tuple and len(pos__a) >= 1:
            if pos__a[0] is not None and pos__a[0][0:4] == 'JUMP' and\
            pos__a[0] != 'JUMP_IF_NOT_EXCEPTION_POP':
                changed_jump = process_jump(cmds,i,added_pass)
                if changed_jump:
                    continue
            if pos__a[0] == 'J_FOR_ITER':
                if pos__b[0] in set_any:
                    cmds[i:i+2] = [('J_LOOP_VARS', pos__a[1], (pos__b,))]
                    continue
                if islineblock(pos__b) and pos__c[0] in set_any:
                    cmds[i:i+3] = [('J_LOOP_VARS', pos__a[1], (pos__c,))]
                    continue
                if pos__b[0] == 'UNPACK_SEQ_AND_STORE' and pos__b[1] == 0:
                    b2 = pos__b[2]
                    if len(b2) == 1:
                        b2 += (None,)
                    cmds[i:i+2] = [('J_LOOP_VARS', pos__a[1], b2)]
                    continue
            if pos__a[0] == '.:' and pos__b[0] == 'J_LOOP_VARS':
                if pos__e[0] == 'JUMP' and is_cmdmem(pos__c):
                    if SCmp(cmds, i, ((':', 4), 'J_LOOP_VARS', '>', \
                                    'LIST_APPEND', 'JUMP', '.:')) and \
                                    pos__a[1] != pos__b[1] and pos__f[0] != pos__b[1] and len(pos__d) == 2:  
                        rpl(cmds, [pos__a, ('J_BASE_LIST_COMPR', pos__b[1], (cmd2mem(pos__c),), (pos__b[2], None, ())),pos__f]                )
                        continue    
                    if SCmp(cmds, i, ((':', 4), 'J_LOOP_VARS', '>', \
                                    ('SET_ADD', 2), 'JUMP', '.:')) and \
                                    pos__a[1] != pos__b[1] and pos__f[0] != pos__b[1] :  
                        rpl(cmds, [pos__a, ('J_BASE_SET_COMPR', pos__b[1], (cmd2mem(pos__c),), (pos__b[2], None, ())),pos__f]                )
                        continue   
                if pos__f[0] == 'JUMP' and is_cmdmem(pos__c) and is_cmdmem(pos__d):
                    if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', '>', '>', \
                                    ('MAP_ADD', 2), 'JUMP', '.:')) and \
                                    pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] :  
                        rpl(cmds, [pos__a, ('J_BASE_MAP_COMPR', pos__b[1], (cmd2mem(pos__d),cmd2mem(pos__c),), (pos__b[2], None, ())),pos__g]   )
                        continue    
                if pos__e[0] == 'LIST_APPEND':
                    if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', '>', \
                                    'LIST_APPEND', 'JUMP', '.:')) and \
                                    pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__e) == 2:  
                        rpl(cmds, [pos__a, ('J_BASE_LIST_COMPR', pos__b[1], (cmd2mem(pos__d),), (pos__b[2], None, (Not(pos__c[2]),))),pos__g]                )
                        continue    
                    if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', '>', \
                                    'LIST_APPEND', 'JUMP', '.:')) and \
                                    pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__e) == 2:  
                        rpl(cmds, [pos__a, ('J_BASE_LIST_COMPR', pos__b[1], (cmd2mem(pos__d),), (pos__b[2], None, (pos__c[2],))),pos__g]                )
                        continue    
                
            if pos__a[0] == '.L':
                if pos__b[0] in jump and len(pos__b) == 2:
                    cmds[i:i+2] = [(pos__b[0], pos__b[1], pos__a[1])]
                    continue
                if pos__b[0] == 'J_SETUP_LOOP' and len(pos__b) == 2:
                    cmds[i:i+2] = [('J_SETUP_LOOP', pos__b[1], pos__a[1])]
                    continue
                if pos__b[0] == '.L':
                    cmds[i:i+2] = [pos__b]
                    continue
                if pos__b[0] == 'DUP_TOP' and is_cmdmem(pos__c) and \
                    len(pos__d) == 2 and pos__d[0] == 'COMPARE_OP' and pos__d[1] == 'exception match':
                    cmds[i:i+4] = [('CHECK_EXCEPTION', cmd2mem(pos__c), pos__a[1])]
                    continue  
    
            if pos__a[0] == 'DELETE_FAST' and pos__a[1][0:2] == '_[':
                cmds[i] = (')END_LIST_COMPR', ('FAST', pos__a[1]))
                continue
            if pos__a[0] == 'DELETE_NAME' and pos__a[1][0:2] == '_[':
                cmds[i] = (')END_LIST_COMPR', ('NAME', pos__a[1]))
                continue
            if pos__a[0] == 'UNPACK_SEQUENCE' and len(pos__a) == 2 and pos__a[1] > 0 and pos__b[0] in set_any:
                cmds[i] = ('UNPACK_SEQ_AND_STORE', pos__a[1], ())
                continue
            if pos__a[0] == 'UNPACK_SEQUENCE' and len(pos__a) == 2 and pos__a[1] > 0 and pos__b[0] == 'UNPACK_SEQ_AND_STORE':
                cmds[i] = ('UNPACK_SEQ_AND_STORE', pos__a[1], ())
                continue
            if pos__a[0] == 'UNPACK_SEQ_AND_STORE':
                if pos__a[1] == 0:
                    cmds[i] = ('SET_VARS', pos__a[2])
                    continue
                if pos__a[1] > 0 and pos__b[0] == '.L' and pos__c[0] in set_any:
                    cmds[i:i+3] = [('UNPACK_SEQ_AND_STORE', pos__a[1]-1, pos__a[2] + (pos__c,))]
                    continue
                if pos__a[1] > 0 and pos__b[0] in set_any:
                    cmds[i:i+2] = [('UNPACK_SEQ_AND_STORE', pos__a[1]-1, pos__a[2] + (pos__b,))]
                    continue
                if pos__a[1] > 0 and pos__b[0] == 'UNPACK_SEQ_AND_STORE' and pos__b[1] == 0 :
                    cmds[i:i+2] = [('UNPACK_SEQ_AND_STORE', pos__a[1]-1, pos__a[2] + (pos__b,))]
                    continue
            if pos__a[0] == 'LOAD_CODEFUNC' and pos__b[0] == 'MAKE_FUNCTION':
                cmds[i:i+2] = [('MK_FUNK', pos__a[1], pos__b[1], ())]
                continue
            if pos__a[0] == 'MK_FUNK' and pos__a[2] == 0:
                cmds[i:i+1] = [('!MK_FUNK', pos__a[1], TupleFromArgs(pos__a[3]))]
                continue
            if pos__a[0] == 'MK_CLOSURE' and pos__a[2] == 0:
                cmds[i:i+1] = [('!MK_CLOSURE', pos__a[1], pos__a[3], TupleFromArgs(pos__a[4]))]
                continue
            if pos__a[0] == 'IMPORT_FROM' and pos__b[0] in set_any:
                cmds[i:i+2] = [('IMPORT_AND_STORE_AS', (pos__a[1],), (pos__b,))] 
                continue

            if pos__a[0] == 'IMPORT_AND_STORE_AS' and pos__b[0] == 'IMPORT_AND_STORE_AS':
                cmds[i:i+2] = [('IMPORT_AND_STORE_AS', pos__a[1] + pos__b[1], pos__a[2] + pos__b[2])] 
                continue
            if pos__a[0] == '!IMPORT_NAME' and pos__b[0] == 'IMPORT_AND_STORE_AS' and pos__c[0] == 'POP_TOP' and pos__a[3][1] == pos__b[1]:
                cmds[i:i+3] = [('IMPORT_FROM_AS', pos__a[1], pos__a[2], pos__a[3], pos__b[2])]
                continue    
    # LOAD_CLOSURE  and LOAD_DEREF marked as 'pure' ? or not ?        
            if pos__a[0] in ('LOAD_GLOBAL', 'LOAD_NAME'):
                if pos__a[1] in ('True', 'False', 'None'):
                    if pos__a[1] == 'True':
                        cmds[i] = ('LOAD_CONST', True)
                    elif pos__a[1] == 'False':
                        cmds[i] = ('LOAD_CONST', False)
                    elif pos__a[1] == 'None':
                        cmds[i] = ('LOAD_CONST', None)
                    continue
                if not redefined_all and pos__a[1] in d_built and \
                (pos__a[1][0:2] != '__' or pos__a[1] in ('__import__',) )and \
                    not  pos__a[1] in redefined_builtin:
                        cmds[i] = ('!LOAD_BUILTIN', pos__a[1])
                        continue
                if pos__a[0] == 'LOAD_GLOBAL':
                    cmds[i] = ('!LOAD_GLOBAL', pos__a[1])
                    continue
                if pos__a[0] == 'LOAD_NAME':
                    cmds[i] = ('!LOAD_NAME', pos__a[1])
                    continue
            if pos__a[0] == 'LOAD_DEREF':
                cmds[i] = ('!LOAD_DEREF', pos__a[1])
                continue
            if pos__a[0] == 'BUILD_LIST' and pos__a[1] == 0:
                if len(pos__a) == 3:
                    cmds[i] = ('!BUILD_LIST', pos__a[2])
                else:
                    cmds[i] = ('!BUILD_LIST', ())
                continue
            if pos__a == ('!BUILD_LIST', ()) and pos__b[0] == '!GET_ITER':
                changed_list_compr = process_list_compr_2(cmds,i,added_pass)
                if changed_list_compr:
                    continue
                
            if pos__a[0] == 'BUILD_TUPLE' and pos__a[1] == 0:
                if len(pos__a) == 3:
                    cmds[i] = TupleFromArgs(pos__a[2])
                else:
                    cmds[i] = ('CONST', ())
                continue
            if pos__a[0] == 'BUILD_SET':
                if pos__a[1] == 0 and len(pos__a) == 3 :
                    cmds[i] = ('!BUILD_SET', pos__a[2])
                    continue            
                if pos__a[1] == 0 and len(pos__a) == 2:
                    cmds[i] = ('!BUILD_SET', ())
                    continue         

            if pos__a == ('!BUILD_SET', ()) and pos__b == ('LOAD_FAST', '.0') and \
               pos__c[0] == 'J_BASE_SET_COMPR' and pos__d == ('.:', pos__c[1]):
                if pos__c[3][1] is None:
                    if pos__c[3][2] == ():
                        cmds[i:i+4] = [('!SET_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), None))]
                        continue 
                    else:
                        cmds[i:i+4] = [('!SET_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), pos__c[3][2]))]
                        continue   
                    
            if pos__a == ('!PyDict_New',) and pos__b == ('LOAD_FAST', '.0') and \
               pos__c[0] == 'J_BASE_MAP_COMPR' and pos__d == ('.:', pos__c[1]):
                if pos__c[3][1] is None:
                    if pos__c[3][2] == ():
                        cmds[i:i+4] = [('!MAP_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), None))]
                        continue 
                    else:
                        cmds[i:i+4] = [('!MAP_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), pos__c[3][2]))]
                        continue   

                     
            if pos__a[0] == '!PyDict_New' and pos__b[0] == 'STORE_MAP':
                if len(pos__a) == 1:
                    cmds[i] = ('!BUILD_MAP', (pos__b[1:],))
                    del cmds[i+1]         
                    continue
            if pos__a[0] == '!BUILD_MAP' and pos__b[0] == 'STORE_MAP':
                cmds[i] = ('!BUILD_MAP', pos__a[1] + (pos__b[1:],))
                del cmds[i+1]         
                continue
            if pos__a[0] == 'BUILD_MAP':
                if pos__a[1] == 0 and len(pos__a) == 2:
                    cmds[i] = ('!PyDict_New',)
                    continue
                if pos__a[1] > 0 and len(pos__a) == 2:
                    cmds[i] = ('BUILD_MAP', pos__a[1], ())
                    continue
                if pos__a[1] > 0 and len(pos__a) == 3 and pos__b[0] == 'STORE_MAP':
                    cmds[i:i+2] = [('BUILD_MAP', pos__a[1]-1, pos__a[2] + ((pos__b[1], pos__b[2]),))]
                    continue
                if pos__a[1] == 0 and len(pos__a) == 3 :
                    cmds[i] = ('!BUILD_MAP', pos__a[2])
                    continue
                if pos__a[1] > 0 and len(pos__a) == 3 and pos__b[0] == '.L':
                    cmds[i:i+2] = [pos__a]
                    continue  
            if pos__a[0] == 'YIELD_VALUE' and len(pos__a) == 2 and pos__b[0] == 'POP_TOP':
                cmds[i:i+2] = [('YIELD_STMT', pos__a[1])]
                continue
            if pos__a[0] == 'LOAD_LOCALS' and pos__b[0] == 'RETURN_VALUE' and len(pos__b) == 1:
                cmds[i:i+2] = [(pos__b[0], ('f->f_locals',))]
                continue
            if pos__a[0] == 'RAISE_VARARGS' and pos__a[1] == 0 and pos__b[0] == 'POP_TOP':
                cmds[i:i+2] = [('RAISE_VARARGS_STMT',) + pos__a[1:]]
                continue            
            if pos__a[0] == '.:':
                if CountJumpCache(pos__a[1], cmds) == 0:
                    del cmds[i]
                    continue
                if pos__b[0] == 'J_LOOP_VARS' and pos__c[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' and\
                        pos__c[1] == pos__a[1] and isretblock(pos__d) and pos__e[0] == '.:' and pos__b[1] == pos__e[1]:
                    cmds[i:i+5] = [pos__a,pos__b,[('(IF',) + pos__c[2:], pos__d, (')ENDIF',)],('JUMP_CONTINUE', pos__a[1]),pos__e]
                    continue
                if pos__b[0] == 'J_LOOP_VARS' and pos__c[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' and\
                        pos__c[1] == pos__a[1] and isblock(pos__d) and pos__e[0] == '.:' and pos__b[1] == pos__e[1]:
                    cmds[i:i+5] = [pos__a,pos__b,[('(IF',) + pos__c[2:], pos__d, (')(ELSE',), [('CONTINUE',)],(')ENDIF',)],pos__e]
                    continue
                if pos__b[0] == '.:':
                    for iii in range(len(cmds)):
                        if cmds[iii][0][0] == 'J' and cmds[iii][1] == pos__a[1]:
                            li = list(cmds[iii])
                            li[1] = pos__b[1]
                            cmds[iii] = tuple(li)
                    del cmds[i]
                    continue        
    
            if pos__a[0] == 'DUP_TOP' and is_cmdmem(pos__b) and \
            len(pos__c) == 2 and pos__c[0] == 'COMPARE_OP' and pos__c[1] == 'exception match':
                cmds[i:i+3] = [('CHECK_EXCEPTION', cmd2mem(pos__b))]
                continue  
            if pos__a[0] == 'CHECK_EXCEPTION':
                if pos__b[0] == 'JUMP_IF_FALSE_POP' and\
                pos__c[0] == 'POP_TOP3' :
                    cmds[i:i+3] = [('JUMP_IF_NOT_EXCEPTION_POP', pos__b[1], pos__a[1:],())]
                    continue
                if pos__b[0] == 'JUMP_IF_FALSE_POP' and\
                pos__c[0] == 'POP_TOP' and pos__d[0] in set_any and\
                pos__e[0] == 'POP_TOP':
                    cmds[i:i+5] = [('JUMP_IF_NOT_EXCEPTION_POP', pos__b[1], pos__a[1:], (pos__d,))]
                    continue
                if pos__b[0] == 'JUMP_IF_FALSE_POP' and\
                pos__c[0] == 'POP_TOP' and pos__d[0] in ('UNPACK_SEQ_AND_STORE',) and pos__d[1] == 0 and\
                pos__e[0] == 'POP_TOP':
                    cmds[i:i+5] = [('JUMP_IF_NOT_EXCEPTION_POP', pos__b[1], pos__a[1:], pos__d[:])]
                    continue
            if pos__a[0] == 'POP_TOP' and pos__b[0] == 'POP_TOP' and pos__c[0] == 'POP_TOP':
                cmds[i:i+3] = [('POP_TOP3',)]
                continue    
            if pos__a[0] == '!GET_ITER':
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] in ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE') and\
                    pos__e[0] == 'PyList_Append' and \
                    pos__f[0] in ('JUMP', 'JUMP_CONTINUE') and\
                    pos__g[0] == '.:'and\
                    pos__h[0] == ')END_LIST_COMPR':
                        cmds[i:i+8] = [('BASE_LIST_COMPR', pos__e[2:], (pos__c[2], pos__a[1:], (pos__d[2],))),pos__g,pos__h] # vars in for, iter in fors, condidion 
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] in ('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP_CONTINUE') and\
                    pos__e[0] == 'PyList_Append' and \
                    pos__f[0] in ('JUMP', 'JUMP_CONTINUE') and\
                    pos__g[0] == '.:'and\
                    pos__h[0] == ')END_LIST_COMPR':
                        cmds[i:i+8] = [('BASE_LIST_COMPR', pos__e[2:], (pos__c[2], pos__a[1:], (Not(pos__d[2]),))),pos__g,pos__h] # vars in for, iter in fors, condidion 
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == 'PyList_Append' and \
                    pos__e[0] in ('JUMP', 'JUMP_CONTINUE') and\
                    pos__f[0] == '.:'and\
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__d[2:], (pos__c[2], pos__a[1:], None)),pos__f,pos__g] # vars in for, iter in fors, condidion 
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] in ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE') and\
                    pos__e[0] == 'BASE_LIST_COMPR' and\
                    pos__f[0] == '.:' and \
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__e[1], (pos__c[2], pos__a[1:], (pos__d[2],)) +pos__e[2]),pos__f,pos__g]
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == 'JUMP_IF2_TRUE_POP' and\
                    pos__e[0] == 'BASE_LIST_COMPR' and\
                    pos__f[0] == '.:' and \
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__e[1], (pos__c[2], pos__a[1:], (pos__d[2],)) +pos__e[2]),pos__f,pos__g]
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == 'BASE_LIST_COMPR' and\
                    pos__e[0] == '.:' and \
                    pos__f[0] == ')END_LIST_COMPR':
                        cmds[i:i+6] = [('BASE_LIST_COMPR', pos__d[1], (pos__c[2], pos__a[1:], None) +pos__d[2]),pos__e,pos__f]
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == '.L' and\
                    pos__e[0] == 'BASE_LIST_COMPR' and\
                    pos__f[0] == '.:' and \
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__e[1], (pos__c[2], pos__a[1:], None) +pos__e[2]),pos__f,pos__g]
                        continue
            if pos__a[0] == '(BEGIN_LIST_COMPR':
                if pos__b[0] == '.L' and pos__c[0] == 'BASE_LIST_COMPR' and pos__d[0] == ')END_LIST_COMPR':
                    cmds[i:i+4] = [('!LIST_COMPR', pos__c[1], pos__c[2])]
                    continue
                if pos__b[0] == 'BASE_LIST_COMPR' and pos__c[0] == ')END_LIST_COMPR':
                    cmds[i:i+3] = [('!LIST_COMPR', pos__b[1], pos__b[2])]
                    continue
            if pos__a[0] == 'RAISE_VARARGS' and pos__a[1] == 0 and pos__b[0] == 'POP_TOP':
                cmds[i:i+2] = [('RAISE_VARARGS_STMT',) + pos__a[1:]]
                continue
        if type(pos__a) is list and isblock(pos__a):
            if pos__b[0] == 'JUMP_IF2_TRUE_POP_CONTINUE' and islineblock(pos__c):
                if type(pos__c) is tuple:
                    cmds[i:i+3] = [pos__a+[('(IF',) + pos__b[2:], [pos__c,('CONTINUE',)], (')ENDIF',)]]
                    continue
                if type(pos__c) is list:
                    cmds[i:i+3] = [pos__a+[('(IF',) + pos__b[2:], pos__c+[('CONTINUE',)], (')ENDIF',)]]
                    continue
            if pos__b[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' and isretblock(pos__c):
                    cmds[i:i+3] = [pos__a+[('(IF',) + pos__b[2:], pos__c, (')ENDIF',)], ('JUMP_CONTINUE', pos__b[1])]
                    continue
        if type(pos__a) is tuple and len(pos__a) >= 1:
            if pos__a[0] == '3CMP_BEG_3':
                if SCmp(cmds,i, ('3CMP_BEG_3', 'JUMP_IF_FALSE', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'JUMP', (':', 1,1), \
                                'ROT_TWO', 'POP_TOP', ('::', 5))):
                    rpl(cmds, [New_3Cmp(('!3CMP',) + pos__a[1:] + (pos__e[1],) + (cmd2mem(pos__d),))])
                    continue
                if SCmp(cmds,i, ('3CMP_BEG_3', 'JUMP_IF_FALSE', \
                                'POP_TOP', '>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP', \
                                'JUMP_IF_FALSE')) and pos__b[1] == pos__h[1]:
                    rpl(cmds, [('J_NCMP', pos__h[1]) + pos__a[1:] + (pos__g[1], cmd2mem(pos__d))])
                    continue
                if SCmp(cmds,i, ('3CMP_BEG_3', 'JUMP_IF_FALSE', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'RETURN_VALUE', (':', 1,1), \
                                'ROT_TWO', 'POP_TOP', 'RETURN_VALUE')):
                    rpl(cmds, [('RETURN_VALUE',New_3Cmp(('!3CMP',) + pos__a[1:] + (pos__e[1],) + (cmd2mem(pos__d),)))])
                    continue
            if pos__a[0] == 'J_NCMP':
                if SCmp(cmds,i, ('J_NCMP', \
                                'POP_TOP', '>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP', \
                                'JUMP_IF_FALSE')) and pos__a[1] == pos__g[1]:
                    rpl(cmds, [pos__a + (pos__f[1], cmd2mem(pos__c))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', \
                                'POP_TOP', '.L', '>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP', \
                                'JUMP_IF_FALSE')) and pos__a[1] == pos__h[1]:
                    rpl(cmds, [pos__a + (pos__g[1], cmd2mem(pos__d))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'JUMP', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', ('::', 4))):       #  1
                    rpl(cmds, [New_NCmp(pos__a[2:] + (pos__d[1], cmd2mem(pos__c)))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '.L', '>', 'COMPARE_OP', 'JUMP', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', ('::', 5))):       #  1
                    rpl(cmds, [New_NCmp(pos__a[2:] + (pos__e[1], cmd2mem(pos__d)))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'RETURN_VALUE', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', 'RETURN_VALUE')):
                    rpl(cmds, [('RETURN_VALUE', New_NCmp(pos__a[2:] + (pos__d[1], cmd2mem(pos__c))))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '.L', '>', 'COMPARE_OP', 'RETURN_VALUE', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', 'RETURN_VALUE')):
                    rpl(cmds, [('RETURN_VALUE', New_NCmp(pos__a[2:] + (pos__e[1], cmd2mem(pos__d))))])
                    continue
            if pos__a[0] == 'LOAD_CODEFUNC' and SCmp(cmds,i, ('LOAD_CODEFUNC', 'MAKE_FUNCTION', '!GET_ITER', 'CALL_FUNCTION_1')) and\
              pos__b[1] == 0 and pos__d[1] == 1: 
                cmds[i:i+4] = [('!GENERATOR_EXPR_NOCLOSURE',) + pos__a[1:] + (pos__c[1],)]
                continue
            if pos__a[0] == '!MK_CLOSURE':
                if pos__b[0] == 'GET_ITER' and\
                pos__c[0] == 'CALL_FUNCTION_1' and pos__c[1] == 1:
                    cmds[i:i+3] = [('!GENERATOR_EXPR',) + pos__a[1:] + (pos__b[1],)]
                    continue   
                if pos__b[0] == '.L':
                    cmds[i:i+2] = [pos__a]
                    continue  
            if pos__a[0] == 'MAKE_CLOSURE' and pos__b[0] == '.L':
                cmds[i:i+2] = [pos__a]
                continue   
    
            if pos__a[0] == 'LOAD_CONST':
                changed_load_const = process_load_const(cmds,i, added_pass)
                if changed_load_const:
                    continue
            if pos__a[0] == 'J_SETUP_FINALLY':
                changed_j_setup_fin = process_j_setup_finally(cmds,i, added_pass)
                if changed_j_setup_fin:
                    process_after_try_detect(cmds,i)
                    continue
            if pos__a[0] == 'J_BEGIN_WITH':
                changed_j_with = process_j_begin_with(cmds,i, added_pass)
                if changed_j_with:
                    continue
            if pos__a[0] == 'J_SETUP_LOOP':
                changed_loop = process_j_setup_loop(cmds,i, added_pass)
                if changed_loop:
                    continue
            if pos__a[0] == 'J_SETUP_LOOP_FOR':
                changed_loopfor = process_j_setup_loop_for(cmds,i)
                if changed_loopfor:
                    continue
            if pos__a[0] == '(BEGIN_TRY':
                changed_exc = process_begin_try(cmds,i)
                if changed_exc:
                    process_after_try_detect(cmds,i)
                    continue
            if pos__a[0] == 'J_SETUP_EXCEPT':
                changed_exc = process_setup_except(cmds,i)
                if changed_exc:
                    process_after_try_detect(cmds,i)
                    continue
            if pos__a[0] in ('JUMP_IF_NOT_EXCEPTION_POP', 'POP_TOP3'):
                changed_exc = process_except_clause(cmds,i)
                if changed_exc:
                    continue
            if is_cmdmem(pos__a):
                if is_cmdmem(pos__b):
                    changed_push = process_push2(cmds,i, added_pass)
                    if changed_push:
                        continue
                else:
                    changed_push = process_push(cmds,i, added_pass)
                    if changed_push:
                        continue
            if pos__a[0] == 'SEQ_ASSIGN_0':   
                if SCmp(cmds,i, ('SEQ_ASSIGN_0', '=')) and pos__a[1] > 0:          
                    rpl(cmds,[('SEQ_ASSIGN_0', pos__a[1]-1, pos__a[2] + (pos__b,), pos__a[3])])
                    continue    
                if SCmp(cmds,i, ('SEQ_ASSIGN_0', 'DUP_TOP')):          
                    rpl(cmds,[('SEQ_ASSIGN_0', pos__a[1]+1, pos__a[2], pos__a[3])])
                    continue    
                if pos__a[1] == 0:      
                    assert len(pos__a) == 4 
                    cmds[i] = ('SEQ_ASSIGN', pos__a[2], pos__a[3])
                    continue    
            if pos__c[0] == 'ROT_TWO':		  
                if pos__a[0] == 'LOAD_FAST' and SCmp(cmds,i, ('LOAD_FAST', '>', 'ROT_TWO')):
                    rpl(cmds,[pos__b[:], pos__a[:]])
                    continue
                if pos__a[0] == 'LOAD_NAME' and SCmp(cmds,i, ('LOAD_NAME', '>', 'ROT_TWO')):
                    rpl(cmds,[pos__b[:], pos__a[:]])
                    continue
            if pos__b[0] == 'J_LOOP_VARS' and pos__a[0] == '.:': 
                if SCmp(cmds,i, ((':', 3,0), 'J_LOOP_VARS', '*n', 'xJUMP_IF2_FALSE_POP_CONTINUE', '*')):
                    rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)]+pos__e])
                    continue
                if SCmp(cmds,i, ((':', 3,0), 'J_LOOP_VARS', '*n', 'xJUMP_IF2_FALSE_POP_CONTINUE', '*l')):
                    if type(pos__e) is tuple:
                        rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)],pos__e])
                    else:
                        rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)]+pos__e])
                    continue
                if SCmp(cmds,i, ((':', 3,0), 'J_LOOP_VARS', '*n', 'xJUMP_IF2_FALSE_POP_CONTINUE')):
                    rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)]])
                    continue
            if added_pass:   
                if pos__a[0] == 'JUMP' and type(pos__b) is tuple and \
                    pos__b[0] not in ('.:', 'POP_BLOCK', 'END_FINALLY', None, '^^'):
                    del cmds[i+1]
                    continue
                if pos__a[0] == 'RETURN_VALUE' and type(pos__b) is tuple and \
                    pos__b[0] not in ('.:', 'POP_BLOCK', 'END_FINALLY', None, '^^'):
                    del cmds[i+1]
                    continue
            if pos__a[0] == '(BEGIN_DEF':  
                if len(cmds) > 2 and SCmp(cmds,i, ('(BEGIN_DEF', '*r')):
                    del cmds[2:]
                    continue
            if pos__a[0] == 'J_COND_PUSH':  
                if SCmp(cmds,i, ('J_COND_PUSH', 'J_COND_PUSH')) and pos__a[1] == pos__b[1]:
                    rpl(cmds,[pos__a[:] + pos__b[2:]])
                    continue
                if SCmp(cmds,i, ('J_COND_PUSH', '>', ('::', 0))):
                    rpl(cmds,[('!COND_EXPR',) + pos__a[2:] + (cmd2mem(pos__b),)])
                    continue
        i = i + 1   
    if len(cmds) > 2:   
        print (filename + ":Can't decompile " + cmds[0][1] + ' ' + str( co.co_firstlineno))
        N2C(cmds[0][1]).decompile_fail = True
    else:
        N2C(cmds[0][1]).decompile_fail = False
    return cmds

def process_list_compr_2(cmds,i,added_pass):
    if SCmp(cmds, i, (('!BUILD_LIST', ()), '!GET_ITER', (':', 5, 1),\
                        'J_LOOP_VARS', '!GET_ITER', 'J_BASE_LIST_COMPR', \
                         ('::', 3))):
        if pos__f[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__f[2], (pos__d[2], (pos__b[1],), None, pos__f[3][0], (pos__e[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__f[2], (pos__d[2], (pos__b[1],), None, pos__f[3][0], (pos__e[1],), pos__f[3][2]))])
            return True   
        
    if SCmp(cmds, i, (('!BUILD_LIST', ()), \
                     '!GET_ITER', (':', 6, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 8, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', 'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__i[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__i[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__i[3][0], (pos__h[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__i[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__i[3][0], (pos__h[1],), pos__i[3][2]))])
            return True   

        

    if SCmp(cmds, i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4,6)),\
                        'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP','!GET_ITER', \
                        'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__g[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (Not(pos__e[2]),), pos__g[3][0], (pos__f[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (Not(pos__e[2]),), pos__g[3][0], (pos__f[1],), pos__g[3][2]))])
            return True                                
                                                                                   
    if SCmp(cmds, i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4,6)),\
                        'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP','!GET_ITER', \
                        'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__g[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (pos__e[2],), pos__g[3][0], (pos__f[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (pos__e[2],), pos__g[3][0], (pos__f[1],), pos__g[3][2]))])
            return True                                
                                                                                   
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', 'J_BASE_LIST_COMPR', ('::', 2))):
        if pos__c[3][1] is None:
            if pos__c[3][2] == ():
                rpl(cmds, [('!LIST_COMPR', pos__c[2], (pos__c[3][0], (pos__b[1],), None))])
                return True   
            else:
                rpl(cmds, [('!LIST_COMPR', pos__c[2], (pos__c[3][0], (pos__b[1],), pos__c[3][2]))])
                return True   

    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('LIST_APPEND', 2), 'JUMP', \
                    ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__e),), (pos__d[2], (pos__b[1],), None))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE', \
                    ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__e),), (pos__d[2], (pos__b[1],), None))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP_CONTINUE', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP_CONTINUE', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    return False

def process_push(cmds,i,added_pass):
    aa = cmd2mem(pos__a)

    if SCmp(cmds,i, ('LOAD_FAST', (':', 4, 1), 'J_LOOP_VARS', '*', 'JUMP', (':', 2, 1))):
        rpl(cmds,[[('(FOR_DIRECT_ITER', aa, pos__c[2]), pos__d, (')FOR_DIRECT_ITER',)]])
        return True       

    if SCmp(cmds,i, ('LOAD_FAST', (':', 5, 1), 'J_LOOP_VARS', '!GET_ITER', (':', 7, 1), \
                     'J_LOOP_VARS', '*', 'JUMP', (':', 2, 1))):
        rpl(cmds,[[('(FOR_DIRECT_ITER2', aa, pos__c[2], pos__d[1]), pos__g, (')FOR_DIRECT_ITER2',)]])
        return True       

    if SCmp(cmds,i, ('>', ('BUILD_LIST_FROM_ARG', 0), 'GET_ITER')):
        rpl(cmds,[ ('BUILD_LIST', 0), aa, pos__c])
        return True       

    if SCmp(cmds,i, ('>', 'J_SETUP_WITH', 'POP_TOP')):    
        rpl(cmds,[('J_BEGIN_WITH', pos__b[1], aa, ())])
        return True       
    if SCmp(cmds,i, ('>', 'J_SETUP_WITH', '=')):    
        rpl(cmds,[('J_BEGIN_WITH', pos__b[1], aa, (pos__c,))])
        return True       
    
    
    if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE_OR_POP', '>', (':', 1, 1))):
        rpl(cmds,[Or_j_s(pos__a, pos__c)])
        return True       
    if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE_OR_POP', '>', (':', 1, 1))):
        rpl(cmds,[And_j_s(pos__a, pos__c)])
        return True       

    if pos__a[0] == '!BUILD_LIST' and len(pos__a[1]) == 0 and pos__b[0] == 'DUP_TOP' and\
        pos__c[0] == 'STORE_FAST' and pos__c[1][0:2] == '_[': # and pos__d[0] == 'GET_ITER':
        cmds[i:i+3] = [('(BEGIN_LIST_COMPR', ('FAST', pos__c[1]))] #, pos__d[1])]
        return True
    if pos__a[0] == '!BUILD_LIST' and len(pos__a[1]) == 0 and pos__b[0] == 'DUP_TOP' and\
        pos__c[0] == 'STORE_NAME' and pos__c[1][0:2] == '_[':# and pos__d[0] == 'GET_ITER':
        cmds[i:i+3] = [('(BEGIN_LIST_COMPR', ('!NAME', pos__c[1]))] #, pos__d[1])]
        return True
    if pos__a[0] == '!BUILD_TUPLE' and pos__b[0] == 'POP_TOP':
        cmds[i:i+2] = [('UNPUSH', aa)]
        return True
    if pos__b is not None and pos__b[0] == 'DUP_TOP':

        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), \
                        'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), ('CALL_FUNCTION_1', 0),\
                        'POP_TOP', 'J_SETUP_FINALLY')):
                cmds[i:i+8] = [('J_BEGIN_WITH', pos__h[1], aa,())] 
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), 'STORE_FAST',\
                        ('LOAD_ATTR_1', '__enter__'), ('CALL_FUNCTION_1', 0), 'POP_TOP', 'J_SETUP_FINALLY')):
                cmds[i:i+8] = [('J_BEGIN_WITH', pos__h[1], aa,())] 
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), \
                        'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), \
                        ('CALL_FUNCTION_1', 0), 'STORE_FAST', \
                        'J_SETUP_FINALLY', 'LOAD_FAST', \
                        'DELETE_FAST', '=')) and pos__g[1] == pos__i[1] and pos__g[1] == pos__j[1]:
                cmds[i:i+11] = [('J_BEGIN_WITH', pos__h[1], aa, (pos__k))] 
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), \
                        'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), ('CALL_FUNCTION_1', 0),\
                            'STORE_FAST', 'J_SETUP_FINALLY', 'LOAD_FAST', \
                        ')END_LIST_COMPR', '=')) and pos__g[1] == pos__i[1] and pos__g[1] == pos__j[1][1]:
                cmds[i:i+11] = [('J_BEGIN_WITH', pos__h[1], aa, (pos__k))] 
                return True
            
        if (pos__a[0] == '!LOAD_DEREF' or pos__a[0] == '!LOAD_NAME' or pos__a[0] == '!LOAD_GLOBAL' or \
            pos__a[0] == '!PyDict_GetItem(glob,' or\
             pos__a[0] == 'LOAD_FAST' or pos__a[0] == '!PyObject_GetAttr'):
            cmds[i:i+2] = [pos__a[:], pos__a[:]]
            return True
                    
        if SCmp(cmds,i, ('>', 'DUP_TOP', '=', '=')):
                cmds[i:i+4] = [('SET_EXPRS_TO_VARS', (pos__d,pos__c), ('CLONE', aa))]
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'UNPACK_SEQ_AND_STORE', '=')) and pos__c[1] == 0:
                cmds[i:i+4] = [('SET_EXPRS_TO_VARS', (pos__d,pos__c), ('CLONE', aa))]
                return True           
        if SCmp(cmds,i, ('>', 'DUP_TOP', '>', 'ROT_TWO', \
                        'PRINT_ITEM_TO_0', 'PRINT_NEWLINE_TO_0')):        
            cmds[i:i+6] = [('PRINT_ITEM_AND_NEWLINE_TO_2', aa, cmd2mem(pos__c))]
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', '>', 'ROT_TWO', \
                        'PRINT_ITEM_TO_0', 
                        'DUP_TOP', '>', 'ROT_TWO', 'PRINT_ITEM_TO_0',
                        'PRINT_NEWLINE_TO_0')):        
            cmds[i:i+10] = [('PRINT_ITEM_AND_NEWLINE_TO_3', aa, cmd2mem(pos__c), cmd2mem(pos__g))]
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', '>', 'ROT_TWO',  'PRINT_ITEM_TO_0', 'POP_TOP')):        
            rpl(cmds,[('PRINT_ITEM_TO_2', aa, cmd2mem(pos__c))])
            return True        
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'LOAD_ATTR_1', '>', 'INPLACE_ADD',\
                        'ROT_TWO', 'STORE_ATTR_1')) and pos__g[1] == pos__c[1]:
            rpl(cmds,[('STORE', (('PyObject_SetAttr', aa, ('CONST', pos__g[1])),), \
                    (('!' + recode_inplace['INPLACE_ADD'], ('!PyObject_GetAttr', aa, ('CONST', pos__c[1])), cmd2mem(pos__d)),))])
            return True   
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'LOAD_ATTR_1', '>', 'INPLACE_MULTIPLY',\
                        'ROT_TWO', 'STORE_ATTR_1')) and pos__g[1] == pos__c[1]:
            rpl(cmds,[('STORE', (('PyObject_SetAttr', aa, ('CONST', pos__g[1])),), 
                    (('!' + recode_inplace['INPLACE_MULTIPLY'], ('!PyObject_GetAttr', aa, ('CONST', pos__c[1])), cmd2mem(pos__d)),))])
            return True   
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'STORE_GLOBAL', 'STORE_FAST')):
            rpl(cmds,[pos__a, pos__d, ('LOAD_FAST', pos__d[1]), pos__c])
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'STORE_FAST', 'STORE_GLOBAL')):
            rpl(cmds,[pos__a, pos__c, ('LOAD_FAST', pos__c[1]), pos__d])
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', '=')):
                rpl(cmds,[('SEQ_ASSIGN_0', 1, (pos__c,), aa)])
                return True    
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'STORE_FAST')): 
                rpl(cmds,[pos__a, pos__c, ('LOAD_FAST', pos__c[1])])
                return True

    ## if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'),\ # By CloneDigger
                    ## 'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), \
                    ## ('CALL_FUNCTION_1', 0), 'STORE_FAST', \
                    ## 'J_SETUP_FINALLY', 'LOAD_FAST', \
                    ## 'DELETE_FAST', '=')) and pos__g[1] == pos__i[1] and pos__g[1] == pos__j[1]:
            ## cmds[i:i+11] = [('J_BEGIN_WITH', pos__h[1], aa, (pos__k))] 
            ## return True
    if SCmp(cmds,i, ('!PyObject_GetAttr', 'STORE', 'J_SETUP_FINALLY', \
                    'LOAD_FAST', ')END_LIST_COMPR', '=')) and\
                    pos__a[2][1] == '__exit__' and \
                    pos__b[1][0][1][:2] == '_[' and \
                    pos__d[1] == pos__b[1][0][1]:
            cmds[i:i+6] = [('J_BEGIN_WITH', pos__c[1], pos__a[1], (pos__f,))] 
            return True
    if SCmp(cmds,i, ('!PyObject_GetAttr', 'STORE', 'J_SETUP_FINALLY', '!LOAD_NAME', \
                    ')END_LIST_COMPR', '=')) and pos__a[2][1] == '__exit__' and pos__d[1] == pos__e[1][1]:
            rpl(cmds,[('J_BEGIN_WITH', pos__c[1], pos__a[1], (pos__f))])
            return True

    if isblock(pos__b) and len(pos__b) == 1 and type(pos__b[0]) is tuple:
        cmds[i+1:i+2] = pos__b
        return True

    if  is_cmdmem(pos__c) and pos__b[0] == '.L':
        del cmds[i+1]
        return True
    if pos__c[0] == 'MK_FUNK' and pos__c[2] > 0 and pos__b[0] == '.L':
        cmds[i:i+3] = [('MK_FUNK', pos__c[1], pos__c[2]-1, (aa,)+pos__c[3])]
        return True
    if pos__b[0] == 'MK_FUNK' and pos__b[2] > 0:
        cmds[i:i+2] = [('MK_FUNK', pos__b[1], pos__b[2]-1, (aa,)+pos__b[3])]
        return True
    if pos__b[0] == 'LOAD_CODEFUNC' and pos__c[0] == 'MAKE_CLOSURE':
        cmds[i:i+3] = [('MK_CLOSURE', pos__b[1], pos__c[1], aa, ())]
        return True
    if pos__b[0] == 'MK_CLOSURE' and pos__b[2] > 0:
        cmds[i:i+2] = [('MK_CLOSURE', pos__b[1], pos__b[2]-1, pos__b[3], (aa,)+pos__b[4])]
        return True       

    if SCmp(cmds,i, ('>', 'JUMP', '>', (':', 1, 1))):
        cmds[i:i+4] = [pos__a[:]]
        return True
    if SCmp(cmds,i, ('>', 'JUMP', '>', (':', 1, 2))):
        cmds[i:i+4] = [pos__a[:], pos__d[:]]
        return True

    if pos__b[0] == 'PRINT_ITEM_TO_2' and \
        pos__c[0] == 'DUP_TOP':
        cmds[i:i+3] = [pos__b[:], pos__a, pos__c]
        return True
    if pos__b[0] == 'PRINT_ITEM_TO_2' and \
        pos__c[0] == 'PRINT_NEWLINE_TO_0':
        cmds[i:i+3] = [pos__b[:], ('PRINT_NEWLINE_TO_1', aa)]
        return True
    if pos__b[0] == 'PRINT_NEWLINE_TO_0':
        cmds[i:i+2] = [('PRINT_NEWLINE_TO_1', aa)]
        return True

    if  is_cmdmem(pos__c) and pos__b[0] == '.L':
            cmds[i:i+3] = pos__b, pos__a, pos__c
            return True
    if pos__b[0] == 'STORE_ATTR_1':
        cmds[i:i+2] = [('PyObject_SetAttr', aa, ('CONST', pos__b[1]))]
        return True
    if  pos__b[0] in set_any:
        cmds[i:i+2] = [('STORE',(pos__b,), (aa,))]
        return True
    if pos__b[0] == 'PRINT_ITEM_0':
        cmds[i:i+2] = [('PRINT_ITEM_1',) + (aa,)]
        return True
    if ( pos__b[0] in ('JUMP_IF_FALSE_POP_BREAK','JUMP_IF_FALSE_POP_CONTINUE',\
                    'JUMP_IF_TRUE_POP_BREAK','JUMP_IF_TRUE_POP_CONTINUE',\
                    'JUMP_IF_FALSE_POP', 'JUMP_IF_TRUE_POP') and len(pos__b) == 2 ):
        bb = 'JUMP_IF2_' + pos__b[0][8:]     
        cmds[i:i+2] = [(bb, pos__b[1], aa)]
        return True
    if pos__b[0] == 'RETURN_VALUE' and len(pos__b) == 1:
        cmds[i:i+2] = [pos__b + (aa,)]
        return True
    if pos__b[0] == 'IMPORT_STAR' and len(pos__b) == 1 and pos__a[0] == '!IMPORT_NAME':
        cmds[i:i+2] = make_import_star(aa)
        return True
    if pos__b[0] == 'IMPORT_STAR' and len(pos__b) == 1:
        cmds[i:i+2] = [pos__b + (aa,)]
        return True
    if pos__b[0] == 'GET_ITER'  and len( pos__b) == 1 :
        cmds[i:i+2] = [('!GET_ITER',) + (aa,)]
        return True
    if pos__b[0] == 'BUILD_LIST' and pos__b[1] > 0:
        if len(pos__b) == 2:
            b_ = (pos__b[0], pos__b[1], ())
        else:
            b_ = pos__b    
        cmds[i:i+2] = [('BUILD_LIST', b_[1] - 1, (aa,) + b_[2])]
        return True
    if pos__b[0] == 'BUILD_TUPLE' and pos__b[1] > 0:
        if len(pos__b) == 2:
            b_ = (pos__b[0], pos__b[1], ())
        else:
            b_ = pos__b    
        cmds[i:i+2] = [('BUILD_TUPLE', b_[1] - 1, (aa,) + b_[2])]
        return True
    if pos__b[0] == 'BUILD_SET' and pos__b[1] > 0:
        if len(pos__b) == 2:
            b_ = (pos__b[0], pos__b[1], ())
        else:
            b_ = pos__b    
        cmds[i:i+2] = [('BUILD_SET', b_[1] - 1, (aa,) + b_[2])]
        return True
    if pos__b[0] == 'LOAD_ATTR_1':
        cmds[i:i+2] = [('!PyObject_GetAttr', aa, ('CONST', pos__b[1]))]
        return True
    if pos__b[0] == 'SLICE+0' and len(pos__b) == 1:
        cmds[i:i+2] = [('!PySequence_GetSlice', aa, 0, 'PY_SSIZE_T_MAX')]        
        return True
    if pos__b[0] == 'YIELD_VALUE' and len(pos__b) == 1 and pos__c[0] == 'POP_TOP':
        cmds[i:i+3] = [('YIELD_STMT', aa)]
        return True
    if pos__b[0] == 'YIELD_VALUE' and len(pos__b) == 1:
        cmds[i:i+2] = [('!YIELD_VALUE', aa)]
        return True
    if pos__b[0] == 'RAISE_VARARGS':
        if len(pos__b) == 2 and pos__b[1] == 1 and pos__c[0] == 'POP_TOP':
            cmds[i:i+3] = [('RAISE_VARARGS_STMT', 0, (aa,))]
            return True
        if len(pos__b) == 3 and pos__b[1] == 1 and pos__c[0] == 'POP_TOP':
            cmds[i:i+3] = [('RAISE_VARARGS_STMT', 0, (aa,)+ pos__b[2])]
            return True
        if len(pos__b) == 2 and pos__b[1] == 1:
            cmds[i:i+2] = [('RAISE_VARARGS', 0, (aa,))]
            return True
        if len(pos__b) == 2 and pos__b[1] >= 1:
            cmds[i:i+2] = [('RAISE_VARARGS', pos__b[1]-1, (aa,))]
            return True
        if len(pos__b) == 3 and pos__b[1] >= 1:
            cmds[i:i+2] = [('RAISE_VARARGS', pos__b[1]-1, (aa,) + pos__b[2])]
            return True
    if pos__b[0] in recode_unary:
        cmds[i:i+2] = [('!' +recode_unary[pos__b[0]], aa)]
        return True    
    if pos__b[0] == 'UNARY_NOT':
        cmds[i:i+2] = [Not(aa)]
        return True
    if pos__b[0][:6] == 'UNARY_':
        cmds[i:i+2] = [('!1' + pos__b[0][6:], aa)]
        return True
    if pos__b[0] == 'DELETE_SLICE+0' and len(pos__b) == 1:
                cmds[i:i+2] = [('DELETE_SLICE+0', aa)]
                return True
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        if len(pos__b[4]) == 0:
# must be after type dectection             
            if pos__a[0] =='!LOAD_BUILTIN':
                cm = attempt_direct_builtin(pos__a[1],pos__b[2], TupleFromArgs(pos__b[2]))
                if cm is not None:
                    cmds[i:i+2] = [cm]
                    return True
            if len(pos__b[2]) == 0:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('CONST',()), ('NULL',))]
                return True
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), ('NULL',))]
            return True
        else:
            if len(pos__b[2]) == 0:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('CONST',()), DictFromArgs(pos__b[4]))]
                return True
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), DictFromArgs(pos__b[4]))]        
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_KW')):
        cmds[i:i+2] =  [('CALL_FUNCTION_KW_1',) + pos__b[1:] + (aa,)]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_KW_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4], pos__b[5])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_KW_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        if len(pos__b[4]) == 0:
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), pos__b[5])]
            return True        
        else:
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), ('!$PyDict_SymmetricUpdate', DictFromArgs(pos__b[4]), pos__b[5]))]
            return True        
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR')):
        cmds[i:i+2] =  [('CALL_FUNCTION_VAR_1',) + pos__b[1:] + (aa,)]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4], pos__b[5])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        if len(pos__b[4]) == 0:
            t = TypeExpr(pos__b[5])
            if len(pos__b[2]) == 0:
                if IsTuple(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, pos__b[5], ('NULL',))]
                elif IsList(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyList_AsTuple', pos__b[5]), ('NULL',))]
                else:
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PySequence_Tuple', pos__b[5]), ('NULL',))]
                return True
            if IsTuple(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), pos__b[5]), ('NULL',))]
            elif IsList(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PyList_AsTuple', pos__b[5])), ('NULL',))]
            else:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PySequence_Tuple', pos__b[5])), ('NULL',))]
            return True        
        else:
            t = TypeExpr(pos__b[5])
            if len(pos__b[2]) == 0:
                if IsTuple(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, pos__b[5], DictFromArgs(pos__b[4]))]
                elif IsList(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyList_AsTuple', pos__b[5]), DictFromArgs(pos__b[4]))]
                else:
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PySequence_Tuple', pos__b[5]), DictFromArgs(pos__b[4]))]
                return True

            if IsTuple(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), pos__b[5]), DictFromArgs(pos__b[4]))]
            elif IsList(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PyList_AsTuple', pos__b[5])), DictFromArgs(pos__b[4]))]
            else:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PySequence_Tuple', pos__b[5])), DictFromArgs(pos__b[4]))]
            return True        
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_KW_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4], pos__b[5],pos__b[6])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_KW_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        t = TypeExpr(pos__b[5])
        if len(pos__b[4]) == 0 and len(pos__b[2]) == 0:
            if IsTuple(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, pos__b[5], pos__b[6])]
            elif IsList(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyList_AsTuple', pos__b[5]), pos__b[6])]
            else:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PySequence_Tuple', pos__b[5]), pos__b[6])]
            return True        
        if len(pos__b[2]) > 0: 
            if IsTuple(t):
                tup = ('!PyNumber_Add', TupleFromArgs(pos__b[2]), pos__b[5]) 
            elif IsList(t):
                tup = ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PyList_AsTuple',pos__b[5])) 
            else:
                tup = ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PySequence_Tuple',pos__b[5])) 
        else:
            tup = pos__b[5]
        if len(pos__b[4]) > 0: 
            dic = ('!$PyDict_SymmetricUpdate', DictFromArgs(pos__b[4]), pos__b[6])  
        else:
            dic = pos__b[6]            
        cmds[i:i+2] = [('!PyObject_Call', aa, tup, dic)]
        return True       
    if SCmp(cmds,i, ('>', '.L', 'CALL_FUNCTION_1')):
        rpl(cmds,[pos__a,pos__c])
        return True
    if SCmp(cmds,i, ('>', 'POP_TOP')):
        rpl(cmds,[('UNPUSH', aa)])
        return True       
    if SCmp(cmds,i, ('>', 'DELETE_ATTR_1')):
        rpl(cmds,[('DELETE_ATTR_2', aa, ('CONST', pos__b[1]))])
        return True
    if SCmp(cmds,i, ('>', 'STORE_SLICE+0')):
                rpl(cmds,[('STORE_SLICE_LV+0', aa)])
                return True
    if SCmp(cmds,i, ('>', 'BOXING_UNBOXING', 'UNPACK_SEQ_AND_STORE')) and pos__c[1] == 0:
        rpl(cmds,[pos__b,pos__a,pos__c])
        return True
    if SCmp(cmds,i, ('>', 'PRINT_ITEM_TO_2', 'POP_TOP')):        
        rpl(cmds,[('UNPUSH', aa), pos__b])
        return True
    if SCmp(cmds,i, ('>', 'SET_VARS')):
        rpl(cmds,[('SET_EXPRS_TO_VARS', pos__b[1], aa)])
        return True        
    if SCmp(cmds,i, ('>', 'SET_EXPRS_TO_VARS', '=')):
        rpl(cmds,[('SET_EXPRS_TO_VARS', (pos__c,) + pos__b[1], (aa,) + pos__b[2])])
        return True        
    if SCmp(cmds,i, ('>', 'SET_EXPRS_TO_VARS', 'SET_VARS')):
        rpl(cmds,[('SET_EXPRS_TO_VARS', (pos__b[1],) + (pos__c[1],), (pos__b[2],) + (aa,))])
        return True        

    if SCmp(cmds,i, ('>', 'STORE', '=')):
        if len(pos__b[1]) == len(pos__b[2]) == 1:
            rpl(cmds,[('SET_EXPRS_TO_VARS', pos__b[1] + (pos__c,), pos__b[2] + (aa,))])
        else:
            assert False   
##            rpl(cmds,[('SET_EXPRS_TO_VARS', (pos__b[1],) + (pos__c,), (pos__b[2],) + (aa,))])
        return True       
    if SCmp(cmds,i, ('>', 'STORE', 'DUP_TOP')) and pos__b[2] == (aa,):
            rpl(cmds,[('SEQ_ASSIGN_0', 2, pos__b[1], aa)])
            return True    
    if SCmp(cmds,i, ('>', 'STORE', 'DUP_TOP')) and pos__b[2] == aa:
            rpl(cmds,[('SEQ_ASSIGN_0', 2, (pos__b[1],), aa)])
            return True    
    if SCmp(cmds,i, ('!PyDict_New', 'DUP_TOP', '>', 'ROT_TWO', '>', 'STORE_SUBSCR_0')):
        rpl(cmds, [('!BUILD_MAP', ((cmd2mem(pos__e), cmd2mem(pos__c)),))])
        return True
    if SCmp(cmds,i, ('!BUILD_MAP', 'DUP_TOP', '>', 'ROT_TWO', '>', 'STORE_SUBSCR_0')):
        rpl(cmds, [('!BUILD_MAP', pos__a[1] + ((cmd2mem(pos__e), cmd2mem(pos__c)),))])
        return True
    if pos__b is not None and pos__b[0] == 'JUMP_IF_FALSE':
        if pos__b[0] == 'JUMP_IF_FALSE' and pos__c[0] == 'POP_TOP' and is_cmdmem(pos__d): 
            if label(pos__b, pos__e):
                if OneJumpCache(pos__e[1], cmds):
                    cmds[i:i+5] = [And_j_s(aa, pos__d)]
                else:    
                    cmds[i:i+5] = [And_j_s(aa, pos__d), pos__e]
                return True
            if pos__e[0] == 'JUMP_IF_FALSE' and pos__b[1] == pos__e[1] and pos__f[0] == 'POP_TOP':
                cmds[i:i+6] = [And_j_s(aa, pos__d),pos__b,pos__c]
                return True
        if pos__b[0] == 'JUMP_IF_FALSE' and pos__c[0] == 'POP_TOP' and islineblock(pos__d) and\
            is_cmdmem(pos__e): 
                del cmds[i+3]
                return True

        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP', '3CMP_BEG_3', \
                        'JUMP_IF_FALSE', 'POP_TOP', '>', 'COMPARE_OP', \
                        'RETURN_VALUE', (':', 4,1), 'ROT_TWO', 'POP_TOP',\
                        (':', 1,1), 'RETURN_VALUE')):
            rpl(cmds, [('RETURN_VALUE', And_j_s(pos__a, \
                                                New_3Cmp(('!3CMP', pos__d[1], pos__d[2], pos__d[3], pos__h[1], cmd2mem(pos__g)))))])
            return True

        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP',\
                        'JUMP_IF2_TRUE_POP_CONTINUE', '>', (':', 1,1),\
                        'JUMP_IF_TRUE_POP_CONTINUE')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[And_j_s(pos__a, Or_j_s(pos__d[2],pos__e)),pos__g])
                return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP',\
                        'JUMP_IF2_TRUE_POP', '>', (':', 1,1),\
                        'JUMP_IF_TRUE_POP')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[And_j_s(pos__a, Or_j_s(pos__d[2],pos__e)),pos__g])
                return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP', 'JUMP_IF2_FALSE_POP', \
                        '>', (':', 1,1), 'JUMP_IF_TRUE', 'POP_TOP', (':', 3, 1),\
                        '>', ('::', 6))): 
                temp1 = And_j_s(pos__a, pos__d[2])         
                temp2 = And_j_s(temp1, pos__e)
                rpl(cmds,[Or_j_s(temp2, pos__j)])
                return True 
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP', '>', 'JUMP')) and pos__b[1] == pos__e[1]:
                rpl(cmds, [And_j_s(pos__a, pos__d), pos__e])
                return True
    if pos__b is not None and pos__b[0] == 'JUMP_IF_TRUE':
        if pos__b[0] == 'JUMP_IF_TRUE' and pos__c[0] == 'POP_TOP' and is_cmdmem(pos__d): 
            if label(pos__b, pos__e):
                if OneJumpCache(pos__e[1], cmds):
                    cmds[i:i+5] = [Or_j_s(aa, pos__d)]
                else:
                    cmds[i:i+5] = [Or_j_s(aa, pos__d), pos__e]
                return True
            if pos__e[0] == 'JUMP_IF_TRUE' and pos__b[1] == pos__e[1] and pos__f[0] == 'POP_TOP':
                cmds[i:i+6] = [Or_j_s(aa, pos__d),pos__b,pos__c]
                return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', '3CMP_BEG_3', \
                        'JUMP_IF_FALSE', 'POP_TOP', '>', 'COMPARE_OP', \
                        'RETURN_VALUE', (':', 4,1), 'ROT_TWO', 'POP_TOP',\
                        (':', 1,1), 'RETURN_VALUE')):
            rpl(cmds, [('RETURN_VALUE', Or_j_s(pos__a, \
                                                New_3Cmp(('!3CMP', pos__d[1], pos__d[2], pos__d[3], pos__h[1], cmd2mem(pos__g)))))])
            return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_FALSE_POP', \
                        '>', 'JUMP_IF_TRUE', 'POP_TOP', (':', 3, 1), \
                        '>', (':', 1, 2))) and pos__b[1] == pos__f[1] and CountJumpCache(pos__j[1],cmds) == 2:
                rpl(cmds,[Or_j_s(pos__a, Or_j_s(And_j_s(pos__d[2], pos__e), pos__i))])
                return True                                           
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_FALSE_POP', \
                        '>', (':', 1,1), 'JUMP_IF_FALSE_POP')) and pos__d[1] == pos__g[1]:
            rpl(cmds,[Or_j_s(aa, And_j_s(pos__d[2],pos__e)),pos__g])
            return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_FALSE_POP_CONTINUE', \
                    '>', (':', 1, 1), '=', 'ju')) and pos__d[1] == pos__h[1]:
# re.match_nl or (match_bol and re.nullable)
            rpl(cmds,[Or_j_s(pos__a, And_j_s(pos__d[2],pos__e)),pos__g,pos__h])
            return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', '>', 'JUMP')) and pos__b[1] == pos__e[1]:
                rpl(cmds, [Or_j_s(pos__a, pos__d), pos__e])
                return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_TRUE_POP', \
                        'LOAD_CONST', (':', 1, 1), 'STORE_FAST', ('::', 3))) and\
                        pos__d[2][0] == 'FAST' and pos__d[2][1] == pos__g[1]:
                rpl(cmds, [Or_j_s(Or_j_s(pos__a, pos__d[2]), pos__e),pos__g])
                return True

    return False

def process_push2(cmds,i,added_pass):
    aa = cmd2mem(pos__a)
    bb = cmd2mem(pos__b)

    if pos__c[0] == 'BUILD_SLICE' and len(pos__c) == 2 and pos__c[1] == 2:
            cmds[i:i+3] = [('!PySlice_New', aa, bb, 'NULL')]
            return True
    if pos__c[0] == 'STORE_MAP' and len(pos__c) == 1:
        cmds[i:i+3] = [('STORE_MAP', bb, aa)]
        return True
    if pos__c[0] == 'ROT_TWO' and pos__d[0] == 'STORE_ATTR_1':
        cmds[i:i+4] = [('STORE', (('PyObject_SetAttr', aa, ('CONST', pos__d[1])),), (pos__b,))]
        return True
    if SCmp(cmds,i, ('>','>', '>', 'BUILD_CLASS')):
            rpl(cmds,[('!_PyEval_BuildClass', cmd2mem(pos__c), bb, aa)])
            return True
    if pos__c[0] == 'ROT_TWO':
        if aa[0] in ('!LOAD_GLOBAL', 'CONST', 'FAST', '!PyObject_Repr', '!PyObject_GetAttr') or \
           bb[0] in ('!LOAD_GLOBAL', 'CONST', 'FAST', '!PyObject_Repr', '!PyObject_GetAttr'):     
            cmds[i:i+3] = [pos__b[:], pos__a[:]]
            return True
    ## if pos__c[0] == 'ROT_TWO':
        ## cmds[i:i+3] = [pos__b[:], pos__a[:]]
        ## return True
    
    if pos__c[0] == 'DELETE_SLICE+1' and len(pos__c) == 1:
        cmds[i:i+3] = [('DELETE_SLICE+1', aa, bb)]
        return True
    if pos__c[0] == 'IMPORT_NAME' and len(pos__c) == 2:
            cmds[i:i+3] = [('!IMPORT_NAME', pos__c[1], aa, bb)]
            return True
    if pos__c[0] == 'COMPARE_OP':
        cmds[i:i+3] = process_compare_op(pos__c[1],pos__a,pos__b)
        return True
    if pos__c[0] == 'LIST_APPEND' and len(pos__c) == 1:
            cmds[i:i+3] = [('PyList_Append', aa, bb)]
            return True
    if pos__c[0] == 'SLICE+1' and len(pos__c) == 1:
            if isintconst(bb):
                cmds[i:i+3] = [('!PySequence_GetSlice', aa, bb[1], 'PY_SSIZE_T_MAX')]
            else:    
                cmds[i:i+3] = [('!_PyEval_ApplySlice', aa, bb, 'NULL')]
            return True
    if pos__c[0] == 'SLICE+2' and len(pos__c) == 1:
            if isintconst(bb):
                cmds[i:i+3] = [('!PySequence_GetSlice', aa, 0, bb[1])]
            else:    
                cmds[i:i+3] = [('!_PyEval_ApplySlice', aa, 'NULL', bb)]
            return True
    ## if pos__c[0] == 'BINARY_ADD' and bb[0] == 'CONST' and \
        ## type(bb[1]) is int and bb[1] >= 0:        
            ## cmds[i:i+3] = [('!from_ceval_BINARY_ADD_Int', aa, bb[1], bb)]
            ## return True
    if pos__c[0] == 'BINARY_MODULO' and aa[0] == 'CONST' and \
        type(aa[1]) is str and bb[0] == '!BUILD_TUPLE':        
            cmds[i:i+3] = [('!PyString_Format', aa, bb)]
            return True
    if pos__c[0] == 'BINARY_MULTIPLY' and (aa[0] == '!STR_CONCAT' or (aa[0] == 'CONST' and \
        (type(aa[1]) is str or type(aa[1]) is list or type(aa[1]) is tuple))):
            cmds[i:i+3] = [('!PySequence_Repeat', aa, bb)]
            return True
    if pos__c[0] == 'BINARY_ADD' and aa[0] == '!STR_CONCAT' and bb[0] == '!STR_CONCAT':        
            cmds[i:i+3] = [aa + bb[1:]]
            return True
    if pos__c[0] == 'BINARY_ADD' and aa[0] == '!PyNumber_Add' and bb[0] == '!STR_CONCAT':        
            cmds[i:i+3] = [(bb[0], aa[1], aa[2]) + bb[1:]]
            return True
    if pos__c[0] == 'BINARY_ADD' and bb[0] == '!PyNumber_Add' and aa[0] == '!STR_CONCAT':        
            cmds[i:i+3] = [(aa[0], aa[1], aa[2]) + bb[1:]]
            return True
    if pos__c[0] == 'BINARY_ADD' and bb[0] == '!STR_CONCAT':        
            cmds[i:i+3] = [('!STR_CONCAT', aa) + bb[1:]]
            return True
    if pos__c[0] == 'BINARY_ADD' and aa[0] == '!STR_CONCAT':        
            cmds[i:i+3] = [aa + (bb,)]
            return True
    if pos__c[0] == 'BINARY_ADD' and bb[0] == 'CONST' and \
        type(bb[1]) is str and aa[0] == '!PyNumber_Add':        
            cmds[i:i+3] = [('!STR_CONCAT', aa[1], aa[2], bb)]
            return True
    if pos__c[0] == 'BINARY_ADD' and bb[0] == 'CONST' and \
        type(bb[1]) is str:        
            cmds[i:i+3] = [('!STR_CONCAT', aa, bb)]
            return True
    if pos__c[0] == 'BINARY_ADD' and aa[0] == 'CONST' and \
        type(aa[1]) is str:        
            cmds[i:i+3] = [('!STR_CONCAT', aa, bb)]
            return True
    if pos__c[0] == 'BINARY_SUBSCR' and bb[0] == 'CONST' and \
        type(bb[1]) is int: # and bb[1] >= 0:        
            cmds[i:i+3] = [('!BINARY_SUBSCR_Int', aa, bb)]
            return True
    if pos__c[0] == 'BINARY_SUBSCR' :        
            cmds[i:i+3] = [('!from_ceval_BINARY_SUBSCR', aa, bb)]
            return True
    if pos__c[0] in recode_binary:
        if recode_binary[pos__c[0]] == 'PyNumber_Power+Py_None':
            cmds[i:i+3] = [('!PyNumber_Power', aa, bb, 'Py_None')]
        else:    
            cmds[i:i+3] = [('!' +recode_binary[pos__c[0]], aa, bb)]
        return True
    if pos__c[0] == 'INPLACE_POWER':
            cmds[i:i+3] = [('!PyNumber_InPlacePower', aa, bb, 'Py_None')]
            return True
    if pos__c[0] in recode_inplace:
            cmds[i:i+3] = [('!' +recode_inplace[pos__c[0]], aa, bb)]
            return True
    if pos__c[0][:8] == 'INPLACE_':
            cmds[i:i+3] = [('!#=' + pos__c[0][8:], aa, bb)]
            return True
    if pos__c[0] == 'DELETE_SUBSCR' and len(pos__c) == 1:
            cmds[i:i+3] = [('DELETE_SUBSCR', aa, bb)]
            return True
    if pos__c[0] == 'DUP_TOPX' and pos__c[1] == 2:
        cmds[i:i+3] = [pos__a,pos__b,pos__a,pos__b]
        return True
    if SCmp(cmds,i, ('>', '>', '=', '=')):
                cmds[i:i+4] = [('SET_EXPRS_TO_VARS', (pos__c,pos__d), (bb,aa))]
                return True
    if pos__c[0] == 'CALL_FUNCTION_KW_1' and pos__c[3] > 0:
        cmds[i:i+3] =  [(pos__c[0], pos__c[1], pos__c[2], pos__c[3]-1, pos__c[4] + ((aa, bb),), pos__c[5])]
        return True       
    if  is_cmdmem(pos__c):    
        cc = cmd2mem(pos__c)
        if pos__d[0] == 'STORE_SUBSCR_0':
                cmds[i:i+4] = [('STORE',(('PyObject_SetItem', bb, cc),), (aa,))]
                return True
        if pos__d[0] == 'SLICE+3' and len(pos__d) == 1:
                cmds[i:i+4] = [('!_PyEval_ApplySlice',) + (aa,) + (bb,) + (cc,)]
                return True
        if pos__d[0] == 'BUILD_SLICE' and len(pos__d) == 2 and pos__d[1] == 3:
                cmds[i:i+4] = [('!PySlice_New', aa, bb, cc)]
                return True
        if pos__d[0] == 'DELETE_SLICE+3':
            cmds[i:i+4] = [('DELETE_SLICE+3', aa, bb, cc)]
            return True
        if pos__d[0] == 'DUP_TOPX' and pos__d[1] == 3:
            cmds[i:i+4] = [pos__a,pos__b,pos__c,pos__a,pos__b,pos__c]
            return True
        if pos__d[0] == 'ROT_THREE' and pos__e[0] in ('STORE_SUBSCR_0', 'STORE_SLICE+2', 'STORE_SLICE+1'):
            cmds[i:i+4] = [pos__c,pos__a,pos__b]
            return True
        if SCmp(cmds,i, ('>','>', '>', '=', '=', '=')):
                    cmds[i:i+6] = [('SET_EXPRS_TO_VARS', (pos__f,pos__e,pos__d), (aa,bb,cc))]
                    return True
        if SCmp(cmds,i, ('>', '>','>', '>', '=', '=', '=', '=')):
                    cmds[i:i+8] = [('SET_EXPRS_TO_VARS', \
                                    (pos__h,pos__g,pos__f,pos__e), \
                                    (aa, bb, cc, cmd2mem(pos__d)))]
                    return True
        if SCmp(cmds,i, ('>', '>', '>','>', '>', '=', '=', '=', '=', '=')):
                    cmds[i:i+10] = [('SET_EXPRS_TO_VARS', \
                                     (pos__j,pos__i,pos__h,pos__g,pos__f), \
                                     (aa, bb, cc, cmd2mem(pos__d),cmd2mem(pos__e)))]
                    return True
        if SCmp(cmds,i, ('>', '>', '>', '>','>', '>', '=', '=', '=', '=', '=', '=')):
                    cmds[i:i+12] = [('SET_EXPRS_TO_VARS', \
                                     (pos__l,pos__k,pos__j,pos__i,pos__h,pos__g), \
                                     (aa, bb, cc, cmd2mem(pos__d), cmd2mem(pos__e),cmd2mem(pos__f)))]
                    return True
        if SCmp(cmds,i, ('>', '>', '>', 'ROT_THREE', 'ROT_TWO', '=', '=', '=')):
                    cmds[i:i+8] = [('SET_EXPRS_TO_VARS', (pos__f,pos__g,pos__h), (aa,bb,cc))]
                    return True
        if SCmp(cmds,i, ('>','>','>', 'EXEC_STMT')):
            rpl(cmds,[('EXEC_STMT_3', aa, bb, cc)])
            return True
        if SCmp(cmds,i, ('>', '>', '>', 'STORE_SLICE+3')):
                    rpl(cmds,[('STORE_SLICE_LV+3', aa, bb, cc)])
                    return True
        if SCmp(cmds,i, ('>', '>', '>', '>', 'ROT_FOUR')):
                rpl(cmds,[pos__d,pos__a,pos__b,pos__c])
                return True       
   
                
    if pos__c[0] == 'DELETE_SLICE+2' and SCmp(cmds,i, ('>', '>', 'DELETE_SLICE+2')) and len(pos__c) == 1:
        cmds[i:i+3] = [(pos__c[0], aa, bb)]
        return True                
    if  pos__c[0] == 'ROT_TWO' and SCmp(cmds,i, ('>', '>', 'ROT_TWO', '=', '=')):
                cmds[i:i+5] = [('SET_EXPRS_TO_VARS', (pos__d,pos__e), (aa,bb))]
                return True
    if  pos__c[0] == 'CALL_FUNCTION_1' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_1')) and pos__c[3] > 0:
        cmds[i:i+3] =  [(pos__c[0], pos__c[1], pos__c[2], pos__c[3]-1, pos__c[4] + ((aa, bb),))]
        return True       
    if  pos__c[0] == 'CALL_FUNCTION_VAR_1' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_VAR_1')) and pos__c[3] > 0:
        rpl(cmds, [(pos__c[0], pos__c[1], pos__c[2], pos__c[3]-1, pos__c[4] + ((aa, bb),), pos__c[5])])
        return True       
    if pos__c[0] == 'CALL_FUNCTION_VAR_KW' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_VAR_KW')):
        cmds[i:i+3] =  [('CALL_FUNCTION_VAR_KW_1',) + pos__c[1:] + (aa,bb)]
        return True       
    if pos__c[0] == 'CALL_FUNCTION_VAR_KW_1' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_VAR_KW_1')) and pos__c[3] > 0:
        cmds[i:i+3] =  [(pos__c[0], pos__c[1], pos__c[2], pos__c[3]-1, pos__c[4] + ((aa, bb),), pos__c[5],pos__c[6])]
        return True       
    if pos__c[0] == 'STORE_SLICE+2' and SCmp(cmds,i, ('>','>', 'STORE_SLICE+2')):
        rpl(cmds,[('STORE_SLICE_LV+2', aa, bb)])
        return True
    if pos__c[0] == 'STORE_SLICE+1' and SCmp(cmds,i, ('>', '>', 'STORE_SLICE+1')):
                rpl(cmds,[('STORE_SLICE_LV+1', aa, bb)])
                return True
    if pos__c[0] == 'DUP_TOP' and SCmp(cmds,i, ('>','>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP')):
        rpl(cmds, [('3CMP_BEG_3', aa, pos__e[1], bb)])
        return True        
    if pos__c[0] == 'DUP_TOP' and SCmp(cmds,i, ('>', '>', 'DUP_TOP', 'EXEC_STMT')):
            rpl(cmds,[('EXEC_STMT_3', aa, bb, bb)])
            return True       

    if pos__c[0] == 'PRINT_ITEM_TO_0':
        cmds[i:i+3] = [('PRINT_ITEM_TO_2', bb,aa)]
        return True

    if pos__c[0] == 'STORE_SUBSCR_0':
            cmds[i:i+3] = [('PyObject_SetItem',) + (aa,) + (bb,)]
            return True

    return False

imported_modules = {}

def module_dict_to_type_dict(pos__d):
    d2 = dict(pos__d)      
    for k in pos__d.keys():
        v = pos__d[k]
        t = type(v)
        if t is types.InstanceType:
            t2 = None
            try:
                t2 = (T_OLD_CL_INST, v.__class__.__name__)
            except:
                pass
            if t2 is not None:
                t = t2
        else:
            if type(t) != type:
                t = (T_NEW_CL_INST, v.__class__.__name__)
            else:    
                t = (t, None)    
        d2[k] = t
    return d2

def CheckExistListImport(nm, fromlist=None,level=-1):
    global filename
    if nm in ('org.python.core',):
        return
    this = None
    ## if nm[0:3] == '_c_':
        ## nm = nm[3:]    
    if nm + '.py' == filename:
        return    
    if nm in list_import:
        return    
    if nm in imported_modules:
        this = imported_modules[nm]
    elif nm in sys.modules:    
        this = sys.modules[nm]
        imported_modules[nm] = this
        list_import[nm] = module_dict_to_type_dict(this.__dict__)
        FillListImport(this)    
        return
    elif Is3(nm, 'ImportedM'):
        v = Val3(nm, 'ImportedM')
        if type(v) is tuple and len(v) == 2:
            return CheckExistListImport(v[0] + '.' + v[1])
        elif type(v) is str and v != nm:
            return CheckExistListImport(v)
        if v != nm:
            Fatal(nm, v)
    if this is None:
#        if nm == '':
#            Fatal('can\'t import empty module')     
        try:
            if fromlist is None and level == -1 and nm != '':
                this = __import__(nm)
                imported_modules[nm] = this
            elif nm == '' and level != -1 and len(fromlist) == 1:
                this = __import__()
                imported_modules[fromlist[0]] = this
            else:    
                this = __import__(nm,{},{}, fromlist)
                imported_modules[nm] = this
        except TypeError:
            if nm != '':
                Fatal('', nm, sys.exc_info())
            Debug(sys.exc_info()[:2])
            ## if nm == '__builtin__.__dict__':
                ## assert False
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return     
        except ImportError:
            Debug(sys.exc_info()[:2])
            ## if nm == '__builtin__.__dict__':
                ## assert False
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return     
        except:
            print (nm)
            print (sys.exc_info())
            if nm != '' and nm[0] != '.':
                Fatal('',nm,sys.exc_info())
            return 
        
    nms = nm.split('.')
    s = ''
    old_this = this
    if fromlist is not None:
        assert this.__name__ == nm
        list_import[nm] = module_dict_to_type_dict(this.__dict__)
        imported_modules[nm] = this
    else:    
        for v in nms:
            pos__d2 = None
            if s != '':
                s += '.'
                if v not in pos__d or pos__d is None:
                    if fromlist is None:
                        Debug('Module %s %s (%s) import unsuccessful3' % (s, v, nm), fromlist) 
                    break
                this = pos__d2[v]
            pos__d2 = this.__dict__
            s += v    
            assert type(this) is types.ModuleType    
            list_import[s] = module_dict_to_type_dict(pos__d2)
            imported_modules[s] = this
    FillListImport(old_this)    

def FillListImport(module, nm = None, list_added = []):
    if nm is None:
        nm = module.__name__
    if not nm in imported_modules:
        imported_modules[nm] = module
    if not nm in list_import:
        list_import[nm] = module_dict_to_type_dict(module.__dict__)    
    if module in list_added:
        return    
    list_added.append(module)
    for k, v in module.__dict__.iteritems():
        if type(v) is types.ModuleType:
            FillListImport(v, nm + '.' + k, list_added)  
                  

FillListImport(sys)
FillListImport(types)
##FillListImport(pprint)
FillListImport(glob)
FillListImport(traceback)
FillListImport(gc)
FillListImport(os)
FillListImport(math)
FillListImport(StringIO)
FillListImport(operator)
FillListImport(csv)
FillListImport(distutils)

def MyImport(nm):
    assert nm is not None
    if nm.startswith('__main__'):
        return None, {}
    CheckExistListImport(nm)
    if nm not in imported_modules:
        return None, {}
    this = imported_modules[nm]
    pos__d = this.__dict__
    
    if '.' in nm:
        nms = nm.split('.')
        pos__d = this.__dict__
        if hasattr(this, '__file__') and this.__file__.endswith(nms[-1] + '.pyc'):
            return this, pos__d
        if this.__name__ == nm:
            return this, pos__d
        for i in range(1, len(nms)):
            if nms[i] in this.__dict__ and type(this.__dict__[nms[i]]) is types.ModuleType:
                this = pos__d[nms[i]]
                pos__d = this.__dict__
            else:
                if nms[i] in pos__d:
                    this = pos__d[nms[i]]
                    pos__d = this.__dict__
                else:
                    Debug('Import Error', nm, this, i, nms) 
                    return None, {}
##                Debug('Import Error', nm, this, i, nms) 
    return this, pos__d


def make_import_star(aa):
    ## nm = aa[1]
    if aa[1] in known_modules and aa[2] == ('CONST', -1):
        d = None
#        try:
        this, d = MyImport(aa[1])
#        except:
#            Debug('Module %s import unsuccessful' % aa[1])     
#            return [('IMPORT_STAR', aa)]
        if '__all__' in d:
            d2 = {}
            for k in d['__all__']:
                if k in d:
                    d2[k] = d[k]
            d = d2     
        r1 = []
        r2 = []
        for v in d:
            if v not in ('__name__', '__module__', '__file__') and \
                v in count_define_get:
                r1.append(v)
                r2.append(('STORE_NAME', v))
        r1 = ('CONST', tuple(r1))
        r2 = tuple(r2)
        return [('IMPORT_FROM_AS', aa[1], ('CONST', -1), r1, r2)]   
    else:
        Debug('Module %s star import unsuccessful - not in knows' % aa[1])     
    return [('IMPORT_STAR', aa)]

def val_imp(nm, k):
    assert nm is not None
    ## if nm.startswith('_c_'):
        ## nm = nm[3:]
    if nm == filename[:-3]:
        return None
    if Is3(nm, 'ImportedM'):
        v = Val3(nm, 'ImportedM')
        if type(v) is tuple and len(v) == 2:
            if v[0] in list_import and v[1] in list_import[v[0]] and not IsModule(list_import[v[0]][v[1]]):
                return None
    this, d = MyImport(nm)
    if this is None:
        if Is3(nm, 'ImportedM'):
            v = Val3(nm, 'ImportedM')
            if type(v) is tuple and len(v) == 2:
                ## imp = v[0] + '.' + v[1]
                return val_imp(v[0] + '.' + v[1], k)
            elif type(v) is str and v != nm:
                return val_imp(v, k)

#        return None
    if k not in d:

        this, d = MyImport(nm + '.' + k)
        if this is not None and this.__name__ == (nm + '.' + k):
            return this
    ## if this is None:
        ## if Is3(nm, 'ImportedM'):
            ## v = Val3(nm, 'ImportedM')
            ## if type(v) is tuple and len(v) == 2:
                ## return val_imp(v[0] + '.' + v[1], k)
        ## return None
    if this is None:
        return None    
    return d[k]
    
def _process_compare_op_const(op, pos__a,pos__b):
    try:
        if op == '==':
            return('CONST', pos__a[1] == pos__b[1])              
        if op == '!=':
            return('CONST', pos__a[1] != pos__b[1])              
        if op == '>=':
            return('CONST', pos__a[1] >= pos__b[1])              
        if op == '<=':
            return('CONST', pos__a[1] <= pos__b[1])              
        if op == '<':
            return('CONST', pos__a[1] < pos__b[1])              
        if op == '>':
            return('CONST', pos__a[1] > pos__b[1])              
    except:
        pass    
    return None    

def _process_compare_op(op, a,b):
    if a[0] in ('LOAD_CONST', 'CONST') and b[0] in ('LOAD_CONST', 'CONST'):
        const_r = _process_compare_op_const(op, a,b)
        if const_r is not None:
            return const_r
    if a[0] in ('LOAD_CONST', 'CONST') and type(a[1]) is int:
        if op in ('==', '!='):
            if op in op_2_c_op and op not in('is', 'is not'):
               return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_Int', cmd2mem(b), cmd2mem(a)))              
        ## elif op in op_2_inv_op_:
            ## op = op_2_inv_op_[op]
            ## if int(a[1]) == a[1] and \
               ## op in op_2_c_op and op not in('is', 'is not'):
               ## return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_Int', cmd2mem(b), a[1]))              

    if a[0] == '!PY_SSIZE_T' and b[0] in ('LOAD_CONST', 'CONST') and type(b[1]) is int:
        if op in op_2_c_op and op not in('is', 'is not'):
            return('!BOOLEAN', ('!SSIZE_T' + op, a[1], b[1]))              
    if b[0] in ('LOAD_CONST', 'CONST') and type(b[1]) is int:
        if int(b[1]) == b[1] and \
            op in op_2_c_op and op not in('is', 'is not'):
            return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_Int', cmd2mem(a), cmd2mem(b)))              
    if b[0] in ('LOAD_CONST', 'CONST') and type(b[1]) is str:
        if op in ('==', '!='):
            return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_String', cmd2mem(a), cmd2mem(b)))
# 11.06.2010 !!!
    if a[0] in ('LOAD_CONST', 'CONST') and type(a[1]) is str:
        if op in ('==', '!='):
            return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_String', cmd2mem(b), cmd2mem(a)))


    ## if b[0] == '!PY_SSIZE_T':
        ## if op in op_2_c_op and op not in('is', 'is not'):
            ## return ('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_Int', cmd2mem(a), b))
    if op == 'not in':            
        return Not(('!BOOLEAN', ('!PySequence_Contains(', cmd2mem(b), cmd2mem(a))))
    if op == 'in':            
        return ('!BOOLEAN', ('!PySequence_Contains(', cmd2mem(b), cmd2mem(a)))
    if op == 'is':            
        return ('!BOOLEAN',('!_EQ_', cmd2mem(a), cmd2mem(b)))
    if op == 'is not':            
        return ('!BOOLEAN',('!_NEQ_', cmd2mem(a), cmd2mem(b)))
    return None

def process_compare_op(op, a,b):
    ret = _process_compare_op(op,a,b)
    if ret is not None:
        return [ret]
    if op in op_2_c_op:            
        return [('!PyObject_RichCompare(', cmd2mem(a), cmd2mem(b), op_2_c_op[op])]
    Fatal('Can\'t handle compare_op', op, a, b)
    
def process_load_const_test1(cmds):
    try:
        if pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:]])
        else:    
            rpl(cmds,[])
        return True
    except:
        pass
    return False

def process_load_const_test2(cmds):
    try:
        if not pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:]])
        else:    
            rpl(cmds,[])
        return True
    except:
        pass
    return False

def process_load_const_test3(cmds):
    try:
        if pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:]])
        else:    
            rpl(cmds,[pos__a])
        return True
    except:
        pass
    return False

def process_load_const_test4(cmds):
    try:
        if not pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:]])
        else:    
            rpl(cmds,[pos__a])
        return True
    except:
        pass
    return False

def process_load_const(cmds,i,added_pass):
    if pos__a[0] == 'LOAD_CONST' and pos__b[0] == 'UNPACK_SEQUENCE' and pos__a[1] is not None and pos__b[1] == len(pos__a[1]):
        cmds[i:i+2] = [('LOAD_CONST', x) for x in reversed(pos__a[1])]
        return True
    if pos__a[0] == 'LOAD_CONST' and pos__b[0] == 'STORE':
        cmds[i:i+2] = [pos__b, pos__a]
        return True
    if pos__a[0] == 'LOAD_CONST' and pos__b[0] == 'DUP_TOP':
        cmds[i:i+2] = [pos__a, pos__a[:]]
        return True   
    if SCmp(cmds,i, ('LOAD_CONST', '-')):
        rpl(cmds,[pos__b,pos__a])
        return True     
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_TRUE', 'POP_TOP')):
        if process_load_const_test1(cmds):
            return True
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_FALSE', 'POP_TOP')):
        if process_load_const_test2(cmds):
            return True
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_TRUE')):
        if process_load_const_test3(cmds):
            return True
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_FALSE')):
        if process_load_const_test4(cmds):
            return True
    return False

def process_j_setup_finally(cmds,i,added_pass):
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), '*', 'END_FINALLY')) and pos__d[1] is None:                                    
            rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), pos__f, (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), 'END_FINALLY')) and pos__d[1] is None:                                    
            rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), [('PASS',)], (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), 'END_FINALLY')) and pos__c[1] is None:                                    
            rpl(cmds,[[('(TRY',), [('PASS',)], (')(FINALLY',), [('PASS',)], (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', 'JUMP_CONTINUE', 'POP_BLOCK', \
                    'LOAD_CONST', (':', 0, 1), '**n', 'END_FINALLY', \
                    'JUMP_CONTINUE')) and pos__b[1] == pos__h[1]:
            rpl(cmds,[[('(TRY',), [('CONTINUE',)], (')(FINALLY',), pos__f, (')ENDTRY',)],pos__h])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*n','JUMP_CONTINUE', 'POP_BLOCK', \
                    'LOAD_CONST', (':', 0, 1), '**n', 'END_FINALLY', \
                    'JUMP_CONTINUE')) and pos__c[1] == pos__i[1]:
            rpl(cmds,[[('(TRY',), pos__b + [('CONTINUE',)], (')(FINALLY',), pos__g, (')ENDTRY',)],pos__h])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), '*', 'END_FINALLY')) and pos__c[1] is None:                                    
            rpl(cmds,[[('(TRY',), [('PASS',)], (')(FINALLY',), pos__e, (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*r', (':',0,1), '*', 'END_FINALLY')):
        rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), pos__d, (')ENDTRY',)]])
        return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*n', 'LOAD_CONST', (':',0,1), \
                    '*', 'END_FINALLY')) and pos__c[1] is None:
        rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), pos__e, (')ENDTRY',)]])
        return True
    return False

def process_j_begin_with(cmds,i,added_pass):
    if SCmp(cmds,i, ('J_BEGIN_WITH', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:],[('PASS',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], pos__b, (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*', 'JUMP_CONTINUE', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], pos__b + [('CONTINUE',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', 'JUMP_CONTINUE', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], [('CONTINUE',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*l', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], [('PASS',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*r',\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], pos__b, (')ENDWITH',)]])
            return True             
    return False

def process_j_setup_loop(cmds,i,added_pass):
    if pos__a[0] == 'J_SETUP_LOOP':
        if len(pos__a) == 2 and pos__b[0] == '!GET_ITER' and len(pos__b) == 2:
            cmds[i:i+2] = [('J_SETUP_LOOP_FOR', pos__a[1], pos__b[1])]
            return True
        if len(pos__a) == 3 and pos__b[0] == '!GET_ITER' and len(pos__b) == 2:
            cmds[i:i+2] = [('.L', pos__a[2]),('J_SETUP_LOOP_FOR', pos__a[1], pos__b[1])]
            return True
        if len(pos__a) == 2 and pos__b[0] == '.L' and pos__c[0] == '!GET_ITER' and len(pos__c) == 2:
            cmds[i:i+3] = [('J_SETUP_LOOP_FOR', pos__a[1], pos__c[1])]
            return True
        if len(pos__a) == 3 and pos__b[0] == '.L' and pos__c[0] == '!GET_ITER' and len(pos__c) == 2:
            cmds[i:i+3] = [('.L', pos__a[2]),('J_SETUP_LOOP_FOR', pos__a[1], pos__c[1])]
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), 'POP_BLOCK', 'JUMP')) and\
            pos__a[0] != pos__d[1]:
            bod = pos__b[1][:-1]
            if len(bod) == 0:
                bod = [('PASS',)]    
            cmds[i:i+4] = [[('(WHILE',) + pos__b[0][1:], bod, (')ENDWHILE',)],pos__d]
            return True
        if isblock(pos__b) and pos__c[0] == 'POP_BLOCK' and \
            pos__d[0] == '.:' and pos__d[1] == pos__a[1] and OneJumpCache(pos__d[1], cmds) and len(pos__b) == 3 and\
            pos__b[0][0] == '(IF' and pos__b[2][0] == ')ENDIF' and type(pos__b[1]) is list:
            cmds[i:i+4] = [[('(WHILE',) + pos__b[0][1:], pos__b[1], (')ENDWHILE',)]]
            return True
        if pos__b[0] == '.:' and pos__c[0] == 'JUMP_IF2_FALSE_POP' and\
            isblock(pos__d) and  pos__e[0] in jump and pos__e[1] == pos__b[1] and \
            pos__f[0] == '.:' and pos__f[1] == pos__c[1] and pos__g[0] == 'POP_BLOCK' and \
            pos__h[0] == '.:' and pos__h[1] == pos__a[1] and\
            OneJumpCache(pos__b[1], cmds) and\
            OneJumpCache(pos__f[1], cmds) and\
            OneJumpCache(pos__h[1], cmds):
            cmds[i:i+8] = [[('(WHILE',) + pos__c[2:], pos__d[:], (')ENDWHILE',)]]
            return True
        if pos__b[0] == '.:' and pos__c[0] == 'JUMP_IF2_FALSE_POP' and\
            isblock(pos__d) and  pos__e[0] in jump and pos__e[1] == pos__b[1] and \
            pos__f[0] == '.:' and pos__f[1] == pos__c[1] and pos__g[0] == 'POP_BLOCK' and \
            pos__h[0] == '.:' and pos__h[1] == pos__a[1] and\
            OneJumpCache(pos__b[1], cmds) and\
            OneJumpCache(pos__f[1], cmds) and\
            CountJumpCache(pos__h[1], cmds) > 1:
            cmds[i:i+8] = [[('(WHILE',) + pos__c[2:], pos__d[:], (')ENDWHILE',)],pos__h]
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'LOAD_FAST', (':', 5, 1),\
                        'J_LOOP_VARS', '*', 'JUMP_CONTINUE', (':',3,1),\
                        'POP_BLOCK', ('::', 0))) and pos__b[1][0] == '.':
            rpl(cmds,[[('(FOR_ITER',  pos__d[2], cmd2mem(pos__b)), pos__e, (')ENDFOR_ITER',)]])
            return True            
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r',
                        (':', 1, 1), 'POP_BLOCK', ('::',0))):
                rpl(cmds,[[('(WHILE',) + pos__b[2:] , pos__c, (')ENDWHILE',)]])
                return True   
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'LOAD_FAST', (':', 5, 1), \
                        'J_FOR_ITER',\
                        '*', 'JUMP_CONTINUE', \
                        (':', 3, 1), 'POP_BLOCK', ('::', 0))) and\
            pos__e[0][0] == 'UNPACK_SEQ_AND_STORE' and pos__e[0][1] == 0 and pos__b[1][0] == '.':
                rpl(cmds,[[('(FOR_GENERATOR', pos__e[0][2]), pos__e[1:], (')ENDFOR_GENERATOR',)]])
                return True                   
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'LOAD_FAST', (':', 5, 1), \
                        'J_FOR_ITER',\
                        '*', 'JUMP_CONTINUE', \
                        (':', 3, 1), 'POP_BLOCK', ('::', 0))) and\
            pos__e[0][0] == '.L' and pos__e[1][0] == 'UNPACK_SEQ_AND_STORE' and pos__e[1][1] == 0 and pos__b[1][0] == '.':
                rpl(cmds,[[('(FOR_GENERATOR', pos__e[1][2]), pos__e[2:], (')ENDFOR_GENERATOR',)]])
                return True    
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 3, 1), '*', 'JUMP_CONTINUE', ('::', 0))):
                rpl(cmds,[[('(WHILE', TRUE), pos__c, (')ENDWHILE',)]])
                return True     
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 4,1), 'JUMP_IF2_FALSE_POP', '*',\
                        'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', ('::', 0))) :
                rpl(cmds, [[('(WHILE',) + pos__c[2:], pos__d, (')ENDWHILE',)]])
                return True   
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 4, 1), 'JUMP_IF2_TRUE_POP', \
                        '*', 'JUMP_CONTINUE', (':',2, 1), 'POP_BLOCK', ('::',0))):
            rpl(cmds,[[('(WHILE', Not(pos__c[2])), pos__d, (')ENDWHILE',)]])
            return True
    # {'*' removed
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), \
                        'POP_BLOCK', '*r', (':',0,1), '*r')):
                rpl(cmds,[[('(WHILE', pos__b[0][1]), pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)],pos__f])
                return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*r', ')ENDIF'), \
                        'POP_BLOCK', '*r', (':',0,1), '*r')):
                rpl(cmds,[[('(WHILE', pos__b[0][1]), pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)],pos__f])
                return True
    # }end '*' removed
        if SCmp(cmds,i, ('J_SETUP_LOOP',  (':', 3, 1), '*', 'JUMP_CONTINUE')):
            rpl(cmds,[[('(WHILE', TRUE), pos__c, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*r', (':', 0,1), 'POP_BLOCK')):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*n', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*r', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                        'POP_BLOCK', '*n', ('::', 0))):
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',),pos__d,(')ENDWHILE',)]])
                return True   
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2, 1), 'JUMP_IF2_TRUE_POP_CONTINUE', \
                        'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE',) + pos__c[2:], [('PASS',)],(')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), 'POP_BLOCK',\
                        'ju')) and pos__d[1] == pos__a[1]:
            bod = pos__b[1][:-1]
            if len(bod) == 0:
                bod = [('PASS',)]    
            rpl(cmds,[[('(WHILE',) + pos__b[0][1:], bod,(')ENDWHILE',)],pos__d])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 4,1), 'JUMP_IF2_FALSE_POP', \
                        '*n', 'J_SETUP_LOOP', (':', 7, 1), '*n', 'JUMP', \
                        (':', 2,1), 'POP_BLOCK', ('::', 0))):
                rpl(cmds,[[('(WHILE',) + pos__c[2:], pos__d + [('(WHILE', TRUE), pos__g, (')ENDWHILE',)], (')ENDWHILE',)]])
                return True       
        ## if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\ # By CloneDigger
                        ## 'POP_BLOCK', '*n', ('::',0))):
                ## rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                ## return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                        'POP_BLOCK', '*n', 'jc')) and pos__a[1] == pos__e[1]:
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                        'POP_BLOCK', '*r', ('::',0))):
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*r', ')ENDIF'),\
                        'POP_BLOCK', '*n', ('::',0))):
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                return True    
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), \
                        'POP_BLOCK', ('::', 0))):       #  4
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '.L', '(IF', '*c', ')ENDIF'), \
                        'POP_BLOCK', ('::', 0))):       #  4
                rpl(cmds,[[('(WHILE',) + pos__b[1][1:], pos__b[2], (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2, 1), 'JUMP_CONTINUE', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), [('PASS',)], (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2,1), 'JUMP_IF2_TRUE_POP_CONTINUE',\
                        'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE',) + pos__c[2:], [('PASS',)], (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2,1), 'JUMP_IF2_FALSE_POP_CONTINUE',\
                        'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE', Not(pos__c[2])), [('PASS',)], (')ENDWHILE',)]])
            return True
    return False

def process_jump(cmds,i, added_pass):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    if pos__a[0] == 'JUMP_IF_TRUE' and pos__b[0] == 'JUMP' and pos__c[0] == '.:' and \
       pos__a[1] == pos__c[1] and pos__b[1] != pos__a[1]:
          if CountJumpCache(pos__a[1], cmds) == 1: 
                cmds[i:i+3] = [('JUMP_IF_FALSE', pos__b[1])]
          else:      
                cmds[i:i+3] = [('JUMP_IF_FALSE', pos__b[1]), pos__c]
          return True
    if pos__a[0] == 'JUMP_IF_FALSE' and pos__b[0] == 'JUMP' and pos__c[0] == '.:' and \
       pos__a[1] == pos__c[1] and pos__b[1] != pos__a[1]:
          if CountJumpCache(pos__a[1], cmds) == 1: 
                cmds[i:i+3] = [('JUMP_IF_TRUE', pos__b[1])]
          else:      
                cmds[i:i+3] = [('JUMP_IF_TRUE', pos__b[1]), pos__c]
          return True
          
    if len(pos__a) >= 3 and len(pos__b) >= 3 and pos__a[2] == pos__b[2]:
        if SCmp(cmds,i,('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP')) and pos__a[2] == pos__b[2]:
            rpl(cmds,[pos__a])
            return True
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP')) and pos__a[2] == pos__b[2]:
            rpl(cmds,[pos__a])
            return True
    if len(pos__a) >= 2 and len(pos__b) >= 2 and pos__a[1] == pos__b[1]:
        if SCmp(cmds,i,('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_FALSE_POP', pos__a[1], And_j(pos__a[2], pos__b[2]))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__a[1], Or_j(pos__a[2], pos__b[2]))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP', 'JUMP_IF2_FALSE_POP')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__a[1], Or_j(pos__a[2], Not(pos__b[2])))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_IF2_FALSE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE', pos__a[1], And_j(pos__a[2], pos__b[2]))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_TRUE_POP_CONTINUE', pos__a[1], Or_j(pos__a[2], pos__b[2]))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP_CONTINUE', 'JUMP_IF2_FALSE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_TRUE_POP_CONTINUE', pos__a[1], Or_j(pos__a[2], Not(pos__b[2]) ))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_FALSE_POP', pos__a[1], And_j(pos__a[2], Not(pos__b[2])))])
            return True
        if SCmp(cmds,i,('JUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE', pos__a[1], And_j(pos__a[2], Not(pos__b[2])))])
            return True

    if type(pos__b) is list:
        if SCmp(cmds,i,('xJUMP_IF2_FALSE_POP', '*', 'ju', (':', 0,1), '*', ('::',2))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)]])
            return True
    
        if SCmp(cmds,i,('xJUMP_IF2_FALSE_POP', ('!', '.L', '(IF', '*', ')ENDIF'), ('::',0))):
            rpl(cmds,[[('(IF', And_j(pos__a[2], pos__b[1][1])), pos__b[2], (')ENDIF',)]])
            return True
    
        if SCmp(cmds,i,('xJUMP_IF2_FALSE_POP', '*', ('::',0))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
    if pos__a[0] == 'JUMP_IF2_TRUE_POP':
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP','JUMP_IF2_TRUE_POP', ('::', 0))):
            rpl(cmds,[(pos__b[0], pos__b[1], Or_j(pos__a[2], Not(pos__b[2])))])
            return True     
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP','JUMP_IF2_FALSE_POP', ('::', 0))):
            rpl(cmds,[(pos__b[0], pos__b[1], Or_j(pos__a[2], pos__b[2]))])
            return True     
        if SCmp(cmds,i,('JUMP_IF2_TRUE_POP','JUMP_IF2_FALSE_POP_CONTINUE', ('::', 0))):
            rpl(cmds,[(pos__b[0], pos__b[1], Or_j(pos__a[2], pos__b[2]))])
            return True     
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', ('::',0))):  
            rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', ('::',0))):  
            rpl(cmds,[('UNPUSH', (pos__a[2]))])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', 'JUMP_CONTINUE', (':',0,1), '*', \
                    ('::',2))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__e, (')(ELSE',),pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', (':',0,1), \
                    '*', ('::',1))):
            ifexpr = Or_j(pos__a[2], pos__b[2])
            rpl(cmds,[[('(IF', ifexpr), pos__d, (')ENDIF',), ('CONTINUE',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', 'JUMP', (':',0,1), '*', ('::',2))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__e, (')(ELSE',), pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', 'JUMP_CONTINUE', ('::', 0))):
            rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b + [('CONTINUE',)], (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '>', 'JUMP_IF_FALSE', 'POP_TOP', ('::',0))):
            rpl(cmds,[Or_j_s(pos__a[2], pos__b), pos__c,pos__d])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*l', '>', 'JUMP_IF_FALSE', 'POP_TOP', ('::',0))):
            rpl(cmds,[Or_j_s(pos__a[2], pos__c), pos__d,pos__e])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*l', ('::',0))):
            rpl(cmds,[('UNPUSH', pos__a[2])])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP', \
                        '*n', 'JUMP', (':', 1,1), '*r', (':', 0,1), '*n',\
                        ('::', 3))):
            rpl(cmds,[[('(IF', Not(pos__a[2])), \
                                [('(IF',) + pos__b[2:], pos__f,\
                                (')(ELSE',), pos__c, (')ENDIF',)],\
                                (')(ELSE',), pos__h, (')ENDIF',)]])
            return True                    
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'JUMP_CONTINUE', ('::', 0))):
                rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE', pos__b[1]) + pos__a[2:]])
                return True       
    elif pos__a[0] == 'JUMP_IF2_FALSE_POP':
        if pos__b[0][0] == 'J':
            if pos__b[0] == 'J_SETUP_LOOP':
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                                'POP_BLOCK', 'JUMP', (':', 0,0))):       #  1
                    rpl(cmds,[pos__a,[('(WHILE',) + pos__c[0][1:], pos__c[1], (')ENDWHILE',)],pos__e,pos__f])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                                'POP_BLOCK', '*n', (':', (0,1),0))) and CountJumpCache(pos__f[1],cmds) == 2:       #  1
                    rpl(cmds,[pos__a,[('(WHILE',) + pos__c[0][1:], pos__c[1], (')(ELSE',), pos__e, (')ENDWHILE',)],pos__f])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                                'POP_BLOCK', '*n', (':', (0,1),0))) and CountJumpCache(pos__f[1],cmds) == 2:       #  1
                    rpl(cmds,[pos__a,[('(WHILE',) + pos__c[0][1:], pos__c[1], (')(ELSE',), pos__e, (')ENDWHILE',)],pos__f])
                    return True
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP','JUMP_IF2_FALSE_POP', ('::', 0))):
                rpl(cmds,[(pos__b[0], pos__b[1], Or_j(Not(pos__a[2]), pos__b[2]))])
                return True 
            
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP_CONTINUE', '*l', ('::',0))):
                rpl(cmds,[(pos__b[0], pos__b[1], And_j(pos__a[2], pos__b[2])),pos__c])
                return True     
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP_CONTINUE', ('::',0))):
                rpl(cmds,[(pos__b[0], pos__b[1], And_j(pos__a[2], pos__b[2]))])
                return True     
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', (':',0,1),\
                        'JUMP_IF2_FALSE_POP', (':', 1,1), '*', 'JUMP_CONTINUE', ('::',3))):
                tt = Or_j( And_j(pos__a[2], pos__b[2]),pos__d[2])
                rpl(cmds,[[('(IF', tt), pos__f + [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', (':',0,1),\
                        'JUMP_IF2_FALSE_POP', ('::', 1))):
                tt = Or_j( And_j(pos__a[2], pos__b[2]),pos__d[2])
                rpl(cmds,[('JUMP_IF2_FALSE_POP', pos__d[1], tt) + pos__a[2:]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', ('::',0))):
                rpl(cmds,[[('(IF',) + pos__a[2:], [('CONTINUE',)], (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP', ('::',0))):
                rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__b[1]) + pos__a[2:]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r',\
                        (':',0,1), 'JUMP_IF2_FALSE_POP_CONTINUE', '*r')) and pos__e[1] == pos__b[1]:
                rpl(cmds,[[('(IF',) + pos__a[2:],
                                [('(IF',) +pos__b[2:], pos__c, (')ENDIF',)], (')(ELSE',),\
                                [('(IF',) +pos__e[2:], pos__f, (')ENDIF',)], (')ENDIF',)], ('JUMP_CONTINUE', pos__b[1])])
                return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', \
                        (':', 0,1), '*n', ('::',1))):
                rpl(cmds,[[('(IF',) + pos__a[2:], [('(IF', Not(pos__b[2])), [('CONTINUE',)], (')ENDIF',)], (')(ELSE',), pos__d,(')ENDIF',)],pos__e])
                return True             
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5,1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3,1), \
                            'POP_BLOCK', '*r', (':', 0, 1))):
                    rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]) , pos__e, (')(ELSE',),pos__i, (')ENDFOR',)],pos__j])
                    return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5,1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3,1),\
                            'POP_BLOCK', 'JUMP', (':', 0,1))):
                    rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]) , pos__e, (')ENDFOR',)],pos__i,pos__j])
                    return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', ('::',0))):
                rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__b[1], And_j(pos__a[2], pos__b[2]))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP', '*n', 'JUMP',\
                            (':', 1,1), '*n', 'JUMP_CONTINUE', (':', (0,3), 2))):
                rpl(cmds,[pos__a,[('(IF',) + pos__b[2:], pos__c, (')(ELSE',),pos__f +[('CONTINUE',)], (')ENDIF',)],pos__h])
                return True
            if  SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', '*r', \
                                (':', 0,1), '*n', ('::', 1))):
                rpl(cmds,[[('(IF',) + pos__a[2:],[('(IF', Not(pos__b[2])), pos__c, (')ENDIF',)],
                                (')(ELSE',), pos__e, (')ENDIF',)  ]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', ('::', 0))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], [('(IF', Not(pos__b[2])), [('CONTINUE',)], (')ENDIF',)],\
                                    (')ENDIF',)]])
                    return True  
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r', ('::', 0))):
                    rpl(cmds,[[('(IF',Not(pos__a[2])), [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)] + pos__c,\
                                    (')ENDIF',)]])
                    return True  
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', \
                            '*n', 'JUMP', (':', 1,1), '*r', (':', 0,1), '*n',\
                            ('::', 3))):
                rpl(cmds,[[('(IF',) + pos__a[2:], \
                                    [('(IF',) + pos__b[2:], pos__f,\
                                    (')(ELSE',), pos__c, (')ENDIF',)],\
                                    (')(ELSE',), pos__h, (')ENDIF',)]])
                return True                    
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', \
                            '*n', 'JUMP', (':', 0,1), '*n', ('::', 3))):
                rpl(cmds,[[('(IF',) + pos__a[2:], \
                                [('(IF',) + pos__b[2:], pos__c, (')(ELSE',), [('CONTINUE',)],(')ENDIF',)],\
                                (')(ELSE',), pos__f, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', \
                            '*r', (':', 1, 1), '*n', ('::', (0,2)))):
                    rpl(cmds,[[('(IF',) + pos__a[2:],\
                                        [('(IF',) + pos__b[2:],  \
                                        [('(IF', Not(pos__c[2])), pos__d, (')ENDIF',)],\
                                        (')(ELSE',), pos__f, (')ENDIF',)],\
                                    (')ENDIF',)]])
                    return True       
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                            (':', 0,1), '*n', (':', 3,2), ('::',1))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], \
                                        [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)] + pos__c, \
                                    (')(ELSE',), pos__f, (')ENDIF',)], pos__g,pos__h])
                    return True       
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                            (':', 0,1), '*n', (':', 3,1), ('::',1))) and pos__b[1] == pos__h[1]:
                    rpl(cmds,[[('(IF',) + pos__a[2:], \
                                        [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)] + pos__c, \
                                    (')(ELSE',), pos__f, (')ENDIF',)], pos__h])
                    return True       
        elif type(pos__b) is list:
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP', '*', ('::', (0,2)))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b+ [('(IF',) + pos__c[2:], pos__d, (')ENDIF',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'ju', (':', 0,1), 'JUMP_IF2_FALSE_POP',\
                        '*', ('::', (2,4)))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), [('(IF',) + pos__e[2:], pos__f, (')ENDIF',)],(')ENDIF',)]])
                return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_CONTINUE', ('::',0))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b+ [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_CONTINUE', (':', 0, 1), \
                        '*', ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_CONTINUE', (':', 0, 2), \
                        '*', ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('CONTINUE',)], (')ENDIF',)],pos__d,pos__e])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*r')):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)], ('JUMP', pos__a[1])])
                return True                         
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP', (':',0,1), '*', ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*l', 'J_SETUP_LOOP_FOR')):
                rpl(cmds,[pos__a,pos__c])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r',\
                        ('::', 0))):
                rpl(cmds,[[('(IF',) +pos__a[2:] ,pos__b+ [('(IF',) + pos__c[2:], pos__d, \
                                        (')ENDIF',), ('CONTINUE',)], (')ENDIF',)]])
                return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP_CONTINUE', '*',\
                        ('::', 0))):
                rpl(cmds,[[('(IF',) +pos__a[2:] ,pos__b+ [('(IF',) + pos__c[2:], pos__d, \
                                        (')(ELSE',), [('CONTINUE',)], \
                                        (')ENDIF',)], (')ENDIF',)]])
                return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*l', ('::',0))):
                if type(pos__b) is tuple:
                    rpl(cmds,[[pos__b, ('UNPUSH', pos__a[2])]])
                    return True
                if type(pos__b) is list:
                    rpl(cmds,[pos__b + [('UNPUSH', pos__a[2])]])
                    return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP_CONTINUE', '*l',\
                        ('::',0,))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), \
                                [('(IF', Not(pos__c[2])), [('CONTINUE',)], (')ENDIF',)], \
                                (')ENDIF',)]])
                return True        
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP_FOR', \
                            (':', 6,1), 'J_LOOP_VARS', '*n', 'ju', (':', 4,1),\
                            'POP_BLOCK', 'ju', (':', 0,1))) and pos__c[1] != pos__j[1]:
                    rpl(cmds,[pos__a, pos__b+[('(FOR', pos__e[2], pos__c[2]) , pos__f, (')ENDFOR',)],pos__j,pos__k])
                    return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0, 1),\
                            'JUMP_IF2_FALSE_POP_CONTINUE', '*n', ('::', 2))):       #  1
                rpl(cmds,[[('(IF',) +pos__a[2:], pos__b, (')(ELSE',), [('(IF', Not(pos__e[2])), [('CONTINUE',)], (')ENDIF',)] + pos__f, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP_CONTINUE', ('::', 0))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF', Not(pos__c[2])), [('CONTINUE',)], (')ENDIF',)],\
                                    (')ENDIF',)]])
                    return True  
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_TRUE_POP', '*n',\
                            'JUMP_CONTINUE', ('::', (0,2)))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF', Not(pos__c[2])), pos__d+[('CONTINUE',)], (')ENDIF',)],\
                                    (')ENDIF',)]])
                return True              
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_TRUE_POP', '*r',\
                            (':', 0, 1), '*n', ('::', 2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF', Not(pos__c[2])), pos__d, (')ENDIF',)], (')(ELSE',), pos__f,(')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP', '*r',\
                            (':', 0, 1), '*n', ('::', 2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF',) +pos__c[2:], pos__d, (')ENDIF',)], (')(ELSE',), pos__f, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                            'JUMP_IF2_FALSE_POP', '*n', ('::', 2))) and islooplabel(pos__e[1],cmds):       #  1
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), \
                                [('(IF',) + pos__e[2:], pos__f, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'jc', (':', 0,1), '*n',\
                            (':', None, 0), ('::',2))) and pos__c[1] != pos__f[1] and pos__a[1] != pos__f[1]:    
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)], ('JUMP_CONTINUE', pos__c[1]), pos__f,('JUMP_CONTINUE', pos__c[1])])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'ju', (':', 0,1), ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1), \
                            'JUMP_CONTINUE',  ('::', 2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP', 'jc', \
                            (':', 0,1), '*n', ('::', 2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], \
                                pos__b + [('(IF',) + pos__c[2:], [('CONTINUE',)], (')ENDIF',)],(')(ELSE',), pos__f, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'jc', ('::', 0))):     
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'ju', (':', 0,1), \
                            'JUMP_IF2_FALSE_POP_CONTINUE', '*n', ('::', 2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), \
                                [('(IF',) + pos__e[2:], pos__f, (')(ELSE',),[('CONTINUE',)], (')ENDIF',)]]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP', \
                            '*n', 'jc', (':', 0,1), '*n', ('::', 2))) and pos__e[1] not in (pos__f[1],pos__h[1]):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + \
                                        [('(IF',) + pos__c[2:], pos__d+ [('CONTINUE',)], (')ENDIF',)], \
                                    (')(ELSE',), pos__g, (')ENDIF',)]])
                    return True       
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_TRUE_POP', '*r', \
                            (':', 2,1), '*r', \
                            (':', (0, 4, 6), 2), '*r')) and CountJumpCache(pos__k[1],cmds) == 3:
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                        [('(IF',) + pos__c[2:], pos__d +\
                                                [('(IF',) + pos__e[2:], pos__f +\
                                                    [('(IF', Not(pos__g[2])), pos__h, (')ENDIF',)],\
                                                (')ENDIF',)],\
                                        (')(ELSE',), pos__j, \
                                        (')ENDIF',)],\
                                    (')ENDIF',)] +pos__l])            
                    return True    
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n',\
                            'JUMP_IF2_TRUE_POP', \
                            'JUMP_IF2_FALSE_POP', '*n',\
                            'JUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', \
                            (':', 3,1), '*n', \
                            (':', (0,2, 5)))) and CountJumpCache(pos__j[1],cmds) == 3:
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                        [('(IF',) + pos__c[2:], [('PASS',)], (')(ELSE',),\
                                                [('(IF',) + pos__d[2:], pos__e +\
                                                    [('(IF',) + pos__f[2:], [('CONTINUE',)], (')ENDIF',)],\
                                                (')(ELSE',), pos__i,
                                                (')ENDIF',)],\
                                        (')ENDIF',)],\
                                    (')ENDIF',)]])           
                    return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_FALSE_POP', '*n', 'JUMP', \
                            (':', 2,1), '*n', 'JUMP_CONTINUE', \
                            (':', 0,1), '*n', ('::', 4))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                        [('(IF',) + pos__c[2:], pos__d, (')(ELSE',),
                                                pos__g + [('CONTINUE',)], (')ENDIF',)],\
                                        (')(ELSE',), pos__j, (')ENDIF',)]])
                    return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n','xJUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                            (':', 0,1), '*n', (':', 4,2), ('::', 2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                        [('(IF',) + pos__c[2:], [('CONTINUE',)], (')ENDIF',)] + pos__d, \
                                    (')(ELSE',), pos__g, (')ENDIF',)], pos__h,pos__i])
                    return True       
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1),\
                            '*n', 'JUMP_CONTINUE')) and pos__c[1] == pos__f[1]:
                rpl(cmds,[[('(IF', pos__a[2]), pos__b , (')(ELSE',), pos__e , (')ENDIF',)], pos__f])
                return True   
        elif is_cmdmem(pos__b):
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                        (':', 0,1), '>', ('::', 2))):
                rpl(cmds,[Or_j_s(And_j_s(pos__a[2], pos__b),pos__f)])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP', (':', 0, 1), '*l', '>', ('::', 2))):
                rpl(cmds,[('!COND_EXPR', pos__a[2], cmd2mem(pos__b),cmd2mem(pos__f))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP', (':', 0, 1), '>', ('::', 2))):
                rpl(cmds,[('!COND_EXPR', pos__a[2], cmd2mem(pos__b),cmd2mem(pos__e))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                            (':', 0, 1), '*l', '>', ('::', 2))):
                rpl(cmds,[Or_j_s(And_j_s(pos__a[2], pos__b), pos__g)])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                            (':', 0,1), 'JUMP_IF2_FALSE_POP', '>', \
                            'JUMP_IF_TRUE', 'POP_TOP', (':', 5,1), '>', \
                            ('::', (2,7)))):
                    rpl(cmds,[Or_j_s(And_j_s(pos__a[2],pos__b), Or_j_s(And_j_s(pos__f[2],pos__g),pos__k))])
                    return True 
        elif pos__b[0] == '.:':
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', ('::',0))):  
                rpl(cmds,[('UNPUSH', (pos__a[2]))])
                return True
        else:
            pass    

    elif pos__a[0] == 'JUMP_IF2_FALSE_POP_CONTINUE':
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*', ('::',0))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*c')):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*n', ('::',0))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*r')):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b , (')ENDIF',)], ('JUMP_CONTINUE', pos__a[1])])
            return True
    elif pos__a[0] == 'JUMP_IF2_TRUE_POP_CONTINUE':
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP_CONTINUE', '*')):
            rpl(cmds,[[('(IF',) + pos__a[2:], [('CONTINUE',)], (')ENDIF',)]+pos__b])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP', '*',\
                    'JUMP_CONTINUE', (':', 1, 2))) and pos__d[1] == pos__a[1]:
            rpl(cmds,[[('(IF',) + pos__a[2:], [('CONTINUE',)],\
                            (')(ELSE',), [('(IF', Not(pos__b[2])), pos__c + [('CONTINUE',)], (')ENDIF',)](')ENDIF',)],pos__e])
            return True                             
    elif pos__a[0] == 'JUMP_IF_TRUE':
        if SCmp(cmds,i, ('JUMP_IF_TRUE', 'POP_TOP', '.L', '>')):
            rpl(cmds,[pos__a,pos__b,pos__d])
            return True    
    elif pos__a[0] == 'JUMP_IF_FALSE':
        if SCmp(cmds,i, ('JUMP_IF_FALSE', 'POP_TOP', '.L', '>')):
            rpl(cmds,[pos__a,pos__b,pos__d])
            return True    
    else:
        if SCmp(cmds,i, ('ju', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1] and pos__a[1] != pos__b[1]:
            rpl(cmds,[pos__b,pos__c])
            return True     
        if SCmp(cmds,i, ('JUMP', ('::',0))):
            rpl(cmds,[])
            return True    
        if SCmp(cmds,i, ('JUMP', '*', ('::',0))):
            rpl(cmds,[])
            return True    
        if SCmp(cmds,i, ('JUMP', '*', 'JUMP', ('::',0))):
            rpl(cmds,[])
            return True    
        if SCmp(cmds,i, ('JUMP', 'POP_BLOCK', 'JUMP', ('::',0))):
            rpl(cmds,[])
            return True      
        if SCmp(cmds,i, ('JUMP', (':', 4, 1), 'xJUMP_IF2_FALSE_POP', '*', 'JUMP')):
            rpl(cmds,[pos__a])
            return True
        if SCmp(cmds,i, ('JUMP_CONTINUE', 'JUMP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[pos__a])
            return True    
        if SCmp(cmds,i, ('JUMP','JUMP')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[pos__a])
            return True            
        if SCmp(cmds,i, ('JUMP', 'JUMP_CONTINUE')):
            rpl(cmds,[pos__a])
            return True
        if  SCmp(cmds,i, ('JUMP_CONTINUE', 'JUMP')):
            rpl(cmds,[pos__a])
            return True
        if  SCmp(cmds,i, ('JUMP', '.:', 'JUMP')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__c])
            return True
        if  SCmp(cmds,i, ('JUMP_CONTINUE', '.:', 'JUMP')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__a])
            return True
        if  SCmp(cmds,i, ('JUMP', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__c])
            return True
        if  SCmp(cmds,i, ('JUMP_CONTINUE', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__c])
            return True
        if SCmp(cmds, i, ('JUMP', '.:', 'JUMP_IF2_FALSE_POP', '*',  (':', 0), 'JUMP')) and pos__f[1] == pos__c[1]:
            rpl(cmds,[pos__a,pos__b, [('(IF', pos__c[2]), pos__d, (')IF',)], pos__e, pos__f ])
            return True
            
  
    ## if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP', (':', 0,1), '*r')):
        ## if type(pos__b) is list:
            ## rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)],pos__c, pos__d])
        ## else:    
            ## rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)],pos__c, pos__d])
        ## return True
    if pos__a[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' or pos__a[0] == 'JUMP_IF2_TRUE_POP_CONTINUE':
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('UNPUSH', pos__a[2]),pos__b])
            return True
        if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP_CONTINUE', 'xJUMP_IF2_FALSE_POP', \
                        'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[[('(IF', Or_j(pos__a[2], pos__b[2])), [('CONTINUE',)], (')ENDIF',)], ('JUMP', pos__b[1])])
            return True   
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP_CONTINUE', '*')):
            rpl(cmds,[[('(IF', Not(pos__a[2])), [('CONTINUE',)], (')ENDIF',)]+pos__b])
            return True

    if pos__a[0] == 'JUMP_IF2_FALSE_POP' or pos__a[0] == 'JUMP_IF2_TRUE_POP':
        if type(pos__b) is list:
            if pos__c[0] == 'J_SETUP_LOOP':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                (':', 5, 1), '*n', 'ju', ('::', 0))):
                    rpl(cmds,[[('(IF',) + pos__a[2:],pos__b + [('(WHILE', TRUE), pos__e, (')ENDWHILE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                ('!', '(IF', '*c', ')ENDIF'), 'POP_BLOCK', '*n', \
                                'JUMP_CONTINUE', (':', 0,0))) and pos__c[1] != pos__a[1] != pos__g[1]:
                    rpl(cmds,[pos__a, pos__b + [('(WHILE',) + pos__d[0][1:], pos__d[1][:-1], (')(ELSE',), pos__f, (')ENDWHILE',)],pos__g,pos__h])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                ('!', '(IF', '*r', ')ENDIF'), 'POP_BLOCK',  ('::', (0,2)))):
                    rpl(cmds,[pos__a, pos__b + [('(WHILE',) + pos__d[0][1:], pos__d[1][:-1], (')ENDWHILE',)],pos__f])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                ('!', '(IF', '*r', ')ENDIF'), 'POP_BLOCK', 'JUMP', (':', 0, 0))) and\
                                pos__a[1] != pos__c[1] and pos__a[1] != pos__f[1]:
                        rpl(cmds,[pos__a,pos__b+[('(WHILE',) + pos__d[0][1:], pos__d[1], (')ENDWHILE',)],pos__f,pos__g])
                        return True    
            elif pos__c[0] == 'JUMP':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                '*n', 'JUMP_CONTINUE', ('::', 2))):            
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b , (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                        return True                
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n', 'JUMP', (':', 0,1),\
                                '*n', 'JUMP_CONTINUE', ('::', 2))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n', 'JUMP', (':', 0,1),\
                                'JUMP_CONTINUE', ('::', 2))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0, 1),\
                                'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 2,1), '*n', \
                                ('::', 4))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), [('(IF', pos__e[2]), [('CONTINUE',)], (')ENDIF',)]+pos__g, (')ENDIF',)]])
                    return True    
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0, 1),\
                                'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 2,1), \
                                ('::', 4))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), [('(IF', pos__e[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                    return True    
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                '*n', 'JUMP_CONTINUE')) and pos__c[1] not in (pos__a[1], pos__d[1], pos__f[1]):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)], pos__c])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                'JUMP_CONTINUE')) and pos__c[1] not in (pos__a[1], pos__d[1], pos__e[1]):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)], pos__c])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1), '*r', \
                                '.:')) and pos__c[1] != pos__f[1]:
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b , (')(ELSE',), pos__e, (')ENDIF',)], pos__c,pos__f])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1), '*n',\
                                'jc', ('::', 2))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b , (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                    return True   
 
            elif is_cmdmem(pos__c):
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*l', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                                (':', 0,1), '>', ('::', 3))):
                    rpl(cmds,[Or_j_s(And_j_s(pos__a[2], pos__c), pos__g)])
                    return True
            elif pos__c[0] == '.:':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*r', ('::',0))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
                        return True 
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*r', (':', None,0), 'END_FINALLY', ('::', 0))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')ENDIF',)], pos__c,pos__d])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*r', '.:', '*n', (':', 0, 0))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')ENDIF',)], ('JUMP', pos__a[1]), pos__c,pos__d,pos__e])
                    return True   
            elif pos__c[0] == 'JUMP_CONTINUE':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP_CONTINUE')):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('CONTINUE',)], (')ENDIF',)], ('JUMP', pos__a[1])])
                    return True   
            elif pos__c[0] == 'J_SETUP_LOOP_FOR':  
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '**n', 'J_SETUP_LOOP_FOR', (':', 6,1),\
                                'J_LOOP_VARS', '**n', 'JUMP_CONTINUE', (':', 4, 1),\
                                'POP_BLOCK', 'JUMP', (':', 0,1), '*n', (':', 2,1),\
                                'JUMP')):
                    cmds[i:i+9] = [pos__a,pos__b+[('(FOR', pos__e[2], pos__c[2]), pos__f[:], (')ENDFOR',)]]
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n', 'J_SETUP_LOOP_FOR', \
                                (':', 6, 1), 'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', \
                                (':', 4, 1), 'POP_BLOCK', 'JUMP_CONTINUE', (':', 0, 0))) and \
                                pos__a[1] != pos__c[1] != pos__j[1]:
                    rpl(cmds,[pos__a, pos__b +[('(FOR', pos__e[2], pos__c[2]), pos__f[:], (')ENDFOR',)],pos__j, pos__k])
                    return True
            elif pos__e[0] == 'JUMP':    
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n','xJUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                                (':', 0,1), '*n', (':', 4,1), ('::', 2))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                            [('(IF',) + pos__c[2:], [('CONTINUE',)], (')ENDIF',)] + pos__d, \
                                        (')(ELSE',), pos__g, (')ENDIF',)],pos__i])
                        return True       
            elif pos__d[0] == '.:':        
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n',\
                                'xJUMP_IF2_TRUE_POP_CONTINUE', ('::', 0))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b + [('(IF', pos__c[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                    return True
            elif pos__e[0] == '.:':        
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'xJUMP_IF2_TRUE_POP', '*r',\
                                (':', 0,1), '*r', ('::', 2))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('(IF', Not(pos__c[2])), pos__d, (')ENDIF',)], (')(ELSE',), pos__f , (')ENDIF',)]])
                    return True
            elif pos__f[0] == 'JUMP_CONTINUE':        
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '**n', 'xJUMP_IF2_FALSE_POP', '**n', \
                                'xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', (':', 0, 1), \
                                '**n', ('::', (2, 4)))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('(IF', pos__c[2]), \
                                                pos__d + [('(IF', pos__e[2]), [('CONTINUE',)], (')ENDIF',)], \
                                                (')ENDIF',)],\
                                (')(ELSE',), pos__h, (')ENDIF',)]])                
                    return True  
            elif pos__g[0] == 'JUMP_CONTINUE':        
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '**n', 'xJUMP_IF2_FALSE_POP', '**n', \
                                'xJUMP_IF2_FALSE_POP', '**n', 'JUMP_CONTINUE', (':', 0, 1), \
                                '**n', ('::', (2, 4)))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('(IF', pos__c[2]), \
                                                pos__d + [('(IF', pos__e[2]), pos__f + [('CONTINUE',)], (')ENDIF',)], \
                                                (')ENDIF',)],\
                                (')(ELSE',), pos__i, (')ENDIF',)]])                
                    return True  
        elif pos__b[0] == '(BEGIN_TRY':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                            'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                            'END_FINALLY', (':', 4, 1), '*r', (':', 0, 1), '*r', ('::', 6))):
                        rpl(cmds,[[('(IF', pos__a[2]), concatenate_try_except(pos__c,pos__f, pos__j), (')(ELSE',), pos__l, (')ENDIF',)]])
                        return True 
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                            'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                            'END_FINALLY', (':', 4, 1), '*r', (':', 0, 1), '*n', ('::', 6))):
                        rpl(cmds,[[('(IF', pos__a[2]), concatenate_try_except(pos__c,pos__f, pos__j), (')(ELSE',), pos__l, (')ENDIF',)]])
                        return True                     
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                            'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                            'END_FINALLY', 'JUMP', (':', 0,None))) and pos__e[1] == pos__i[1]:
                rpl(cmds,[pos__a, concatenate_try_except(pos__c, pos__f),pos__j])
                return True                    
        elif pos__b[0] == 'J_SETUP_LOOP_FOR':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', 'J_LOOP_VARS', \
                            '*', (':', 2,1), 'POP_BLOCK', '*r', (':', 0,1), '*',(':', 1,1))):
                    rpl(cmds,[pos__a, [('(FOR', pos__c[2], pos__b[2]) , pos__d, (')(ELSE',),pos__g, (')ENDFOR',)],pos__h,pos__i,pos__j])
                    return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', 'J_LOOP_VARS', \
                            '*r', (':', 2, 1), 'POP_BLOCK', 'JUMP', (':', 0, 1))) and\
                            pos__g[1] not in (pos__a[1], pos__b[1], pos__c[1]):
                    rpl(cmds,[pos__a, [('(FOR', pos__c[2], pos__b[2]) , pos__d, (')ENDFOR',)],pos__g,pos__h])
                    return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5, 1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3, 1),\
                            'POP_BLOCK', '*n', 'JUMP_CONTINUE', (':', 0, 1), '*n',\
                            (':', 1,1), ('::', 9))):
                rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]), pos__e[:], (')(ELSE',), pos__i,(')ENDFOR',)],pos__j,pos__k,pos__l,cmds[i+12]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', 'J_SETUP_LOOP_FOR', (':', 5, 1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3, 1),\
                            'POP_BLOCK', 'JUMP_CONTINUE', (':', 0, 0))) and \
                            pos__i[1] not in (pos__a[1], pos__b[1], pos__d[1], pos__f[1]):
                rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]), pos__e[:], (')ENDFOR',)],pos__i,pos__j])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5, 1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3, 1), \
                            'POP_BLOCK', '*n', 'JUMP', ('::', 0))) and pos__b[1] != pos__j[1] and \
                            pos__b[1] not in (pos__a[1],pos__c[1], pos__d[1]):       #  1
                rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]), pos__e[:], (')(ELSE',), pos__i,(')ENDFOR',)],pos__j,pos__k])
                return True
        elif pos__b[0] == 'J_SETUP_LOOP':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP', \
                            (':', 4, 1), '*n', 'ju', ('::', 0))):
                rpl(cmds,[[('(IF',) + pos__a[2:],[('(WHILE', TRUE), pos__d, (')ENDWHILE',)], (')ENDIF',)]])
                return True
        elif pos__b[0] == 'JUMP':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('UNPUSH', pos__a[2]),pos__b])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', 'JUMP', (':', 0,1),\
                            '*n', 'JUMP_CONTINUE', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', 'JUMP', (':', 0,1),\
                            'JUMP_CONTINUE', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0, 1),\
                            'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 1,1), '*n', \
                            ('::', 3))):
                rpl(cmds,[[('(IF', Not(pos__a[2])),[('(IF', pos__d[2]), [('CONTINUE',)], (')ENDIF',)]+pos__f, (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0, 1),\
                            'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 1,1), \
                            ('::', 3))):
                rpl(cmds,[[('(IF', Not(pos__a[2])),[('(IF', pos__d[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0,1),\
                            '*n', 'JUMP_CONTINUE')) and pos__b[1] not in (pos__a[1], pos__c[1], pos__e[1]):
                rpl(cmds,[[('(IF', pos__a[2]), [('PASS',)], (')(ELSE',), pos__d + [('CONTINUE',)], (')ENDIF',)], pos__b])
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0,1),\
                            'JUMP_CONTINUE')) and pos__b[1] not in (pos__a[1], pos__c[1], pos__d[1]):
                rpl(cmds,[[('(IF', pos__a[2]), [('PASS',)], (')(ELSE',), [('CONTINUE',)], (')ENDIF',)], pos__b])
                return True   
        elif pos__b[0][0] == 'J':           
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP',\
                            'xJUMP_IF2_TRUE_POP_CONTINUE', ('::', 0))):
                rpl(cmds,[[('(IF', Not(pos__a[2])), [('(IF', pos__b[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_TRUE_POP', '*r',\
                            (':', 0,1), '*r', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), [('(IF', Not(pos__b[2])), pos__c, (')ENDIF',)], (')(ELSE',), pos__e , (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', '*n',\
                            'ju', (':', 0, 1), '*n', (':', 1, 1),\
                            '*n', ('::', 3))):
                rpl(cmds,[[('(IF', pos__a[2]),[('(IF', pos__b[2]), pos__c, (')(ELSE',), pos__h, (')ENDIF',)], (')(ELSE',), pos__f, (')ENDIF',)]])
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', \
                            'ju', (':', 0, 1), '*n', (':', 1, 1),\
                            '*n', ('::', 2))):
                pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i = [('PASS',)],pos__c,pos__d,pos__e,pos__f,pos__g,pos__h                
                rpl(cmds,[[('(IF', pos__a[2]),[('(IF', pos__b[2]), pos__c, (')(ELSE',), pos__h, (')ENDIF',)], (')(ELSE',), pos__f, (')ENDIF',)]])
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', '**n', \
                            'xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', (':', 0, 1), \
                            '**n', ('::', (1, 3)))):
                rpl(cmds,[[('(IF', pos__a[2]), [('(IF', pos__b[2]), \
                                            pos__c + [('(IF', pos__d[2]), [('CONTINUE',)], (')ENDIF',)], \
                                            (')ENDIF',)],\
                            (')(ELSE',), pos__g, (')ENDIF',)]])                
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_COND_PUSH', (':', 0, 1),\
                            '>', ('::', 1))):
                rpl(cmds,[('!COND_EXPR', pos__a[2], ('!COND_EXPR',) + pos__b[2:] + (cmd2mem(pos__d),), cmd2mem(pos__d))])
                return True
        elif pos__b[0] == 'RETURN_VALUE':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'RETURN_VALUE', ('::',0))) and len(pos__b) == 2:
                rpl(cmds,[[('(IF', pos__a[2]), [pos__b], (')ENDIF',)]])
                return True
        elif is_cmdmem(pos__b):           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '>', 'JUMP', ('::', 0))) and pos__c[1] != pos__d[1]:
                rpl(cmds,[('J_COND_PUSH', pos__c[1], pos__a[2], cmd2mem(pos__b))])
                return True
        else:
            pass
    if added_pass:
        if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP_CONTINUE',)):
            rpl(cmds,[[('(IF', pos__a[2]), [('CONTINUE',)], (')ENDIF',)]])
            return True   
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP',)) and islooplabel(pos__a[1],cmds):
            rpl(cmds,[('JUMP_IF2_TRUE_POP_CONTINUE',) + pos__a[1:]])
            return True   
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP',)) and islooplabel(pos__a[1],cmds):
            rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE',) + pos__a[1:]])
            return True   
        if SCmp(cmds,i, ('JUMP',)) and islooplabel(pos__a[1],cmds):
            rpl(cmds,[('JUMP_CONTINUE',) + pos__a[1:]])
            return True   
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', \
                    (':', 0,0), '*n', (':', 1,0))):
            rpl(cmds,[pos__a,[('(IF', pos__b[2]), [('CONTINUE',)], (')ENDIF',)],('JUMP', pos__b[1]), pos__d,pos__e,pos__f])
            return True           
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', '.:')) and pos__a[1] != pos__b[1] != pos__c[1]: 
            rpl(cmds,[[('(IF', pos__a[2]), [('CONTINUE',)], (')ENDIF',)],('JUMP', pos__a[1]),pos__c])
            return True           
    return False

def process_j_setup_loop_for(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':',4,1), 'J_LOOP_VARS', '*', 'ju',
                        (':',2,1), 'POP_BLOCK', ('::',0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)]])
        return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*', (':',1,1), 'POP_BLOCK',\
                    'JUMP')) and pos__a[1] == pos__f[1]:
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)],pos__f])
        return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':',4,1), 'J_LOOP_VARS', '*n',\
                    'ju', (':',2,1), 'POP_BLOCK', '*n', 'jc', ('::',0)))and\
                    pos__i[1] != pos__e[1]:
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h + [('CONTINUE',)],(')ENDFOR',)]])
            return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*', (':', 1, 1),\
                    'POP_BLOCK', ('::',0))):
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)]])
        return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3,0), 'J_LOOP_VARS',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*r')):
            rpl(cmds,[pos__a,pos__b,pos__c,[('(IF',) + pos__d[2:], pos__e, (')ENDIF',)], ('JUMP_CONTINUE',pos__d[1])])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3,0), 'J_LOOP_VARS',\
                    'xJUMP_IF2_FALSE_POP', '*r')):
            rpl(cmds,[pos__a,pos__b,pos__c,[('(IF',) + pos__d[2:], pos__e, (')ENDIF',)], ('JUMP',pos__d[1])])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*', (':',1,1), 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]) , pos__c, (')ENDFOR',)]])
            return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 2), 'J_LOOP_VARS', \
                    'xJUMP_IF2_TRUE_POP_CONTINUE', '*', 'JUMP_CONTINUE', \
                    (':', 2, 1), 'POP_BLOCK', ('::', 0))) and pos__d[1] == pos__f[1]:
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]) , [('(IF',) +pos__d[2:],\
                                                    [('CONTINUE',)],(')ENDIF',)]+ pos__e, (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 1), 'J_LOOP_VARS', \
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]) , [('PASS',)], (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*n', (':', 1,1),\
                    'POP_BLOCK', '*r', ('::', 0))):
            rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]) , pos__c, (')(ELSE',),pos__f, (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*n', (':', 2, 1),\
                    'POP_BLOCK', ('::', 0))):       #  1
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]) , \
                            pos__d + [('(IF',) + pos__e[2:], pos__f, (')ENDIF',)], \
                            (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,2), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*n', 'JUMP_CONTINUE')):       
            rpl(cmds,[pos__a,pos__b,pos__c,pos__d + [('(IF',) +pos__e[2:], pos__f, (')ENDIF',)], pos__g])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 2), 'J_LOOP_VARS', \
                     'xJUMP_IF2_TRUE_POP')):
            if type(cmds[i+4]) is list:
                cmds[i:i+5] = [pos__a,pos__b,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]+cmds[i+4]]
            else:          
                cmds[i:i+4] = [pos__a,pos__b,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]]
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3,1), 'J_LOOP_VARS', \
                     'xJUMP_IF2_TRUE_POP')):
            if type(cmds[i+4]) is list:
                cmds[i:i+5] = [pos__a,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]+cmds[i+4]]
            else:                 
                cmds[i:i+4] = [pos__a,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]]
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,2), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*n')):       
            rpl(cmds,[pos__a,pos__b,pos__c,pos__d+ [('(IF', Not(pos__e[2])), [('CONTINUE',)], (')ENDIF',)]+pos__f])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,0), 'J_LOOP_VARS', '*n', 'JUMP')):
        rpl(cmds,[pos__a,pos__b,pos__c,pos__d,('JUMP_CONTINUE',) + pos__e[1:]])
        return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1),\
                    'POP_BLOCK', '*n', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')(ELSE',),pos__f,(')ENDFOR',)]])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', '*n', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',),pos__h,(')ENDFOR',)]])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'ju', (':', 2,1), 'POP_BLOCK', '*r', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',),pos__h,(')ENDFOR',)]])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', '*n', 'ju',\
                    (':', 2,1), 'POP_BLOCK', '*n', 'ju')) and pos__a[1] == pos__i[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',),pos__h,(')ENDFOR',)],pos__i])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', 'JUMP')) and pos__h[1] == pos__a[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)],pos__h])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', 'JUMP_CONTINUE')) and pos__h[1] == pos__a[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)],pos__h])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', 'jc',\
                    ('::', 0))) and pos__h[1] not in (pos__b[1],pos__f[1],pos__i[1]):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), [('CONTINUE',)],(')ENDFOR',)]])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', 'ju', \
                    '.:', 'END_FINALLY', ('::', 0))) and \
                    pos__h[1] not in (pos__a[1], pos__b[1],pos__c[1],pos__e[1],pos__f[1]) and\
                    pos__i[1] not in (pos__a[1], pos__b[1],pos__c[1],pos__e[1],pos__f[1]):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)],pos__h,pos__i,pos__j])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', '*r',\
                    '.:', 'END_FINALLY', ('::', 0))) and pos__i[1] not in [pos__b[1], pos__f[1],pos__k[1]]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h,(')ENDFOR',)],pos__i,pos__j])
        return True         
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1), \
                    'POP_BLOCK', '*r', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')(ELSE',), pos__f,(')ENDFOR',)]])
        return True         
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1),\
                    'POP_BLOCK', 'JUMP_CONTINUE')) and pos__a[1] == pos__f[1]:
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)],pos__f])
        return True        
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1),\
                    'POP_BLOCK', 'JUMP')) and pos__a[1] == pos__f[1]:
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)],pos__f])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', '*r', '.:')) \
                    and pos__i[1] != pos__a[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h, (')ENDFOR',)],pos__i])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,2), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_TRUE_POP')):
        rpl(cmds,[pos__a,pos__b,pos__c,pos__d,('JUMP_IF2_TRUE_POP_CONTINUE',) + pos__e[1:]])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_TRUE_POP')):
        rpl(cmds,[pos__a,pos__c,pos__d,('JUMP_IF2_TRUE_POP_CONTINUE',) + pos__e[1:]])
        return True       
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', '*n', \
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', '*r',\
                    'END_FINALLY', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h, (')ENDFOR',)],pos__i])
        return True   
    return False

def process_begin_try(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', (':', 3, 1), '*r')):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__k, (')ENDTRY',)],pos__g])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', (':', 3, 1), '*r')) and pos__g[1] not in (pos__d[1],pos__e[1]):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__k, (')ENDTRY',)],pos__g])
             return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1), 'END_FINALLY',\
                    (':', 3, 1), '*r', ('::', 5))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
             return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    'JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP', (':', 4,1), 'END_FINALLY',\
                    (':', 3, 1), '*n', ('::', 6))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__k, (')ENDTRY',)]])
             return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1), 'END_FINALLY',\
                    (':', 3, 1), '*n', ('::', 5))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
                return True 
                  
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', ('::', (3,5)))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)],(')ENDTRY',)]])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 3, 1),\
                    'END_FINALLY', ('::', 4))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], [('PASS',)],(')ENDTRY',)]])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', ('::', (3,6)))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*l', 'POP_TOP3', '*', 'JUMP', 'END_FINALLY', ('::', (3,7)))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), pos__g, (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*l', 'POP_TOP3', 'JUMP', 'END_FINALLY', ('::', (3,6)))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)], (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'POP_TOP3', '*n', 'END_FINALLY', ('::', 3))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), pos__f, (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*', 'JUMP', (':', 3, 1), 'END_FINALLY', ('::', 5))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)]])
                return True               
    ## if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP',\ # By CloneDigger
                    ## 'JUMP', (':', 3, 1), 'END_FINALLY', ('::', 4))):
                ## rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], [('PASS',)], (')ENDTRY',)]])
                ## return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*', 'JUMP', (':', 3, 1), 'END_FINALLY', 'JUMP')) and pos__f[1] == pos__i[1]:
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)],pos__i])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    'JUMP', (':', 3,1), 'END_FINALLY', 'JUMP')) and pos__e[1] == pos__h[1]:
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], [('PASS',)], (')ENDTRY',)],pos__h])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*r', (':', 3,1), 'END_FINALLY')):         
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4, 1), 'END_FINALLY',\
                    (':', 3,1), '*n', 'JUMP')) and pos__k[1] not in(pos__d[1],pos__e[1]):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__j, (')ENDTRY',)],pos__k])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4, 1), 'END_FINALLY',\
                    ('::', 3))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', ('!', 'PASS'), ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', (':', 3,1), '*n', ('::', 4))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)],(')(ELSE',),pos__h, (')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', ('!', 'PASS'), ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', ('::', (3,4)))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)],(')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', \
                    (':', 4,1), 'END_FINALLY', (':', 3,1), '*n', 'JUMP_CONTINUE')) and pos__f[1] == pos__k[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('CONTINUE',)], (')(ELSE',),pos__j, (')ENDTRY',)],pos__k])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', \
                    (':', 4,1), 'END_FINALLY', (':', 3,1), '*n', 'JUMP')) and pos__f[1] == pos__k[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('CONTINUE',)], (')(ELSE',),pos__j, (')ENDTRY',)],pos__k])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', ('::', 3))):
            rpl(cmds,[concatenate_try_except(pos__b, pos__e)])
            return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', 'JUMP')) and pos__d[1] == pos__g[1] and pos__d[1] == pos__j[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)],pos__g])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', 'JUMP_CONTINUE')) and pos__d[1] == pos__g[1] and pos__d[1] == pos__j[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)],pos__g])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', 'JUMP_CONTINUE')) and pos__d[1] == pos__f[1] and pos__d[1] == pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')ENDTRY',)],pos__f])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and\
                    pos__d[1] == pos__f[1] and pos__d[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__h])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY',\
                    '.:', 'ju')) and\
                    pos__d[1] == pos__f[1] and pos__d[1] == pos__i[1] and pos__h[1] not in (pos__d[1], pos__f[1], pos__i[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__h, pos__i])
                return True             
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY',\
                    'ju')) and\
                    pos__d[1] == pos__f[1] and pos__d[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__h])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY',\
                    ('::', (3,5)))):
           rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
           return True 
    ## if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \ # By CloneDigger
                    ## 'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4, 1), 'END_FINALLY',\
                    ## ('::', 3))):
                ## rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)]])
                ## return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'JUMP')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'JUMP_CONTINUE')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', \
                    (':', 4,1), 'END_FINALLY', ('::', 3))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f + [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if  SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*n', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', ('::', 4))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True
    ## if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \ # By CloneDigger
                    ## '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    ## '*n', ('::', 5))):
                ## rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                ## return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4,1), 'END_FINALLY', \
                    (':', 3, 1), '*n', ('::', 5))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*n', (':', 3, 1), 'END_FINALLY')):            
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', 'JUMP_CONTINUE')) and\
                    pos__d[1] == pos__f[1] and pos__f[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    (':', 3, 1), '*n', 'JUMP_CONTINUE')) and pos__f[1] == pos__j[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),pos__j])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE',\
                    'END_FINALLY', 'JUMP_CONTINUE')) and pos__e[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__d),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE',\
                    'END_FINALLY', 'JUMP')) and pos__e[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__d),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*l', 'POP_TOP3', 'JUMP', 'END_FINALLY', (':', 3,1),\
                    '*n', ('::', 6))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1), 'END_FINALLY',\
                    'JUMP')) and pos__d[1] == pos__f[1] and pos__f[1] ==pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], [('PASS', )], (')ENDTRY',)],pos__i])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4,1), 'END_FINALLY',\
                    'JUMP')) and pos__d[1] == pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], pos__f, (')ENDTRY',)],pos__i])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                   'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4,1), 'END_FINALLY',\
                   'JUMP_CONTINUE')) and pos__d[1] == pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], pos__f, (')ENDTRY',)],pos__i])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', ('::', 3))):       #  1
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', ('::',3))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', \
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', ('::', 4))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    ('!', '(EXCEPT1', '*n', ')ENDEXCEPT'), 'J_AFTER_EXCEPT_HANDLE_CONTINUE', \
                    'END_FINALLY', 'JUMP')) and\
                    pos__d[1] == pos__h[1] and pos__f[1] != pos__d[1]:
                tempor = pos__e[:-1]
                if len(tempor[-1][0]) > 0 and tempor[-1][0][0] == 'PASS':
                    tempor[-1] = [('CONTINUE',)]
                else:   
                    tempor[-1].append(('CONTINUE',))        
                tempor = tempor + [pos__e[-1]]                
                rpl(cmds,[concatenate_try_except(pos__b,tempor), pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    ('!', '(EXCEPT1', '*n', ')ENDEXCEPT'), 'J_AFTER_EXCEPT_HANDLE_CONTINUE', \
                    'END_FINALLY', ('::',3))) and pos__f[1] != pos__d[1]:
                tempor = pos__e[:-1]
                if len(tempor[-1][0]) > 0 and tempor[-1][0][0] == 'PASS':
                    tempor[-1] = [('CONTINUE',)]
                else:   
                    tempor[-1].append(('CONTINUE',))        
                tempor = tempor + [pos__e[-1]]
                rpl(cmds,[concatenate_try_except(pos__b,tempor)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*r', ('::', 5))):       #  1            
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*c', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', ('::', 4))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3,1),\
                    '*n', 'JUMP')) and pos__f[1] == pos__j[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),pos__j])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                     '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', ('::', (3,5)))):
        rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
        return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'JUMP')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', ('::', 3))):       #  2
                rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', 'JUMP')) and\
                    pos__d[1] == pos__f[1] == pos__h[1]:            
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'ju')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3,1), '*n',\
                    'JUMP_CONTINUE')) and pos__f[1] == pos__j[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),pos__j])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', 'JUMP_CONTINUE')) and\
                    pos__d[1] == pos__f[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    ('!', '(EXCEPT1', ('!', 'PASS'), ')ENDEXCEPT'), \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):
                rpl(cmds,[[('(TRY',), pos__b, ('(EXCEPT',) + pos__e[0][1:], [('CONTINUE',)], (')ENDTRY',)]])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*n', 'JUMP_CONTINUE', (':', 4,1), 'END_FINALLY', ('::', 3))):
                rpl(cmds,[[('(TRY',), pos__b, ('(EXCEPT',) + pos__e[2:], pos__f+[('CONTINUE',)], (')ENDTRY',)]])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', '*e', \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and pos__e[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__d),pos__g])
                return True                        
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3,1),\
                    '*n', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', '*e', \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    (':', 3, 1), '*r')):                   
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),('JUMP_CONTINUE', pos__f[1])])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '.L', '(EXCEPT0', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '(EXCEPT0', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True                     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '.L', '(EXCEPT1', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',pos__e[1][1]), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '(EXCEPT1', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',pos__e[0][1]), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True    
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', 'JUMP_CONTINUE', \
                    ('::', 5))) and pos__d[1] == pos__h[1]:       #  1            
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,[('CONTINUE',)])])
                return True                                    
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*', '.:', 'END_FINALLY', ('::', 5))) and not islineblock(pos__i) and\
                    pos__j[1] not in (pos__d[1],pos__f[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i), pos__j,pos__k])
                return True                                    
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', '*e', 'END_FINALLY')):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', 'JUMP_CONTINUE', '.:', '*n', (':', (3,5), 1),\
                    'JUMP_CONTINUE')) and pos__h[1] == pos__l[1] and pos__i[1] not in (pos__d[1], pos__h[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h,pos__i,pos__j,pos__l])
                return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', 'JUMP_CONTINUE', '.:', '*n', (':', (3,5), 2),\
                    'JUMP_CONTINUE')) and pos__h[1] == pos__l[1] and pos__i[1] not in (pos__d[1], pos__h[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h,pos__i,pos__j,pos__k,pos__l])
                return True              
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*r', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True              
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*l', 'POP_TOP3', '*r', 'END_FINALLY')):
                rpl(cmds, [[('(TRY',), pos__b, (')(EXCEPT',), pos__f, (')ENDTRY',)]])
                return True            
    return False

def process_except_clause(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    if SCmp(cmds,i, ('POP_TOP3', '*r', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), pos__b, (')ENDEXCEPT',)],pos__c])
        return True
    if SCmp(cmds,i, ('POP_TOP3', '*n', 'JUMP_CONTINUE', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), pos__b + [('CONTINUE',)], (')ENDEXCEPT',)],pos__d])
        return True
    if SCmp(cmds,i, ('POP_TOP3', 'JUMP_CONTINUE', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), [('CONTINUE',)], (')ENDEXCEPT',)],pos__c])
        return True
    if SCmp(cmds,i, ('POP_TOP3', 'JUMP', 'END_FINALLY')):
        if not islooplabel(pos__b[1],cmds):
           rpl(cmds,[[('(EXCEPT0',), [('PASS',)], (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__b[1]),pos__c])
        else:   
           rpl(cmds,[[('(EXCEPT0',), [('CONTINUE',)], (')ENDEXCEPT',)],pos__c])
        return True
    if SCmp(cmds,i, ('POP_TOP3', '*n', 'JUMP', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), pos__b, (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__c[1]),pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b, (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__c[1]),pos__e])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b + [('CONTINUE',)], (')ENDEXCEPT',)],pos__e])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b, (')ENDEXCEPT',)],pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], [('PASS',)], (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__b[1]),pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], [('CONTINUE',)], (')ENDEXCEPT',)],pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b, (')ENDEXCEPT',)], pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'xJUMP_IF2_FALSE_POP', '*r',\
                    (':', 0, 1), 'END_FINALLY', '.:', '*n', ('::', 1))) and\
                    pos__a[1] != pos__f[1] != pos__b[1]:
        rpl(cmds,[pos__a, [('(IF', pos__b[2]), pos__c, (')ENDIF',)], pos__d,pos__e,pos__f,pos__g])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n',\
                    'xJUMP_IF2_FALSE_POP', '*n', \
                    'JUMP_CONTINUE', (':',0 ,1), \
                    'END_FINALLY', ('::', 2))):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b + \
                                 [('(IF',) + pos__c[2:], pos__d + [('CONTINUE',)], (')ENDIF',)],\
                         (')ENDEXCEPT',)], pos__g])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1), \
                    ('!', '(EXCEPT1', '*r', ')ENDEXCEPT'), 'END_FINALLY')):
        cmds[i:i+6] = [concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__c[1] == pos__f[1]:
        cmds[i:i+6] = [concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__c[1] == pos__f[1]:
        cmds[i:i+6] = [concatenate_except(pos__a[2:], pos__b, pos__e),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE')) and pos__b[1] == pos__e[1]:
        cmds[i:i+5] = [concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1), \
                    '*e', 'END_FINALLY', 'JUMP_CONTINUE')) and pos__c[1] == pos__g[1]:
        cmds[i:i+7] = [concatenate_except(pos__a[2:], pos__b, pos__e),pos__f,pos__g]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', \
                    (':', 0, 1), '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__c[1] != pos__f[1]:
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__b[1] == pos__e[1]:
        cmds[i:i+5] = [concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e]
        return True
    ## if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0, 1), \ # By CloneDigger
                    ## '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__b[1] == pos__e[1]:
        ## cmds[i:i+5] = [concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e]
        ## return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 0,1), '*e',
                    'END_FINALLY', ('::', 2))):
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b, pos__e),pos__f])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0, 1), '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 4, 2))):
        cmds[i:i+7] = [concatenate_except(pos__a[2:], pos__b, pos__d),pos__e,pos__f,pos__g]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0, 1), '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 4, 1))):
        cmds[i:i+7] = [concatenate_except(pos__a[2:], pos__b, pos__d),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0, 1), '*e',\
                    'END_FINALLY')):
        cmds[i:i+5] = [concatenate_except(pos__a[2:], pos__b, pos__d),pos__e]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0,1), '*e')):       
        cmds[i:i+4] = [concatenate_except(pos__a[2:], pos__b, pos__d)]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*ra', 'JUMP', (':', 0,1), '*e')) and\
                    pos__c[1] != pos__a[1]:
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b, pos__e)])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0, 1), '*e',\
                    'END_FINALLY', ('::', 1))):
        rpl(cmds,[concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', \
                    (':', 0, 1), '*e', 'END_FINALLY')):          
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', \
                    (':', 0, 1), '*e', 'END_FINALLY')):          
        rpl(cmds,[concatenate_except(pos__a[2:], [('CONTINUE',)], pos__d),pos__e])
        return True
    return False
    
def process_after_try_detect(cmds,_i):
    global count_define_set
    aa = cmds[_i]
    v0,v1,v2 = [], [], []
    ## i = 0
    if len(aa) == 5 and aa[0] == ('(TRY',) and \
       len(aa[1]) == 2 and aa[1][0][0] == '.L' and\
       TCmp(aa[1][1], v0, ('STORE', (('STORE_NAME', '?'),), \
                                 (('!IMPORT_NAME', '?', '?', '?'),))) and \
       TCmp(aa[2], v1, (')(EXCEPT', (('!LOAD_BUILTIN', 'ImportError'), '?'), ())) and\
       len(aa[3]) == 2 and aa[3][0][0] == '.L' and\
       TCmp(aa[3][1], v2, ('STORE', (('STORE_NAME', '?'),), (('CONST', None),))) and \
       aa[4] == (')ENDTRY',) and v0[0] == v0[1] and v0[0] == v2[0]:
            this, d = None, None
            this, d = MyImport(v0[1])
            cmds[_i] = aa[1]
            if v0[0] in count_define_set and count_define_set[v0[0]] > 1:
                count_define_set[v0[0]] -= 1
    
def process_setup_except(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'xJUMP_IF2_TRUE_POP_CONTINUE', '*l', 'POP_BLOCK')):
        if type(pos__c) is tuple:
            rpl(cmds,[pos__a, [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)]+[pos__c],pos__d])
        else:    
            rpl(cmds,[pos__a, [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)]+pos__c,pos__d])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*', 'POP_BLOCK', 'JUMP', ('::', 0))) and pos__d[1] != pos__e[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__d[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'POP_BLOCK', 'JUMP', ('::', 0))) and pos__d[1] != pos__c[1]:
        rpl(cmds,[('(BEGIN_TRY',), [('PASS',)], (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__c[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'JUMP_CONTINUE', 'POP_BLOCK', 'JUMP_CONTINUE', \
                    (':', 0, 1))) and pos__b[1] == pos__d[1]:
        rpl(cmds,[('(BEGIN_TRY',), [('CONTINUE',)], (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'POP_BLOCK', 'JUMP_CONTINUE', \
                    (':', 0, 1))):
        rpl(cmds,[('(BEGIN_TRY',), [('CONTINUE',)], (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*', 'JUMP_CONTINUE', \
                    'POP_BLOCK', 'JUMP', ('::', 0))) and pos__e[1] != pos__f[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b + [('CONTINUE',)], (')END_BEGIN_TRY',), \
                       ('J_IF_NO_EXCEPT_IN_TRY', pos__e[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*n', 'JUMP', ('::', 0))) and pos__c[1] != pos__d[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__c[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*n', 'JUMP_CONTINUE', ('::', 0))) and pos__c[1] != pos__d[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b +[('CONTINUE',)], (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*n', 'JUMP_CONTINUE', 'POP_BLOCK',\
                    'JUMP_CONTINUE', (':', 0,1), '*e')):
        rpl(cmds,[('(BEGIN_TRY',), pos__b +[('CONTINUE',)], (')END_BEGIN_TRY',),pos__g])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*', 'POP_BLOCK', 'JUMP_CONTINUE', ('::', 0))) and pos__d[1] != pos__e[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__d[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*r', ('::', 0))):
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'JUMP_CONTINUE', 'POP_BLOCK',\
                    'JUMP_CONTINUE', (':', 0,1), '*e', \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and pos__b[1] == pos__d[1] == pos__g[1] == pos__i[1]:
        rpl(cmds,[concatenate_try_except([('CONTINUE',)],pos__f), pos__i])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'POP_BLOCK', 'JUMP_CONTINUE', (':', 0, 1),\
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and pos__c[1] == pos__f[1] == pos__h[1]:
        rpl(cmds,[concatenate_try_except([('PASS',)],pos__e), pos__h])
        return True    
    return False
    
def concatenate_try_except(bl1, exc_tail, else_tail = None):
    out = []
    out.append(('(TRY',))
    out.append(bl1)
    if exc_tail is None:
       if else_tail is not None: 
          out.append((')(ELSE',))
          out.append(else_tail)
       out.append((')ENDTRY',) )
       return out
    tail = exc_tail[:]
    while len(tail) > 0 and tail[0][0] == '.L':
        del tail[0]
    if tail[0][0] in ('(EXCEPT','(EXCEPT0','(EXCEPT1'):
        t1 = (')(EXCEPT',) + tail[0][1:]
        out.append(t1)
        return add_endtry(out, tail, bl1, exc_tail, else_tail)
    elif tail[0][0] == '(EXCEPT0':
        out.append((')(EXCEPT',))
        return add_endtry(out, tail, bl1, exc_tail, else_tail)
    Fatal('Error in exception sequence', bl1, exc_tail, else_tail)
    return '~'

def add_endtry(out, tail, bl1, exc_tail, else_tail):
    del tail[0]
    out.extend(tail[:-1])
    if tail[-1][0] != ')ENDEXCEPT':
        Fatal('Must be ENDEXCEPT', bl1, exc_tail, else_tail)
        return '%%'
    if else_tail is not None: 
        out.append((')(ELSE',))
        out.append(else_tail)
    out.append((')ENDTRY',))
    return out
    
def concatenate_except(cond, bl1, exc_tail):
    out = []
    out.append(('(EXCEPT',) + cond)
    out.append(bl1)
    if exc_tail is None:
       out.append((')ENDEXCEPT',) )
       return out
    tail = exc_tail[:]
    while len(tail) > 0 and tail[0][0] == '.L':
        del tail[0]
    if len(tail) == 0:
       out.append((')ENDEXCEPT',) )
       return out
    if tail[0][0] in ('(EXCEPT','(EXCEPT0','(EXCEPT1'):
        t1 = (')(EXCEPT',) + tail[0][1:]
        out.append(t1)
        del tail[0]
        out.extend(tail)
        return out
    elif tail[0][0] == '(EXCEPT0':
        t1 = (')(EXCEPT',)
        out.append(t1)
        del tail[0]
        out.extend(tail)
        return out
    Fatal('Error in concatenate except', filename)
    return '~'

def New_3Cmp(tupl):
    t = ('!NCMP', tuple(tupl[1:]))
    return ('!BOOLEAN', t)                 

def New_NCmp(tupl):
    t = ('!NCMP', tupl)
    return ('!BOOLEAN', t)                 

def isintconst(b):
    return type(b) is tuple and len(b) == 2 and b[0] == 'CONST' \
            and type(b[1]) is int

def rpl(cmds,new):
    global matched_tail_label
    if matched_tail_label is not None and (matched_tail_label[1] > 0 or matched_tail_label[3]):
        new = new + [matched_tail_label[2]]
    if type(new) is list:    
        if len(new) >= 2 and type(new[-1]) is tuple and type(new[-2]) is tuple and\
        len(new[-1]) == 2 and len(new[-2]) == 2 and new[-1][0] == '.:'  and new[-2][0] == '.:' and\
        new[-1][1] == new[-2][1]:
            Fatal("Dublicate label")
    cmds[matched_i:matched_i+matched_len] = new
    return 

def begin_cmp():
    global matched_i
    global matched_p
    global matched_len
    global matched_tail_label
    matched_i = -1
    matched_p = None
    matched_len = -1
    matched_tail_label = None

stats__ = {}
def SCmp(cmds,i0,pattern,recursive=False):
    global matched_i
    global matched_p
    global matched_len
    global matched_tail_label
    global used_cmpl, used_cmp, used_line, matched_cmpl, matched_cmp,matched_line,collect_stat,p2l
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    if type(cmds) is tuple:
        return False
    assert type(cmds) is list
    assert type(i0) is int
    ## if pattern not in stats__:
      ## stats__[pattern] = 1
    ## else:
      ## stats__[pattern] = stats__[pattern] + 1
    tempor = cmds[i0:i0+len(pattern)]
    if len(tempor) != len(pattern):
        return False
    for i,p in enumerate(pattern):
        assert type(tempor) is list
        if i >= len(tempor):
            return False
        tempi = tempor[i]
#        if type(tempi) is not int and type(p) is str and tempi[0] == p:
        if type(p) is str:
            if tempi[0] == p:
                continue
            if p[:9] == 'xJUMP_IF2':
                if p[1:] in anagr:
                    if tempi[0] == p[1:]:
                        continue
                    elif tempi[0] == anagr[p[1:]]:
                        tempi = list(tempi)
                        tempi[2] = Not(tempi[2])
                        tempi[0] = p[1:]
                        tempi = tempor[i] = tuple(tempi)
                        continue
                return False    
            if p == 'ju':
                if tempi[0] not in ('JUMP', 'JUMP_CONTINUE'):
                    return False
                continue
            elif p == 'jc':
                if tempi[0] not in ('JUMP', 'JUMP_CONTINUE') or not islooplabel(tempi[1],cmds):
                    return False
                continue
            elif p == '>':
                if type(tempi) is tuple and len(tempi) >= 1 and\
                (tempi[0] in ('CONST', 'FAST', 'LOAD_FAST', 'LOAD_CONST', 'LOAD_CLOSURE', 'PY_TYPE') or\
                    tempi[0][0] == '!'):
                        continue
                return False   
            elif p == '=':
                if tempi[0] in set_any:
                    continue
                return False
            elif p == '*':
                if type(tempi) is list and (len(tempi) > 1 or tempi[0][0] != '.L'):
                    continue
                return False
            elif p == '*r':
                if type(tempi) is list and tempi[-1][0] == 'RETURN_VALUE':
                    continue
                return False
            elif p == '*ra':
                if type(tempi) is list and tempi[-1][0] == 'RAISE_VARARGS':
                    continue
                return False
            elif p == '*c':
                if type(tempi) is list and tempi[-1][0] == 'CONTINUE':
                    continue
                return False
            elif p == '*l':
                if type(tempi) is list and len(tempi) == 1 and tempi[0][0] == '.L':
                    continue
                elif tempi[0] == '.L':    
                    continue
                return False  
            elif p == '*e':
                if not (type(tempi) is list):
                    return False
                if not isexceptblock(tempi):
                    return False
                continue
            elif p == '*n':
                if type(tempi) is list and (len(tempi) > 1 or tempi[0][0] != '.L'):
                    if tempi[-1][0] == 'RETURN_VALUE' or isexceptblock(tempi):
                        return False
                    continue
                return False
            elif p == '**n':
                if type(tempi) is list and (len(tempi) > 1 or tempi[0][0] != '.L'):
                    if tempi[-1][0] == 'RETURN_VALUE' or isexceptblock(tempi):
                        return False
                else:                
                    tempor[i:i+1] = [[('PASS',)], tempi]
                    tempor = tempor[0:len(pattern)]
                continue
        elif type(p) is tuple:
            if p[0] == '!':
                if len(tempi) == len(p)-1 and type(tempi) is list and SCmp(tempi,0, p[1:],True):
                    continue
                return False                
            elif p[0] == ':':
                if len(p) == 3:
                    if type(p[1]) is tuple:
                        for pp in p[1]:
                            if pp>= len(tempor) or not label(tempor[pp], tempi):
                                return False
                    elif p[1] is not None:
                        if p[1] >= len(tempor) or not label(tempor[p[1]], tempi):
                            return False
                    is_one = OneJumpCache(tempi[1],cmds)        
                    if p[2] == 1 and not is_one:
                        return False
                    if p[2] == 2 and is_one:
                        return False
            elif p[0] == '::':
                if len(p) == 2:
                    ltemp = 0
                    isjump = False
                    cnt_ju = None
                    if tempi[0] == '.:': 
                        if type(p[1]) is tuple:
                            ltemp = len(p[1])
                            for pp in p[1]:
                                if not label(cmds[i0+pp], tempi):
                                    return False
                        elif p[1] is not None:
                            ltemp = 1
                            if not label(cmds[i0+p[1]], tempi):
                                return False
                        cnt_ju = CountJumpCache(tempi[1],cmds)        
                        if cnt_ju == 0:
                            return False
                    elif tempi[0] in jump: 
                        isjump = True
                        if type(p[1]) is tuple:
                            ltemp = len(p[1])
                            for pp in p[1]:
                                if not endlabel(cmds[i0+pp], tempi):
                                    return False
                        elif p[1] is not None:
                            ltemp = 1
                            if not endlabel(cmds[i0+p[1]], tempi):
                                return False
                        cnt_ju = CountJumpCache(tempi[1],cmds)        
                        if cnt_ju == 0:
                            return False
                    else:
                        return False    
                    if i == len(pattern)-1:
                        if cnt_ju is None:
                            cnt_ju = CountJumpCache(tempi[1],cmds)        
                        matched_tail_label = (p, cnt_ju-ltemp, tempi, isjump)
            elif len(p) == 2:
                if len(tempi) < 2 or not (p[0] == tempi[0] and p[1] == tempi[1]):
                    return False
            continue
        if type(tempi) is int or tempi[0] != p:
            return False
    if not recursive:   
       matched_i = i0   
       matched_p = pattern
       matched_len = len(pattern)
##    if not recursive:
       tempor = tempor[0:min(len(pattern),12)]
       while len(tempor) < 12:
           tempor.append('^^') # ibo nefig
       pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l = tempor       
    return True    

def islineblock(a):
    if type(a) is list:
        if len(a) == 1 and a[0][0] == '.L':
            return True
    elif a[0] == '.L':
        return True    
    return False  

def isblock(a):
    if type(a) is list:
        if len(a) > 1:
            return True
        if a[0][0] == '.L':
            return False
        else:
            return True
    else:
        return False 

def isretblock(a):
    return type(a) is list and a[-1][0] == 'RETURN_VALUE'

def islooplabel(label,cmds):
    if type(label) is int and type(cmds) is list:
        for i in range(1, len(cmds)-1):
            v = cmds[i]
            if type(v) is tuple:
                assert type(v) is tuple
                if v[0] == '.:' and v[1] == label:
                    if cmds[i-1][0] == 'J_SETUP_LOOP_FOR' and cmds[i+1][0] == 'J_LOOP_VARS':
                        return True
                    if cmds[i-1][0] == 'J_SETUP_LOOP':
                        return True
    return False       

def isexceptblock(a):
    if type(a) is list:
        if a[-1][0] == ')ENDEXCEPT':
            if a[0][0] in ('(EXCEPT', '(EXCEPT0', '(EXCEPT1'):
                return True
            if a[0][0] == '.L' and a[1][0]  in ('(EXCEPT', '(EXCEPT0', '(EXCEPT1'):
                return True
    return False

def revert_conditional_jump_over_uncond_jump(cmds):
    i = 0
    while i < ( len(cmds) - 4):            
        a = cmds[i]
        if a[0][:8] == 'JUMP_IF_' and a[0][-4:] == '_POP':
            b,c, d = cmds[i+1], cmds[i+2], cmds[i+3]
            if b[0] == '.L' and c[0] in jump and d[0] == '.:' and a[1] == d[1]:
                if a[0] == 'JUMP_IF_FALSE_POP':
                    e = 'JUMP_IF_TRUE_POP'
                else:
                    e = 'JUMP_IF_FALSE_POP'
                oldlabel = a[1]    
                cmds[i:i+4] = [(e, c[1]),b,d] 
                del_if_unused_label(cmds, oldlabel)
                continue
            elif b[0] in jump and c[0] == '.:' and a[1] == c[1]:
                if a[0] == 'JUMP_IF_FALSE_POP':
                    e = 'JUMP_IF_TRUE_POP'
                else:
                    e = 'JUMP_IF_FALSE_POP'
                oldlabel = a[1]
                cmds[i:i+3] = [(e, b[1]),c] 
                del_if_unused_label(cmds, oldlabel)
                continue
        i = i + 1    
    
def del_dead_code(cmds):
    i = 0
    updated = False
    while i < (len(cmds) - 1):            
        cmd = cmds[i]
        if cmd[0] in jump:
            cmd2 = cmds[i+1]
            if cmd2[0] not in ('END_FINALLY', 'POP_BLOCK') and (type(cmd2[0]) != str or cmd2[0][0] != '.'):
                del cmds[i+1]
                updated = True
                continue
            elif cmd2[0] == '.L':
                del cmds[i+1]
                updated = True
                continue
            elif cmd2[0] == '.:' and cmd2[1] == cmd[1]:
                oldlabel = cmd[1]
                del cmds[i]
                del_if_unused_label(cmds, oldlabel)
                i = max(0, i-3)
                updated = True
                continue
        i = i + 1        
    i = 0
    while i < (len(cmds) - 1):            
        cmd = cmds[i]
        if cmd[0] == 'RETURN_VALUE' and \
        (type(cmds[i+1][0]) != str or cmds[i+1][0][0] != '.') and \
        cmds[i+1][0]  not in ('END_FINALLY', 'POP_BLOCK'):
            del cmds[i+1]
            updated = True
            continue
        elif cmd[0] == 'RETURN_VALUE' and cmds[i+1][0] == '.L':
            del cmds[i+1]
            updated = True
            continue
        i = i + 1    
    return updated

def set_conditional_jump_popped(cmds):
    i = 0    
    updated = False
##    print '10', cmds
    while i < (len(cmds) - 1):            
        cmd,b = cmds[i], cmds[i+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           oldlabel = cmd[1]
           if to_label[1][0] == 'POP_TOP':
               if to_label[2][0] == '.:':
                    cmds[i:i+2] = [(cmd[0] + '_POP', to_label[2][1])]
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, i-3)
                    updated = True
                    continue
               elif pos_to_label > i+2:
                    new_label = gen_new_label(cmds)
                    cmds.insert(pos_to_label+2, ('.:', new_label))              
                    cmds[i:i+2] = [(cmd[0] + '_POP', new_label)]
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, i-3)
                    updated = True
                    continue
               elif pos_to_label < i:
                    new_label = gen_new_label(cmds)
                    cmds[i:i+2] = [(cmd[0] + '_POP', new_label)]
                    cmds.insert(pos_to_label+2, ('.:', new_label))              
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, pos_to_label-3) ### 27 08 2010 erlier pos_label (name of func)
                    updated = True
                    continue
               else:
                    Fatal('/3', 'Unhandled', to_label, '???', pos_to_label)    
        i = i + 1        
    i = 0
##    print '11', cmds
    while i < (len(cmds) - 1):            
        cmd,b = cmds[i], cmds[i+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           oldlabel = cmd[1]
           if ( to_label[1][0] == 'JUMP_IF_FALSE_POP' and cmd[0] == 'JUMP_IF_FALSE') or\
              ( to_label[1][0] == 'JUMP_IF_TRUE_POP' and cmd[0] == 'JUMP_IF_TRUE'):
                cmds[i:i+2] = [(cmd[0] + '_POP', to_label[1][1])]
                del_if_unused_label(cmds, oldlabel)
                i = max(0, i-3)
                updated = True
                continue
        i = i + 1        

    i = 0
##    print '12', cmds
    while i < (len(cmds) - 1):            
        cmd,b = cmds[i], cmds[i+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           oldlabel = cmd[1]
           if len(to_label) >= 3 and to_label[2][0] == '.:' and \
             (( to_label[1][0] == 'JUMP_IF_FALSE_POP' and cmd[0] == 'JUMP_IF_TRUE') or\
              ( to_label[1][0] == 'JUMP_IF_TRUE_POP' and cmd[0] == 'JUMP_IF_FALSE')):
                cmds[i:i+2] = [(cmd[0] + '_POP', to_label[2][1])]
                del_if_unused_label(cmds, oldlabel)
                i = max(0, i-3)
                updated = True
                continue
        i = i + 1      
    i = 1
##    print '12-1', cmds
    while i < (len(cmds) - 1) and i > 0:            
        prev,cmd,b = cmds[i-1],cmds[i], cmds[i+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP' and prev[0] == 'LOAD_FAST'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           oldlabel = cmd[1]
           if ( to_label[1][0] == 'STORE_FAST' and \
               to_label[1][1] == prev[1]):
               if to_label[2][0] == '.:':
                    cmds[i:i+2] = [(cmd[0] + '_POP', to_label[2][1])]
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, i-3)
                    updated = True
                    continue
               elif pos_to_label > i+2:
                      new_label = gen_new_label(cmds)
                      cmds.insert(pos_to_label+2, ('.:', new_label))              
                      cmds[i:i+2] = [(cmd[0] + '_POP', new_label)]
                      del_if_unused_label(cmds, oldlabel)
                      i = max(0, i-3)
                      updated = True
                      continue
               elif pos_to_label < i:
                      new_label = gen_new_label(cmds)
                      cmds[i:i+2] = [(cmd[0] + '_POP', new_label)]
                      cmds.insert(pos_to_label+2, ('.:', new_label))              
                      del_if_unused_label(cmds, oldlabel)
                      i = max(0, pos_to_label-3)  
                      updated = True
                      continue
        i = i + 1        
##    print '15', cmds
    return updated

## def print_cmds2(cmds, skip):
    ## if not print_pycmd:
        ## return
    ## pprint(cmds, out, 4, 120)
    ## return None
    ## ## skip += 4
    ## ## for cmd in cmds:    
        ## ## if type(cmd) is list:
            ## ## print >>out, '{'
            ## ## print_cmds2(cmd, skip)
            ## ## print >>out, '}'
            ## ## continue
        ## ## if cmd[0] == '.L':
            ## ## print >>out, '                    .L', cmd[1]
        ## ## elif cmd[0] == '.:':
## ## #            decompile_fail = True            
            ## ## print >>out, '^^',' ' * skip, cmd, '      # ', len(ref_to_label(cmd[1], cmds))    
        ## ## elif is_cmdmem(cmd):    
## ## #            decompile_fail = True            
            ## ## print >>out, '^^', ' ' * skip, cmd   
        ## ## else:    
            ## ## pprint(cmd, out, skip, 120)
## ##            print >>out, ' ' * skip, cmd   

def print_cmds(cmds):
    if not print_pycmd:
        return
    print >>out, 'co_const:'
    pprint(consts_from_cmds(cmds),out)
##    skip = 0
    pprint(cmds, out, 4, 120)
    return None
    
    ## for cmd in cmds:        
        ## if type(cmd) is list:
            ## print  >>out, '{'
            ## print_cmds2(cmd, skip)
            ## print >>out, '}'
            ## continue
        ## if cmd[0] == '.L':
            ## print >>out, '^^','                    .L', cmd[1]
        ## elif cmd[0] == '.:':
            ## print >>out, '^^',' ' * skip, cmd, '      # ', len(ref_to_label(cmd[1], cmds))   
        ## elif cmd[0][0] == 'J':    
            ## print >>out, '^^',' ' * skip, cmd, '      # ', len(ref_to_label(cmd[1], cmds))    
        ## elif is_cmdmem(cmd):    
            ## print >>out, '^^', ' ' * skip, cmd   
        ## elif is_cmdmem(cmd):    
            ## print >>out, '^^', ' ' * skip, cmd   
        ## else:   
            ## pprint(cmd, out, skip, 120) 
## ##            print >>out, ' ' * skip, cmd   
 
## def ref_to_label(label, cmds):
    ## if type(cmds) is list and type(label) is int:
        ## return [i for i, x in enumerate(cmds) if type(x) is tuple and x[0][0] == 'J' and x[1] == label]
    ## else:
        ## Fatal('ref_to_label of tuple', label, cmds)
        ## return []

## def CntJump(label, cmds):
    ## if type(cmds) is list and type(label) is int:
        ## return len([x for x in cmds if type(x) is tuple and x[0][0] == 'J' and x[1] == label])
    ## else:
        ## Fatal('CntJump of tuple', label, cmds)
        ## return -1

## def OneJump(label, cmds):
    ## if type(cmds) is list and type(label) is int:
        ## return len([x for x in cmds if type(x) is tuple and x[0][0] == 'J' and x[1] == label]) == 1
    ## else:
        ## Fatal('OneJump of tuple', label, cmds)
        ## return False

cache_jumps = {}

def ClearJumpCache():
    cache_jumps.clear()
    
def CountJumpCache(label, cmds):
    if label in cache_jumps:
        return cache_jumps[label]
    if type(cmds) is list and type(label) is int:
        v = len([x for x in cmds if type(x) is tuple and x[0][0] == 'J' and x[1] == label])
        cache_jumps[label] = v
        return v
    else:
        Fatal('CntJump of tuple', label, cmds)
        return -1

def OneJumpCache(label, cmds):
    if label in cache_jumps:
        return cache_jumps[label] == 1
    if type(cmds) is list and type(label) is int:
        v = len([x for x in cmds if type(x) is tuple and x[0][0] == 'J' and x[1] == label])
        cache_jumps[label] = v
        return v == 1
    else:
        Fatal('OneJump of tuple', label, cmds)
        return False

def TupleFromArgs(args):
    if len(args) > 0 and args[0] in ('!BUILD_TUPLE', 'CONST'):
        return args
    if len([x for x in args if x[0] != 'CONST']) == 0:
        return ('CONST', tuple([x[1] for x in args]))
    return ('!BUILD_TUPLE', args)

def DictFromArgs(args):
    return ('!BUILD_MAP', args)    

def cmd2mem(cmd):
    cm = cmd[0]
    if cm == 'LOAD_CLOSURE':
        return ('LOAD_CLOSURE', cmd[1])
    if cm == 'LOAD_FAST':
        return ('FAST', cmd[1])
    if cm == 'LOAD_CONST':
        return ('CONST', cmd[1])
    if type(cmd) is tuple and type(cm) is str:
        if cm[0:1] == '!':
            return cmd
        if cm in ('CONST', 'FAST'):
            return cmd
        if cm == 'PY_TYPE':
            return cmd
    Fatal('Illegal cms2mem', cmd)
    return ()

def is_cmdmem(cmd):
    a = cmd[0]
    return a in ('CONST', 'FAST', 'LOAD_FAST', 'LOAD_CONST', 'LOAD_CLOSURE', 'PY_TYPE') \
        or (a is not None and a[0] == '!')

def del_if_unused_label(cmds, oldlabel):
##    print '/30', cmds
##    print oldlabel, sys.getrefcount(oldlabel)
    la = [x[1] for x in cmds if x[0][0] == 'J']
    if oldlabel not in la:
        i = 0
        while i < len(cmds):    
            assert type(i) is int        
            cmd = cmds[i]
            if cmd[0] == '.:' and cmd[1] == oldlabel:
                if i > 0 and cmds[i-1][0] in jump and i < (len(cmds) - 1) and cmds[i+1][0] == 'POP_TOP':
                  del cmds[i]
                  del cmds[i]
                  continue
                else:    
                  del cmds[i]
                if i > 0 and cmds[i][0] == '.L' and cmds[i-1][0] == '.L':
                    del cmds[i]
                    continue
                return
            i = i + 1 
##    print '/31', cmds
##    print oldlabel, sys.getrefcount(oldlabel)
            
def gen_new_label(cmds):
    return max( [x[1] for x in cmds if x[0] == '.:']) + 1

def after_label(cmds, label, n):
    for i in range(len(cmds)):            
        cmd = cmds[i]
        if type(cmd) is tuple and cmd[0] == '.:' and cmd[1] == label:
            return cmds[i:i+n], i
        
def pos_label(cmds, label):
    i = 0
    while i < len(cmds):    
        assert type(i) is int        
##        cmd = cmds[i]
        if cmds[i][0] == '.:' and cmds[i][1] == label:
            return i
        i = i + 1
        
def NoGoToGo(cmds):
##    print '/1', cmds
    while True:
        updated = False
        i = 0
        while i < (len(cmds) - 3):            
            if cmds[i][0] == 'JUMP_IF_TRUE' and cmds[i+1][0] == 'JUMP' and cmds[i+2][0] == '.:' and \
            cmds[i][1] == cmds[i+2][1] and cmds[i][1] != cmds[i+1][1]:
                ## if CountJumpCache(cmds[i][1], cmds) == 1: 
                        ## cmds[i:i+3] = [('JUMP_IF_FALSE', cmds[i+1][1])]
                ## else:      
                oldlabel = cmds[i+2][1]
##                print '/1', sys.getrefcount(oldlabel)
                cmds[i:i+3] = [('JUMP_IF_FALSE', cmds[i+1][1]), cmds[i+2]]
                del_if_unused_label(cmds, oldlabel)
                i = max(0, i-3)
                updated = True
                continue
            if cmds[i][0] == 'JUMP_IF_FALSE' and cmds[i+1][0] == 'JUMP' and cmds[i+2][0] == '.:' and \
            cmds[i][1] == cmds[i+2][1] and cmds[i][1] != cmds[i+1][1]:
                ## if CountJumpCache(cmds[i][1], cmds) == 1: 
                        ## cmds[i:i+3] = [('JUMP_IF_TRUE', cmds[i+1][1])]
                ## else:      
                oldlabel = cmds[i+2][1]
##                print '/2', sys.getrefcount(oldlabel)
                cmds[i:i+3] = [('JUMP_IF_TRUE', cmds[i+1][1]), cmds[i+2]]
                del_if_unused_label(cmds, oldlabel)
                i = max(0, i-3)
                updated = True
                continue
            i += 1        
##        print '/2', cmds
        i = 0
        while i < len(cmds)-1:
                assert type(i) is int
                a,b = cmds[i], cmds[i+1]
                if b[0] == '.:' and ((a[0] == 'JUMP_ABSOLUTE' or \
                                    a[0] in jump) and a[1] == b[1]):
                    oldlabel = a[1]
                    del cmds[i]
                    updated = True
                    del_if_unused_label(cmds, oldlabel)
                    continue
                i += 1
##        print '/3', cmds        
        crossjump = {}
        for i in range(len(cmds) - 1):
            a,b = cmds[i], cmds[i+1]
            if a[0] == '.:' and ((b[0] == 'JUMP_ABSOLUTE' or \
                                  b[0] in jump) and a[1] != b[1]):
                crossjump[a[1]] = b[1]
        loopes = {}
##        print '/4', cmds
        for i in range(len(cmds)):
            a = cmds[i]
            if a[0] in ('J_SETUP_LOOP', 'J_SETUP_LOOP_FOR') and a[1] in crossjump:
                loopes[a[1]] = i
        i = 0
##        print '/5', cmds
        while i < len(cmds):  
            assert type(i) is int 
            ## pre_cmd = ('',)
            ## if i > 0:
                ## pre_cmd = cmds[i-1]         
            cmd = cmds[i]
            if cmd[0][0] == 'J' and cmd[1] in crossjump: 
                if cmd[1] not in loopes or (cmd[1] in loopes and loopes[cmd[1]] > i):
                    oldlabel = cmd[1]
                    cmds[i] = (cmd[0], crossjump[cmd[1]]) + cmd[2:]
                    del_if_unused_label(cmds, oldlabel)
                    updated = True
                    continue
            i = i + 1
##        print '/6', cmds    
        if not updated:
##            print '/6.5', cmds
            updated = set_conditional_jump_popped(cmds)
##        print '/7', cmds    
        if not updated:
            updated = del_dead_code(cmds)    
##        print '/8', cmds    
        if not updated:
            return    
##        print '/9', cmds
 
def NoGoToReturn(cmds):
    ## crossjump = {}
    return None
    ## for i in range(len(cmds) - 1):
        ## a,b = cmds[i], cmds[i+1]
        ## if a[0] == '.:' and b[0] == 'RETURN_VALUE' and len(b) == 2:
            ## crossjump[a[1]] = b
        ## elif a[0] == '.:' and type(b) is list and len(b) == 1 and \
                ## b[0][0] == 'RETURN_VALUE' and len(b[0]) == 2:
            ## crossjump[a[1]] = b[0]
        ## elif a[0] == '.:' and type(b) is list and len(b) == 2 and \
                ## b[0][0] == '.L' and b[1][0] == 'RETURN_VALUE' and len(b[0]) == 2:
            ## crossjump[a[1]] = b[1]
    ## i = 0
    ## while i < len(cmds):   
        ## pre_cmd = ('',)
        ## if i > 0:
            ## pre_cmd = cmds[i-1]         
        ## cmd = cmds[i]
        ## if cmd[0] in jump and cmd[1] in crossjump: 
                ## oldlabel = cmd[1]
                ## cmds[i] = crossjump[cmd[1]]
                ## if type(cmds[i-1]) is list:
                    ## cmds[i-1] += [cmds[i]]
                    ## del cmds[i]    
                ## del_if_unused_label(cmds, oldlabel)
                ## continue
        ## i = i + 1

def consts_from_cmds(cmds):
    return dict.fromkeys([x[1] for x in cmds if x[0] == 'LOAD_CONST']).keys()

def walk(co, match=None):
    if match is None or co.co_name == match:
        dis(co)
    for obj in co.co_consts:
        if type(obj) is types.CodeType:
            walk(obj, match)

def Pynm2Cnm(filename):
    global c_name
    pair = os.path.split(filename)
    nmmodule = nmvar_to_loc(pair[1][:-3])
    if c_name is not None:
        outnm = c_name + '.c'    
    elif not build_executable:
        outnm = nmmodule + '.c'
    else:
        ## print filename, nmmodule, '.c'
        outnm = nmmodule + '.c'    
    outnm = os.path.join(pair[0], outnm)
    return outnm, nmmodule
    
def main():
    global out
    global out3
    global debug
#    global collect_stat
    global filename
    global TRUE
    global no_build
    global print_cline 
    global print_pyline
    global make_indent
    global direct_call
    global stat_func
    global Pass_Exit
    global flag_stat
    global opt_flag
    global start_sys_modules
    global hash_compile
    global hide_debug
    global dirty_iteritems
    global redefined_attribute
    global line_number
    global build_executable
    global no_generate_comment
    global c_name
    global calc_ref_total
    global recalc_refcnt
    global debug_tx
    global no_tx
    global no_cfunc
    global print_pycmd
    global inline_flag
    global print_tree_node
    global no_fastlocals
    global current_co
    TRUE = cmd2mem(('LOAD_CONST', True))
    c_name = None
 
    parser = OptionParser()
    parser.add_option("-e", "--build-executable", action="store_true", dest="build_executable", default=False, help="build executable (not extension module)")
    parser.add_option("", "--show-debug", action="store_false", dest="hide_debug", default=True, help="show compiler debug messages")
    parser.add_option("-S", "--show-statistic", action="store_true", dest="flag_stat", default=False, help="show compiler internal statistic")
    parser.add_option("", "--no-line-numbers", action="store_false", dest="line_number", default=True, help="supress line number code")
    parser.add_option("", "--no-generate-comments", action="store_true", dest="no_generate_comment", default=False, help="supress internal tree comment")
    parser.add_option("-c", "--no-compile", action="store_true", dest="no_build", default=False, help="only generate C-code, no compile")
    parser.add_option("-i", "--indent", action="store_true", dest="make_indent", default=False, help="run \'indent\' for generated C file")
    parser.add_option("-L", "--trace-py-line-numbers", action="store_true", dest="print_pyline", default=False, help="trace python line numbers")
    parser.add_option("-l", "--trace-c-line-numbers", action="store_true", dest="print_cline", default=False, help="trace C line numbers")
    parser.add_option("", "--no-direct-call", action="store_false", dest="direct_call", default=True, help="supress direct C call convenction")
    parser.add_option("-d", "--decompiler-debug", action="store_true", dest="debug", default=False, help="trace decompilation")
    parser.add_option("", "--decompiler-print", action="store_true", dest="print_pycmd", default=False, help="print decompilation psevdocode")
    parser.add_option("", "--optimiser-debug", action="store_true", dest="debug_tx", default=False, help="trace optimisation")
    parser.add_option("", "--no-optimiser", action="store_true", dest="no_tx", default=False, help="no text optimisation")
    parser.add_option("", "--inline-subst", action="store_true", dest="inline_flag", default=False, help="inline subst of small's def")
    parser.add_option("", "--not-use-fastlocals-array", action="store_true", dest="no_fastlocals", default=False, help="no faslocals array")
    parser.add_option("", "--print-tree-node", action="store_true", dest="print_tree_node", default=False, help="print all passed tree node")
    parser.add_option("-f", "--compiler-flag", action="store", type="string", dest="opt_flag")
    parser.add_option("-n", "--c-named-as", action="store", type="string", dest="c_name")
    parser.add_option("", "--no-cfunc", action="store_true", dest="no_cfunc", default=False, help="not generate cfunc")
    
    (options, argv) = parser.parse_args()
    
    debug = bool(options.debug)
    no_fastlocals = bool(options.no_fastlocals)
    print_pycmd = bool(options.print_pycmd)
    build_executable = bool(options.build_executable)
    hide_debug = bool(options.hide_debug)
    flag_stat = bool(options.flag_stat)
    line_number = bool(options.line_number)
    no_generate_comment = bool(options.no_generate_comment)
    no_build = bool(options.no_build)
    make_indent = bool(options.make_indent)
    print_pyline = bool(options.print_pyline)
    print_cline = bool(options.print_cline)
    direct_call = bool(options.direct_call)
    debug_tx = bool(options.debug_tx)
    no_tx = bool(options.no_tx)
    no_cfunc = bool(options.no_cfunc)
    opt_flag = options.opt_flag
    if opt_flag is None:
        opt_flag = ''
    if len(opt_flag) > 0:
        if ' ' in opt_flag:
            opt_flag = opt_flag.split()
        else:
            opt_flag = [opt_flag]
    else:
        opt_flag = []        
    inline_flag = bool(options.inline_flag)
    print_tree_node = bool(options.print_tree_node)
    debug = options.debug
    c_name = options.c_name
    ## codename = None
    if calc_ref_total and "gettotalrefcount" not in sys.__dict__:
        calc_ref_total = False
        Debug('Can\'t generate "calc_ref_total" code for not Py_REF_DEBUG python')
    if recalc_refcnt and "gettotalrefcount" not in sys.__dict__:
        recalc_refcnt = False
        Debug('Can\'t generate "recalc_refcnt" code for not Py_REF_DEBUG python')
        
    if len(argv) == 0:
        exit(1)
    filenames = argv[0:]
    listf1 = []
    for filename in filenames:    
        listf = glob.glob(filename)
        listf1.extend(listf)
    listf = listf1 
    if len(listf) == 0:
        print ('Files not found')
        exit(1)
    start_sys_modules = sys.modules.copy()   
    for filename in listf:          
        clear_one_file()
        compilable = True
        if filename.endswith('.py') or filename.endswith('.PY'):
            print ('Compile ' + filename)
            buf = open(filename).read()
            redefined_attribute =  ( '__slots__' in buf or '__get__' in buf or \
                                    '__set__' in buf or '__delete__' in buf or \
                                    '__getattribute__' in buf or \
                                    '__delattr__' in buf or '__getattr__' in buf or \
                                    '__delattr__' in buf )\
                                        and filename != '2c.py'
            if print_pycmd:                            
                outnm = filename[:-3] + '.pycmd'
                out = open(outnm, 'w')
            else:
                out = None    
            outnm, nmmodule = Pynm2Cnm(filename)
            out3 = open(outnm, 'w')
            is_compile = True
            hash_compile = hash(buf) 
            try:
                co = compile(buf, filename, "exec")
            except SyntaxError:
                buf = buf.replace('\r\n', '\n')
                is_compile = False
            if not is_compile:    
                try:
                    co = compile(buf, filename, "exec")
                except:
                    print ('Error in ' + filename)
                    compilable = False
            if compilable:   
                if co.co_flags & 0x10000 and not 'print' in d_built:
                    b = __import__('__builtin__')
                    d_built['print'] = b.__dict__["print"]
                    b = None
                else:
                    if 'print' in d_built:
                        del d_built['print']    
                SetPass('DisAssemble') 
                walk(co)
                
                post_disassemble() 
                clear_one_file()
                co = None
                current_co = None
                if out is not None:
                    out.close()
                if out3 is not None:    
                    out3.close() 
    link_c()    
    co = compile('print 1\n', 'test.py', "exec")
    clear_after_all_files()
    co = None
    current_co = None  
        
def And_j_s(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', And_bool(a,b))
    if b[0] == '!AND_JUMPED_STACKED':
        return ('!AND_JUMPED_STACKED', a) + b[1:]
    if a[0] == '!AND_JUMPED_STACKED':
        return a + (b,)
    return ('!AND_JUMPED_STACKED', a,b)
        
def Or_j_s(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', Or_bool(a,b))
    if b[0] == '!OR_JUMPED_STACKED':
        return ('!OR_JUMPED_STACKED', a) + b[1:]
    if a[0] == '!OR_JUMPED_STACKED':
        return a + (b,)
    return ('!OR_JUMPED_STACKED', a,b)

def And_j(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', And_bool(a,b))
    if b[0] == '!AND_JUMP' == a[0]:
        return  a + b[1:]
    if b[0] == '!AND_JUMP':
        return ('!AND_JUMP', a) + b[1:]
    if a[0] == '!AND_JUMP':
        return a + (b,)
    return ('!AND_JUMP', a,b)

def And_bool(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if b[1][0] == '!AND_BOOLEAN' == a[1][0]:
        return  a[1] + b[1][1:]
    if b[1][0] == '!AND_BOOLEAN':
        return ('!AND_BOOLEAN', a) + b[1][1:]
    if a[1][0] == '!AND_BOOLEAN':
        return a[1] + (b,)
    return ('!AND_BOOLEAN', a,b)

def Or_j(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', Or_bool(a,b))
    if b[0] == '!OR_JUMP' == a[0]:
        return  a + b[1:]
    if b[0] == '!OR_JUMP':
        return ('!OR_JUMP', a) + b[1:]
    if a[0] == '!OR_JUMP':
        return a + (b,)
    return ('!OR_JUMP', a,b)

def Or_bool(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if b[1][0] == '!OR_BOOLEAN' == a[1][0]:
        return  a[1] + b[1][1:]
    if b[1][0] == '!OR_BOOLEAN':
        return ('!OR_BOOLEAN', a) + b[1][1:]
    if a[1][0] == '!OR_BOOLEAN':
        return a[1] + (b,)
    return ('!OR_BOOLEAN', a,b)
        
def Not(b):    
    if b[0] == '!1NOT':
        return b[1]
    return ('!1NOT', b)

def formire_call(t):
    if '(' in t[2] and ')' in t[2]:
        if t[2][-1] == ')':
            t = list(t)
            i = t[2].index('(')
            t[2] = t[2][0:-1]
            i = t[2].index('(')
            t[2:3] = [t[2][:i], '(', t[2][i+1:]]
            t = tuple(t) + (')',)   
    elif t[2][-1] != ')':        
        if t[2][-1] == '(':
            t = list(t)
            t[2] = t[2][0:-1]
            t = tuple(t)   
        t = list(t)      
        t[2:3] = [t[2], '(']
        i = 4
        while i < len(t)-1:
            assert type(i) is int
            if t[i+1] != ',':
                t[i:i+1] = [t[i], ',']
            i += 2
        t = tuple(t) + (')',)
    return t    

def Cls1(o, v):
    if istempref(v):
        clearref(o, v)
    elif istemptyped(v):
        clear_typed(v)

class Out(list):
    def print_to(self, s):
        self.append(s)
    def append_cline(self):
        if print_cline :
            self.append('if (PyErr_Occurred()) {printf (\"ERROR %s\\n\",PyObject_REPR(PyErr_Occurred()));}')
            self.append('printf (\"cline %d\\n\", __LINE__);')
    def Cls(self, *vv):
        for v in vv:
            if istempref(v):
                clearref(self, v)
            elif istemptyped(v):
                clear_typed(v)
            else:
                pass
    def ZeroTemp(self, g):
        if istempref(g):
            self.Raw(g, ' = 0;')
            if len(self) > 1 and self[-1] == self[-2]:
                del self[-1]

    def CLEAR(self, ref): 
        assert istempref(ref) or ref.startswith('temp[') or ref.startswith('GETLOCAL(') or ref.startswith('GETFREEVAR(')    
        self.append('Py_CLEAR(' + CVar(ref) + ');')

    def INCREF(self, ref): 
##        assert istempref(ref)       
        self.append('Py_INCREF(' + CVar(ref) + ');')
    def DECREF(self, ref): 
##        assert istempref(ref)       
        self.append('Py_DECREF(' + CVar(ref) + ');')
    def XINCREF(self, ref): 
##        assert istempref(ref)       
        self.append('Py_XINCREF(' + CVar(ref) + ');')
        
    def ClsFict(self, v):
        if istempref(v):
            clearref(self, v, True)
        elif istemptyped(v):
            clear_typed(v)
        else:
            pass
    def Comment(self, it):
        if no_generate_comment:
            return None
        if not isinstance(it, types.StringTypes):
##def pformat(object, indent=1, width=80, depth=None):
            s = PrettyPrinter(indent=2, width=144).pformat(it)
##            s = pformat(it, 2, 144)
            if '/*' in s:
                s = s.replace('/*', '/?*')
            if '*/' in s:
                s = s.replace('*/', '*?/')
            ls = list(s.split('\n'))
            if ls[-1] == '':
                del ls[-1]
            self.append('')
            for iit in ls:
                self.append('/* ' + iit + ' */')
                
    def check_err(self, t0, eq):
        if eq == 'NULL':
            eq = '0'
        self.Raw('if (', t0, ' == ', eq, ') goto ', labl, ';')
        ## add2 = ('if (', t0, '==', eq, ') goto', labl)
        UseLabl()
        ## s = do_str(add2)
        ## self.append(s)

    def PushInt(self, t, i):
        assert istempref(t)
##        self.Raw('PushInt ', t[1], ' ', i)
        self.Raw(t, ' = PyInt_FromLong ( ', i, ' );')
##        self.Raw('if ((', t, ' = PyInt_FromLong ( ', i, ' )) == 0) goto ', labl, ';')
##        UseLabl()

    def PushFloat(self, t, i):
        assert istempref(t)
##        self.Raw('PushInt ', t[1], ' ', i)
        self.Raw(t, ' = PyFloat_FromDouble ( ', i, ' );')
##        self.Raw('if ((', t, ' = PyInt_FromLong ( ', i, ' )) == 0) goto ', labl, ';')
##        UseLabl()

    def Raw(self, *t):
        self.append(''.join([CVar(x) for x in t]))

#        for it in t:
#            s += CVar(it)
#        self.append(s)
                
    def Stmt(self, *t):
        ## if len(t) == 1 and t[0] == '':
            ## self.append('')
            ## return
        if len(t) == 2 and t[0] == 'CLEARREF' and istempref(t[1]):
            self.append('CLEARTEMP('+str(t[1][1]) + ');')
            return
        elif len(t) == 3 and type(t[0]) is tuple and t[1] == '='and IsCalcConst(t[0]):
            self.append(do_str(t))
            self.append_cline()
            return            
        elif t[0] in CFuncVoid:
            if t[0] == 'SETLOCAL' and t[1] not in current_co.used_fastlocals:
                current_co.used_fastlocals[t[1]] = True
                if current_co.list_compr_in_progress == False:
                    self.Stmt('LETLOCAL', t[1], t[2])
                    return
            Used(t[0])
            t2 = [t[0], '(']
            for v in t[1:]:
                t2.append(v)
                t2.append(',')
            if len(t) == 1:
                t2.append(')')  
            else:      
                t2[-1] = ')'
            self.append(do_str(tuple([CVar(x) for x in t2])))
            self.append_cline()
            return

        elif t[0] in CFuncIntCheck:
            Used(t[0])
            t2 = mk_t2(t)
            t2.append(') == -1) goto ' + CVar(labl))
            UseLabl()
            self.append(do_str(t2))
            self.append_cline()
            return
        elif t[0] in CFuncIntAndErrCheck:
            Used(t[0])
            t2 = mk_t2(t)
            t2.append(') == -1 && PyErr_Occurred()) goto ' + CVar(labl))
            UseLabl()
            self.append(do_str(t2))
            self.append_cline()
            return
        elif t[0] in CFuncPyObjectRef:
            Used(t[0])
            t2 = mk_t2(t)
            assert labl is not None
            t2.append(') == 0) goto ' + CVar(labl))
            UseLabl()
            self.append(do_str(t2))
            self.append_cline()
            return
        elif len(t) >= 3 and t[1] == '=' and t[0] != 'f->f_lineno' and \
               (type(t[2]) != int and type(t[2]) != long and (type(t[2]) != tuple or t[2][0] != 'CONST')):
            if len(t) == 5 and t[3] in ('==', '!='):       
                self.append(do_str(t))
                self.append_cline()
                return
            if len(t) == 3 and t[2][0] == 'FAST' and t[0][0] == 'PY_TEMP':
                self.append(do_str(t))
                self.append_cline()
                return
            if len(t) == 4 and t[2][0] == '!' and t[0][0] == 'TYPED_TEMP' and t[3][0] == 'TYPED_TEMP':
                self.append(do_str(t))
                self.append_cline()
                return
            if istemptyped(t[2]) and istemptyped(t[0]):
                self.append(do_str(t))
                self.append_cline()
                return    
            if istempref(t[0]) and t[2] in ('Py_True', 'Py_False'):
                self.append(do_str(t))
                self.append_cline()
                return    
            if type(t[2]) is str and t[2].endswith('(glob,'):
                t = list(t)
                t[2:3] = [t[2][:-6], 'glob']
                t = tuple(t)
            t = formire_call(t)
            if t[2] in CFuncNoCheck:
                Used(t[2])
                assign_py = t[0][0] == 'PY_TEMP'                
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_py:
                    if t[2] not in ( 'PyIter_Next', 'Py_INCREF'):
                       Fatal(t, '???', t[2], 'Py_INCREF(' + t[0] + ');')
                elif t[2] not in CFuncIntNotCheck and t[2] not in CFuncFloatNotCheck \
                     and t[2] not in CFuncLongNotCheck:    
                    Fatal(t)
                return                   

            if t[2] in CFuncPyObjectRef:
                Used(t[2])
                assign_py = type(t[0]) is tuple and \
                    (t[0][0] == 'PY_TEMP' or t[0][:9] == 'GETLOCAL(')
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_py:
                    ### COND_METH STRANGE
                    if self[-1].startswith(ConC(t[0], ' = ')) and self[-1].endswith(';'):
                        s0 = '(' + self[-1][:-1] + ')'
                        del self[-1]
                        self.check_err(s0, 'NULL')
                    else:    
                        self.check_err(t[0], 'NULL')
                    if t[2] in CFuncNeedINCREF:
                        self.append('Py_INCREF(' + t[0] + ');')
                    elif not t[2] in CFuncNotNeedINCREF:
                        Debug('INCREF?', t)
                        self.append('Py_INCREF(' + t[0] + ');')
                    if checkmaxref != 0 and not is_pypy:
                        self.append('if ((' + t[0] + ')->ob_refcnt > ' + str(checkmaxref) + ') printf("line %5d, refcnt %6d \\n", __LINE__,(' + t[0] + ')->ob_refcnt);')
                else:    
                    Fatal(t)
                return                   
            if t[2] in set_IntCheck: #CFuncIntCheck or t[2] in CFuncLongCheck:
                Used(t[2])
                assign_temp = t[0][0] == 'TYPED_TEMP'   
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_temp:
                    if self[-1].startswith(ConC(t[0], ' = ')) and self[-1].endswith(';'):
                        s0 = '(' + self[-1][:-1] + ')'
                        del self[-1]
                        self.check_err(s0, '-1' if t[2] not in CFuncIntAndErrCheck else '-1 && PyErr_Occurred()')
                    else:    
                        self.check_err(t[0], '-1' if t[2] not in CFuncIntAndErrCheck else '-1 && PyErr_Occurred()')
#                    self.check_err(t[0], '-1' if t[2] not in CFuncIntAndErrCheck else '-1 && PyErr_Occurred()')
                else:    
                    Fatal(t)
                return     
            elif type(t[2]) is str and t[2].startswith('_Direct_'):
                assign_py = type(t[0]) is tuple and \
                    (t[0][0] == 'PY_TEMP' or t[0][:9] == 'GETLOCAL(')
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_py:
                    if self[-1].startswith(ConC(t[0], ' = ')) and self[-1].endswith(';'):
                        s0 = '(' + self[-1][:-1] + ')'
                        del self[-1]
                        self.check_err(s0, 'NULL')
                    else:    
                        self.check_err(t[0], 'NULL')
                    if checkmaxref != 0 and not is_pypy:
                        self.append('if ((' + t[0] + ')->ob_refcnt > ' + str(checkmaxref) + ') printf("line %5d, refcnt %6d \\n", __LINE__,(' + t[0] + ')->ob_refcnt);')
                else:    
                    Fatal(t)
                return                   
            Fatal('Call undefined C-function', t[2], t)
        elif t[0] in ( '}', '{', 'if'):
            pass
        elif maybe_call(t[0]):
            t = list(t)      
            t[0:1] = [t[0], '(']
            i = 2
            while i < len(t)-1:
                assert type(i) is int
                if t[i+1] != ',':
                   t[i:i+1] = [t[i], ',']
                i += 2
            t = tuple(t) + (')',)
            Used(t[0])
            if t[0] not in CFuncVoid:
                Fatal('Call undefined C-function', t[0],t)
        self.append(do_str(t))

def TextMatch(s, p, v):
    for i, p2 in enumerate(p):
        if p2 == '*':
            if i == len(p) - 1:
                v.append(s)
                return True
            else:
                ind = s.find(p[i+1])  
                if ind == -1:
                    return False  
                v.append(s[:ind])
                s = s[ind:]
        else:
            if s.startswith(p2):
                s = s[len(p2):]
            else:
                return False    
    if len(s) != 0:
        return False
    return True

Tx_compiled = {}
Tx_pre_compiled = {}
Tx_fast = {}
Tx_len_match = 0
Tx_pos_match = 0
Tx_pattern = None
Tx_cnt = {}

def TxMatch(o, pos_z, p2_, li, debug = False):
    global Tx_cnt
    if p2_ in Tx_cnt:
        Tx_cnt[p2_] += 1
    else:
        Tx_cnt[p2_] = 1
    if type(pos_z) is int and type(o) is Out and type(li) is list:
        pos = pos_z
        if p2_ in Tx_fast and not o[pos].startswith(Tx_fast[p2_]):
            return False    
        if type(p2_) is str:
            if p2_ not in Tx_pre_compiled:
                p2 = TxPreCompile(p2_)
                Tx_pre_compiled[p2_] = p2
            else:
                p2 = Tx_pre_compiled[p2_]
        else:
            p2 = p2_                        
        if p2 not in Tx_compiled:
            Tx_compiled[p2] = TxCompile(p2)
            if type(Tx_compiled[p2][0][0]) is str:
                Tx_fast[p2] = Tx_compiled[p2][0][0]
                if p2 != p2_:
                    Tx_fast[p2_] = Tx_compiled[p2][0][0]
        if pos >= len(o):
            return False
        o1 = o[pos]
        assert type(o1) is str
        if (o1 == '' or o1.startswith('/*') or\
                        o1.startswith('PyLine = ') or\
                        o1.startswith('PyAddr = ') or\
                        o1.startswith('f->f_lineno = ') or\
                        o1.startswith('f->f_lasti = ')):
            return False
        li[:] = (None, None, None, None, None, None, None, None, None, None, \
                None, None, None, None, None, None, None, None, None, None) * 5
##        pprint(Tx_compiled[p2])
##        pprint(o)
        pos_i = TxBaseMatch(pos, Tx_compiled[p2], o, li, debug)
##        print li[:10]
        if pos_i > 0:
            global Tx_len_match, Tx_pattern, Tx_pos_match
            Tx_len_match = pos_i - pos
            Tx_pattern = p2
            Tx_pos_match = pos
            return True
    return False

def TxBaseMatch(pos_i, patt, o, li, debug):
    i = 0
    if type(o) is Out and type(patt) is tuple and type(pos_i) is int and type(li) is list and type(debug) is bool:
        while i < len(patt):
            assert type(i) is int
            assert type(pos_i) is int
            while pos_i < len(o) and \
                (o[pos_i] == '' or \
                o[pos_i].startswith('/*') or\
                o[pos_i].startswith('PyLine = ') or\
                o[pos_i].startswith('PyAddr = ') or\
                o[pos_i].startswith('f->f_lineno = ') or\
                o[pos_i].startswith('f->f_lasti = ')):
                pos_i += 1
            if pos_i >= len(o):
                return -1
            p = patt[i]
            if type(p) is tuple:
    ##            print p, i
                if TxMatch__(o[pos_i], p, li, debug):
                    if debug:
                        print ('/ %d success' % i, o[pos_i], p, li)
                    pos_i += 1
                    if i == len(patt) - 1:
                        return pos_i
                    elif pos_i >= len(o):
                        return -1
                    i += 1
                    continue
                if debug:
                    print ('/ %d fail' % i, o[pos_i], p, li)
                return -1        
            if type(p) is int:
                if 60 > p >= 30 and li[p] is None:
                    i2 = pos_i
                    success = False
                    while i2 < len(o):
                        if o[i2].startswith('/*') or\
                        o[i2].startswith('PyLine = ') or\
                        o[i2].startswith('PyAddr = ') or\
                        o[i2].startswith('f->f_lineno = ') or\
                        o[i2].startswith('f->f_lasti = '):
                            return -1
    ##                    print p, i, i+1, patt[i+1]
    ##                    pprint(patt)
                        if type(patt[i+1]) is tuple and o[i2].startswith(patt[i+1][0]) :
                            li2 = li[:]
                            if TxMatch__(o[i2], patt[i+1], li2, False):
                                li[:] = li2
                                if debug:
                                    print ('/ %d success' % i, o[pos_i:i2], p, li)
                                li[p] = o[pos_i:i2]
                                pos_i = i2
                                success = True
                                i += 1
                                break
                            if debug:
                                print ('/ %d fail' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                            return -1        
                        elif  '{' in o[i2] or '}' in o[i2]:
                            if debug:
                                pprint(patt)
                                pprint(o[i2])
                                print (i+1)
                                print ('/ %d fail 93' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                            return -1
    
    ##***
                        i2 += 1
                    if success == False:                    
                        if debug:
                            print ('/ %d fail 0' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                        return -1
                    else:
                        continue
                elif 90 > p >= 60 and li[p] is None:
                    i2 = pos_i
                    success = False
                    ## print 'i2', i2
                    while i2 < len(o):
                        ## print 'i2-0', i2
                        if o[i2].startswith('/*') or\
                        o[i2].startswith('PyLine = ') or\
                        o[i2].startswith('PyAddr = ') or\
                        o[i2].startswith('f->f_lineno = ') or\
                        o[i2].startswith('f->f_lasti = '):
                            return -1
    ## ##                    print p, i, i+1, patt[i+1]
    ## ##                    pprint(patt)
                        ## print 'i2=', i2, 'i=', i, 'o[i2]=', o[i2], 'patt[i+1]=', patt[i+1]
                        if i + 1 == len(patt):
                            s3 = o[i2]
                            if not (s3.startswith('CLEARTEMP(') or\
                                    s3.startswith('Py_CLEAR(temp[') or\
                                    ( s3.startswith('temp[') and \
                                    s3.endswith('] = 0;'))):
                                if debug:
                                    print ('/ %d success' % i, o[pos_i:i2], p, li)
                                li[p] = o[pos_i:i2]
                                pos_i = i2                         
                                success = True
                                i += 1
                                break
                        elif type(patt[i+1]) is tuple and o[i2].startswith(patt[i+1][0]) :
                            li2 = li[:]
                            ## print 'li2'
                            if TxMatch__(o[i2], patt[i+1], li2, False):
                                li[:] = li2
                                if debug:
                                    print ('/ %d success' % i, o[pos_i:i2], p, li)
                                li[p] = o[pos_i:i2]
                                pos_i = i2
                                for s3 in o[pos_i:i2]:
                                    if not (s3.startswith('CLEARTEMP(') or\
                                        s3.startswith('Py_CLEAR(temp[') or\
                                        ( s3.startswith('temp[') and \
                                        s3.endswith('] = 0;'))):
                                        if debug:
                                            print ('/ %d fail 1 ' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                                        return -1                               
                                success = True
                                i += 1
                                break
                            if debug:
                                print ('/ %d fail' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                            return -1  
                        elif  '{' in o[i2] or '}' in o[i2]:
                            if debug:
                                pprint(patt)
                                pprint(o[i2])
                                print (i+1)
                                print ('/ %d fail 9' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                            return -1
    ##***
                        i2 += 1
                        ## print 'i2+', i2
                    if success == False:                    
                        if debug:
                            print ('/ %d fail 5' % i, o[pos_i:i2], o[i2], patt[i+1], li)
                        return -1
                    else:
                        continue
    
                elif 60 > p >= 30 and li[p] is not None:
                    if li[p] == o[pos_i:pos_i+len(li[p])]:
                        pos_i += len(li[p])
                        i += 1
                        continue
                print (p, i)
                pprint(patt)
                assert False
    else:
        Fatal('massaraksh')
        return 0
    return pos_i
                
debug_tx = False
def TxRepl(o, pos, p2, li, used = None):
    global debug_tx
    global Tx_pos_match
    pos = Tx_pos_match
    if p2 not in Tx_compiled:
        Tx_compiled[p2] = TxCompile(TxPreCompile(p2))
    new = []
    for p in Tx_compiled[p2]:
        if type(p) is int:
            new.extend(li[p])
        else:
            new.append(TxRepl__(p, li))
##    new = [TxRepl__(p, li) for p in Tx_compiled[p2]]
    print_patterns = True
    if debug_tx:
        print ('')
        print ('')
        print (' === BEFORE ' + pos)
        for v in o[max(pos-2, 0):pos]:
            print '  ', v
        for v in o[pos:pos+Tx_len_match]:
            print '>>', v
        for v in o[pos+Tx_len_match:min(pos+Tx_len_match +2, len(o) - 1)]:
            print '  ', v
        if print_patterns:    
            print    
            print '    === Apply:'
            for v in Tx_pattern:
                print '??', v        
            print    
            print '    === Replace:'
            if type(p2) is tuple:
                for v in p2:
                    print '!!', v   
            elif type(p2) is str:
                for v in p2.split('\n'):
                    v = v.strip()
                    if v != '':
                        print '!!', v.strip()   
            print            
            print '    === Memo:'  
            di = dict([(i, li1) for i,li1 in enumerate(li) if li1 is not None])      
            pprint(di)     
        print
        print '    === After', pos 
    if o[pos:pos+Tx_len_match] == new:
        Fatal ('Cycle modification', new)
    o[pos:pos+Tx_len_match] = new
    if debug_tx:
        for v in o[max(pos-2, 0):pos]:
            print '  ', v
        for v in o[pos:pos+len(new)]:
            print '<<', v
        for v in o[pos+len(new):min(pos+len(new) +2, len(o) - 1)]:
            print '  ', v
    if used is not None:
        for x in used:
            Used(x)
            
def TxPreCompile(tupl):
    if type(tupl) is str:
        ## tupl0 = tupl
        tupl = tupl.strip()
        tupl = tupl.splitlines()
        tupl = [t.strip() for t in tupl if t.strip() != '']
        tupl = [t.replace('\r', '') for t in tupl]
        tupl = [t.replace('\n', '') for t in tupl]
        tupl = [t.strip() for t in tupl if t.strip() != '']
        tupl = [t.strip() for t in tupl if t.strip() != '']
        tupl = tuple(tupl)
    return tupl
        
def TxCompile(tupl):
    compiled = []
    for p in tupl:
        assert type(p) is str
        if len(p) > 0 and p[0] == '>' and len(p) >= 2 and len(p) <= 3:
            compiled.append(int(p[1:]) + 30)
        elif len(p) > 0 and p[0] == '<' and len(p) >= 2 and len(p) <= 3:
            compiled.append(int(p[1:]) + 60)
        else:
            p = p.replace('$', '`$').split('`')
            s3 = []
            if len(p[0]) == 0:
                p = p[1:]
            for _s in p:
                if _s[0] == '$': 
                    assert len(_s) >= 2
                    if _s[1] == '1' and len(_s) > 2 and _s[2] >= '0' and _s[2] <= '9':
                        s3.append(int(_s[1] + _s[2]))
                        if len(_s) > 3:
                            s3.append(_s[3:])
                    else:    
                        s3.append(int(_s[1]))
                        if len(_s) > 2:
                            s3.append(_s[2:])
                else:       
                    s3.append(_s)
            compiled.append(tuple(s3))
    return tuple(compiled)            

def TxMatch__(s, p, li, debug = False):
    if type(s) is str and type(li) is list and type(p) is tuple and type(debug) is bool:
        for i, p2 in enumerate(p):
            assert type(s) is str
            if type(p2) is int:
                if li[p2] == None:
                    if i == len(p) - 1:
                        li[p2] = s
                        return True
                    else:
                        p3 = p[i+1]
                        if type(p3) is str:
                            ind = s.find(p3)  
                            assert type(ind) is int
                            if ind == -1:
                                if debug:
                                    print p3 , 'not found'
                                return False  
                            ## assert type(s) is str
                            li[p2] = s[:ind]
                            s = s[ind:]
                        else:
                            Fatal('not str', p3)
                            return False
                else:
                    p2 = li[p2]
            if type(p2) is str:
                if s.startswith(p2):
                    s = s[len(p2):]
                else:
                    if debug:
                        print 'not started with2', p2, ':::', p                      
                    return False   
        if len(s) != 0:
            return False
        assert len(s) == 0
        return True
    else:
        Fatal('strange types')
    return False

def TxRepl__(p, li):
    s = ''
##    pprint(p)
##    print li[:10]
    for p2 in p:
##        print repr(s), repr(p2)
        if type(p2) is int:
##            print li[p2]
            s += li[p2]
        else:
            s += p2    
    return s

def repl_sk_typed_loc(s, beg, replbeg): 
    assert type(s) is str
    l1, l2 = s.split(beg, 1) 
    if ')' not in l2:
        return s 
    l2, l3 = l2.split(')', 1)
    if ''.join(l2.split('_')).isalnum():
        return l1 + replbeg + l2 + l3 
    return s 
  
no_tx = False
no_cfunc = False
def optimize(o):
    global current_co, debug_tx
##    t1 = time.clock()
    global no_tx
    if no_tx:
        return
    assert type(o) is Out
    i = 0
    while i < len(o) - 1:
        assert type(i) is int
##        print 'ReStart optimise', i, current_co.co_name
        for i in range(max(i - 200, 0), len(o)):    
            v2 = []
            ## v3 = []
    #        prev_i = int(i)
            ## if TxMatch(o, i, (), v2, True):
                    ## TxRepl(o, i, (), v2)
                    ## break
            oi = o[i]
            assert type(oi) is str
            oiold = oi
            if '(Loc_' in oi:
                if '((Loc_' in oi:
                    oi = repl_sk_typed_loc(oi, '((Loc_', '(Loc_') 
                if '( (Loc_' in oi:
                    oi = repl_sk_typed_loc(oi, '( (Loc_', '( Loc_') 
                if ')(Loc_' in oi:
                    oi = repl_sk_typed_loc(oi, ')(Loc_', ')Loc_') 
                if '!(Loc_' in oi:
                    oi = repl_sk_typed_loc(oi, '!(Loc_', '!Loc_') 
                if '= (Loc_' in oi:
                    oi = repl_sk_typed_loc(oi, '= (Loc_', '= Loc_') 
                if oi is not oiold:
                    o[i] = oi
            assert type(oi) is str
            if i + 1 < len(o):
                oi1 = o[i+1]
                assert type(oi1) is str
                if (oi1.startswith('CLEARTEMP(') or \
                (oi1.startswith('temp[') and \
                 oi1.endswith('] = 0;') ) ):
                        if '{' not in oi and '}' not in oi and \
                           ':' not in oi and \
                           'Trace' not in oi and \
                           ' ;' not in oi and \
                           'Py_CLEAR' not in oi and \
                           'Py_INCREF' not in oi and \
                           'Py_DECREF' not in oi and \
                           not oi.startswith('CLEARTEMP(') and \
                           not oi.startswith('PyObject ') and \
                           not oi.startswith('long ') and \
                           not oi.startswith('int ') and \
                           not oi.startswith('temp = ') and \
                           not (oi.startswith('temp[') and oi.endswith('] = 0;') ) and \
                           ';' in oi:
                            if 'temp[' not in o[i]:
                                o[i], o[i+1] = o[i+1], o[i]
                                ## print 'success1', 	o[i], o[i+1]
                                break
                            else:
                                if o[i+1].startswith('CLEARTEMP('):
                                    tempn = 'temp[' +o[i+1][10:-2] + ']'
                                else:
                                    tempn = o[i+1][:-5]
                                if '(' in tempn or ')' in tempn or not tempn.startswith('temp[') or not tempn.endswith(']'):
                                    Fatal('Unsiccess', o[i], o[i+1], tempn)
                                if tempn not in o[i]:
                                    o[i], o[i+1] = o[i+1], o[i]
                                    ## print 'success2', tempn, o[i], o[i+1]
                                    break

            
            if not o[i].startswith('if ('):
                if o[i] == '{':
                    if TxMatch(o, i, """
                        {
                        char __s[1];
                        __s[0] = (unsigned char)$3;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto label_$10;
                        }
                        int_$11 = PyString_GET_SIZE ($12 );
                        temp[$1] = PyString_FromStringAndSize(NULL, 1 + int_$11);
                        charref_$7 = PyString_AS_STRING ( temp[$1] );
                        *charref_$7++ = *PyString_AS_STRING ( temp[$0] );
                        CLEARTEMP($0);
                        """, v2):
                            TxRepl(o, i, """
                                int_$11 = PyString_GET_SIZE ($12 );
                                temp[$1] = PyString_FromStringAndSize(NULL, 1 + int_$11);
                                charref_$7 = PyString_AS_STRING ( temp[$1] );
                                *charref_$7++ = (unsigned char)$3;
                                   """, v2)
                            break
                if o[i].startswith('temp['):
                    if tune_let_temp(o, i):
                        break
                    
                if o[i].startswith('Py_CLEAR(temp['):
                    if TxMatch(o, i, ('Py_CLEAR(temp[$1]);',
                        'temp[$1] = 0;'), v2):
                            TxRepl(o, i, ('CLEARTEMP($1);',), v2)
                            break
                    if TxMatch(o, i, ('Py_CLEAR(temp[$0]);',), v2):
                            TxRepl(o, i, ('CLEARTEMP($0);',), v2)
                            break         
        
                if 'PyInt_AsSsize_t' in o[i]:
                    if TxMatch(o, i, ('$1 = PyInt_AsSsize_t ( $8 );',
                        'if (PyInt_CheckExact( $8 ) && ($3 = PyInt_AS_LONG ( $8 )) < (INT_MAX-$4) ) {',
                        'temp[$0] = PyInt_FromLong ( $3 + $5 );',
                        '} else if (PyFloat_CheckExact( $8 )) {',
                        'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($8) + ((double)$5));',
                        '} else {',
                        'if ((temp[$0] = PyNumber_Add ( $8 , $6 )) == 0) goto $7;',
                        '}',
                        '$2 = PyInt_AsSsize_t ( temp[$0] );',
                        'CLEARTEMP($0);'), v2):
                            TxRepl(o, i, ('$1 = PyInt_AsSsize_t ( $8 );',
                                '$2 = $1 + $5;'), v2)
                            break
                
                    if TxMatch(o, i, ('$1 = PyInt_AsSsize_t ( $8 );',
                        'if (PyInt_CheckExact( $8 ) && ($3 = PyInt_AS_LONG ( $8 )) < (INT_MAX-$4) ) {',
                        'temp[$0] = PyInt_FromLong ( $3 + $5 );',
                        '} else {',
                        'if ((temp[$0] = PyNumber_Add ( $8 , $6 )) == 0) goto $7;',
                        '}',
                        '$2 = PyInt_AsSsize_t ( temp[$0] );',
                        'CLEARTEMP($0);'), v2):
                            TxRepl(o, i, ('$1 = PyInt_AsSsize_t ( $8 );',
                                '$2 = $1 + $5;'), v2)
                            break
                    if TxMatch(o, i, ('$2 = PyInt_AsSsize_t ( temp[$1] );',
                        'CLEARTEMP($1);',
                        'if (PyInt_CheckExact( $3 )) {',
                        '$5 = PyInt_AS_LONG ( $3 ) $7 $2;',
                        '} else {',
                        'if ((temp[$0] = PyInt_FromSsize_t($2)) == 0) goto $4;',
                        'if (($5 = PyObject_RichCompareBool ( $3 , temp[$0] , Py_$8 )) == -1) goto $4;',
                        'CLEARTEMP($0);',
                        '}'), v2):
                            TxRepl(o, i, ('if (PyInt_CheckExact( $3 )) {',
                                '$2 = PyInt_AsSsize_t ( temp[$1] );',          
                                'CLEARTEMP($1);',
                                '$5 = PyInt_AS_LONG ( $3 ) $7 $2;',
                                '} else {',
                                'if (($5 = PyObject_RichCompareBool ( $3 , temp[$1] , Py_$8 )) == -1) goto $4;',
                                'CLEARTEMP($1);',
                                '}'), v2)
                            break 
            
                if o[i].startswith('Py_INCREF') and i+1 < len(o):    
                    if o[i+1].startswith('Py_INCREF'):
                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            Py_INCREF($5);
                            Py_INCREF($6);
                            Py_INCREF($7);
                            Py_INCREF($8);
                            Py_INCREF($9);
                            if ((temp[$3] = PyTuple_New ( 7 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            PyTuple_SET_ITEM ( temp[$3] , 2 , $5 );
                            PyTuple_SET_ITEM ( temp[$3] , 3 , $6 );
                            PyTuple_SET_ITEM ( temp[$3] , 4 , $7 );
                            PyTuple_SET_ITEM ( temp[$3] , 5 , $8 );
                            PyTuple_SET_ITEM ( temp[$3] , 6 , $9 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 7 , $1 , $2 , $5 , $6 , $7 , $8 , $9 )) == 0) goto label_$4;
                                    """, v2)
                                break   

                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            Py_INCREF($5);
                            Py_INCREF($6);
                            Py_INCREF($7);
                            Py_INCREF($8);
                            if ((temp[$3] = PyTuple_New ( 6 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            PyTuple_SET_ITEM ( temp[$3] , 2 , $5 );
                            PyTuple_SET_ITEM ( temp[$3] , 3 , $6 );
                            PyTuple_SET_ITEM ( temp[$3] , 4 , $7 );
                            PyTuple_SET_ITEM ( temp[$3] , 5 , $8 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 6 , $1 , $2 , $5 , $6 , $7 , $8 )) == 0) goto label_$4;
                                    """, v2)
                                break   
                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            Py_INCREF($5);
                            Py_INCREF($6);
                            Py_INCREF($7);
                            if ((temp[$3] = PyTuple_New ( 5 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            PyTuple_SET_ITEM ( temp[$3] , 2 , $5 );
                            PyTuple_SET_ITEM ( temp[$3] , 3 , $6 );
                            PyTuple_SET_ITEM ( temp[$3] , 4 , $7 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 5 , $1 , $2 , $5 , $6 , $7 )) == 0) goto label_$4;
                                    """, v2)
                                break   
                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            Py_INCREF($5);
                            Py_INCREF($6);
                            if ((temp[$3] = PyTuple_New ( 4 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            PyTuple_SET_ITEM ( temp[$3] , 2 , $5 );
                            PyTuple_SET_ITEM ( temp[$3] , 3 , $6 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 4 , $1 , $2 , $5 , $6 )) == 0) goto label_$4;
                                    """, v2)
                                break   
                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            Py_INCREF($5);
                            if ((temp[$3] = PyTuple_New ( 3 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            PyTuple_SET_ITEM ( temp[$3] , 2 , $5 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 3 , $1 , $2 , $5 )) == 0) goto label_$4;
                                    """, v2)
                                break                
                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            if ((temp[$3] = PyTuple_New ( 2 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 2 , $1 , $2 )) == 0) goto label_$4;
                                    """, v2)
                                break 
                    elif o[i] == 'Py_INCREF(Py_None);' and TxMatch(o, i, """
                        Py_INCREF(Py_None);
                        temp[$0] = Py_None;
                        CLEARTEMP($0);  
                        """, v2):
                            TxRepl(o, i, '', v2)
                            break                           
                    elif 'PyInt_CheckExact' in o[i+1]:           
                        if TxMatch(o, i, ('Py_INCREF($1);',
                            'if (PyInt_CheckExact( $1 ) && ($6 = PyInt_AS_LONG ( $1 )) < (INT_MAX-$2) ) {',
                            'temp[$0] = PyInt_FromLong ( $6 + $3 );',
                            '} else if (PyFloat_CheckExact( $1 )) {',
                            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$3));',
                            '} else {',
                            'if ((temp[$0] = PyNumber_Add ( $1 , $4 )) == 0) goto $5;',
                            '}',
                            'if (PyInt_CheckExact( temp[$0] )) {',
                            '$7 = PyInt_AS_LONG ( temp[$0] );',
                            'if ( $7 < 0) {',
                            '$7 += PyList_GET_SIZE($8);',
                            '}',
                            'if ( PyList_SetItem ( $8 , $7 , $1 ) == -1) goto $5;',
                            '} else {',
                            'if ( PyObject_SetItem ( $8 , temp[$0] , $1 ) == -1) goto $5;',
                            'Py_DECREF($1);',
                            '}',
                            'CLEARTEMP($0);'), v2) and v2[6] != v2[7]:
                                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($6 = PyInt_AS_LONG ( $1 )) < (INT_MAX-$2) ) {',
                                    '$7 = $6 + $3;',
                                    'if ( $7 < 0) {',
                                    '$7 += PyList_GET_SIZE($8);',
                                    '}',
                                    'Py_INCREF($1);',
                                    'if ( PyList_SetItem ( $8 , $7 , $1 ) == -1) goto $5;',
                                    '} else {',
                                    'if ((temp[$0] = PyNumber_Add ( $1 , $4 )) == 0) goto $5;',
                                    'if ( PyObject_SetItem ( $8 , temp[$0] , $1 ) == -1) goto $5;',
                                    'CLEARTEMP($0);',
                                    '}'), v2)
                                break                
                        if TxMatch(o, i, ('Py_INCREF($6);',
                            'if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
                            'temp[$2] = PyInt_FromLong ( $9 - 1 );',
                            '} else if (PyFloat_CheckExact( $5 )) {',
                            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) - ((double)1));',
                            '} else {',
                            'if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;',
                            '}',
                            'if (PyInt_CheckExact( temp[$2] )) {',
                            '$10 = PyInt_AS_LONG ( temp[$2] );',
                            'if ( $10 < 0) {',
                            '$10 += PyList_GET_SIZE($7);',
                            '}',
                            'if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;',
                            '} else {',
                            'if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;',
                            'Py_DECREF($6);',
                            '}',
                            'CLEARTEMP(2);'), v2):
                                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
                                    '$10 = $9 - 1;',
                                    'if ( $10 < 0) {',
                                    '$10 += PyList_GET_SIZE($7);',
                                    '}',
                                    'Py_INCREF($6);',
                                    'if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;',
                                    '} else {',
                                    'if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;',
                                    'if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;',
                                    'CLEARTEMP(2);',
                                    '}'), v2)
                                break 
                    
                        if TxMatch(o, i, ('Py_INCREF($6);',
                            'if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
                            'temp[$2] = PyInt_FromLong ( $9 - 1 );',
                            '} else {',
                            'if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;',
                            '}',
                            'if (PyInt_CheckExact( temp[$2] )) {',
                            '$10 = PyInt_AS_LONG ( temp[$2] );',
                            'if ( $10 < 0) {',
                            '$10 += PyList_GET_SIZE($7);',
                            '}',
                            'if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;',
                            '} else {',
                            'if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;',
                            'Py_DECREF($6);',
                            '}',
                            'CLEARTEMP(2);'), v2):
                                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
                                    '$10 = $9 - 1;',
                                    'if ( $10 < 0) {',
                                    '$10 += PyList_GET_SIZE($7);',
                                    '}',
                                    'Py_INCREF($6);',
                                    'if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;',
                                    '} else {',
                                    'if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;',
                                    'if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;',
                                    'CLEARTEMP(2);',
                                    '}'), v2)
                                break 
                            
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$0]);
                            if (PyInt_CheckExact$2) {
                            long_$13 = $3;
                            long_$12 = $4;
                            if ($5) goto label_$16 ;
                            temp[$1] = PyInt_FromLong ($6);
                            } else if (PyFloat_CheckExact$7) {
                            temp[$1] = PyFloat_FromDouble($8);
                            } else { label_$16 :;
                            if ((temp[$1] = PyNumber_$9) == 0) goto label_$10;
                            }
                            CLEARTEMP($0);                            
                            """, v2):
                                TxRepl(o, i, """
                                    if (PyInt_CheckExact$2) {
                                    long_$13 = $3;
                                    long_$12 = $4;
                                    if ($5) goto label_$16 ;
                                    temp[$1] = PyInt_FromLong ($6);
                                    temp[$0] = 0;
                                    } else if (PyFloat_CheckExact$7) {
                                    temp[$1] = PyFloat_FromDouble($8);
                                    temp[$0] = 0;
                                    } else { label_$16 :;
                                    Py_INCREF(temp[$0]);
                                    if ((temp[$1] = PyNumber_$9) == 0) goto label_$10;
                                    CLEARTEMP($0);                            
                                    }
                                    """, v2)
                                break 
                            
                            
                    elif o[i+1].startswith('SETLOCAL'):
                        if TxMatch(o, i, """
                            Py_INCREF(Py_None);
                            SETLOCAL ( $0 , Py_None );
                            """, v2):
                                TxRepl(o, i, """
                                    Py_XDECREF(GETLOCAL($0));   
                                    Py_INCREF(Py_None);
                                    GETLOCAL($0) = Py_None;
                                    """, v2)
                                break 
                    if o[i+1].startswith('temp['):
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            temp[$0] = 0;
                            if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    temp[$0] = 0;
                                    if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            temp[$0] = 0;
                            if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    temp[$0] = 0;
                                    if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                    if o[i+1].startswith('if ((int_'):
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 

                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            CLEARTEMP($0);
                            int_$2 = temp[$1] $5= $3;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    CLEARTEMP($0);
                                    int_$2 = temp[$1] $5= $3;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                    if True:                    
                        if i+2 < len(o):
                            if 'PyList_GetItem' in o[i+1] and TxMatch(o, i, """ 
                                Py_INCREF($3);
                                if ((temp[$0] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                                Py_INCREF(temp[$0]);
                                if ((temp[$1] = PyTuple_New ( 2 )) == 0) goto label_$2;
                                PyTuple_SET_ITEM ( temp[$1] , 0 , $3 );
                                PyTuple_SET_ITEM ( temp[$1] , 1 , temp[$0] );
                                temp[$0] = 0;""", v2):
                                    TxRepl(o, i, """                
                                        if ((temp[$0] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                                        if ((temp[$1] = PyTuple_Pack ( 2 , $3 , temp[$0] )) == 0) goto label_$2;
                                        temp[$0] = 0;
                                        """, v2)
                                    break                
                            
                            if o[i+2].startswith('PyTuple_SET_ITEM') and TxMatch(o, i, """                
                                Py_INCREF($1);
                                if ((temp[$3] = PyTuple_New ( 1 )) == 0) goto label_$4;
                                PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                                """, v2):
                                    TxRepl(o, i, """                
                                        if ((temp[$3] = PyTuple_Pack ( 1 , $1 )) == 0) goto label_$4;
                                        """, v2)
                                    break                
                            if o[i].startswith('Py_INCREF(temp[') and o[i+2].startswith('CLEARTEMP('):
                                if TxMatch(o, i, ('Py_INCREF(temp[$2]);',
                                    'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( temp[$2] , $3 )) == 0) goto $4;',
                                    'CLEARTEMP($2);'), v2):
                                        TxRepl(o, i, ('if ((temp[$1] = ___c_BINARY_SUBSCR_Int ( temp[$2] , $3 )) == 0) goto $4;',
                                                      'temp[$2] = 0;'), v2, ('___c_BINARY_SUBSCR_Int',))
                                        break
                                        
                                        
                                if TxMatch(o, i, ('Py_INCREF(temp[$0]);',
                                    'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;',
                                    'CLEARTEMP($0);'), v2):
                                        TxRepl(o, i, ('if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;',
                                            'temp[$0] = 0;'), v2)
                                        break 
                                if TxMatch(o, i, """
                                    Py_INCREF(temp[$0]);
                                    $1 = temp[$0];
                                    CLEARTEMP($0);""", v2):
                                        TxRepl(o, i, """
                                            $1 = temp[$0];
                                            temp[$0] = 0;""", v2)

                    
                if o[i] == '} else if (1) {' and TxMatch(o, i, ('} else if (1) {', '$1', '} else {', '$2', '}'), v2):
                    if '{' not in v2[1] and '{' not in v2[2] and \
                    '}' not in v2[1] and '}' not in v2[2] and \
                    ':' not in v2[1] and ':' not in v2[2]:
                        TxRepl(o, i, ('} else {', '$1', '}'), v2)
                        break   
                    
                if o[i].startswith('} else if (Py'):
                    if TxMatch(o, i, """
                        } else if (Py$1_CheckExact( $2 ) && Py$1_CheckExact( $2 )) {
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (Py$1_CheckExact( $2 )) {
                            """, v2) 
                        break 
                    if TxMatch(o, i, """
                        } else if (Py$1_CheckExact( temp[$2] ) && Py$1_CheckExact( temp[$2] )) {
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (Py$1_CheckExact( temp[$2] )) {
                            """, v2) 
                        break 
                    if TxMatch(o, i, """
                        } else if (PyInt_CheckExact( $9 )) {
                        long_$6 = PyInt_AS_LONG ( $9 );
                        long_$7 = PyInt_AS_LONG ( $9 );
                        if (long_$6 && long_$7 && (long_$6 * long_$7) / long_$7 == long_$6) {
                        temp[$0] = PyInt_FromLong ( long_$6 * long_$7 );
                        } else {                    
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (PyInt_CheckExact( $9 )) {
                            long_$6 = PyInt_AS_LONG ( $9 );
                            if (long_$6 && (long_$6 * long_$6) / long_$6 == long_$6) {
                            temp[$0] = PyInt_FromLong ( long_$6 * long_$6 );
                            } else {                    
                            """, v2) 
                        break 
                    if TxMatch(o, i, """
                        } else if (PyInt_CheckExact( temp[$9] )) {
                        long_$6 = PyInt_AS_LONG ( temp[$9] );
                        long_$7 = PyInt_AS_LONG ( temp[$9] );
                        if (long_$6 && long_$7 && (long_$6 * long_$7) / long_$7 == long_$6) {
                        temp[$0] = PyInt_FromLong ( long_$6 * long_$7 );
                        } else {                    
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (PyInt_CheckExact( temp[$9] )) {
                            long_$6 = PyInt_AS_LONG ( temp[$9] );
                            if (long_$6 && (long_$6 * long_$6) / long_$6 == long_$6) {
                            temp[$0] = PyInt_FromLong ( long_$6 * long_$6 );
                            } else {                    
                            """, v2) 
                        break    
                    if TxMatch(o, i, """
                        } else if (PyInt_CheckExact( temp[$12] )) {
                        long_$1 = PyInt_AS_LONG ( temp[$12] );
                        long_$2 = PyInt_AS_LONG ( temp[$12] );
                        if (!long_$1 || !long_$2 || (long_$1 * long_$2) / long_$2 == long_$1) {
                        temp[$3] = PyInt_FromLong ( long_$1 * long_$2 );
                        } else {
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (PyInt_CheckExact( temp[$12] )) {
                            long_$1 = PyInt_AS_LONG ( temp[$12] );
                            if (!long_$1 || (long_$1 * long_$1) / long_$1 == long_$1) {
                            temp[$3] = PyInt_FromLong ( long_$1 * long_$1 );
                            } else { 
                            """, v2) 
                        break    
                if o[i] == '{':
                    if TxMatch(o, i, """
                        {
                        char __s[1];
                        __s[0] = (unsigned char)long_$2;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $3;
                        }
                        int_$5 = PyString_GET_SIZE ( $4 );
                        int_$6 = PyString_GET_SIZE ( temp[$0] );
                        temp[$1] = PyString_FromStringAndSize(NULL, int_$5 + int_$6);
                        charref_$8 = PyString_AS_STRING ( temp[$1] );
                        memcpy(charref_$8, PyString_AS_STRING ( $4 ), int_$5);
                        charref_$8 += int_$5;
                        memcpy(charref_$8, PyString_AS_STRING ( temp[$0] ), int_$6);
                        CLEARTEMP($0);
                        """, v2):
                            TxRepl(o, i, """
                                int_$5 = PyString_GET_SIZE ( $4 );
                                temp[$1] = PyString_FromStringAndSize(NULL, int_$5 + 1);
                                charref_$8 = PyString_AS_STRING ( temp[$1] );
                                memcpy(charref_$8, PyString_AS_STRING ( $4 ), int_$5);
                                charref_$8 += int_$5;
                                charref_$8[0] = (unsigned char)long_$2;
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        {
                        char __s[1];
                        __s[0] = (unsigned char)long_$11;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $3;
                        }
                        if (PyString_CheckExact(temp[$1])) {
                        int_$4 = (PyString_GET_SIZE(temp[$1]) == PyString_GET_SIZE(temp[$0])) && (PyString_AS_STRING(temp[$1])[0] == PyString_AS_STRING(temp[$0])[0]) && (memcmp(PyString_AS_STRING(temp[$1]), PyString_AS_STRING(temp[$0]), PyString_GET_SIZE(temp[$1])) == 0);
                        } else {
                        if ((int_$4 = PyObject_RichCompareBool ( temp[$1] , temp[$0] , Py_EQ )) == -1) goto $3;
                        }
                        CLEARTEMP($1);
                        CLEARTEMP($0);                    
                        """, v2):
                            TxRepl(o, i, """
                                if (PyString_CheckExact(temp[$1])) {
                                int_$4 = (PyString_GET_SIZE(temp[$1]) == 1) && (PyString_AS_STRING(temp[$1])[0] == (unsigned char)long_$11);
                                } else {
                                char __s[1];
                                __s[0] = (unsigned char)long_$11;
                                if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $3;
                                if ((int_$4 = PyObject_RichCompareBool ( temp[$1] , temp[$0] , Py_EQ )) == -1) goto $3;
                                CLEARTEMP($0);
                                }
                                CLEARTEMP($1);
                                """, v2)
                            break  
                        
                if o[i].startswith('int_'):
                    if 'int_' in o[i][4:]:
                        if TxMatch(o, i, ('int_$1 =  int_$1 ;',), v2):
                                TxRepl(o, i, (), v2)
                                break
            
                        if TxMatch(o, i, ('int_$1 = int_$1;',), v2):
                                TxRepl(o, i, (), v2)
                                break
                    
                        if TxMatch(o, i, ('int_$1 =  int_$1;',), v2):
                                TxRepl(o, i, (), v2)
                                break
                    if i+1 < len(o) and o[i+1].startswith('if ('):        
                        if TxMatch(o, i, ('int_$1 = $12;',
                            'if (!( int_$1 )) {',
                            'int_$1 = $11;',
                            '}'), v2):
                                TxRepl(o, i, ('int_$1 = ($12) || ($11);',), v2)
                                break  
                        if TxMatch(o, i, ('int_$1 = $12;',
                            'if ( !(int_$1) ) {',
                            'int_$1 = $11;',
                            '}'), v2):
                                TxRepl(o, i, ('int_$1 = ($12) || ($11);',), v2)
                                break  
                        if TxMatch(o, i, ('int_$1 = $12;',
                            'if ( !int_$1 ) {',
                            'int_$1 = $11;',
                            '}'), v2):
                                TxRepl(o, i, ('int_$1 = ($12) || ($11);',), v2)
                                break  
                        if TxMatch(o, i, ('int_$1 = $12;',
                            'if ( int_$1 ) {',
                            'int_$1 = $11;',
                            '}'), v2):
                                TxRepl(o, i, ('int_$1 = ($12) && ($11);',), v2)
                                break  
                    else:        
                        if TxMatch(o, i, """
                            int_$1 = $2temp[$3]$4;
                            CLEARTEMP($3);
                            Loc_int_$5 = int_$1;""", v2):    
                                TxRepl(o, i, """
                                    Loc_int_$5 = $2temp[$3]$4;
                                    CLEARTEMP($3);""", v2)
                                break  
            
                
                if o[i] == '{' and TxMatch(o, i, ('{',
                    'char __s[1];',
                    '__s[0] = (unsigned char)$6;',
                    'if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $5;',
                    '}',
                    '$2 = *PyString_AS_STRING(temp[$0]);',
                    'Py_CLEAR(temp[$0]);',
                    'temp[$0] = 0;'), v2):
                        TxRepl(o, i, ('$2 = (unsigned char)$6;',), v2)
                        break  
                if o[i] == '{' and TxMatch(o, i, ('{',
                    'char __s[1];',
                    '__s[0] = (unsigned char)$6;',
                    'if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $5;',
                    '}',
                    '$2 = *PyString_AS_STRING ( temp[$0] );',
                    'Py_CLEAR(temp[$0]);',
                    'temp[$0] = 0;'), v2):
                        TxRepl(o, i, ('$2 = (unsigned char)$6;',), v2)
                        break  
            
                if o[i].startswith('double'):
                    if TxMatch(o, i, ('double_$4 = $3;',
                        'if ((temp[$0] = PyFloat_FromDouble ( double_$4 )) == 0) goto label_$0;',
                        '$5 = PyFloat_AsDouble(temp[$0]);',
                        'CLEARTEMP($0);',), v2):
                            TxRepl(o, i, ('$5 = $3;',), v2)
                            break  
                    if TxMatch(o, i, ('double_$3 = Loc_double_$11;',
                        'double_$4 = Loc_double_$12;',
                        'double_$5 = double_$3 $0 double_$4;'), v2):
                            TxRepl(o, i, ('double_$5 = Loc_double_$11 $0 Loc_double_$12;',), v2)
                            break  
                    if TxMatch(o, i, ('double_$3 = Loc_double_$11;',
                        'double_$4 = (double)PyInt_AsLong ( $15 );',
                        'double_$5 = double_$3 $0 double_$4;'), v2):
                            TxRepl(o, i, ('double_$5 = Loc_double_$11 $0 (double)PyInt_AsLong ( $15 );',), v2)
                            break  
                    if TxMatch(o, i, ('double_$1 = $0;',
                        'return double_$1;'), v2):    
                            TxRepl(o, i, ('return $0;',), v2)
                            break  
                    if TxMatch(o, i, ('double_$5 = $0;',
                        'if ((temp[$6] = PyFloat_FromDouble ( double_$5 )) == 0) goto $10;'), v2):
                            TxRepl(o, i, ('if ((temp[$6] = PyFloat_FromDouble ( $0 )) == 0) goto $10;',), v2)
                            break  
                    if TxMatch(o, i, ('$1 = PyFloat_AsDouble ( GETLOCAL($4) );',
                        '$2 = PyFloat_AsDouble ( GETLOCAL($5) );',
                        '$3 = $1 - $2;',
                        'if ((temp[$0] = PyFloat_FromDouble ( $3 )) == 0) goto $6;'), v2):
                            TxRepl(o, i, ('$3 = PyFloat_AsDouble ( GETLOCAL($4) ) - PyFloat_AsDouble ( GETLOCAL($5) );',
                                'if ((temp[$0] = PyFloat_FromDouble ( $3 )) == 0) goto $6;'), v2)
                            break  

                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($5) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($5) );
                        if ((temp[$0] = PyFloat_FromDouble ( double_$3 $7 double_$4 )) == 0) goto label_$10;
                        """, v2) and not ' ' in v2[7]:
                            TxRepl(o, i, """
                                double_$3 = PyFloat_AsDouble ( GETLOCAL($5) );
                                if ((temp[$0] = PyFloat_FromDouble ( double_$3 $7 double_$3 )) == 0) goto label_$10;
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$9 = double_$3 + double_$4;
                        """, v2):
                            TxRepl(o, i, """
                                    double_$9 = PyFloat_AsDouble ( GETLOCAL($11) ) * 2;
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$9 = double_$3 $7 double_$4;
                        """, v2) and not ' ' in v2[7]:
                            TxRepl(o, i, """
                                    double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                                    double_$9 = double_$3 $7 double_$3;
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($5) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($6) );
                        if ((temp[$0] = PyFloat_FromDouble ( double_$3 $7 double_$4 )) == 0) goto label_$10;
                        """, v2) and not ' ' in v2[7]:
                            TxRepl(o, i, """
                                   if ((temp[$0] = PyFloat_FromDouble ( PyFloat_AsDouble ( GETLOCAL($5) ) $7 PyFloat_AsDouble ( GETLOCAL($6) ) )) == 0) goto label_$10;
                                """, v2)
                            break              
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($12) );
                        double_$9 = double_$3 $7 double_$4;
                        """, v2) and not ' ' in v2[7]:
                            TxRepl(o, i, """
                                   double_$9 = PyFloat_AsDouble ( GETLOCAL($11) ) $7 PyFloat_AsDouble ( GETLOCAL($12) );
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = $11;
                        double_$4 = Loc_double_$12;
                        double_$9 = double_$3 $7 double_$4;
                        """, v2) and not ' ' in v2[7] and ' ' in v2[11]:
                            TxRepl(o, i, """
                                   double_$9 = ($11) $7 Loc_double_$12;
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = (double)( Loc_long_$10 );
                        double_$4 = double_$3 $7 $11;
                        """, v2) and not ' ' in v2[7]:
                            TxRepl(o, i, """
                                   double_$4 = (double)( Loc_long_$10 ) $7 $11;
                                """, v2)
                            break  
                    ## if TxMatch(o, i, """
                        ## double_$3 = $14;
                        ## double_$4 = double_$3 $7 $11;
                        ## """, v2) and not ' ' in v2[7] and ' ' in v2[14]:
                            ## TxRepl(o, i, """
                                   ## double_$4 = ($14) $7 $11;
                                ## """, v2)
                            ## break  
                    if TxMatch(o, i, """
                        double_$4 = $14;
                        Loc_double_$15 = double_$4 $7 $11;                         
                        """, v2) and not ' ' in v2[7] and ' ' in v2[14]:
                            TxRepl(o, i, """
                                   Loc_double_$15 = ($14) $7 $11;
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        double_$13 = exp ( double_$12 );
                        double_$12 = $14 $15 double_$13;                        
                        """, v2) and not ' ' in v2[14] and not ' ' in v2[15]:
                            TxRepl(o, i, """
                                double_$12 = $14 $15 exp ( double_$12 );                        
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        double_$13 = $3;
                        double_$12 = $14 $15 double_$13;                        
                        """, v2) and not ' ' in v2[14] and not ' ' in v2[15] and ' ' in v2[3]:
                            TxRepl(o, i, """
                                double_$12 = $14 $15 ( $3 );                        
                                """, v2)
                            break  

                    if TxMatch(o, i, """
                        double_$17 = PyFloat_AS_DOUBLE ( temp[$1] );
                        if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                        } else {
                        """, v2) and v2[18].count('(double_' + v2[17] + ')') == 1:
                            tupl = v2[18].rpartition('(double_' + v2[17] + ')')
                            v2[18] = tupl[0] + 'PyFloat_AS_DOUBLE ( temp[' + v2[1] + '] )' + tupl[2]
                            TxRepl(o, i, """
                                if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                                } else {
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        double_$17 = PyFloat_AS_DOUBLE ( GETLOCAL($1) );
                        if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                        } else {
                        """, v2) and v2[18].count('(double_' + v2[17] + ')') == 1:
                            tupl = v2[18].rpartition('(double_' + v2[17] + ')')
                            v2[18] = tupl[0] + 'PyFloat_AS_DOUBLE ( GETLOCAL(' + v2[1] + ') )' + tupl[2]
                            TxRepl(o, i, """
                                if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                                } else {
                                """, v2)
                            break  

                if o[i].startswith('long'):
                    if TxMatch(o, i, """
                        long_$4 = ($6_GET_SIZE($7));
                        temp[$0] = PyInt_FromLong ( (long_$4 $5 $1) );
                        """, v2):    
                            TxRepl(o, i, """temp[$0] = PyInt_FromLong ( $6_GET_SIZE($7) $5 $1 );""", v2)
                            break     
                    if TxMatch(o, i, """
                        long_$4 = $5;
                        temp[$14] = PyInt_FromLong ( long_$4 );
                        """, v2):    
                            TxRepl(o, i, """temp[$14] = PyInt_FromLong ( $5 );""", v2)
                            break     

                    if TxMatch(o, i, """
                        long_$2 = ($6_GET_SIZE($7));
                        long_$4 = long_$2 $3 $8;
                        """, v2):    
                            TxRepl(o, i, """long_$4 = ($6_GET_SIZE($7)) $3 $8;""", v2)
                            break  
                    if TxMatch(o, i, """
                        long_$4 = ( Py$7_GET_SIZE($8) $9 $10 );
                        if ( !(($6 $5 long_$4)) ) {
                        """, v2):    
                            TxRepl(o, i, """if ( !($6 $5 ( Py$7_GET_SIZE($8) $9 $10 )) ) {""", v2)
                            break                                                                  
                    if TxMatch(o, i, ('long_$8 = $18;',
                        'long_$11 = Loc_long_$19;',
                        'long_$7 = long_$8 + long_$11;',
                        'if (( long_$7 ^ long_$8 ) < 0 && ( long_$7 ^ long_$11 ) < 0) goto label_$12 ;'), v2):
                            TxRepl(o, i, ('long_$8 = $18;',
                                'long_$7 = long_$8 + Loc_long_$19;',
                                'if (( long_$7 ^ long_$8 ) < 0 && ( long_$7 ^ Loc_long_$19 ) < 0) goto label_$12 ;'), v2)
                            break
                        
    ##                if TxMatch(o, i, ('long_$4 = $1;',
    ##                    'if ((temp[$2] = PyInt_FromLong ( long_$4 )) == 0) goto $0;'), v2):
    ##                        TxRepl(o, i, ('if ((temp[$2] = PyInt_FromLong ( $1 )) == 0) goto $0;',), v2)
    ##                        break
                        
                    if TxMatch(o, i, ('long_$1 = (long)$3;',
                        'long_$2 = long_$1;',
                        'long_$1 = long_$2 + 1;'), v2):
                            TxRepl(o, i, ('long_$1 = ((long)$3) + 1;',), v2)
                            break
                    
                    if TxMatch(o, i, ('long_$4 = $2;',
                        'temp[$1] = PyInt_FromLong ( long_$4 );',
                        'long_$4 = PyInt_AS_LONG ( temp[$1] );',
                        'CLEARTEMP($1);'), v2):
                            v2[2] = v2[2].strip()
                            TxRepl(o, i, ('long_$4 = $2;', ), v2)
                            break
                                    
                    if TxMatch(o, i, ('long_$2 = $1;',
                        'long_$4 = $3;',
                        'int_$11 = long_$2 $5 long_$4;'), v2):
                            v2[1] = v2[1].strip()
                            v2[3] = v2[3].strip()
                            TxRepl(o, i, ('int_$11 = ($1) $5 ($3);', ), v2)
                            break
                            
                    if TxMatch(o, i, ('long_$4 = $1;',
                        'Py_ssize_t_$2 = long_$4;'), v2):
                            TxRepl(o, i, ('Py_ssize_t_$2 = $1;',), v2)
                            break 
                
                    if TxMatch(o, i, ('long_$2 = long_$1 + 1;',
                        'long_$1 = long_$2;'), v2):
                            TxRepl(o, i, ('long_$1 = long_$1 + 1;',), v2)
                            break    
                
                    if TxMatch(o, i, ('long_$2 = $3;', 'long_$1 = long_$2;'), v2):
                            TxRepl(o, i, ('long_$1 = $3;',), v2)
                            break  
            
                    if TxMatch(o, i, ('long_$4 = $1;',
                        'Loc_long_$2 = long_$4;'), v2):
                            TxRepl(o, i, ('Loc_long_$2 = $1;',), v2)
                            break 
                    if TxMatch(o, i, ('long_$1 = $2;',
                        'long_$1 = long_$1 + 1;'), v2):
                            TxRepl(o, i, ('long_$1 = ($2) + 1;',), v2)
                            break  
            
                    if TxMatch(o, i, """long_$0 = $3;
                        long_$1 = Glob_long_$4;
                        long_$2 = long_$0 - long_$1;
                        if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ long_$1 ) < 0) goto $5 ;""", v2) and\
                        not ' ' in v2[4]:
                            TxRepl(o, i, """long_$0 = $3;
                                long_$2 = long_$0 - Glob_long_$4;
                                if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ Glob_long_$4 ) < 0) goto $5 ;""", v2)
                            break 
                            
                    if TxMatch(o, i, """long_$0 = $3;
                        long_$1 = Loc_long_$4;
                        long_$2 = long_$0 - long_$1;
                        if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ long_$1 ) < 0) goto $5 ;""", v2) and\
                        not ' ' in v2[4]:
                            TxRepl(o, i, """long_$0 = $3;
                                long_$2 = long_$0 - Loc_long_$4;
                                if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ Loc_long_$4 ) < 0) goto $5 ;""", v2)
                            break  
                            
                    if TxMatch(o, i, """long_$2 = Loc_long_$6;
                        long_$4 = PyInt_AS_LONG ( $5 );
                        long_$1 = long_$2 + long_$4;
                        if (( long_$1 ^ long_$2 ) < 0 && ( long_$1 ^ long_$4 ) < 0) goto $9 ;""", v2):
                            TxRepl(o, i, """long_$4 = PyInt_AS_LONG ( $5 );
                                long_$1 = Loc_long_$6 + long_$4;
                                if (( long_$1 ^ Loc_long_$6 ) < 0 && ( long_$1 ^ long_$4 ) < 0) goto $9 ;""", v2)
                            break  
                            
                    if TxMatch(o, i, """
                        long_$3 = $10;
                        long_$4 = long_$3 * $5;
                        if (long_$4 / $5 == long_$3) {
                        temp[$2] = PyInt_FromLong (long_$4);
                        } else {
                        temp[$0] = $11;
                        temp[$2] = $12;
                        CLEARTEMP($0);
                        }
                        long_$15 = PyInt_AS_LONG ( temp[$2] );
                        """, v2):
                            TxRepl(o, i, """
                                long_$3 = $10;
                                temp[$2] = PyInt_FromLong (long_$3 * $5);
                                long_$15 = PyInt_AS_LONG ( temp[$2] );
                                """, v2)
                            break  
        
                    if TxMatch(o, i, "long_$2 = ( long_$5 );", v2) and ' ' not in v2[5]:
                            TxRepl(o, i, "long_$2 = long_$5;", v2)
                            break  
        
                    if TxMatch(o, i, """
                        long_$3 = $0 + 1;
                        Loc_long_$2 = ( long_$3 );
                        """, v2):
                            v2[0] = v2[0].strip()
                            TxRepl(o, i, "Loc_long_$2 = $0 + 1;", v2)
                            break  
        
                    if TxMatch(o, i, """
                        long_$4 = $1;
                        Loc_long_$2 = ( long_$4 );""", v2):
                            v2[1] = v2[1].strip()
                            TxRepl(o, i, "Loc_long_$2 = ( $1 );", v2)
                            break  
                    if TxMatch(o, i, ('$2 = PyInt_AS_LONG ( $1 );',
                        '$3 = 0 - $2;',
                        'temp[$4] = PyInt_FromLong ( $3 );'), v2):
                            TxRepl(o, i, ('temp[$4] = PyInt_FromLong ( - PyInt_AS_LONG ( $1 ) );',), v2)
                            break     
                                   
                    if TxMatch(o, i, """
                        long_$2 = PyInt_AS_LONG ( $5 );
                        if (PyInt_CheckExact( $6 )) {
                        int_$1 = long_$2 $7 PyInt_AS_LONG ( $6 );
                        } else {
                        if ((int_$1 = PyObject_RichCompareBool ( $5 , $6 , Py_$8 )) == -1) goto label_$0;
                        }
                        """, v2):
                            TxRepl(o, i, """
                                if (PyInt_CheckExact( $6 )) {
                                int_$1 = PyInt_AS_LONG ( $5 ) $7 PyInt_AS_LONG ( $6 );
                                } else {
                                if ((int_$1 = PyObject_RichCompareBool ( $5 , $6 , Py_$8 )) == -1) goto label_$0;
                                }
                                """, v2)
                            break     

                    if TxMatch(o, i, """
                        long_$5 =  $9 ;
                        long_$6 = long_$5 - 1;
                        temp[$0] = PyInt_FromLong ( long_$6 );
                        if ((temp[$1] = $11) == 0) goto label_$10;
                        CLEARTEMP($0);
                        """, v2) and ' ' not in v2[9]:
                            TxRepl(o, i, """
                                temp[$0] = PyInt_FromLong ( $9 - 1 );
                                if ((temp[$1] = $11) == 0) goto label_$10;
                                CLEARTEMP($0);
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        long_$5 =  $9 ;
                        long_$6 = long_$5 $2 $3;
                        temp[$0] = PyInt_FromLong ( long_$6 );
                        if ($15) goto label_$10;
                        CLEARTEMP($0);                           
                        """, v2) and ' ' not in v2[9] and v2[2] in '+-' and v2[3].isdigit():
                            TxRepl(o, i, """
                                temp[$0] = PyInt_FromLong ( $9 $2 $3 );
                                if ($15) goto label_$10;
                                CLEARTEMP($0);                           
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        long_$4 =  $1 ;
                        long_$4 = long_$4 $2 $3;
                        """, v2) and ' ' not in v2[1] and v2[2] in '+-' and v2[3].isdigit():
                            TxRepl(o, i, """
                                long_$4 = $1 $2 $3;
                                """, v2)
                            break     

                    if TxMatch(o, i, """
                        long_$4 = $3;
                        temp[$1] = PyInt_FromLong ( long_$4 );
                        if ( _PyEval_AssignSlice ( $5 , temp[$1] , NULL , temp[$0] ) == -1) goto label_$6;
                        CLEARTEMP($0);
                        CLEARTEMP($1);
                        """, v2):
                            TxRepl(o, i, """
                                if ( PySequence_SetSlice ( $5 , $3 , PY_SSIZE_T_MAX , temp[$0] ) == -1) goto label_$6;
                                CLEARTEMP($0);
                                """, v2)
                            break    

                    if TxMatch(o, i, """
                        long_$6 = PyInt_AS_LONG ( $2 );
                        long_$5 = long_$6 + $7;
                        temp[$1] = PyInt_FromLong ( long_$5 );
                        if ( _PyEval_AssignSlice ( $4 , $2 , temp[$1] , temp[$0] ) == -1) goto label_$3;
                        CLEARTEMP($0);
                        CLEARTEMP($1);
                        """, v2):
                            TxRepl(o, i, """
                                long_$6 = PyInt_AS_LONG ( $2 );
                                if ( PySequence_SetSlice ( $4 , long_$6 , long_$6 + $7 , temp[$0] ) == -1) goto label_$3;
                                CLEARTEMP($0);
                                """, v2)
                            break    
                    if TxMatch(o, i, """
                        long_$3 = 0;
                        if ((temp[$1] = PyList_GetItem ( $5 , long_$3 )) == 0) goto label_$0;
                        Py_INCREF(temp[$1]);
                        long_$4 = long_$3 + 1;
                        if ( PyList_SetSlice ( $5 , long_$3 , long_$4 , NULL ) == -1) goto label_$0;
                        """, v2):
                            TxRepl(o, i, """
                                if ((temp[$1] = PyList_GetItem ( $5 , 0 )) == 0) goto label_$0;
                                Py_INCREF(temp[$1]);
                                if ( PyList_SetSlice ( $5 , 0 , 1 , NULL ) == -1) goto label_$0;
                                """, v2)
                            break    
    
                    if TxMatch(o, i, """
                        long_$3 = PyInt_AS_LONG ( $11 ) $12 $14;
                        temp[$0] = PyInt_FromLong ( long_$3 );
                        int_$2 = PyInt_AS_LONG ( temp[$0] ) $15 $16;
                        CLEARTEMP($0);    
                        """, v2):
                            TxRepl(o, i, """
                                int_$2 = ( PyInt_AS_LONG ( $11 ) $12 $14 ) $15 $16;
                                """, v2)
                            break    

                    if TxMatch(o, i, ('long_$1 = long_$1;',), v2):
                            TxRepl(o, i, (), v2)
                            break

                    if TxMatch(o, i, """
                        long_$11 = PyInt_AS_LONG ( $10 );
                        if (long_$11 < LONG_BIT) {
                        temp[$0] = PyInt_FromLong ( 0x1 << long_$11 );
                        } else {
                        if ((temp[$0] = PyNumber_Lshift($4, $10)) == 0) goto label_$2;
                        }
                        if (PyInt_CheckExact( temp[$0] )) {
                        long_$13 = PyInt_AS_LONG ( temp[$0] );
                        long_$12 = long_$13 $7 $5;
                        if ($18) goto label_$3 ;
                        temp[$1] = PyInt_FromLong ( long_$12 );
                        } else if (PyFloat_CheckExact( temp[$0] )) {
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $7 ((double)$5));
                        } else { label_$3 :;
                        if ((temp[$1] = PyNumber_$8 ( temp[$0] , $6 )) == 0) goto label_$2;
                        }
                        CLEARTEMP($0);
                        """, v2):
                            TxRepl(o, i, """
                                long_$11 = PyInt_AS_LONG ( $10 );
                                if (long_$11 < LONG_BIT) {
                                long_$13 = 0x1 << long_$11;
                                long_$12 = long_$13 $7 $5;
                                if ($18) goto label_$3 ;
                                temp[$1] = PyInt_FromLong ( long_$12 );
                                } else { label_$3 :;
                                if ((temp[$0] = PyNumber_Lshift($4, $10)) == 0) goto label_$2;
                                if ((temp[$1] = PyNumber_$8 ( temp[$0] , $6 )) == 0) goto label_$2;
                                CLEARTEMP($0);
                                }
                                """, v2)
                            break    
                    if TxMatch(o, i, """
                        long_$6 = PyInt_AS_LONG ( GETLOCAL($1) );
                        long_$5 = long_$6 $12 $11;
                        temp[$0] = PyInt_FromLong ( long_$5 );
                        SETLOCAL ( $1 , temp[$0] );
                        temp[$0] = 0;
                        """, v2):
                            TxRepl(o, i, """
                                long_$6 = PyInt_AS_LONG ( GETLOCAL($1) );
                                Py_DECREF(GETLOCAL($1));
                                GETLOCAL($1) = PyInt_FromLong ( long_$6 $12 $11 );                                   
                                """, v2)
                            break    
                    if TxMatch(o, i, """
                        long_$6 = PyInt_AS_LONG ( GETLOCAL($1) );
                        long_$5 = long_$6 $12 $11;
                        temp[$0] = PyInt_FromLong ( long_$5 );
                        """, v2):
                            TxRepl(o, i, """
                                temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( GETLOCAL($1) ) $12 $11 );
                                """, v2)
                            break       
                    if TxMatch(o, i, """
                        long_$0 = $10;
                        long_$1 = PyInt_AS_LONG ( $9 );
                        long_$2 = long_$1 + long_$0;
                        if (( long_$2 ^ long_$1 ) < 0 && ( long_$2 ^ long_$0 ) < 0) goto label_$3 ;
                        temp[$5] = PyInt_FromLong ( long_$2 );
                        if (1) {
                        } else { label_$3 :;
                        temp[$6] = PyInt_FromLong ( long_$0 );
                        if ((temp[$5] = PyNumber_Add ( $9 , temp[$6] )) == 0) goto label_$4;
                        CLEARTEMP($6);
                        }
                        if (($7 = _PyEval_ApplySlice ( $8 , $9 , temp[$5] )) == 0) goto label_$4;
                        CLEARTEMP($5);
                        """, v2):
                            TxRepl(o, i, """
                                long_$0 = $10;
                                long_$1 = PyInt_AS_LONG ( $9 );
                                long_$2 = long_$1 + long_$0;
                                if (( long_$2 ^ long_$1 ) < 0 && ( long_$2 ^ long_$0 ) < 0) goto label_$3 ;
                                if (($7 = PySequence_GetSlice ( $8 , long_$1 , long_$2 )) == 0) goto label_$4;
                                if (0) { label_$3 :;
                                temp[$6] = PyInt_FromLong ( long_$0 );
                                if ((temp[$5] = PyNumber_Add ( $9 , temp[$6] )) == 0) goto label_$4;
                                CLEARTEMP($6);
                                if (($7 = _PyEval_ApplySlice ( $8 , $9 , temp[$5] )) == 0) goto label_$4;
                                CLEARTEMP($5);
                                }
                                """, v2)
                            break    

                if o[i].startswith('Py_ssize_t'):
                    if TxMatch(o, i, ('Py_ssize_t_$2 = $11;',
                        'CLEARTEMP($0);',
                        'int_$1 = Py_ssize_t_$2 == $10;'), v2):
                            TxRepl(o, i, ('int_$1 = $11 == $10;',
                                        'CLEARTEMP($0);'), v2)
                            break
                
                    if TxMatch(o, i, ('Py_ssize_t_$2 = $11;',
                        'CLEARTEMP($0);',
                        'int_$1 = Py_ssize_t_$2 >= $10;'), v2):
                            TxRepl(o, i, ('int_$1 = $11 >= $10;',
                                        'CLEARTEMP($0);'), v2)
                            break
                
                    if TxMatch(o, i, ('Py_ssize_t_$2 = $11;',
                        'CLEARTEMP($0);',
                        'int_$1 = Py_ssize_t_$2 > $10;'), v2):
                            TxRepl(o, i, ('int_$1 = $11 > $10;',
                                        'CLEARTEMP($0);'), v2)
                            break
                            
                    if TxMatch(o, i, ('Py_ssize_t_$1 =  Py_ssize_t_$1 ;',), v2):   
                        TxRepl(o, i, (), v2)  
                    
            
                if o[i].startswith('CLEARTEMP'):
                    if i+1 < len(o):
                        if o[i] == o[i+1]:
                            del o[i+1]
                            break         
                        if o[i+1].startswith('temp[') and TxMatch(o, i, ('CLEARTEMP($0);', 'temp[$0] = 0;'), v2):
                            del o[i+1]
                            break 
                if  i < (len(o) - 1) and ' = ' in o[i] and o[i+1].startswith('temp['):
                    if TxMatch(o, i, ('$2 = $3;',
                        'temp[$1] = PyInt_FromLong ( $2 );',
                        'if (PyInt_CheckExact( $6 )) {',
                        '$7 = PyInt_AS_LONG ( $6 );',
                        '$8 = PyInt_AS_LONG ( temp[$1] );',
                        '$9 = $7 + $8;',
                        'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                        'temp[$0] = PyInt_FromLong ( $9 );',
                        '} else if (PyFloat_CheckExact( $6 )) {',
                        'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) + (double)PyInt_AS_LONG ( temp[$1] ));',
                        '} else { $5 :;',
                        'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                        '}',
                        'CLEARTEMP($1);'), v2):
                            TxRepl(o, i, ('if (PyInt_CheckExact( $6 )) {',
                                '$7 = PyInt_AS_LONG ( $6 );',
                                '$8 = $3;',
                                '$9 = $7 + $8;',
                                'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                                'temp[$0] = PyInt_FromLong ( $9 );',
                                '} else if (PyFloat_CheckExact( $6 )) {',
                                'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) + (double)($3));',
                                '} else { $5 :;',
                                'temp[$1] = PyInt_FromLong ( $3 );',
                                'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                                'CLEARTEMP($1);',
                                '}'), v2)
                            break              
                
                    if TxMatch(o, i, ('$2 = $3;',
                        'temp[$1] = PyInt_FromLong ( $2 );',
                        'if (PyInt_CheckExact( $6 )) {',
                        '$7 = PyInt_AS_LONG ( $6 );',
                        '$8 = PyInt_AS_LONG ( temp[$1] );',
                        '$9 = $7 + $8;',
                        'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                        'temp[$0] = PyInt_FromLong ( $9 );',
                        '} else { $5 :;',
                        'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                        '}',
                        'CLEARTEMP($1);'), v2):
                            TxRepl(o, i, ('if (PyInt_CheckExact( $6 )) {',
                                '$7 = PyInt_AS_LONG ( $6 );',
                                '$8 = $3;',
                                '$9 = $7 + $8;',
                                'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                                'temp[$0] = PyInt_FromLong ( $9 );',
                                '} else { $5 :;',
                                'temp[$1] = PyInt_FromLong ( $3 );',
                                'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                                'CLEARTEMP($1);',
                                '}'), v2)
                            break              
                
                
                    if TxMatch(o, i, ('$2 = $3;',
                        'temp[$1] = PyInt_FromLong ( $2 );',
                        'if (PyInt_CheckExact( $6 )) {',
                        '$7 = PyInt_AS_LONG ( $6 );',
                        '$8 = PyInt_AS_LONG ( temp[$1] );',
                        '$9 = $7 + $8;',
                        'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                        'temp[$0] = PyInt_FromLong ( $9 );',
                        '} else if (PyFloat_CheckExact( $6 )) {',
                        'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) + (double)PyInt_AS_LONG ( temp[$1] ));',
                        '} else { $5 :;',
                        'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                        '}',
                        'CLEARTEMP($14);',
                        'CLEARTEMP($1);'), v2) and v2[1] != v2[14]:
                            TxRepl(o, i, ('if (PyInt_CheckExact( $6 )) {',
                                '$7 = PyInt_AS_LONG ( $6 );',
                                '$8 = $3;',
                                '$9 = $7 + $8;',
                                'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                                'temp[$0] = PyInt_FromLong ( $9 );',
                                '} else if (PyFloat_CheckExact( $6 )) {',
                                'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) + (double)($3));',
                                '} else { $5 :;',
                                'temp[$1] = PyInt_FromLong ( $3 );',
                                'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                                'CLEARTEMP($1);',
                                '}',
                                'CLEARTEMP($14);'), v2)
                            break   
                
                    if TxMatch(o, i, ('$2 = $3;',
                        'temp[$1] = PyInt_FromLong ( $2 );',
                        'if (PyInt_CheckExact( $6 )) {',
                        '$7 = PyInt_AS_LONG ( $6 );',
                        '$8 = PyInt_AS_LONG ( temp[$1] );',
                        '$9 = $7 + $8;',
                        'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                        'temp[$0] = PyInt_FromLong ( $9 );',
                        '} else { $5 :;',
                        'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                        '}',
                        'CLEARTEMP($14);',
                        'CLEARTEMP($1);'), v2) and v2[1] != v2[14]:
                            TxRepl(o, i, ('if (PyInt_CheckExact( $6 )) {',
                                '$7 = PyInt_AS_LONG ( $6 );',
                                '$8 = $3;',
                                '$9 = $7 + $8;',
                                'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                                'temp[$0] = PyInt_FromLong ( $9 );',
                                '} else { $5 :;',
                                'temp[$1] = PyInt_FromLong ( $3 );',
                                'if ((temp[$0] = PyNumber_$15Add ( $6 , temp[$1] )) == 0) goto $4;',
                                'CLEARTEMP($1);',
                                '}',
                                'CLEARTEMP($14);'), v2)
                            break   
            
                if i < (len(o) - 1) and o[i] == '} else' and o[i+1] == '{':
                        o[i] = '} else {'
                        del o[i+1]
                        break 
            
                if o[i].startswith('f->f_lineno = ') and TxMatch(o, i, ('f->f_lineno = $0;',
                    'f->f_lasti = $1;',
                    'f->f_lineno = $2;',
                    'f->f_lasti = $3;'), v2):
                        TxRepl(o, i, ('f->f_lineno = $2;',
                            'f->f_lasti = $3;'), v2)
                        break 
                                        
                if o[i] == 'for (;;) {' and TxMatch(o, i, ('for (;;) {',
                    'int_$0 = $1;',
                    'if (!( int_$0 )) break;'), v2):
                        TxRepl(o, i, ('while ($1) {',), v2)
                        break  
            
            if len(o) > i + 1 and \
               (o[i].startswith('goto ') or o[i].startswith('return ') or \
                o[i].startswith('break;') or o[i].startswith('continue;')):
                    i2 = i+1
                    while i2 < len(o) and (o[i2].startswith('/*') or o[i2] == ''):
                        i2 += 1
                    if i2 < len(o):
                        if o[i2].startswith('PyErr_Restore'):
                            del o[i2]
                            break
                        if o[i2].startswith('_PyEval_reset_exc_info'):
                            del o[i2]
                            break
                        if TxMatch(o, i2, """
                            Py_INCREF($1);""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if TxMatch(o, i2, """
                            Py_CLEAR($1);""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if TxMatch(o, i2, """
                            CLEARTEMP($1);""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if TxMatch(o, i2, """
                            return $1;""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if TxMatch(o, i2, """                    
                            if (tstate->frame->f_exc_type != NULL) {
                                _PyEval_reset_exc_info ( f->f_tstate );
                            }""", v2): 
                                TxRepl(o, i2, '', v2)
                                break   
                        if TxMatch(o, i2, """Py_LeaveRecursiveCall();""", v2): 
                                TxRepl(o, i2, '', v2)
                                break 
                        if TxMatch(o, i2, """tstate->frame = f->f_back;""", v2): 
                                TxRepl(o, i2, '', v2)
                                break 
                                
            if o[i].startswith('if ('):
                if o[i].endswith(';'):
                    if tune_if_dotcomma(o, i):
                        break
                elif o[i].endswith('{'): 
                    if tune_if_sk(o, i):
                        break
        
                    if o[i] == 'if (1) {' and o[i+2] == '} else {' and o[i+4] == '}' and \
                       '{' not in o[i+1] and '{' not in o[i+3] and \
                       '}' not in o[i+1] and '}' not in o[i+3] and \
                       ':' not in o[i+1] and ':' not in o[i+3]:
                            o[i:i+5] = [o[i+1]] 
                            break      
                if '= long_' in o[i]:
                    if TxMatch(o, i, ('if $0((long_$1 = long_$1)$2',), v2):
                            TxRepl(o, i, ('if $0(long_$1$2',), v2)
                            break  
    for i in range(len(o)):
        if o[i].startswith('SETLOCAL ( ') and o[i].endswith('] );') and 'temp[' in o[i]:
            if TxMatch(o, i, ('SETLOCAL ( $0 , temp[$1] );',), v2):
                TxRepl(o, i, ('SETLOCAL2 ( $0 , temp[$1] );',), v2)
    ## t2 = time.clock()
    ## global t_opt
    ## t_opt += t2 - t1
##    pprint(o)

def tune_let_temp(o, i):
    v2 = []
    if '*_PyObject_GetDictPtr' in o[i]:
        
        if TxMatch(o, i, """
temp[$1] = *_PyObject_GetDictPtr($5);
if ((temp[$2] = PyDict_GetItem ( temp[$1] , $6 )) == 0) goto label_$4;
Py_INCREF(temp[$2]);
temp[$1] = 0;
if ((int_$3 = Py$8 ( temp[$2] )) == -1) goto label_$4;
CLEARTEMP($2);
if ( !(int_$3)) {
temp[$0] = Py_$9;
Py_INCREF(temp[$0]);
} else {
temp[$1] = *_PyObject_GetDictPtr($5);
if ((temp[$0] = PyDict_GetItem ( temp[$1] , $7 )) == 0) goto label_$4;
Py_INCREF(temp[$0]);
temp[$1] = 0;
}
            """ , v2):
                TxRepl(o, i, """
temp[$1] = *_PyObject_GetDictPtr($5);
if ((temp[$2] = PyDict_GetItem ( temp[$1] , $6 )) == 0) goto label_$4;
Py_INCREF(temp[$2]);
if ((int_$3 = Py$8 ( temp[$2] )) == -1) goto label_$4;
CLEARTEMP($2);
if ( !(int_$3)) {
temp[$0] = Py_$9;
Py_INCREF(temp[$0]);
} else {
if ((temp[$0] = PyDict_GetItem ( temp[$1] , $7 )) == 0) goto label_$4;
Py_INCREF(temp[$0]);
}
temp[$1] = 0;

                """, v2)
                return True
        
        
        if TxMatch(o, i, """
            temp[$1] = *_PyObject_GetDictPtr($0);
            Py_INCREF(temp[$1]);
            if ((temp[$2] = PyDict_GetItem ( temp[$1] , $3 )) == 0) goto label_$4;
            Py_INCREF(temp[$2]);
            CLEARTEMP($1);
            """ , v2):
                TxRepl(o, i, """
            temp[$1] = *_PyObject_GetDictPtr($0);
            if ((temp[$2] = PyDict_GetItem ( temp[$1] , $3 )) == 0) goto label_$4;
            Py_INCREF(temp[$2]);
            temp[$1] = 0;
                """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = *_PyObject_GetDictPtr($9);
            if ((temp[$1] = PyDict_GetItem ( temp[$0] , $3 )) == 0) goto label_$10;
            temp[$0] = 0;
            if ((int_$7 = PyObject_$5 ( temp[$1] )) == -1) goto label_$10;
            temp[$1] = 0;
            if ( $19int_$7 ) {
            temp[$0] = *_PyObject_GetDictPtr($9);
            if ((temp[$1] = PyDict_GetItem ( temp[$0] , $4 )) == 0) goto label_$10;
            temp[$0] = 0;
            if ((int_$7 = PyObject_$6 ( temp[$1] )) == -1) goto label_$10;
            temp[$1] = 0;
            }        
            """ , v2):
                TxRepl(o, i, """
                    temp[$0] = *_PyObject_GetDictPtr($9);
                    if ((temp[$1] = PyDict_GetItem ( temp[$0] , $3 )) == 0) goto label_$10;
                    if ((int_$7 = PyObject_$5 ( temp[$1] )) == -1) goto label_$10;
                    temp[$1] = 0;
                    if ( $19int_$7 ) {
                    if ((temp[$1] = PyDict_GetItem ( temp[$0] , $4 )) == 0) goto label_$10;
                    if ((int_$7 = PyObject_$6 ( temp[$1] )) == -1) goto label_$10;
                    temp[$1] = 0;
                    }
                    temp[$0] = 0;
                """, v2)
                return True

        if TxMatch(o, i, """
temp[$0] = *_PyObject_GetDictPtr($3);
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $4 )) == 0) goto label_$2;
temp[$0] = 0;
if ((int_$11 = PyObject_$9 ( temp[$1] )) == -1) goto label_$2;
temp[$1] = 0;
if ( $7int_$11 ) {
temp[$0] = *_PyObject_GetDictPtr($3);
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $5 )) == 0) goto label_$2;
if ((int_$11 = PyObject_$10 ( temp[$1] )) == -1) goto label_$2;
temp[$1] = 0;
if ( $8int_$11 ) {
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $6 )) == 0) goto label_$2;
if ((int_$11 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$2;
temp[$1] = 0;
}
temp[$0] = 0;
}   
            """ , v2):
                TxRepl(o, i, """
temp[$0] = *_PyObject_GetDictPtr($3);
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $4 )) == 0) goto label_$2;
if ((int_$11 = PyObject_$9 ( temp[$1] )) == -1) goto label_$2;
temp[$1] = 0;
if ( $7int_$11 ) {
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $5 )) == 0) goto label_$2;
if ((int_$11 = PyObject_$10 ( temp[$1] )) == -1) goto label_$2;
temp[$1] = 0;
if ( $8int_$11 ) {
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $6 )) == 0) goto label_$2;
if ((int_$11 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$2;
temp[$1] = 0;
}
}   
temp[$0] = 0;
                """, v2)
                return True
        
        if TxMatch(o, i, """
temp[$0] = *_PyObject_GetDictPtr($9);
if ((temp[$1] = PyDict_GetItem ( temp[$0] , $8 )) == 0) goto label_$7;
Py_INCREF(temp[$1]);
temp[$0] = 0;
CLEARTEMP($1);        
            """ , v2):
                TxRepl(o, i, '', v2)
                return True
        
    if 'PyDict_GetItem' in o[i]:
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem(_$3_dict, $1);
            Py_INCREF(temp[$0]);
            if (_$4_dict) {
            if (PyDict_SetItem(_$4_dict, $2, temp[$0]) == -1) goto label_$10;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($4) , $2 , temp[$0] ) == -1) goto label_$10;
            }
            CLEARTEMP($0);        
            """ , v2):
                TxRepl(o, i, """
                    if (_$4_dict) {
                    if (PyDict_SetItem(_$4_dict, $2, PyDict_GetItem(_$3_dict, $1)) == -1) goto label_$10;
                    } else {
                    temp[$0] = PyDict_GetItem(_$3_dict, $1);
                    Py_INCREF(temp[$0]);
                    if ( PyObject_SetAttr ( GETLOCAL($4) , $2 , temp[$0] ) == -1) goto label_$10;
                    CLEARTEMP($0);        
                    }
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem$15($11,$12);
            if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
            temp[$0] = 0;        
            """ , v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyObject_IsTrue ( PyDict_GetItem$15($11,$12) )) == -1) goto label_$10;
                       """, v2)
                return True

        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem$15($11,$12);
            if ((int_$1 = PyObject_Not ( temp[$0] )) == -1) goto label_$10;
            temp[$0] = 0;        
            """ , v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyObject_Not ( PyDict_GetItem$15($11,$12) )) == -1) goto label_$10;
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($3, $4);
            Py_INCREF(temp[$0]);
            Py_ssize_t_$2 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);
            """ , v2):
                TxRepl(o, i, """
                    Py_ssize_t_$2 = PyInt_AsSsize_t ( PyDict_GetItem($3, $4) );
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($3, $4);
            Py_INCREF(temp[$0]);
            if ((temp[$1] = PyList_GetItem ( temp[$0] , $5 )) == 0) goto label_$2;
            Py_INCREF(temp[$1]);
            CLEARTEMP($0);
            """ , v2) and ('temp[%s]' % v2[0]) not in v2[5]:
                TxRepl(o, i, """
                    if ((temp[$1] = PyList_GetItem ( PyDict_GetItem($3, $4) , $5 )) == 0) goto label_$2;
                    Py_INCREF(temp[$1]);
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($9, $4);
            Py_INCREF(temp[$0]);
            temp[$1] = PyDict_GetItem($11, $5);
            Py_INCREF(temp[$1]);
            if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$10;
            CLEARTEMP($0);
            CLEARTEMP($1);
            if (PyDict_SetItem($12, $6, temp[$2]) == -1) goto label_$10;
            CLEARTEMP($2);        
            """ , v2):
                TxRepl(o, i, """
                    if ((temp[$2] = _Direct_$7 ( PyDict_GetItem($9, $4) , PyDict_GetItem($11, $5) )) == 0) goto label_$10;
                    if (PyDict_SetItem($12, $6, temp[$2]) == -1) goto label_$10;
                    CLEARTEMP($2);        
                       """, v2)
                return True
        
    if 'PyInt_FromLong' in o[i]:
        if let_temp_PyInt_FromLong(o, i):
            return True

    if 'PyFloat_FromDouble' in o[i]:
        if TxMatch(o, i, """
            temp[$1] = PyFloat_FromDouble($10);
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1])$11);
            CLEARTEMP($1);
            """, v2):   
                TxRepl(o, i, """
                    temp[$2] = PyFloat_FromDouble(($10)$11);
                    """, v2)
                return True      

        if TxMatch(o, i, ('temp[$1] = PyFloat_FromDouble ($2);',
            'double_$3 = PyFloat_AsDouble ( temp[$1] );',
            'CLEARTEMP($1);'), v2):
                v2[2] = v2[2].strip()
                TxRepl(o, i, ('double_$3 = $2;',), v2)
                return True
        if TxMatch(o, i, ('temp[$1] = PyFloat_FromDouble ($3);',
            'if (PyFloat_CheckExact( temp[$0] )) {',
            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $5 PyFloat_AS_DOUBLE(temp[$1]));',
            '} else {',
            'if ((temp[$2] = PyNumber_$6 ( temp[$0] , temp[$1] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($0);',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyFloat_CheckExact( temp[$0] )) {',
                    'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $5 $3);',
                    '} else {',
                    'temp[$1] = PyFloat_FromDouble ($3);',
                    'if ((temp[$2] = PyNumber_$6 ( temp[$0] , temp[$1] )) == 0) goto $4;',
                    'CLEARTEMP($1);',
                    '}',
                    'CLEARTEMP($0);'), v2)
                return True 
        if TxMatch(o, i, ('temp[$0] = PyFloat_FromDouble ($5);',
                'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $6);',
                'CLEARTEMP($0);'), v2) and ('temp[' + v2[0] + ']') not in v2[6]:
                TxRepl(o, i, ('temp[$1] = PyFloat_FromDouble(($5) $6);',), v2)
                return True 

        if TxMatch(o, i, """
            temp[$0] = PyFloat_FromDouble ($11);
            int_$5 = PyFloat_CheckExact( temp[$0] );
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, ('int_$5 = 1;',), v2)
                return True 

    if 'PyBool_FromLong' in o[i]:
      
        if TxMatch(o, i, """
            temp[$0] = PyBool_FromLong($11);
            if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
            if ( int_$1 ) {
            """, v2):
                TxRepl(o, i, """
                    temp[$0] = PyBool_FromLong($11);
                    int_$1 = $11;
                    if ( int_$1 ) {
                                """, v2)        
                return True    
        if TxMatch(o, i, """
            temp[$0] = PyBool_FromLong($11);
            if ((int_$1 = PyObject_Not ( temp[$0] )) == -1) goto label_$10;
            if ( int_$1 ) {
            """, v2):
                TxRepl(o, i, """
                    temp[$0] = PyBool_FromLong($11);
                    int_$1 = !$11;
                    if ( int_$1 ) {
                                """, v2)        
                return True              

        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong($2);',
            'if (($1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $4;',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                if v2[2] != v2[1]:
                    TxRepl(o, i, ('$1 = $2;',), v2)
                else:    
                    TxRepl(o, i, ('$1 = $2;',), v2)
                return True
            
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong($2);',
            'if (($1 = PyObject_Not ( temp[$0] )) == -1) goto $4;',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                TxRepl(o, i, ('$1 = ! $2;',), v2)
                return True
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong($2);',
            '$1 = PyObject_IsTrue ( temp[$0] ));',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                if v2[2] != v2[1]:
                    TxRepl(o, i, ('$1 = $2;',), v2)
                else:    
                    TxRepl(o, i, (), v2)
                return True
            
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong($2);',
            '$1 = PyObject_Not ( temp[$0] ));',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                TxRepl(o, i, ('$1 = ! $2;',), v2)
                return True
            
            
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong ($2);',
            '$2 = PyObject_IsTrue ( temp[$0] );',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, (), v2)
                return True      
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong(int_$1);',
            'int_$1 = PyObject_IsTrue ( temp[$0] );',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, (), v2)
                return True
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong($1);',
            'if (($1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $2;'), v2):
                TxRepl(o, i, ('temp[$0] = PyBool_FromLong($1);',), v2)
                return True 
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong($1);',
            '$2 = PyObject_IsTrue(temp[$0]);',
            'CLEARTEMP($0);'), v2):
                v2[1] = v2[1].strip()
                TxRepl(o, i, ('$2 = $1;',), v2)                
                return True  
            
        if TxMatch(o, i, ('temp[$0] = PyBool_FromLong(int_$1);', 'CLEARTEMP($0);'), v2):
                TxRepl(o, i, (), v2)                
                return True  
                    
                        
        
    if 'PyString_FromStringAndSize' in o[i]:    
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            '$3 = PyString_AS_STRING(temp[$0])[0] $6 PyString_AS_STRING($4)[0];',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$3 = $2 $6 PyString_AS_STRING($4)[0];',), v2)
                return True
            
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$3, 1);',
            'if (PyString_CheckExact( temp[$0] ) && PyString_GET_SIZE( temp[$0] ) == 1) {',
            '$4 = (long)((unsigned char)*PyString_AS_STRING(temp[$0]));',
            'temp[$1] = PyInt_FromLong ( $4 );',
            '} else {',
            'if ((temp[$2] = PyTuple_New ( 1 )) == 0) goto $5;',
            'PyTuple_SET_ITEM ( temp[$2] , 0 , temp[$0] );',
            'temp[$0] = 0;',
            'if ((temp[$1] = PyCFunction_Call ( loaded_builtin[$6] , temp[$2] , NULL )) == 0) goto $5;',
            'CLEARTEMP($2);',
            '}',
            'Py_CLEAR(temp[$0]);'), v2):
                TxRepl(o, i, ('$4 = (long)((unsigned char)$3);',
                    'temp[$1] = PyInt_FromLong ( $4 );'), v2)
                return True                          
    
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            '$6 = PyString_AS_STRING(temp[$0])[0] $7 $5;',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$6 = $2 $7 $5;',), v2)
                return True 
                        
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$6, 1);',
            '$5 = c_Py_EQ_String(temp[$0], 1, \"$4\", $3);',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$5 = $6 == \'$4\';',), v2)
                return True 
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$6, 1);',
            '$5 = c_Py_NE_String(temp[$0], 1, \"$4\", $3);',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$5 = $6 != \'$4\';',), v2)
                return True 
                        
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            'temp[$1] = PyString_FromStringAndSize(&$3, 1);',
            '$6 = PyString_AS_STRING(temp[$0])[0] $4 PyString_AS_STRING(temp[$1])[0];',
            'CLEARTEMP($0);',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('$6 = $2 $4 $3;',), v2)
                return True         
        
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$3, 1);',
            'long_$1 = (long)((unsigned char)*PyString_AS_STRING(temp[$0]));',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('long_$1 = (long)((unsigned char)$3);',), v2)
                return True  
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            '$9 = *PyString_AS_STRING ( temp[$0] );',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$9 = $2;',), v2)
                return True  
                        
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            '$9 = *PyString_AS_STRING(temp[$0]);',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$9 = $2;',), v2)
                return True                                 
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize($2, 1);',
            '$9 = *PyString_AS_STRING ( temp[$0] );',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('$9 = *($2);',), v2)
                return True   
                        
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            'int_$1 = *PyString_AS_STRING(temp[$0]) $3 \'$4\';',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('int_$1 = $2 $3 \'$4\';',), v2)
                return True   
                            
        if TxMatch(o, i, ('temp[$0] = PyString_FromStringAndSize(&$4, 1);',
            'temp[$1] = PyString_FromStringAndSize(&$5, 1);',
            'int_$2 = *PyString_AS_STRING(temp[$0]) $3 *PyString_AS_STRING(temp[$1]);',
            'CLEARTEMP($0);',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('int_$2 = $4 $3 $5;',), v2)
                return True   
        if TxMatch(o, i, """
            temp[$0] = PyString_FromStringAndSize(&$1, 1);
            long_$2 = (long)((unsigned char)*PyString_AS_STRING ( temp[$0] ));
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    long_$2 = (long)$1;
                    """, v2)
                return True   
        
        if TxMatch(o, i, """
            temp[$0] = PyString_FromStringAndSize(&$2, 1);
            int_$1 = *PyString_AS_STRING ( temp[$0] ) $5 $6;
            CLEARTEMP($0);        
            """, v2):
                TxRepl(o, i, """
                    int_$1 = $2 $5 $6;
                    """, v2)
                return True   
        if TxMatch(o, i, """
            temp[$0] = PyString_FromStringAndSize(&$5, 1);
            temp[$1] = PyString_FromStringAndSize(&$4, 1);
            int_$2 = *PyString_AS_STRING ( temp[$0] ) $3 *PyString_AS_STRING ( temp[$1] );
            CLEARTEMP($0);
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    int_$2 = $5 $3 $4;
                    """, v2)
                return True   
        if TxMatch(o, i, """
            temp[$0] = 0;
            if ((temp[$0] = $1""", v2):
                TxRepl(o, i, """if ((temp[$0] = $1""", v2)
                return True           
        if TxMatch(o, i, """
            temp[$0] = 0;
            temp[$0] = $1;""", v2):
                TxRepl(o, i, """temp[$0] = $1""", v2)
                return True   
           
    return False
    
def let_temp_PyInt_FromLong(o, i):
    v2 = []
    if TxMatch(o, i, """    
        temp[$1] = PyInt_FromLong($11);
        Loc_$12 = PyInt_AsLong(temp[$1]);
        CLEARTEMP($1);
        """, v2) :
            TxRepl(o, i, """
                Loc_$12 = $11;
                    """, v2)
            return True    
    if TxMatch(o, i, """    
        temp[$0] = PyInt_FromLong ( long_$3 );
        if ((Py_ssize_t_$18 = PyObject_Size ( $1 )) == -1) goto label_$10;
        int_$11 = PyInt_AS_LONG ( temp[$0] ) $15 Py_ssize_t_$18;
        CLEARTEMP($0);    
        """, v2) and 'Py_ssize_t_' not in v2[3]:
            TxRepl(o, i, """
                if ((Py_ssize_t_$18 = PyObject_Size ( $1 )) == -1) goto label_$10;
                int_$11 = ( long_$3 ) $15 Py_ssize_t_$18;
                    """, v2)
            return True    
    if TxMatch(o, i, """    
        temp[$2] = PyInt_FromLong ( $1 );
        if (PyInt_CheckExact( $3 )) {
        >0
        } else {
        >1
        }
        CLEARTEMP($2);
        """, v2) and ('temp[%s]' % v2[2]) not in v2[3]:
            TxRepl(o, i, """
                if (PyInt_CheckExact( $3 )) {
                temp[$2] = PyInt_FromLong ( $1 );
                >0
                CLEARTEMP($2);
                } else {
                temp[$2] = PyInt_FromLong ( $1 );
                >1
                CLEARTEMP($2);
                }
                    """, v2)
            return True    
    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $3 );
        $1 = $11;
        long_$2 = PyInt_AS_LONG ( temp[$0] );
        """, v2) and ('temp[%s]' % v2[0]) not in v2[1] and ('temp[%s]' % v2[0]) not in v2[11] and v2[1] not in v2[3]:
            TxRepl(o, i, """
                long_$2 = $3;
                $1 = $11;
                temp[$0] = PyInt_FromLong ( long_$2 );
                """, v2)
            return True        

    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $2 );
        if ($3) {
        temp[$1] = PyInt_FromLong ( $4 );
        } else {
        temp[$1] = $5temp[$0]$6;
        }
        CLEARTEMP($0);
        """, v2) and ('temp[%s]' % v2[0]) not in v2[3] and ('temp[%s]' % v2[0]) not in v2[4]:
            TxRepl(o, i, """
                if ($3) {
                temp[$1] = PyInt_FromLong ( $4 );
                } else {
                temp[$0] = PyInt_FromLong ( $2 );
                temp[$1] = $5temp[$0]$6;
                CLEARTEMP($0);
                }
                """, v2)
            return True        

    
    if TxMatch(o, i, """
        temp[$2] = PyInt_FromLong ($10);
        if (PyInt_CheckExact( GETLOCAL(crc) ) && PyInt_CheckExact( temp[$2] )) {
        >0
        } else {
        >1
        }
        CLEARTEMP($2);
        """, v2):
            TxRepl(o, i, """
                if (PyInt_CheckExact( GETLOCAL(crc) )) {
                temp[$2] = PyInt_FromLong ($10);
                >0
                CLEARTEMP($2);
                } else {
                temp[$2] = PyInt_FromLong ($10);
                >1
                CLEARTEMP($2);
                }    
                """, v2)
            return True        
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($1);',
        'long_$4 = PyInt_AS_LONG ( temp[$0] );',
        'if ( long_$4 < 0) {',
        'long_$4 += $5;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('long_$4 = $1;',
                'if ( long_$4 < 0) {',
                'long_$4 += $5;',
                '}'), v2)
            return True
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($1);',
        '$2 = PyInt_AS_LONG ( temp[$0] ) $3;',
        'CLEARTEMP($0);'), v2):
            v2[1] = v2[1].strip()
            TxRepl(o, i, ('$2 = ($1) $3;',), v2)
            return True 
            
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        'if (PyInt_CheckExact( $1 )) {',
        '$3 = PyInt_AS_LONG ( $1 );',
        '$4 = PyInt_AS_LONG ( temp[$0] );',
        '$5 = $3 - $4;',
        'if (( $5 ^ $3 ) < 0 && ( $5 ^~ $4 ) < 0) goto $6 ;',
        'temp[$8] = PyInt_FromLong ( $5 );',
        '} else if (PyFloat_CheckExact( $1 )) {',
        'temp[$8] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - (double)PyInt_AS_LONG ( temp[$0] ));',
        '} else { $6 :;',
        'if ((temp[$8] = PyNumber_Subtract ( $1 , temp[$0] )) == 0) goto $7;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('if (PyInt_CheckExact( $1 )) {',
                '$3 = PyInt_AS_LONG ( $1 );',
                '$4 = $2;',
                '$5 = $3 - $4;',
                'if (( $5 ^ $3 ) < 0 && ( $5 ^~ $4 ) < 0) goto $6 ;',
                'temp[$8] = PyInt_FromLong ( $5 );',
                '} else if (PyFloat_CheckExact( $1 )) {',
                'temp[$8] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - (double)$2);',
                '} else { $6 :;',
                'temp[$0] = PyInt_FromLong ($2);',
                'if ((temp[$8] = PyNumber_Subtract ( $1 , temp[$0] )) == 0) goto $7;',
                'CLEARTEMP($0);',
                '}'), v2)
            return True
            
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        'if (PyInt_CheckExact( $1 )) {',
        '$3 = PyInt_AS_LONG ( $1 );',
        '$4 = PyInt_AS_LONG ( temp[$0] );',
        '$5 = $3 - $4;',
        'if (( $5 ^ $3 ) < 0 && ( $5 ^~ $4 ) < 0) goto $6 ;',
        'temp[$8] = PyInt_FromLong ( $5 );',
        '} else { $6 :;',
        'if ((temp[$8] = PyNumber_Subtract ( $1 , temp[$0] )) == 0) goto $7;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('if (PyInt_CheckExact( $1 )) {',
                '$3 = PyInt_AS_LONG ( $1 );',
                '$4 = $2;',
                '$5 = $3 - $4;',
                'if (( $5 ^ $3 ) < 0 && ( $5 ^~ $4 ) < 0) goto $6 ;',
                'temp[$8] = PyInt_FromLong ( $5 );',
                '} else { $6 :;',
                'temp[$0] = PyInt_FromLong ($2);',
                'if ((temp[$8] = PyNumber_Subtract ( $1 , temp[$0] )) == 0) goto $7;',
                'CLEARTEMP($0);',
                '}'), v2)
            return True
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] )$2);',
        'CLEARTEMP($0);',
        '$5 = PyInt_AS_LONG ( temp[$1] ) $3 $4;',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$5 = (PyInt_AS_LONG ( temp[$0] )$2) $3 $4;',
                        'CLEARTEMP($0);'), v2)
            return True
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        'if (PyInt_CheckExact( $3 )) {',
        '$4 = PyInt_AS_LONG ( temp[$0] );',
        '$5 = PyInt_AS_LONG ( $3 );',
        '$6 = $4 + $5;',
        'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) goto $7 ;',
        'temp[$1] = PyInt_FromLong ( $6 );',
        '} else if (PyFloat_CheckExact( $3 )) {',
        'temp[$1] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) + PyFloat_AS_DOUBLE($3));',
        '} else { $7 :;',
        'if ((temp[$1] = PyNumber_Add ( temp[$0] , $3 )) == 0) goto $8;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, (
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = $2;',
                '$5 = PyInt_AS_LONG ( $3 );',
                '$6 = $4 + $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) goto $7 ;',
                'temp[$1] = PyInt_FromLong ( $6 );',
                '} else if (PyFloat_CheckExact( $3 )) {',
                'temp[$1] = PyFloat_FromDouble((double)$2 + PyFloat_AS_DOUBLE($3));',
                '} else { $7 :;',
                'temp[$0] = PyInt_FromLong ($2);',
                'if ((temp[$1] = PyNumber_Add ( temp[$0] , $3 )) == 0) goto $8;',
                'CLEARTEMP($0);',
                '}'), v2)
            return True
            
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        'if (PyInt_CheckExact( $3 )) {',
        '$4 = PyInt_AS_LONG ( temp[$0] );',
        '$5 = PyInt_AS_LONG ( $3 );',
        '$6 = $4 + $5;',
        'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) goto $7 ;',
        'temp[$1] = PyInt_FromLong ( $6 );',
        '} else { $7 :;',
        'if ((temp[$1] = PyNumber_Add ( temp[$0] , $3 )) == 0) goto $8;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, (
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = $2;',
                '$5 = PyInt_AS_LONG ( $3 );',
                '$6 = $4 + $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) goto $7 ;',
                'temp[$1] = PyInt_FromLong ( $6 );',
                '} else { $7 :;',
                'temp[$0] = PyInt_FromLong ($2);',
                'if ((temp[$1] = PyNumber_Add ( temp[$0] , $3 )) == 0) goto $8;',
                'CLEARTEMP($0);',
                '}'), v2)
            return True

    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ( $1 );',
        'if (($3 = PyObject_Not ( temp[$0] )) == -1) goto $2;',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('$3 = ! $1;',), v2)
            return True
            
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ( $1 );',
        'if (PyInt_CheckExact( $2 )) {',
        '$3 = PyInt_AsSsize_t ( temp[$0] );',
        'CLEARTEMP($0);',
        '$4 = PyInt_AS_LONG ( $2 ) $5 $3;',
        '} else {',
        'if (($4 = PyObject_RichCompareBool ( $2 , temp[$0] , Py_$6 )) == -1) goto $7;',
        'CLEARTEMP($0);',
        '}'), v2):
            TxRepl(o, i, ('if (PyInt_CheckExact( $2 )) {',
                '$4 = PyInt_AS_LONG ( $2 ) $5 $1;',
                '} else {',
                'temp[$0] = PyInt_FromLong ( $1 );',
                'if (($4 = PyObject_RichCompareBool ( $2 , temp[$0] , Py_$6 )) == -1) goto $7;',
                'CLEARTEMP($0);',
                '}'), v2)
            return True            
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ($2);',
        'if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , $4 , temp[$1] )) == 0) goto $5;',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('if ((temp[$0] = __c_BINARY_SUBSCR_Int ( $3 , $4 )) == 0) goto $5;',), v2, ('__c_BINARY_SUBSCR_Int',))
            return True
    if TxMatch(o, i, """
        temp[$3] = PyInt_FromLong ( Loc_long_$4 );
        if ((temp[$2] = _c_BINARY_SUBSCR_Int ( temp[$1] , Py_ssize_t_$5 , temp[$3] )) == 0) goto label_$0;
        CLEARTEMP($3);""", v2):                        
            TxRepl(o, i, ('if ((temp[$2] = __c_BINARY_SUBSCR_Int ( temp[$1] , Py_ssize_t_$5 )) == 0) goto label_$0;',), v2, ('__c_BINARY_SUBSCR_Int',))
            return True
                        
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($11);',
        'if (PyInt_CheckExact( $2 )) {',
        'int_$1 = PyInt_AS_LONG ( $2 ) $4 PyInt_AS_LONG ( temp[$0] );',
        '} else {',
        'if ((int_$1 = PyObject_RichCompareBool ( $2 , temp[$0] , Py_$5 )) == -1) goto $6;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('if (PyInt_CheckExact( $2 )) {',
                'int_$1 = PyInt_AS_LONG ( $2 ) $4 $11;',
                '} else {',
                'temp[$0] = PyInt_FromLong ($11);',
                'if ((int_$1 = PyObject_RichCompareBool ( $2 , temp[$0] , Py_$5 )) == -1) goto $6;',
                'CLEARTEMP($0);',
                '}'), v2)
            return True
                    
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($5);',
        'if (1) {',
        '$4 = PyInt_AS_LONG ( temp[$0] );',
        '$3 = $4 + 1;',
        'if (( $3 ^ $4 ) < 0 && ( $3 ^ 1 ) < 0) goto $6 ;',
        'temp[$1] = PyInt_FromLong ( $3 );',
        '} else { $6 :;',
        'if ((temp[$1] = PyNumber_Add ( temp[$0] , $9 )) == 0) goto $7;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('if ($5 < INT_MAX) {',
                'temp[$1] = PyInt_FromLong ( $5 + 1 );',
                '} else {',
                'temp[$0] = PyInt_FromLong ($5);',
                'if ((temp[$1] = PyNumber_Add ( temp[$0] , $9 )) == 0) goto $7;',
                'CLEARTEMP($0);',
                '}'), v2)       
            return True
            
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        'if (($5 = $3) == -1) goto $4;',
        'if ((temp[$1] = PyInt_FromSsize_t ( $5 )) == 0) goto $4;',
        '$6 = PyInt_AS_LONG ( temp[$0] );',
        '$7 = PyInt_AS_LONG ( temp[$1] );',
        '$8 = $6 - $7;',
        'temp[$2] = PyInt_FromLong ( $8 );',
        'CLEARTEMP($0);',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$6 = $2;',
                'if (($7 = $3) == -1) goto $4;',
                'temp[$2] = PyInt_FromLong ( $6 - $7 );'), v2)      
            return True
                    
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        '$4 = PyInt_AS_LONG ( $3 );',
        '$5 = PyInt_AS_LONG ( temp[$0] );',
        '$6 = $4 + $5;',
        'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) {',
        'if ((temp[$1] = PyNumber_Add ( GETLOCAL(a) , temp[$0] )) == 0) goto $7;',
        '} else {',
        'temp[$1] = PyInt_FromLong ( $6 );',
        '}',
        'CLEARTEMP($0);'), v2):
            v2[2] = v2[2].strip()
            TxRepl(o, i, ('$4 = PyInt_AS_LONG ( $3 );',
                '$5 = $2;',
                '$6 = $4 + $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) {',
                'temp[$0] = PyInt_FromLong ($2);',
                'if ((temp[$1] = PyNumber_Add ( $3 , temp[$0] )) == 0) goto $7;',
                'CLEARTEMP($0);',
                '} else {',
                'temp[$1] = PyInt_FromLong ( $6 );',
                '}'), v2)
            return True 
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($3);',
        'if ((temp[$1] = PyInt_Type.tp_str ( temp[$0] )) == 0) goto $4;',
        'CLEARTEMP($0);',
        'temp[$0] = PyInt_FromLong ($3);',
        'if ((temp[$2] = PyInt_Type.tp_str ( temp[$0] )) == 0) goto $4;',
        'CLEARTEMP($0);'), v2):
            v2[3] = v2[3].strip()
            TxRepl(o, i, ('temp[$0] = PyInt_FromLong ($3);',
                'if ((temp[$1] = PyInt_Type.tp_str ( temp[$0] )) == 0) goto $4;',
                'CLEARTEMP($0);',
                'temp[$2] = temp[$1];',
                'Py_INCREF(temp[$2]);'), v2)
            return True 
                        
                        
    if TxMatch(o, i, ('temp[$2] = PyInt_FromLong ($3);',
        'CLEARTEMP($0);',
        '$4 = PyInt_AsLong(temp[$2]);',
        'CLEARTEMP($2);'), v2):
            TxRepl(o, i, ('$4 = ($3);',
                        'CLEARTEMP($0);'), v2)
            return True 
                
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        '$1 = PyInt_CheckExact( temp[$0] );',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('$1 = 1;',), v2)
            return True     
            
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ($3);',
        'CLEARTEMP($0);',
        'if ((int_$4 = PyObject_Not ( temp[$1] )) == -1) goto $2;',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('int_$4 = !($3);', 
                        'CLEARTEMP($0);'), v2)
            return True   
                        
    if TxMatch(o, i, ('temp[$4] = PyInt_FromLong ($1);',
        'if ((temp[$5] = PyObject_GetItem ( $2 , temp[$4] )) == 0) goto $0;',
        'CLEARTEMP($4);'), v2):
            v2[1] = v2[1].strip()
            TxRepl(o, i, ('if ((temp[$5] = __c_BINARY_SUBSCR_Int ( $2, $1 )) == 0) goto $0;',), v2, ('__c_BINARY_SUBSCR_Int',))
            return True   
    
    if TxMatch(o, i, ('temp[$4] = PyInt_FromLong ($1);',
        'if ((temp[$5] = PyObject_GetItem ( temp[$2] , temp[$4] )) == 0) goto $0;',
        'CLEARTEMP($4);'), v2):
            v2[1] = v2[1].strip()
            TxRepl(o, i, ('if ((temp[$5] = __c_BINARY_SUBSCR_Int ( temp[$2], $1 )) == 0) goto $0;',), v2, ('__c_BINARY_SUBSCR_Int',))
            return True   
            
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($3);',
        'if (($5 = $6) == -1) goto $4;',
        'if ((temp[$1] = PyInt_FromSsize_t ( $5 )) == 0) goto $4;',
        '$7 = PyInt_AS_LONG ( temp[$0] );',
        '$8 = PyInt_AS_LONG ( temp[$1] );',
        '$9 = $7 $10 $8;',
        'temp[$2] = PyInt_FromLong ( $9 );',
        'CLEARTEMP($0);',
        'CLEARTEMP($1);'), v2):
            v2[3] = v2[3].strip()
            TxRepl(o, i, ('$7 = $3;',
                '$8 = $6;',
                '$9 = $7 $10 $8;',
                'temp[$2] = PyInt_FromLong ( $9 );'), v2)
            return True   
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong (Loc_long_$4);',
        'if (Loc_long_$4 < INT_MAX) {',
        'temp[$3] = PyInt_FromLong ( Loc_long_$4 + 1 );',
        '} else {',
        'temp[$2] = PyInt_FromLong (Loc_long_$4);',
        'if ((temp[$3] = PyNumber_Add ( temp[$2] , $6 )) == 0) goto $5;',
        'CLEARTEMP(2);',
        '}',
        'if ( _PyEval_AssignSlice ( $7 , temp[$0] , temp[$3] , temp[$1] ) == -1) goto $5;',
        'CLEARTEMP(1);',
        'CLEARTEMP(0);',
        'CLEARTEMP(3);'), v2):
            TxRepl(o, i, ('if ( PySequence_SetSlice ( $7 , Loc_long_$4 , Loc_long_$4 + 1 , temp[$1] ) == -1) goto $5;',
                'CLEARTEMP(1);'), v2)
            return True  

    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ($1);
        if ($1 < $3) {
        temp[$2] = PyInt_FromLong ( $1 + $4 );
        } else {
        temp[$5] = PyInt_FromLong ($1);
        if ((temp[$2] = PyNumber_$6) == 0) goto label_$7;
        CLEARTEMP($5);
        }
        if ( _PyEval_AssignSlice ( $8 , temp[$0] , temp[$2] , temp[$9] ) == -1) goto label_$7;
        CLEARTEMP($9);
        CLEARTEMP($0);
        CLEARTEMP($2);
        """, v2):
            TxRepl(o, i, """
                if ($1 < $3) {
                if ( PySequence_SetSlice ( $8 , $1 , $1 + $4 , temp[$9] ) == -1) goto label_$7;
                } else {
                temp[$5] = PyInt_FromLong ($1);
                if ((temp[$2] = PyNumber_$6) == 0) goto label_$7;
                if ( _PyEval_AssignSlice ( $8 , temp[$5] , temp[$2] , temp[$9] ) == -1) goto label_$7;
                CLEARTEMP($0);
                CLEARTEMP($5);
                }
                CLEARTEMP($9);
                """, v2)
            return True  
    if TxMatch(o, i, """
        temp[$1] = PyInt_FromLong ($0);
        long_$3 = $0 $4 $5;
        temp[$2] = PyInt_FromLong ( long_$3 );
        if ( _PyEval_AssignSlice ( $6 , temp[$1] , temp[$2] , temp[$10] ) == -1) goto label_$11;
        CLEARTEMP($10);
        CLEARTEMP($1);
        CLEARTEMP($2);
        """, v2):
            TxRepl(o, i, """
                if ( PySequence_SetSlice ( $6 , $0 , $0 $4 $5 , temp[$10] ) == -1) goto label_$11;
                CLEARTEMP($10);
                """, v2)
            return True  

    if TxMatch(o, i, """
        temp[$1] = PyInt_FromLong ( $4 );
        if ( _PyEval_AssignSlice ( $3 , temp[$1] , NULL , temp[$0] ) == -1) goto label_$2;
        CLEARTEMP($0);
        CLEARTEMP($1);
        """, v2):
            TxRepl(o, i, """
                if ( PySequence_SetSlice ( $3 , $4 , PY_SSIZE_T_MAX , temp[$0] ) == -1) goto label_$2;
                CLEARTEMP($0);
                """, v2)
            return True  

    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $12 );
        if ((temp[$1] = _PyEval_ApplySlice ( $10 , NULL , temp[$0] )) == 0) goto label_$11;
        CLEARTEMP($0);""", v2):
            TxRepl(o, i, """    
                if ((temp[$1] = PySequence_GetSlice ( $10 , 0 , $12 )) == 0) goto label_$11;
                """,  v2)
            return True

    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($5);',
        '$6 = $5 + $10;',
        'temp[$1] = PyInt_FromLong ( $6 );',
        'if ((temp[$2] = _PyEval_ApplySlice ( $4 , temp[$0] , temp[$1] )) == 0) goto $3;',
        'CLEARTEMP($0);',
        'CLEARTEMP($1);'), v2):          
            TxRepl(o, i, ('if ((temp[$2] = PySequence_GetSlice ( $4 , $5 , $5 + $10 )) == 0) goto $3;',), v2)
            return True 
        
    if TxMatch(o, i, """                       
        temp[$0] = PyInt_FromLong ( $1 );
        long_$2 =  $1 ;
        long_$3 = long_$2 + $4;
        if ($12) goto label_$5 ;
        temp[$6] = PyInt_FromLong ( long_$3 );
        if (0) { label_$5 :;
        temp[$7] = PyInt_FromLong ( $1 );
        if ((temp[$6] = PyNumber_$9) == 0) goto label_$10;
        CLEARTEMP($7);
        }
        if ((temp[$8] = _PyEval_ApplySlice ( $11 , temp[$0] , temp[$6] )) == 0) goto label_$10;
        CLEARTEMP($0);
        CLEARTEMP($6);
        """, v2):          
            TxRepl(o, i, """
                long_$2 = $1;
                long_$3 = long_$2 + $4;
                if (!($12)) {
                if ((temp[$8] = PySequence_GetSlice ( $11 , $1 , long_$3 )) == 0) goto label_$10;
                } else {
                temp[$7] = PyInt_FromLong ( $1 );
                if ((temp[$6] = PyNumber_$9) == 0) goto label_$10;
                if ((temp[$8] = _PyEval_ApplySlice ( $11 , temp[$7] , temp[$6] )) == 0) goto label_$10;
                CLEARTEMP($7);
                CLEARTEMP($6);                       
                }
                    """, v2)
            return True 
                    
                        
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($2);',
        'if ((temp[$1] = _PyEval_ApplySlice ( $4 , temp[$0] , NULL )) == 0) goto $5;',
        'CLEARTEMP($0);'), v2):
            v2[2] = v2[2].strip()
            TxRepl(o, i, ('if ((temp[$1] = PySequence_GetSlice ( $4 , $2 , PY_SSIZE_T_MAX )) == 0) goto $5;',), v2)
            return True 
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong (Loc_long_$1);',
        'Py_ssize_t_$2 = PyInt_AsSsize_t ( temp[$0] );',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('Py_ssize_t_$2 = Loc_long_$1;',), v2)
            return True  
    if TxMatch(o, i, ('temp[$2] = PyInt_FromLong ($10);',
        'if (PyInt_CheckExact( $6 )) {',
        '$7 = PyInt_AS_LONG ( $6 );',
        '$8 = PyInt_AS_LONG ( temp[$2] );',
        '$9 = $7 + $8;',
        'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
        'temp[$3] = PyInt_FromLong ( $9 );',
        '} else if (PyFloat_CheckExact( $6 )) {',
        'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) + (double)PyInt_AS_LONG ( temp[$2] ));',
        '} else { $5 :;',
        'if ((temp[$3] = PyNumber_Add ( $6 , temp[$2] )) == 0) goto $4;',
        '}',
        'CLEARTEMP($2);'), v2):
            v2[10] = v2[10].strip()
            TxRepl(o, i, ('if (PyInt_CheckExact( $6 )) {',
                '$7 = PyInt_AS_LONG ( $6 );',
                '$8 = $10;',
                '$9 = $7 + $8;',
                'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                'temp[$3] = PyInt_FromLong ( $9 );',
                '} else if (PyFloat_CheckExact( $6 )) {',
                'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) + (double)$10);',
                '} else { $5 :;',
                'temp[$2] = PyInt_FromLong ($10);',
                'if ((temp[$3] = PyNumber_Add ( $6 , temp[$2] )) == 0) goto $4;',
                'CLEARTEMP($2);',
                '}'), v2)
            return True  
            
    if TxMatch(o, i, ('temp[$2] = PyInt_FromLong ($10);',
        'if (PyInt_CheckExact( $6 )) {',
        '$7 = PyInt_AS_LONG ( $6 );',
        '$8 = PyInt_AS_LONG ( temp[$2] );',
        '$9 = $7 + $8;',
        'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
        'temp[$3] = PyInt_FromLong ( $9 );',
        '} else { $5 :;',
        'if ((temp[$3] = PyNumber_Add ( $6 , temp[$2] )) == 0) goto $4;',
        '}',
        'CLEARTEMP($2);'), v2):
            v2[10] = v2[10].strip()
            TxRepl(o, i, ('if (PyInt_CheckExact( $6 )) {',
                '$7 = PyInt_AS_LONG ( $6 );',
                '$8 = $10;',
                '$9 = $7 + $8;',
                'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $5 ;',
                'temp[$3] = PyInt_FromLong ( $9 );',
                '} else { $5 :;',
                'temp[$2] = PyInt_FromLong ($10);',
                'if ((temp[$3] = PyNumber_Add ( $6 , temp[$2] )) == 0) goto $4;',
                'CLEARTEMP($2);',
                '}'), v2)
            return True  

    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ($5);',
        '$3 = PyInt_AS_LONG ( temp[$0] );',
        '$4 = $3 $6 1;',
        'temp[$1] = PyInt_FromLong ( $4 );',
        'CLEARTEMP($0);'), v2):
            v2[5] = v2[5].strip()
            TxRepl(o, i, ('$3 = $5;', '$4 = $3 $6 1;', 
                        'temp[$1] = PyInt_FromLong ( $4 );'), v2)                            
            return True  
                        
    if TxMatch(o, i, ('temp[$2] = PyInt_FromLong ($0);',
        '$3 = PyInt_AS_LONG ( temp[$2] );',
        'if ( $3 < 0) {',
        '$3 += PyList_GET_SIZE($1);',
        '}',
        'if ((temp[$11] = PyList_GetItem ( $1 , $3 )) == 0) goto $10;',
        'Py_INCREF(temp[$11]);',
        'CLEARTEMP($2);'), v2):
            TxRepl(o, i, ('$3 = $0;',
                'if ( $3 < 0) {',
                '$3 += PyList_GET_SIZE($1);',
                '}',
                'if ((temp[$11] = PyList_GetItem ( $1 , $3 )) == 0) goto $10;',
                'Py_INCREF(temp[$11]);'), v2)
            return True 
                        
    if TxMatch(o, i, ('temp[$2] = PyInt_FromLong ($8);',
        'if (($9 = $6) == -1) goto $7;',
        'if ((temp[$4] = PyInt_FromSsize_t ( $9 )) == 0) goto $7;',
        '$10 = PyInt_AS_LONG ( temp[$2] );',
        '$11 = PyInt_AS_LONG ( temp[$4] );',
        '$12 = $10 + $11;',
        'if (( $12 ^ $10 ) < 0 && ( $12 ^ $11 ) < 0) {',
        'if ((temp[$5] = PyNumber_Add ( temp[$2] , temp[$4] )) == 0) goto $7;',
        '} else {',
        'temp[$5] = PyInt_FromLong ( $12 );',
        '}',
        'CLEARTEMP($2);',
        'CLEARTEMP($4);'), v2):
            TxRepl(o, i, ('$10 = $8;',
                '$11 = $6;',
                '$12 = $10 + $11;',
                'if (( $12 ^ $10 ) < 0 && ( $12 ^ $11 ) < 0) {',
                'temp[$2] = PyInt_FromLong ( $10 );',
                'temp[$4] = PyInt_FromLong ( $11 );',
                'if ((temp[$5] = PyNumber_Add ( temp[$2] , temp[$4] )) == 0) goto $7;',
                'CLEARTEMP($2);',
                'CLEARTEMP($4);',                    
                '} else {',
                'temp[$5] = PyInt_FromLong ( $12 );',
                '}'), v2)
            return True  
    
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong (Loc_long_$2);',
        'if (1) {',
        '$3 = PyInt_AS_LONG ( temp[$0] );',
        '$4 = $3 - 1;',
        'if (( $4 ^ $3 ) < 0 && ( $4 ^~ 1 ) < 0) goto $6 ;',
        'temp[$1] = PyInt_FromLong ( $4 );',
        '} else { $6 :;',
        'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $5;',
        '}',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('temp[$1] = PyInt_FromLong ( Loc_long_$2 - 1 );',), v2)
            return True  

    v2 = []
    ## v3 = []
    if TextMatch(o[i], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2):
        patt = 'PyInt_AsLong(temp[' + v2[0] + '])'
        if i < (len(o) - 2) and patt in o[i+1] and\
        TextMatch(o[i+2], ('CLEARTEMP(', v2[0],');'), []):            
            o[i+1] = o[i+1].replace(patt, '(' + v2[1] + ')')
            del o[i+2]
            del o[i]
            return True
    if TextMatch(o[i], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2):
        patt = 'PyInt_AsLong ( temp[' + v2[0] + '] )'
        if i < (len(o) - 2) and patt in o[i+1] and\
        TextMatch(o[i+2], ('CLEARTEMP(', v2[0],');'), []):            
            o[i+1] = o[i+1].replace(patt, '(' + v2[1] + ')')
            del o[i+2]
            del o[i]
            return True
    v2 = []
    ## v3 = []
    if TextMatch(o[i], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2):
        patt = 'PyInt_AS_LONG ( temp[' + v2[0] + '] )'
        if i < (len(o) - 2) and patt in o[i+1] and\
        TextMatch(o[i+2], ('CLEARTEMP(', v2[0],');'), []):            
            o[i+1] = o[i+1].replace(patt, '(' + v2[1] + ')')
            del o[i+2]
            del o[i]
            return True

    if TxMatch(o, i, """
temp[$1] = PyInt_FromLong ($4);
if (($5 = PyObject_Size ( $8 )) == -1) goto $6;
if ((temp[$2] = PyInt_FromSsize_t ( $5 )) == 0) goto $6;
long_$9 = PyInt_AS_LONG ( temp[$1] );
long_$10 = PyInt_AS_LONG ( temp[$2] );
long_$11 = long_$9 + long_$10;
if (( long_$11 ^ long_$9 ) < 0 && ( long_$11 ^ long_$10 ) < 0) goto $7 ;
temp[$3] = PyInt_FromLong ( long_$11 );
if (1) {
} else { $7 :;
if ((temp[$3] = PyNumber_Add ( temp[$1] , temp[$2] )) == 0) goto $6;
}
CLEARTEMP($1);
CLEARTEMP($2);
""", v2):    
            TxRepl(o, i, """
long_$9 = $4;
if ((long_$10 = PyObject_Size ( $8 )) == -1) goto $6;
long_$11 = long_$9 + long_$10;
if (( long_$11 ^ long_$9 ) < 0 && ( long_$11 ^ long_$10 ) < 0) goto $7 ;
temp[$3] = PyInt_FromLong ( long_$11 );
if (0) { $7 :;
temp[$1] = PyInt_FromLong ($4);
if ((temp[$2] = PyInt_FromSsize_t ( long_$10 )) == 0) goto $6;
if ((temp[$3] = PyNumber_Add ( temp[$1] , temp[$2] )) == 0) goto $6;
CLEARTEMP($1);
CLEARTEMP($2);
}
""", v2)
    
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ($2);
long_$3 = PyInt_AS_LONG ( temp[$0] );
long_$4 = long_$3 + $8;
if (( long_$4 ^ long_$3 ) < 0 && ( long_$4 ^ $8 ) < 0) goto $6 ;
temp[$1] = PyInt_FromLong ( long_$4 );
if (1) {
} else { $6 :;
if ((temp[$1] = PyNumber_Add ( temp[$0] , $7 )) == 0) goto $5;
}
CLEARTEMP($0);
""", v2):    
            TxRepl(o, i, """
long_$3 = $2;
long_$4 = long_$3 + $8;
if (( long_$4 ^ long_$3 ) < 0 && ( long_$4 ^ $8 ) < 0) goto $6 ;
temp[$1] = PyInt_FromLong ( long_$4 );
if (0) { $6 :;
temp[$0] = PyInt_FromLong ($2);
if ((temp[$1] = PyNumber_Add ( temp[$0] , $7 )) == 0) goto $5;
CLEARTEMP($0);
}
""", v2)
            return True
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ($4);
long_$3 = PyInt_AS_LONG ( temp[$0] );
temp[$1] = PyInt_FromLong ( long_$3 $5 );
CLEARTEMP($0);
""", v2):
        TxRepl(o, i, """
temp[$1] = PyInt_FromLong ( ($4) $5 );
""", v2)      
        return True  
    
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ($2);
if ((int_$1 = PyObject_Not ( temp[$0] )) == -1) goto $3;
CLEARTEMP($0);
""", v2):
        TxRepl(o, i, """
int_$1 = !($2);
""", v2)      
        return True  
    
    if TxMatch(o, i, """
temp[$1] = PyInt_FromLong ($2);
long_$3 = PyInt_AS_LONG ( temp[$1] );
long_$6 = long_$3 * $5;
if (long_$6 / $5 == long_$3) {
temp[$12] = PyInt_FromLong (long_$6);
} else {
temp[$12] = PyInt_Type.tp_as_number->nb_multiply(consts[$10], temp[$1]);
}
CLEARTEMP($1); 
""", v2):
        TxRepl(o, i, """
long_$3 = $2;
long_$6 = long_$3 * $5;
if (long_$6 / $5 == long_$3) {
temp[$12] = PyInt_FromLong (long_$6);
} else {
temp[$1] = PyInt_FromLong (long_$3);
temp[$12] = PyInt_Type.tp_as_number->nb_multiply(consts[$10], temp[$1]);
CLEARTEMP($1); 
}
""", v2)      
        return True  
    
    if TxMatch(o, i, """                        
temp[$0] = PyInt_FromLong ($2);
long_$3 = PyInt_AS_LONG ( temp[$0] );
long_$4 = long_$3 * $12;
if (long_$4 / $12 == long_$3) {
temp[$1] = PyInt_FromLong (long_$4);
} else {
temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], consts[$5]);
}
CLEARTEMP($0);
""", v2):                       
        TxRepl(o, i, """                        
long_$3 = $2;
long_$4 = long_$3 * $12;
if (long_$4 / $12 == long_$3) {
temp[$1] = PyInt_FromLong (long_$4);
} else {
temp[$0] = PyInt_FromLong ($2);
temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], consts[$5]);
CLEARTEMP($0);
}
""", v2)
        return True
    
    if TxMatch(o, i, """                        
temp[$2] = PyInt_FromLong ($4);
if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$2] )) {
temp[$0] = PyInt_FromLong (PyInt_AS_LONG ( temp[$1] ) $12 PyInt_AS_LONG ( temp[$2] ));
} else {
if ((temp[$0] = PyNumber_$11 ( temp[$1] , temp[$2] )) == 0) goto label_$10;
}
CLEARTEMP($1);
CLEARTEMP($2);
""", v2):                       
        TxRepl(o, i, """                        
if (PyInt_CheckExact( temp[$1] )) {
temp[$0] = PyInt_FromLong (PyInt_AS_LONG ( temp[$1] ) $12 ($4));
} else {
temp[$2] = PyInt_FromLong ($4);
if ((temp[$0] = PyNumber_$11 ( temp[$1] , temp[$2] )) == 0) goto label_$10;
CLEARTEMP($2);
}
CLEARTEMP($1);
""", v2)
        return True
    
    if TxMatch(o, i, """                        
temp[$2] = PyInt_FromLong ($4);
if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( temp[$2] )) {
temp[$0] = PyInt_FromLong (PyInt_AS_LONG ( $1 ) $12 PyInt_AS_LONG ( temp[$2] ));
} else {
if ((temp[$0] = PyNumber_$11 ( $1 , temp[$2] )) == 0) goto label_$10;
}
CLEARTEMP($2);
""", v2):                       
        TxRepl(o, i, """                        
if (PyInt_CheckExact( $1 )) {
temp[$0] = PyInt_FromLong (PyInt_AS_LONG ( $1 ) $12 ($4));
} else {
temp[$2] = PyInt_FromLong ($4);
if ((temp[$0] = PyNumber_$11 ( $1 , temp[$2] )) == 0) goto label_$10;
CLEARTEMP($2);
}
""", v2)
        return True
    
    if TxMatch(o, i, """                        
temp[$1] = PyInt_FromLong ($10);
long_$4 = PyInt_AS_LONG ( temp[$1] );
long_$3 = $11;
if ($12) goto label_$18 ;
temp[$2] = PyInt_FromLong ( long_$3 );
if (1) {
} else { label_$18 :;
if ((temp[$2] = $15) == 0) goto label_$0;
}
CLEARTEMP($1);
""", v2):                       
        TxRepl(o, i, """                        
long_$4 = $10;
long_$3 = $11;
if ($12) goto label_$18 ;
temp[$2] = PyInt_FromLong ( long_$3 );
if (1) {
} else { label_$18 :;
temp[$1] = PyInt_FromLong ($10);
if ((temp[$2] = $15) == 0) goto label_$0;
CLEARTEMP($1);
}
""", v2)
        return True
    
    if TxMatch(o, i, """                        
temp[$0] = PyInt_FromLong ( $10 );
long_$3 = PyInt_AS_LONG ( temp[$0] );
long_$4 = long_$3 * $2;
if (long_$4 / $2 == long_$3) {
temp[$1] = PyInt_FromLong ( long_$4 );
} else {
temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $11);
}
CLEARTEMP($0);    
""", v2):                       
        TxRepl(o, i, """                        
long_$3 = $10;
long_$4 = long_$3 * $2;
if (long_$4 / $2 == long_$3) {
temp[$1] = PyInt_FromLong ( long_$4 );
} else {
temp[$0] = PyInt_FromLong ( $10 );
temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $11);
CLEARTEMP($0);    
}
""", v2)
        
        
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ( $1 );',
        'int_$3 = PyInt_AS_LONG ( temp[$0] ) $4;',
        'CLEARTEMP($0);'), v2) and ('temp[' + v2[0] + ']') not in v2[4]:
            TxRepl(o, i, ('int_$3 = ($1) $4;',), v2)
            return True 
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $2 );',
        'if ((temp[$4] = _PyEval_ApplySlice ( $5 , temp[$1] , NULL )) == 0) goto $3;',
        'CLEARTEMP($1);'), v2):
            v2[2] = v2[2].strip()
            TxRepl(o, i, ('if ((temp[$4] = PySequence_GetSlice ( $5 , $2 , PY_SSIZE_T_MAX )) == 0) goto $3;',), v2)
            return True 
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $2 );',
        'temp[$0] = 0;',
        'if (PyInt_CheckExact( $3 )) {',
        '$4 = PyInt_AS_LONG ( $3 ) $7 PyInt_AS_LONG ( temp[$1] );',
        '} else {',
        'if (($4 = PyObject_RichCompareBool ( $3 , temp[$1] , Py_$6 )) == -1) goto $5;',
        '}',
        'CLEARTEMP($1);'), v2) and v2[0] != v2[1]:
            TxRepl(o, i, ('temp[$0] = 0;',
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = PyInt_AS_LONG ( $3 ) $7 $2;',
                '} else {',
                'temp[$1] = PyInt_FromLong ( $2 );',
                'if (($4 = PyObject_RichCompareBool ( $3 , temp[$1] , Py_$6 )) == -1) goto $5;',
                'CLEARTEMP($1);',
                '}'), v2)
            return True
            
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $2 );',
        'if (PyInt_CheckExact( $3 )) {',
        '$4 = PyInt_AS_LONG ( $3 ) $7 PyInt_AS_LONG ( temp[$1] );',
        '} else {',
        'if (($4 = PyObject_RichCompareBool ( $3 , temp[$1] , Py_$6 )) == -1) goto $5;',
        '}',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('if (PyInt_CheckExact( $3 )) {',
                '$4 = PyInt_AS_LONG ( $3 ) $7 $2;',
                '} else {',
                'temp[$1] = PyInt_FromLong ( $2 );',
                'if (($4 = PyObject_RichCompareBool ( $3 , temp[$1] , Py_$6 )) == -1) goto $5;',
                'CLEARTEMP($1);',
                '}'), v2)
            return True
                        
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $3 );',
        'CLEARTEMP($2);',
        '$3 = PyInt_AsLong ( temp[$1] );',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('CLEARTEMP($2);',), v2)
            return True                  
    
    
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $2 );',
        '$3 = PyInt_AS_LONG ( temp[$1] );',
        '$4 = $3 + 1;',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$3 = $2;',
                '$4 = $3 + 1;'), v2)
            return True                          
    
        
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ($2);',
        'if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , $4 , temp[$1] )) == 0) goto $5;',
        'CLEARTEMP($1);'), v2):
            v2[2] = v2[2].strip()
            TxRepl(o, i, ('if ((temp[$0] = __c_BINARY_SUBSCR_Int ( $3 , $4 )) == 0) goto $5;',), v2, ('__c_BINARY_SUBSCR_Int',))
            return True
    
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ($2);',
        '$4 = PyInt_AsLong(temp[$1]);',
        'CLEARTEMP($1);'), v2):
            v2[2] = v2[2].strip()
            v2[4] = v2[4].strip()
            TxRepl(o, i, ('$4 = $2;',), v2)
            return True
    
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $0 );',
        '$3 = PyInt_AsLong(temp[$1]);',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$3 = $0;',), v2)
            return True
                        
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( int_$2 );',
        '$4 = PyInt_AsLong(temp[$1]);', # 1202 line 1238
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$4 = int_$2;',), v2)
            return True
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $3 );',
            '$2 = PyInt_AS_LONG ( temp[$1] );',
            'CLEARTEMP($1);'), v2):                
                TxRepl(o, i, ('$2 = $3;',), v2)
                return True 
    
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $4 );',
        'if (PyInt_CheckExact( $3 )) {',
        '$5 = PyInt_AS_LONG ( $3 );',
        '$6 = PyInt_AS_LONG ( temp[$1] );',
        '$7 = $5 - $6;',
        'if (( $7 ^ $5 ) < 0 && ( $7 ^~ $6 ) < 0) goto $8 ;',
        'temp[$0] = PyInt_FromLong ( $7 );',
        '} else if (PyFloat_CheckExact( $3 )) {',
        'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - (double)PyInt_AS_LONG ( temp[$1] ));',
        '} else { $8 :;',
        'if ((temp[$0] = PyNumber_InPlaceSubtract ( $3 , temp[$1] )) == 0) goto $2;',
        '}',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$6 = $4;',
                'if (PyInt_CheckExact( $3 )) {',
                '$5 = PyInt_AS_LONG ( $3 );',
                '$7 = $5 - $6;',
                'if (( $7 ^ $5 ) < 0 && ( $7 ^~ $6 ) < 0) goto $8 ;',
                'temp[$0] = PyInt_FromLong ( $7 );',
                '} else if (PyFloat_CheckExact( $3 )) {',
                'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - (double)( $6 ));',
                '} else { $8 :;',
                'temp[$1] = PyInt_FromLong ( $6 );',
                'if ((temp[$0] = PyNumber_InPlaceSubtract ( $3 , temp[$1] )) == 0) goto $2;',
                'CLEARTEMP($1);',
                '}'), v2)
            return True                
                    
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ( $2 );',
        'CLEARTEMP($1);',
        '$6 = PyInt_AsLong ( temp[$0] );',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('$6 = $2;',
                'CLEARTEMP($1);'), v2)
            return True    
                        
    if TxMatch(o, i, ('temp[$2] = PyInt_FromLong ( long_$1 );',
        'CLEARTEMP($0);',
        'long_$1 = PyInt_AS_LONG ( temp[$2] );',
        'long_$1 = long_$1 + 1;',
        'CLEARTEMP($2);'), v2):              
            TxRepl(o, i, ('CLEARTEMP($0);', 'long_$1 = long_$1 + 1;'), v2)
            return True    
                                    
                        
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ( $1 );',
        '$2 = PyInt_AS_LONG ( temp[$0] );',
        '$3 = $2 * $5;',
        'if ($3 / $5 == $2) {',
        'temp[$11] = PyInt_FromLong ($3);',
        '} else {',
        'temp[$11] = PyInt_Type.tp_as_number->nb_multiply(consts[$4], temp[$0]);',
        '}',
        'CLEARTEMP($0);'),v2):
            TxRepl(o, i, ('$2 = $1;',
                '$3 = $2 * $5;',
                'if ($3 / $5 == $2) {',
                'temp[$11] = PyInt_FromLong ($3);',
                '} else {',
                'temp[$0] = PyInt_FromLong ( $2 );',                    
                'temp[$11] = PyInt_Type.tp_as_number->nb_multiply(consts[$4], temp[$0]);',
                'CLEARTEMP($0);',
                '}'), v2)
            return True  
    
    
    
    if TxMatch(o, i, ('temp[$1] = PyInt_FromLong ( $4 );',
        '$2 = PyInt_AsSsize_t ( temp[$1] );',
        'CLEARTEMP($1);'), v2):
            TxRepl(o, i, ('$2 = $4;',), v2)
            return True  
                                        
    if TxMatch(o, i, ('temp[$0] = PyInt_FromLong ( $3 );',
        'if ((temp[$1] = PyObject_GetItem ( $4 , temp[$0] )) == 0) goto $2;',
        'CLEARTEMP($0);'), v2):
            TxRepl(o, i, ('if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $4 , $3 )) == 0) goto $2;',), v2, ('__c_BINARY_SUBSCR_Int',))
            return True   
        
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $3 );
temp[$2] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] ) << $8);
CLEARTEMP($0);
""", v2):
        TxRepl(o, i, """
temp[$2] = PyInt_FromLong (($3) << $8);
""", v2)      
        return True  
        
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $3 );
temp[$2] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] ) >> $8);
CLEARTEMP($0);
""", v2):
        TxRepl(o, i, """
temp[$2] = PyInt_FromLong (($3) >> $8);
""", v2)      
        return True  
        
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $5 );
temp[$1] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] ) $11);
CLEARTEMP($0);    
""", v2):
        TxRepl(o, i, """
temp[$1] = PyInt_FromLong (($5) $11);
""", v2)      
        return True  
    
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $3 );
if (PyInt_CheckExact( temp[$1] )) {
long_$6 = PyInt_AS_LONG ( temp[$1] );
long_$7 = PyInt_AS_LONG ( temp[$0] );
long_$8 = long_$6 $9 long_$7;
if ($10) goto $5 ;
temp[$2] = PyInt_FromLong ( long_$8 );
} else if (PyFloat_CheckExact( temp[$1] )) {
temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) + (double)PyInt_AS_LONG ( temp[$0] ));
} else { $5 :;
if ((temp[$2] = PyNumber_Add ( temp[$1] , temp[$0] )) == 0) goto $4;
}
CLEARTEMP($1);
CLEARTEMP($0);  
""", v2): 
                TxRepl(o, i, """
if (PyInt_CheckExact( temp[$1] )) {
long_$7 = $3;
long_$6 = PyInt_AS_LONG ( temp[$1] );
long_$8 = long_$6 $9 long_$7;
if ($10) goto $5 ;
temp[$2] = PyInt_FromLong ( long_$8 );
} else if (PyFloat_CheckExact( temp[$1] )) {
temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) + (double)($3));
} else { $5 :;
temp[$0] = PyInt_FromLong ( $3 );
if ((temp[$2] = PyNumber_Add ( temp[$1] , temp[$0] )) == 0) goto $4;
CLEARTEMP($0);  
}
CLEARTEMP($1);
""", v2) 
                return True
                    
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( long_$14 );
long_$3 = PyInt_AS_LONG ( temp[$0] );
long_$4 = long_$3 * $6;
if (long_$4 / $6 == long_$3) {
temp[$2] = PyInt_FromLong (long_$4);
} else {
temp[$2] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $7);
}
CLEARTEMP($0);                
""", v2): 
                TxRepl(o, i, """
long_$3 = long_$14;
long_$4 = long_$3 * $6;
if (long_$4 / $6 == long_$3) {
temp[$2] = PyInt_FromLong (long_$4);
} else {
temp[$0] = PyInt_FromLong ( long_$3 );
temp[$2] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $7);
CLEARTEMP($0);                
}
""", v2) 
                return True
    
    if TxMatch(o, i, """
temp[$2] = PyInt_FromLong ( $10 );
if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$2] )) {
temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $4 PyInt_AS_LONG ( temp[$2] ) );
} else {
if ((temp[$0] = PyNumber_$5 ( temp[$1] , temp[$2] )) == 0) goto $6;
}
CLEARTEMP($1);
CLEARTEMP($2);    
""", v2): 
                TxRepl(o, i, """
if (PyInt_CheckExact( temp[$1] )) {
temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $4 ($10) );
} else {
temp[$2] = PyInt_FromLong ( $10 );
if ((temp[$0] = PyNumber_$5 ( temp[$1] , temp[$2] )) == 0) goto $6;
CLEARTEMP($2);   
}
CLEARTEMP($1);
""", v2) 
                return True
    
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $5 );
long_$3 = PyInt_AS_LONG ( temp[$0] );
long_$2 = $4;
temp[$1] = PyInt_FromLong ( long_$2 );
CLEARTEMP($0);
""", v2): 
                TxRepl(o, i, """
long_$3 = $5;
long_$2 = $4;
temp[$1] = PyInt_FromLong ( long_$2 );
""", v2) 
                return True
        
    if TxMatch(o, i, """
temp[$1] = PyInt_FromLong ( $10 );
long_$5 = PyInt_AS_LONG ( temp[$1] );
long_$6 = $7;
if ($8) {
temp[$2] = PyInt_FromLong ( long_$6 );
} else {
temp[$2] = PyInt_Type.tp_as_number->nb$9;
}
CLEARTEMP($1);
""", v2): 
                TxRepl(o, i, """
long_$5 = $10;
long_$6 = $7;
if ($8) {
temp[$2] = PyInt_FromLong ( long_$6 );
} else {
temp[$1] = PyInt_FromLong ( $10 );
temp[$2] = PyInt_Type.tp_as_number->nb$9;
CLEARTEMP($1);
}
""", v2) 
                return True
    
    if TxMatch(o, i, """
temp[$1] = PyInt_FromLong ( $10 );
if (PyInt_CheckExact( $11 )) {
long_$5 = PyInt_AS_LONG ( temp[$1] );
long_$7 = PyInt_AS_LONG ( $11 );
long_$4 = long_$5 $6 long_$7;
if ($9) goto $8 ;
temp[$2] = PyInt_FromLong ( long_$4 );
} else if (PyFloat_CheckExact( $11 )) {
temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$1] ) $6 PyFloat_AS_DOUBLE($11));
} else { $8 :;
if ((temp[$2] = PyNumber_$12) == 0) goto $13;
}
CLEARTEMP($1);
""", v2): 
                TxRepl(o, i, """
if (PyInt_CheckExact( $11 )) {
long_$5 = $10;
long_$7 = PyInt_AS_LONG ( $11 );
long_$4 = long_$5 $6 long_$7;
if ($9) goto $8 ;
temp[$2] = PyInt_FromLong ( long_$4 );
} else if (PyFloat_CheckExact( $11 )) {
temp[$2] = PyFloat_FromDouble((double)($10) $6 PyFloat_AS_DOUBLE($11));
} else { $8 :;
temp[$1] = PyInt_FromLong ( $10 );
if ((temp[$2] = PyNumber_$12) == 0) goto $13;
CLEARTEMP($1);
}
""", v2) 
                return True
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $10 );
if (PyInt_CheckExact( temp[$1] )) {
long_$12 = PyInt_AS_LONG ( temp[$1] );
long_$14 = PyInt_AS_LONG ( temp[$0] );
long_$15;
if ($16) goto label_$7 ;
temp[$2] = PyInt_FromLong ( long_$17 );
} else if (PyFloat_CheckExact( temp[$1] )) {
temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) + (double)PyInt_AS_LONG ( temp[$0] ));
} else { label_$7 :;
if ((temp[$2] = PyNumber_$18) == 0) goto label_$11;
}
CLEARTEMP($1);
CLEARTEMP($0);
""", v2): 
                TxRepl(o, i, """
if (PyInt_CheckExact( temp[$1] )) {
long_$12 = PyInt_AS_LONG ( temp[$1] );
long_$14 = ($10);
long_$15;
if ($16) goto label_$7 ;
temp[$2] = PyInt_FromLong ( long_$17 );
} else if (PyFloat_CheckExact( temp[$1] )) {
temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) + (double)($10));
} else { label_$7 :;
temp[$0] = PyInt_FromLong ( $10 );
if ((temp[$2] = PyNumber_$18) == 0) goto label_$11;
CLEARTEMP($0);
}
CLEARTEMP($1);
""", v2) 
                return True
                
    if TxMatch(o, i, """
temp[$0] = PyInt_FromLong ( $7 );
if (PyInt_CheckExact( $3 )) {
long_$4 = PyInt_AS_LONG ( $3 );
long_$5 = PyInt_AS_LONG ( temp[$0] );
long_$2 = long_$4 + long_$5;
if (( long_$2 ^ long_$4 ) < 0 && ( long_$2 ^ long_$5 ) < 0) goto label_$6 ;
temp[$1] = PyInt_FromLong ( long_$2 );
} else if (PyFloat_CheckExact( $3 )) {
temp[1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + (double)PyInt_AS_LONG ( temp[$0] ));
} else { label_$6 :;
if ((temp[1] = PyNumber_$9Add ( $3 , temp[$0] )) == 0) goto label_$10;
}
CLEARTEMP($0);
""", v2): 
                TxRepl(o, i, """
if (PyInt_CheckExact( $3 )) {
long_$4 = PyInt_AS_LONG ( $3 );
long_$5 = $7;
long_$2 = long_$4 + long_$5;
if (( long_$2 ^ long_$4 ) < 0 && ( long_$2 ^ long_$5 ) < 0) goto label_$6 ;
temp[$1] = PyInt_FromLong ( long_$2 );
} else if (PyFloat_CheckExact( $3 )) {
temp[1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + (double)($7));
} else { label_$6 :;
temp[$0] = PyInt_FromLong ( $7 );
if ((temp[1] = PyNumber_$9Add ( $3 , temp[$0] )) == 0) goto label_$10;
CLEARTEMP($0);
}
""", v2) 
                return True 


    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $1 );
        if ( PyObject_SetAttr ( $3 ) == -1) goto label_$4;
        CLEARTEMP($0);
        temp[$0] = PyInt_FromLong ( $1 );
            """, v2): 
                TxRepl(o, i, """
                    temp[$0] = PyInt_FromLong ( $1 );
                    if ( PyObject_SetAttr ( $3 ) == -1) goto label_$4;
                        """, v2) 
                return True 
    return False                
                
def tune_if_dotcomma(o, i):
    v2 = []
    if 'PyString_AsStringAndSize' in o[i]:
        if TxMatch(o, i, """
            if ( PyString_AsStringAndSize ( $0 , &charref_$4 , &Py_ssize_t_$3 ) == -1) goto label_$10;
            int_$11 = $16;
            if ( !int_$11 ) {
            if ( PyString_AsStringAndSize ( $0 , &charref_$4 , &Py_ssize_t_$3 ) == -1) goto label_$10;
            int_$11 = $17;
            }""", v2):   
                TxRepl(o, i, """
                    if ( PyString_AsStringAndSize ( $0 , &charref_$4 , &Py_ssize_t_$3 ) == -1) goto label_$10;
                    int_$11 = $16;
                    if ( !int_$11 ) {
                    int_$11 = $17;
                    }""", v2)
                return True         
        if TxMatch(o, i, """
            if ( PyString_AsStringAndSize ( $0 , &$1 , &$12 ) == -1) goto label_$3;
            int_$4 = $12 - $7;
            charref_$5 = $1 + int_$4;
            int_$6 = ($12 >= $7 && 0 == memcmp($8, charref_$5, $7));
            """, v2):   
                TxRepl(o, i, """
                    if ( PyString_AsStringAndSize ( $0 , &$1 , &$12 ) == -1) goto label_$3;
                    int_$6 = ($12 >= $7 && 0 == memcmp($8, $1 + ($12 - $7), $7));
                    """, v2)
                return True   

    if o[i].startswith('if ((Py_ssize_t_'):     
        if TxMatch(o, i, """
            if ((Py_ssize_t_$2 = PyObject_Size ( temp[$0] )) == -1) goto label_$10;
            CLEARTEMP($0);
            long_$3 = Py_ssize_t_$2;""", v2):   
                TxRepl(o, i, """
                       if ((long_$3 = PyObject_Size ( temp[$0] )) == -1) goto label_$10;
                       CLEARTEMP($0);""", v2)
                return True 
        if TxMatch(o, i, """
            if ((Py_ssize_t_$1 = $2) == -1) goto $3;
            Loc_long_$4 = ( Py_ssize_t_$1 );""", v2):
                TxRepl(o, i, "if ((Loc_long_$4 = $2) == -1) goto $3;", v2)
                return True 
        if TxMatch(o, i, """
            if ((Py_ssize_t_$2 = $5) == -1) goto label_$0;
            long_$3 =  Py_ssize_t_$2  $9;
            if (PyInt_CheckExact( $6 )) {
            int_$1 = PyInt_AS_LONG ( $6 ) $8  long_$3 ;
            } else {
            temp[$4] = PyInt_FromLong ( long_$3 );
            if ((int_$1 = PyObject_RichCompareBool ( $6 , temp[$4] , Py_$7 )) == -1) goto label_$0;
            CLEARTEMP($4);
            }
            """, v2):
                TxRepl(o, i, """
                if ((Py_ssize_t_$2 = $5) == -1) goto label_$0;
                if (PyInt_CheckExact( $6 )) {
                int_$1 = PyInt_AS_LONG ( $6 ) $8 (Py_ssize_t_$2 $9);
                } else {
                temp[$4] = PyInt_FromLong ( Py_ssize_t_$2 $9 );
                if ((int_$1 = PyObject_RichCompareBool ( $6 , temp[$4] , Py_$7 )) == -1) goto label_$0;
                CLEARTEMP($4);
                }
                """, v2)
                return True 
            

        if TxMatch(o, i, """
            if ((Py_ssize_t_$8 = $10 )) == -1) goto label_$4;
            temp[$1] = PyInt_FromLong ( Py_ssize_t_$8 );
            long_$7 = PyInt_AS_LONG ( temp[$1] );
            long_$6 = $9 + long_$7;
            if (( long_$6 ^ $9 ) < 0 && ( long_$6 ^ long_$7 ) < 0) goto label_$5 ;
            temp[$2] = PyInt_FromLong ( long_$6 );
            if (1) {
            } else { label_$5 :;
            temp[$3] = PyInt_FromLong ( $9 );
            if ((temp[$2] = PyNumber_Add ( temp[$3] , temp[$1] )) == 0) goto label_$4;
            CLEARTEMP($3);
            }
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    if ((long_$7 = $10 )) == -1) goto label_$4;
                    long_$6 = $9 + long_$7;
                    if (( long_$6 ^ $9 ) < 0 && ( long_$6 ^ long_$7 ) < 0) {
                    temp[$1] = PyInt_FromLong ( long_$7 );
                    temp[$3] = PyInt_FromLong ( $9 );
                    if ((temp[$2] = PyNumber_Add ( temp[$3] , temp[$1] )) == 0) goto label_$4;
                    CLEARTEMP($3);
                    CLEARTEMP($1);
                    } else {
                    temp[$2] = PyInt_FromLong ( long_$6 );
                    }
                """, v2) ### line 32938
                return True 

    elif o[i].startswith('if ((int_'):     
        if '_Direct_' in o[i]:
            if TxMatch(o, i, ('if ((int_$8 = _Direct_$19;',
                'Loc_int_$2 = int_$8;'), v2):
                    TxRepl(o, i, ('if ((Loc_int_$2 = _Direct_$19;',), v2)
                    return True 
            if TxMatch(o, i, ('if ((int_$8 = _Direct_$19;',
                'CLEARTEMP($0);',
                'Loc_int_$2 = int_$8;'), v2):
                    TxRepl(o, i, ('if ((Loc_int_$2 = _Direct_$19;',
                        'CLEARTEMP($0);'), v2)
                    return True 
            if TxMatch(o, i, ('if ((int_$8 = _Direct_$19;',
                'CLEARTEMP($0);',
                'CLEARTEMP($1);',
                'Loc_int_$2 = int_$8;'), v2):
                    TxRepl(o, i, ('if ((Loc_int_$2 = _Direct_$19;',
                        'CLEARTEMP($0);',
                        'CLEARTEMP($1);'), v2)
                    return True 
            if TxMatch(o, i, ('if ((int_$3 = _Direct_$1) == -1) goto label_$0;',
                'int_$2 = int_$3;'), v2):
                    TxRepl(o, i, ('if ((int_$2 = _Direct_$1) == -1) goto label_$0;',), v2)
                    return True   
                            
        
            if TxMatch(o, i, ('if ((int_$2 = _Direct_$0) == -1) goto $3;',
                'CLEARTEMP($4);',
                'int_$1 = int_$2;',
                'if ( int_$1 ) {'), v2) and v2[2] != v2[1]:
                    TxRepl(o, i, ('if ((int_$1 = _Direct_$0) == -1) goto $3;',
                        'CLEARTEMP($4);',
                        'if ( int_$1 ) {'), v2)      
                    return True
                
            if TxMatch(o, i, ('if ((int_$2 = _Direct_$0) == -1) goto $3;',
                'CLEARTEMP($4);',
                'int_$1 = int_$2;',
                '}'), v2) and v2[2] != v2[1]:
                    TxRepl(o, i, ('if ((int_$1 = _Direct_$0) == -1) goto $3;',
                        'CLEARTEMP($4);',
                        '}'), v2)      
                    return True       
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'temp[$0] = PyBool_FromLong($2);',
                '$12 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = _Direct_$5) == -1) goto $3;',), v2)
                    return True    
                            
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$12 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = _Direct_$5) == -1) goto $3;',), v2)
                    return True                     
                
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'CLEARTEMP($6);',              
                'temp[$0] = PyBool_FromLong($2);',
                '$12 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = _Direct_$5) == -1) goto $3;',
                                'CLEARTEMP($6);'), v2)
                    return True    
                            
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'CLEARTEMP($6);',              
                'if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$12 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = _Direct_$5) == -1) goto $3;',
                                'CLEARTEMP($6);'), v2)
                    return True     
                
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'CLEARTEMP($6);',              
                'CLEARTEMP($7);',              
                'if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$12 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = _Direct_$5) == -1) goto $3;',
                                'CLEARTEMP($6);',
                                'CLEARTEMP($7);'), v2)
                    return True     
                            
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$12 = PyObject_Not ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = !_Direct_$5) == -1) goto $3;',), v2)
                    return True                     
                
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'CLEARTEMP($6);',              
                'if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$12 = PyObject_Not ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = !_Direct_$5) == -1) goto $3;',
                                'CLEARTEMP($6);'), v2)
                    return True     
                
            if TxMatch(o, i, ('if (($2 = _Direct_$5) == -1) goto $3;',
                'CLEARTEMP($6);',              
                'CLEARTEMP($7);',              
                'if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$12 = PyObject_Not ( temp[$0] );',
                'CLEARTEMP($0);'), v2) and v2[2] != v2[12]:
                    TxRepl(o, i, ('if (($12 = !_Direct_$5) == -1) goto $3;',
                                'CLEARTEMP($6);',
                                'CLEARTEMP($7);'), v2)
                    return True                   

        if TxMatch(o, i, """
            if ((int_$1 = $9temp[$10]$11) == -1) goto label_$0;
            CLEARTEMP($10);
            Loc_int_$3 = int_$1;
            """, v2): 
                    TxRepl(o, i, """
                        if ((Loc_int_$3 = $9temp[$10]$11) == -1) goto label_$0;
                        CLEARTEMP($10);
                        """, v2) 
                    return True
    
        if TxMatch(o, i, """
            if ((int_$3 = $4) == -1) goto label_$0;
            Loc_int_$5 = int_$3;
            """, v2): 
                    TxRepl(o, i, """
                        if ((Loc_int_$5 = $4) == -1) goto label_$0;
                        """, v2) 
                    return True

            
    elif o[i].startswith('if ((temp['):     
        if 'SUBSCR' in o[i]:
            if i+1 < len(o) and o[i+1].startswith('int_'):
                if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                    'int_$1 = $12;',
                    'CLEARTEMP($0);',
                    'if (!( int_$1 )) {',
                    'if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                    'int_$1 = $11;',
                    'CLEARTEMP($0);',
                    '}'), v2):
                        TxRepl(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                            'int_$1 = ($12) || ($11);',
                            'CLEARTEMP($0);'), v2)
                        return True  
                if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                    'int_$1 = $12;',
                    'CLEARTEMP($0);',
                    'if ( !int_$1 ) {',
                    'if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                    'int_$1 = $11;',
                    'CLEARTEMP($0);',
                    '}'), v2):
                        TxRepl(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                            'int_$1 = ($12) || ($11);',
                            'CLEARTEMP($0);'), v2)
                        return True  
                if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                    'int_$1 = $12;',
                    'CLEARTEMP($0);',
                    'if ( int_$1 ) {',
                    'if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                    'int_$1 = $11;',
                    'CLEARTEMP($0);',
                    '}'), v2):
                        TxRepl(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;',
                            'int_$1 = ($12) && ($11);',
                            'CLEARTEMP($0);'), v2)
                        return True  
            ## if ' , consts[' in o[i]:
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , 0 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_0 ( $3 )) == 0) goto $5;',), v2, ('_GET_ITEM_0',))
                        ## return True
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , -1 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_LAST ( $3 )) == 0) goto $5;',), v2, ('_GET_ITEM_LAST',))
                        ## return True
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , 1 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_1 ( $3 )) == 0) goto $5;',), v2, ('_GET_ITEM_1',))
                        ## return True
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , 2 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_2 ( $3 )) == 0) goto $5;',), v2, ('_GET_ITEM_2',))
                        ## return True 
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( temp[$3] , 0 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_0 ( temp[$3] )) == 0) goto $5;',), v2, ('_GET_ITEM_0',))
                        ## return True
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( temp[$3] , -1 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_LAST ( temp[$3] )) == 0) goto $5;',), v2, ('_GET_ITEM_LAST',))
                        ## return True
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( temp[$3] , 1 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_1 ( temp[$3] )) == 0) goto $5;',), v2, ('_GET_ITEM_1',))
                        ## return True
                ## if TxMatch(o, i, ('if ((temp[$0] = _c_BINARY_SUBSCR_Int ( temp[$3] , 2 , consts[$9] )) == 0) goto $5;',), v2):
                        ## TxRepl(o, i, ('if ((temp[$0] = _GET_ITEM_2 ( temp[$3] )) == 0) goto $5;',), v2, ('_GET_ITEM_2',))
                        ## return True 
        if 'PyList_GetItem' in o[i]:
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = _Direct_$12 ( temp[$0] )) == 0) goto label_$11;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    if ((temp[$1] = _Direct_$12 ( temp[$0] )) == 0) goto label_$11;
                    temp[$0] = 0;""", v2)
                        return True 
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($11)) == 0) goto label_$10;
                    Py_INCREF(temp[$0]);
                    if (($15 = _Direct_$12(temp[$0])) == -1) goto label_$10;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                            if ((temp[$0] = PyList_GetItem ($11)) == 0) goto label_$10;
                            if (($15 = _Direct_$12(temp[$0])) == -1) goto label_$10;
                            temp[$0] = 0;""", v2)
                        return True 
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($16)) == 0) goto label_$15;
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyList_GetItem ($16)) == 0) goto label_$15;
                    Py_INCREF(temp[$1]);
                    if (($11 = _Direct_$12($13)) == $14) goto label_$15;
                    CLEARTEMP($0);
                    CLEARTEMP($1);
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$0] = PyList_GetItem ($16)) == 0) goto label_$15;
                            if ((temp[$1] = PyList_GetItem ($16)) == 0) goto label_$15;
                            if (($11 = _Direct_$12($13)) == $14) goto label_$15;
                            temp[$0] = 0;
                            temp[$1] = 0;""", v2)
                        return True 
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    Py_INCREF(temp[$0]);
                    if (($5 = _Direct_$12 ( temp[$0] ))$6) goto label_$11;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    if (($5 = _Direct_$12 ( temp[$0] ))$6) goto label_$11;
                    temp[$0] = 0;""", v2)
                        return True     
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    Py_INCREF(temp[$0]);
                    if (($5 = _Direct_$12 ($7temp[$0]$8))$6) goto label_$11;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    if (($5 = _Direct_$12 ($7temp[$0]$8))$6) goto label_$11;
                    temp[$0] = 0;""", v2)
                        return True  
        if 'PyFloat_FromDouble' in o[i]:    
            if TxMatch(o, i, ('if ((temp[$0] = PyFloat_FromDouble ( double_$1 )) == 0) goto $9;',
                'if ((double_$1 = PyFloat_AsDouble ( temp[$0] )) == -1) goto $9;',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, (), v2)
                    return True 
            if TxMatch(o, i, ('if ((temp[$0] = PyFloat_FromDouble ( $2 )) == 0) goto $3;',
                'if ((double_$4 = PyFloat_AsDouble ( temp[$0] )) == -1) goto $3;',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('double_$4 = $2;',), v2)
                    return True 
            if TxMatch(o, i, """
                if ((temp[$0] = PyFloat_FromDouble ( $3 )) == 0) goto label_$15;
                int_$5 = PyFloat_AS_DOUBLE( temp[$0] ) $10;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """int_$5 = ( $3 ) $10;""", v2)
                    return True 
    
        if '_PyEval_ApplySlice' in o[i]:    
            if TxMatch(o, i, ('if ((temp[$1] = _PyEval_ApplySlice ( $3 , $4 , NULL )) == 0) goto $5;',
                'if (PyInt_CheckExact( $7 ) && PyInt_CheckExact( temp[$1] )) {',
                '$8 = PyInt_AS_LONG ( $7 );',
                '$9 = PyInt_AS_LONG ( temp[$1] );',
                '$10 = $8 + $9;',
                'if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $6 ;',
                'temp[$2] = PyInt_FromLong ( $10 );',
                '} else if (PyFloat_CheckExact( $7 ) && PyFloat_CheckExact( temp[$1] )) {',
                'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($7) + PyFloat_AS_DOUBLE(temp[$1]));',
                '} else { $6 :;',
                'if ((temp[$2] = PyNumber_Add ( $7 , temp[$1] )) == 0) goto $5;',
                '}'), v2):
                    TxRepl(o, i, ('if ((temp[$1] = _PyEval_ApplySlice ( $3 , $4 , NULL )) == 0) goto $5;',
                        'if ((temp[$2] = PyNumber_Add ( $7 , temp[$1] )) == 0) goto $5;'), v2)
                    return True            
                
                
            if TxMatch(o, i, ('if ((temp[$1] = _PyEval_ApplySlice ( $3 , $4 , NULL )) == 0) goto $5;',
                'if (PyInt_CheckExact( $7 ) && PyInt_CheckExact( temp[$1] )) {',
                '$8 = PyInt_AS_LONG ( $7 );',
                '$9 = PyInt_AS_LONG ( temp[$1] );',
                '$10 = $8 + $9;',
                'if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $6 ;',
                'temp[$2] = PyInt_FromLong ( $10 );',
                '} else { $6 :;',
                'if ((temp[$2] = PyNumber_Add ( $7 , temp[$1] )) == 0) goto $5;',
                '}'), v2):
                    TxRepl(o, i, ('if ((temp[$1] = _PyEval_ApplySlice ( $3 , $4 , NULL )) == 0) goto $5;',
                        'if ((temp[$2] = PyNumber_Add ( $7 , temp[$1] )) == 0) goto $5;'), v2)
                    return True    
        if 'PyBool_FromLong' in o[i]:    
            if TxMatch(o, i, """
                if ((temp[$1] = PyBool_FromLong ($9)) == 0) goto label_$0;
                if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$0;
                CLEARTEMP($1);""", v2):            
                    TxRepl(o, i, """
                        if ((int_$3 = ! ($9)) == -1) goto label_$0;""", v2)
                    return True     
            if TxMatch(o, i, ('if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;',
                '$2 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, (), v2)
                    return True     
            if TxMatch(o, i, ('if ((temp[$0] = PyBool_FromLong ($6)) == 0) goto $3;',
                'SETLOCAL ( $1 , temp[$0] );',
                'temp[$0] = 0;',
                'if ((int_$4 = PyObject_IsTrue ( GETLOCAL($1) )) == -1) goto $3;'), v2):
                    v2[6] = v2[6].strip()
                    TxRepl(o, i, ('int_$4 = $6;',
                                'if ((temp[$0] = PyBool_FromLong ( int_$4 )) == 0) goto $3;',
                        'SETLOCAL ( $1 , temp[$0] );',
                        'temp[$0] = 0;'), v2)
                    return True 
            if TxMatch(o, i, ('if ((temp[$0] = PyBool_FromLong ( $1 )) == 0) goto $3;',
                'int_$2 = PyObject_IsTrue ( temp[$0] );',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('int_$2 = $1;',), v2)
                    return True                   
                        
            if TxMatch(o, i, ('if ((temp[$1] = PyBool_FromLong ( $2 )) == 0) goto $0;',
                'if (($3 = PyObject_IsTrue ( temp[$1] )) == -1) goto $0;',
                'CLEARTEMP($1);'), v2):
                    TxRepl(o, i, ('$3 = ($2);',), v2)
                    return True     
            if TxMatch(o, i, ('if ((temp[$0] = PyBool_FromLong ($1)) == 0) goto $5;',
                '$2 = PyObject_IsTrue(temp[$0]);',
                'CLEARTEMP($0);'), v2):
                    v2[1] = v2[1].strip()
                    TxRepl(o, i, ('$2 = $1;',), v2)                
                    return True  
            if TxMatch(o, i, """
                if ((temp[$0] = PyBool_FromLong ( int_$10 )) == 0) goto label_$12;
                if ((temp[$1] = PyTuple_New ( 1 )) == 0) goto label_$12;
                PyTuple_SET_ITEM ( temp[$1] , 0 , temp[$0] );
                if ((temp[$0] = PyBool_Type.tp_new ( &PyBool_Type , temp[$1] , NULL )) == 0) goto label_$12;
                CLEARTEMP($1);
                int_$10 = PyObject_IsTrue ( temp[$0] );""", v2):
                    TxRepl(o, i, '', v2)                
                    return True  
            if TxMatch(o, i, """
                if ((temp[$0] = PyBool_FromLong ( int_$10 )) == 0) goto label_$12;
                if ((temp[$1] = PyTuple_New ( 1 )) == 0) goto label_$12;
                PyTuple_SET_ITEM ( temp[$1] , 0 , temp[$0] );
                if ((temp[$0] = PyBool_Type.tp_new ( &PyBool_Type , temp[$1] , NULL )) == 0) goto label_$12;
                CLEARTEMP($1);
                int_$15 = PyObject_IsTrue ( temp[$0] );""", v2):
                    TxRepl(o, i, ('int_$15 = int_$10;',), v2)                
                    return True  
                
            if TxMatch(o, i, ('if ((temp[$4] = PyBool_FromLong ($1)) == 0) goto $5;',
                'CLEARTEMP($0);',
                'if (($2 = PyObject_IsTrue ( temp[$4] )) == -1) goto $5;',
                'CLEARTEMP($4);'), v2):
                    v2[1] = v2[1].strip()
                    TxRepl(o, i, ('$2 = $1;',
                                'CLEARTEMP($0);'), v2)                
                    return True  

            if TxMatch(o, i, """
                if ((temp[$2] = PyBool_FromLong ( $6 )) == 0) goto label_$5;
                if ((temp[$3] = PyTuple_New ( 1 )) == 0) goto label_$5;
                PyTuple_SET_ITEM ( temp[$3] , 0 , temp[$2] );
                if ((temp[$2] = PyBool_Type.tp_new ( &PyBool_Type , temp[$3] , NULL )) == 0) goto label_$5;
                CLEARTEMP($3);
                if ((int_$7 = PyObject_IsTrue ( temp[$2] )) == -1) goto label_$5;
                CLEARTEMP($2);
                """, v2):
                    TxRepl(o, i, """int_$7 = $6;""", v2)
                    return True  


        if 'PyInt_FromSsize_t' in o[i]:
            if TxMatch(o, i, ('if ((temp[$1] = PyInt_FromSsize_t ($2)) == 0) goto $3;',
                    'Py_ssize_t_$4 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);'), v2):  
                v2[3] = v2[3].strip()
                TxRepl(o, i, ('Py_ssize_t_$4 = $2;',), v2)
                return True
            
            
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;',
                'if (PyInt_CheckExact( $2 )) {',
                '$5 = PyInt_AS_LONG ( $2 );',
                '$6 = PyInt_AS_LONG ( temp[$0] );',
                '$7 = $5 + $6;',
                'if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;',
                'temp[$11] = PyInt_FromLong ( $7 );',
                '} else if (PyFloat_CheckExact( $2 )) {',
                'temp[$11] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + (double)PyInt_AS_LONG ( temp[$0] ));',
                '} else { $4 :;',
                'if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;',
                '}',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $2 )) {',
                        '$5 = PyInt_AS_LONG ( $2 );',
                        '$6 = $1;',
                        '$7 = $5 + $6;',
                        'if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;',
                        'temp[$11] = PyInt_FromLong ( $7 );',
                        '} else if (PyFloat_CheckExact( $2 )) {',
                        'temp[$11] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + (double)($1));',
                        '} else { $4 :;',
                        'if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;',
                        'if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;',
                        'CLEARTEMP($0);'
                        '}'), v2)
                    return True
                
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;',
                'if (PyInt_CheckExact( $2 )) {',
                '$5 = PyInt_AS_LONG ( $2 );',
                '$6 = PyInt_AS_LONG ( temp[$0] );',
                '$7 = $5 + $6;',
                'if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;',
                'temp[$11] = PyInt_FromLong ( $7 );',
                '} else { $4 :;',
                'if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;',
                '}',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $2 )) {',
                        '$5 = PyInt_AS_LONG ( $2 );',
                        '$6 = $1;',
                        '$7 = $5 + $6;',
                        'if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;',
                        'temp[$11] = PyInt_FromLong ( $7 );',
                        '} else { $4 :;',
                        'if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;',
                        'if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;',
                        'CLEARTEMP($0);'
                        '}'), v2)
                    return True

            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $2;',
                '$3 = PyInt_AsLong(temp[$0]);',
                'Py_CLEAR(temp[$0]);',
                'temp[$0] = 0;'), v2):
                    TxRepl(o, i, ('$3 = $1;',), v2)
                    return True   
                
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ($2)) == 0) goto $3;',
                'long_$5 = PyInt_AS_LONG ( temp[$0] );',
                'long_$4 = long_$5 - $6;',
                'temp[$1] = PyInt_FromLong ( long_$4 );',
                'CLEARTEMP($0);'), v2):
                    v2[2] = v2[2].strip()
                    TxRepl(o, i, ('long_$4 = ($2) - $6;', 
                                'temp[$1] = PyInt_FromLong ( long_$4 );'), v2)
                    return True
                
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ($2)) == 0) goto $3;',
                'long_$5 = PyInt_AS_LONG ( temp[$0] );',
                'long_$4 = long_$5 + $6;',
                'temp[$1] = PyInt_FromLong ( long_$4 );',
                'CLEARTEMP($0);'), v2):
                    v2[2] = v2[2].strip()
                    TxRepl(o, i, ('long_$4 = ($2) + $6;', 
                                'temp[$1] = PyInt_FromLong ( long_$4 );'), v2)
                    return True
                                            
            if TxMatch(o, i, ('if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = PyInt_AS_LONG ( $3 );',
                '$5 = PyInt_AS_LONG ( temp[$1] );',
                '$6 = $4 - $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                'temp[$2] = PyInt_FromLong ( $6 );',
                '} else if (PyFloat_CheckExact( $3 )) {',
                'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - (double)PyInt_AS_LONG ( temp[$1] ));',
                '} else { $7 :;',
                'if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;',
                '}',
                'CLEARTEMP($1);'),v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $3 )) {',
                        '$4 = PyInt_AS_LONG ( $3 );',
                        '$5 = $10;',
                        '$6 = $4 - $5;',
                        'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                        'temp[$2] = PyInt_FromLong ( $6 );',
                        '} else if (PyFloat_CheckExact( $3 )) {',
                        'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - (double)$10);',
                        '} else { $7 :;',
                        'if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                        'if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;',
                        'CLEARTEMP($1);'
                        '}'), v2)
                    return True
                
            if TxMatch(o, i, ('if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = PyInt_AS_LONG ( $3 );',
                '$5 = PyInt_AS_LONG ( temp[$1] );',
                '$6 = $4 - $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                'temp[$2] = PyInt_FromLong ( $6 );',
                '} else { $7 :;',
                'if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;',
                '}',
                'CLEARTEMP($1);'),v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $3 )) {',
                        '$4 = PyInt_AS_LONG ( $3 );',
                        '$5 = $10;',
                        '$6 = $4 - $5;',
                        'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                        'temp[$2] = PyInt_FromLong ( $6 );',
                        '} else { $7 :;',
                        'if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                        'if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;',
                        'CLEARTEMP($1);'
                        '}'), v2)
                    return True
                
                
            if TxMatch(o, i, ('if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = PyInt_AS_LONG ( temp[$1] );',
                '$5 = PyInt_AS_LONG ( $3 );',
                '$6 = $4 - $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                'temp[$2] = PyInt_FromLong ( $6 );',
                '} else if (PyFloat_CheckExact( $3 )) {',
                'temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$1] ) - PyFloat_AS_DOUBLE($3));',
                '} else { $7 :;',
                'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;',
                '}',
                'CLEARTEMP($1);'),v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $3 )) {',
                        '$4 = $10;',
                        '$5 = PyInt_AS_LONG ( $3 );',
                        '$6 = $4 - $5;',
                        'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                        'temp[$2] = PyInt_FromLong ( $6 );',
                        '} else if (PyFloat_CheckExact( $3 )) {',
                        'temp[$2] = PyFloat_FromDouble((double)$10 - PyFloat_AS_DOUBLE($3));',
                        '} else { $7 :;',
                        'if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                        'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;',
                        'CLEARTEMP($1);',
                        '}'), v2)
                    return True
                
            if TxMatch(o, i, ('if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                'if (PyInt_CheckExact( $3 )) {',
                '$4 = PyInt_AS_LONG ( temp[$1] );',
                '$5 = PyInt_AS_LONG ( $3 );',
                '$6 = $4 - $5;',
                'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                'temp[$2] = PyInt_FromLong ( $6 );',
                '} else { $7 :;',
                'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;',
                '}',
                'CLEARTEMP($1);'),v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $3 )) {',
                        '$4 = $10;',
                        '$5 = PyInt_AS_LONG ( $3 );',
                        '$6 = $4 - $5;',
                        'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                        'temp[$2] = PyInt_FromLong ( $6 );',
                        '} else { $7 :;',
                        'if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;',
                        'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;',
                        'CLEARTEMP($1);'
                        '}'), v2)
                    return True
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;',
                'if ((long_$4 = PyInt_AsLong ( temp[$0] )) == -1) goto $3;',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('long_$4 = $1;',), v2)
                    return True

            if TxMatch(o, i, ('if ((temp[$19] = PyInt_FromSsize_t ( $17 )) == 0) goto $12;',
                'if ($11) {',
                'long_$18 = PyInt_AS_LONG ( temp[$19] );',                         
                'if ((int_$3 = $14) == -1) goto $12;',
                'temp[$0] = PyBool_FromLong(int_$3);',
                '} else {',
                'if ((temp[$2] = $15) == 0) goto $12;',
                'if ((temp[$0] = $16) == 0) goto $12;',
                'CLEARTEMP($2);',
                '}',
                'CLEARTEMP($19);',
                'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;',
                'CLEARTEMP($0);'), v2) and v2[19] != v2[0] and v2[19] != v2[2] and ('temp[' + v2[19] + ']') not in v2[14]:
                    TxRepl(o, i, ('if ($11) {',
                        'long_$18 = $17;',                         
                        'if ((int_$1 = $14) == -1) goto $12;',
                        '} else {',
                        'if ((temp[$19] = PyInt_FromSsize_t ( $17 )) == 0) goto $12;',
                        'if ((temp[$2] = $15) == 0) goto $12;',
                        'if ((temp[$0] = $16) == 0) goto $12;',
                        'CLEARTEMP($2);',
                        'CLEARTEMP($19);',                    
                        'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;',
                        'CLEARTEMP($0);',
                        '}'), v2)
                    return True 

            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $2;',
                '$3 = PyInt_AS_LONG ( temp[$0] );',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('$3 = $1;',), v2)
                    return True 
                
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $8 )) == 0) goto $4;',
                'if (PyInt_CheckExact( $2 )) {',
                '$5 = PyInt_AS_LONG ( $2 );',
                '$6 = PyInt_AS_LONG ( temp[$0] );',
                '$7 = $5 + $6;',
                'if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $3 ;',
                'temp[$1] = PyInt_FromLong ( $7 );',
                '} else { $3 :;',
                'if ((temp[$1] = PyNumber_Add ( $2 , temp[$0] )) == 0) goto $4;',
                '}',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $2 )) {',
                        '$5 = PyInt_AS_LONG ( $2 );',
                        '$6 = $8;',
                        '$7 = $5 + $6;',
                        'if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $3 ;',
                        'temp[$1] = PyInt_FromLong ( $7 );',
                        '} else { $3 :;',
                        'if ((temp[$0] = PyInt_FromSsize_t ( $8 )) == 0) goto $4;',                                        
                        'if ((temp[$1] = PyNumber_Add ( $2 , temp[$0] )) == 0) goto $4;',
                        'CLEARTEMP($0);',
                        '}'), v2)
                    return True 
                                
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromSsize_t ( $2 )) == 0) goto $3;',
                '$4 = PyInt_AS_LONG ( temp[$0] );',
                '$5 = $6 - $4;',
                'temp[$1] = PyInt_FromLong ( $5 );',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('$4 = $2;',
                        '$5 = $6 - $4;',
                        'temp[$1] = PyInt_FromLong ( $5 );'), v2)
                    return True             

            if TxMatch(o, i, ('if ((temp[$2] = PyInt_FromSsize_t ( $7 )) == 0) goto $6;',
                'if (PyInt_CheckExact( $4 )) {',
                '$8 = PyInt_AS_LONG ( $4 );',
                '$9 = PyInt_AS_LONG ( temp[$2] );',
                '$10 = $8 + $9;',
                'if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $5 ;',
                'temp[$3] = PyInt_FromLong ( $10 );',
                '} else if (PyFloat_CheckExact( $4 )) {',
                'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) + (double)PyInt_AS_LONG ( temp[$2] ));',
                '} else { $5 :;',
                'if ((temp[$3] = PyNumber_Add ( $4 , temp[$2] )) == 0) goto $6;',
                '}',
                'CLEARTEMP($2);'), v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $4 )) {',
                        '$8 = PyInt_AS_LONG ( $4 );',
                        '$9 = $7;',
                        '$10 = $8 + $9;',
                        'if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $5 ;',
                        'temp[$3] = PyInt_FromLong ( $10 );',
                        '} else if (PyFloat_CheckExact( $4 )) {',
                        'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) + (double)$7);',
                        '} else { $5 :;',
                        'if ((temp[$2] = PyInt_FromSsize_t ( $7 )) == 0) goto $6;',                    
                        'if ((temp[$3] = PyNumber_Add ( $4 , temp[$2] )) == 0) goto $6;',
                        'CLEARTEMP($2);',
                        '}'), v2)
                    return True   
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $2 )) == 0) goto $5;
                if ((temp[$1] = _PyEval_ApplySlice ( $4 , temp[$0] , NULL )) == 0) goto $5;
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, ('if ((temp[$1] = PySequence_GetSlice ( $4 , $2 , PY_SSIZE_T_MAX )) == 0) goto $5;',), v2)
                    return True 

        if 'PyTuple_New' in o[i]:
            if TxMatch(o, i, """
                if ((temp[$1] = PyTuple_New ( 1 )) == 0) goto label_$2;
                PyTuple_SET_ITEM ( temp[$1] , 0 , temp[$0] );
                if ((temp[$0] = PyBool_Type.tp_new ( &PyBool_Type , temp[$1] , NULL )) == 0) goto label_$2;
                CLEARTEMP($1);
                int_$3 = PyObject_IsTrue ( temp[$0] );
                """, v2):
                    TxRepl(o, i, ('if ((int_$3 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$2;',), v2)
                    return True 
            if TxMatch(o, i, """
                if ((temp[$1] = PyTuple_New ( 1 )) == 0) goto label_$2;
                PyTuple_SET_ITEM ( temp[$1] , 0 , temp[$0] );
                if ((temp[$0] = PyBool_Type.tp_new ( &PyBool_Type , temp[$1] , NULL )) == 0) goto label_$2;
                CLEARTEMP($1);
                if ((int_$3 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$2;
                """, v2):
                    TxRepl(o, i, ('if ((int_$3 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$2;',), v2)
                    return True 


        v2 = []
        v3 = []
        
        
        if 'PyDict_GetItem' in o[i]:
            if TextMatch(o[i], ('if ((temp[', '*', '] = PyDict_GetItem', '*'), v2):
                if i < (len(o) - 4) and TextMatch(o[i+1], ('Py_INCREF(temp[', v2[0], ']);'), []) and\
                    TextMatch(o[i+2], ('if ((temp[', '*', '] = PyList_GetItem ( temp[', v2[0], ']', '*'), v3) and\
                    TextMatch(o[i+3], ('Py_INCREF(temp[', v3[0], ']);'), []) and\
                    TextMatch(o[i+4], ('CLEARTEMP(', v2[0], ');'), []):
                        o[i+4] = 'temp[' + v2[0] + '] = 0;'
                        del o[i+1]
                        return True
                        
                                    
            if TxMatch(o, i, ('if ((temp[$1] = PyDict_GetItem ($2)) == 0) goto $3;',
                'Py_INCREF(temp[$1]);',
                '$4 = PyInt_AsSsize_t ( temp[$1] );', 
                'CLEARTEMP($1);'), v2):
                    TxRepl(o, i, ('if ((temp[$1] = PyDict_GetItem ($2)) == 0) goto $3;',
                        '$4 = PyInt_AsSsize_t ( temp[$1] );', 
                        'temp[$1] = 0;'), v2)
                    return True    
    
            if TxMatch(o, i, ('if ((temp[$0] = PyDict_GetItem ($3)) == 0) goto $12;',
                'if ((temp[$1] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $5;',
                'Py_INCREF(temp[$1]);',
                'if ((temp[$0] = PyDict_GetItem ($3)) == 0) goto $12;',
                'if ((temp[$2] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $5;',
                'Py_INCREF(temp[$2]);',
                'temp[$0] = 0;'), v2):
                    TxRepl(o, i, ('if ((temp[$0] = PyDict_GetItem ($3)) == 0) goto $12;',
                        'if ((temp[$1] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $5;',
                        'Py_INCREF(temp[$1]);',
                        'temp[$2] = temp[$1];',
                        'Py_INCREF(temp[$2]);',
                        'temp[$0] = 0;'), v2)      
                    return True      
    
            
            if TxMatch(o, i, ('if ((temp[$1] = PyDict_GetItem ( $6 , $5 )) == 0) goto $3;',
                'Py_INCREF(temp[$1]);',
                'if ((temp[$2] = PyObject_GetItem ( temp[$1] , $4 )) == 0) goto $3;',
                'CLEARTEMP($1);'), v2):
                    TxRepl(o, i, ('if ((temp[$1] = PyDict_GetItem ( $6 , $5 )) == 0) goto $3;',
                                'if ((temp[$2] = PyObject_GetItem ( temp[$1] , $4 )) == 0) goto $3;',
                                'temp[$1] = 0;'), v2)
                    return True  
                
            if TxMatch(o, i, ('if ((temp[$1] = PyDict_GetItem ( $6 , $5 )) == 0) goto $3;',
                'Py_INCREF(temp[$1]);',
                'if ((Py_ssize_t_$7 = PyObject_Size ( temp[$1] )) == -1) goto $3;',
                'CLEARTEMP($1);'), v2):
                    TxRepl(o, i, ('if ((temp[$1] = PyDict_GetItem ( $6 , $5 )) == 0) goto $3;',
                                'if ((Py_ssize_t_$7 = PyObject_Size ( temp[$1] )) == -1) goto $3;',
                                'temp[$1] = 0;'), v2)
                    return True  
        
            if TxMatch(o, i, ('if ((temp[$1] = PyDict_GetItem ( $3 , $4 )) == 0) goto $0;',
                'Py_INCREF(temp[$1]);',
                'if ((temp[$2] = PyObject_GetAttr ( temp[$1] , $5 )) == 0) goto $0;',
                'CLEARTEMP($1);'), v2):
                    TxRepl(o, i, ('if ((temp[$1] = PyDict_GetItem ( $3 , $4 )) == 0) goto $0;',
                        'if ((temp[$2] = PyObject_GetAttr ( temp[$1] , $5 )) == 0) goto $0;',
                        'temp[$1] = 0;'), v2)
                    return True  
        
            if TxMatch(o, i, ('if ((temp[$0] = PyDict_GetItem ($5)) == 0) goto $3;',
                'Py_INCREF(temp[$0]);',
                'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;',
                'CLEARTEMP($0);'), v2):
                    TxRepl(o, i, ('if ((temp[$0] = PyDict_GetItem ($5)) == 0) goto $3;',
                        'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;',
                        'temp[$0] = 0;'), v2)
                    return True 
                
            if TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$0]);
                if (PyInt_CheckExact( $3 )) {
                long_$4 = PyInt_AS_LONG ( $3 );
                if ( long_$4 < 0) {
                long_$4 += PyList_GET_SIZE(temp[$0]);
                }
                if ((temp[$1] = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                } else {
                if ((temp[$1] = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                }
                CLEARTEMP($0);  
                LETLOCAL ( $10 , temp[$1] );
                temp[$1] = 0;                
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                        if (PyInt_CheckExact( $3 )) {
                        long_$4 = PyInt_AS_LONG ( $3 );
                        if ( long_$4 < 0) {
                        long_$4 += PyList_GET_SIZE(temp[$0]);
                        }
                        if ((GETLOCAL($10) = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                        Py_INCREF(GETLOCAL($10));
                        } else {
                        if ((GETLOCAL($10) = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                        }
                        temp[$0] = 0;                
                        """, v2)
                    return True 

            if TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$0]);
                if (PyInt_CheckExact( $3 )) {
                long_$4 = PyInt_AS_LONG ( $3 );
                if ( long_$4 < 0) {
                long_$4 += PyList_GET_SIZE(temp[$0]);
                }
                if ((temp[$1] = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                } else {
                if ((temp[$1] = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                }
                CLEARTEMP($0);  
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                        if (PyInt_CheckExact( $3 )) {
                        long_$4 = PyInt_AS_LONG ( $3 );
                        if ( long_$4 < 0) {
                        long_$4 += PyList_GET_SIZE(temp[$0]);
                        }
                        if ((temp[$1] = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                        Py_INCREF(temp[$1]);
                        } else {
                        if ((temp[$1] = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                        }
                        temp[$0] = 0;                
                        """, v2)
                    return True 
                        
            if TxMatch(o, i, """
                if ((temp[$2] = PyDict_GetItem ( $3 )) == 0) goto label_$0;
                Py_INCREF(temp[$2]);
                if ((int_$4 = PyObject_Not ( temp[$2] )) == -1) goto label_$0;
                CLEARTEMP($2);                        
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$2] = PyDict_GetItem ( $3 )) == 0) goto label_$0;
                        if ((int_$4 = PyObject_Not ( temp[$2] )) == -1) goto label_$0;
                        temp[$2] = 0;          
                        """, v2)
                    return True 
                        
                        
        if 'PyObject_GetItem' in o[i]:            
            if TxMatch(o, i, ('if ((temp[$0] = PyObject_GetItem ( $6 , $7 )) == 0) goto $5;',
                'if (PyInt_CheckExact( $7 ) && ($4 = PyInt_AS_LONG ( $7 )) < INT_MAX ) {',
                '$4 = $4 + 1;',
                'if ((temp[$2] = __c_BINARY_SUBSCR_Int ( $6 , $4 )) == 0) goto $5;',
                '} else {',
                'if ((temp[$1] = PyNumber_Add ( $7 , consts[$3] )) == 0) goto $5;',
                'if ((temp[$2] = PyObject_GetItem ( $6 , temp[$1] )) == 0) goto $5;',
                'CLEARTEMP($1);',
                '}'), v2):
                    TxRepl(o, i, ('if (PyInt_CheckExact( $7 ) && ($4 = PyInt_AS_LONG ( $7 )) < INT_MAX ) {',
                        'if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $6 , $4 , $7 )) == 0) goto $5;',          
                        'if ((temp[$2] = __c_BINARY_SUBSCR_Int ( $6 , $4 + 1 )) == 0) goto $5;',
                        '} else {',
                        'if ((temp[$0] = PyObject_GetItem ( $6 , $7 )) == 0) goto $5;',
                        'if ((temp[$1] = PyNumber_Add ( $7 , consts[$3] )) == 0) goto $5;',
                        'if ((temp[$2] = PyObject_GetItem ( $6 , temp[$1] )) == 0) goto $5;',
                        'CLEARTEMP($1);',
                        '}'), v2)
                    return True   
        if i+1 < len(o) and o[i+1].startswith('Py_INCREF(temp['):
            if i < len(o) - 10:
                v2 = []
                v3 = []
                if TextMatch(o[i], ('if ((temp[', '*', '] = PyList_GetItem', '*'), v2):
                    if  TextMatch(o[i+1], ('Py_INCREF(temp[', v2[0], ']);'), []) and\
                        TextMatch(o[i+2], ('if (PyList_CheckExact( temp[', v2[0], '] )) {'), []) and\
                        TextMatch(o[i+3], ('if ( PyList_SetItem ( temp[', v2[0], '] , ', '*'), []) and\
                        TextMatch(o[i+4], ('} else {',), []) and\
                        TextMatch(o[i+5], ('if ( PyObject_SetItem ( temp[', v2[0], '] , ', '*'), []) and\
                        TextMatch(o[i+6], ('Py_CLEAR(temp[', '*', ']);'), v3) and\
                        TextMatch(o[i+7], ('}',), []) and\
                        TextMatch(o[i+8], ('CLEARTEMP(', v2[0],');'), []) and\
                        TextMatch(o[i+9], ('temp[', v3[0], '] = 0;'), []) and v3[0] != v2[0]:
                            o[i+8] = 'temp[' + v2[0] + '] = 0;'
                            del o[i+1]
                            return True
            if TxMatch(o, i, ('if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;', 
                            'Py_INCREF(temp[$0]);',
                            '$12',
                            'CLEARTEMP($0);'), v2):
                typ = v2[11]
                temp = v2[0]
                n1, n2, n3 = v2[1], v2[2], v2[3]
                action = v2[12]
                if typ in ('Dict', 'List', 'Tuple') and '_Direct_' not in action and allowed_no_incref(action, temp, v2[3]):
                    TxRepl(o, i, ('if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;', 
                            '$12',
                            'temp[$0] = 0;'), v2)
                    return True  
                ## else:
                    ## if '_Direct_' not in action and 'PyObject_GetIter' not in action:
                        ## pprint(['!!!!!!'] + o[i:i+6])
            elif TxMatch(o, i, ('if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;', 
                            'Py_INCREF(temp[$0]);',
                            'CLEARTEMP($15);',
                            '$12',
                            'CLEARTEMP($0);'), v2) and v2[15] != v2[0] and ('temp['+v2[15]+']') in o[i]:
                typ = v2[11]
                temp = v2[0]
                n1, n2, n3 = v2[1], v2[2], v2[3]
                action = v2[12]
                if typ in ('Dict', 'List', 'Tuple') and '_Direct_' not in action and allowed_no_incref(action, temp, v2[3]):
                    TxRepl(o, i, ('if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;', 
                            'CLEARTEMP($15);',
                            '$12',
                            'temp[$0] = 0;'), v2)
                    return True  
            elif TxMatch(o, i, """
                if ((temp[$0] = PyTuple_GetItem ( $15 , $16 )) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyTuple_GetItem ( $15 , $16 )) == 0) goto label_$10;
                        if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                        Py_INCREF(temp[$1]);
                        temp[$0] = 0;""", v2)
                    return True                  
            elif TxMatch(o, i, """
                if ((temp[$0] = PyList_GetItem ( $15 , $16 )) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyList_GetItem ( $15 , $16 )) == 0) goto label_$10;
                        if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                        Py_INCREF(temp[$1]);
                        temp[$0] = 0;""", v2)
                    return True                  
            elif TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem ( $15 , $16 )) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem ( $15 , $16 )) == 0) goto label_$10;
                        if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                        Py_INCREF(temp[$1]);
                        temp[$0] = 0;""", v2)
                    return True                  
        if i+2 < len(o) and o[i+2].startswith('Py_INCREF(temp['):
            if TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True 

        if 'PyFloat_FromDouble' in o[i] and TxMatch(o, i, """
            if ((temp[$0] = PyFloat_FromDouble ( $2 )) == 0) goto $3;
            Loc_double_$1 = PyFloat_AsDouble(temp[$0]);
            CLEARTEMP($0);
            """, v2):
            TxRepl(o, i, """
                Loc_double_$1 = $2;
                """, v2)      
            return True  
            
        if i+3 <len(o) and o[i+3].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$2] = $10) == 0) goto label_$11;
            CLEARTEMP($1);
            CLEARTEMP($0);
            LETLOCAL ( $5 , temp[$2] );
            temp[$2] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        CLEARTEMP($1);
                        CLEARTEMP($0);""", v2) 
                    return True
    
        if i+4 <len(o) and o[i+4].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$2] = $10) == 0) goto label_$11;
            CLEARTEMP($1);
            CLEARTEMP($0);
            CLEARTEMP($12);
            LETLOCAL ( $5 , temp[$2] );
            temp[$2] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        CLEARTEMP($12);
                        """, v2) 
                    return True
    
    
        if i+2 <len(o) and o[i+2].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$2] = $10) == 0) goto label_$11;
            CLEARTEMP($1);
            LETLOCAL ( $5 , temp[$2] );
            temp[$2] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        CLEARTEMP($1);
                        """, v2) 
                    return True
    
        if i+1 <len(o) and o[i+1].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$0] = $10) == 0) goto label_$11;
            LETLOCAL ( $5 , temp[$0] );
            temp[$0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        """, v2) 
                    return True
        if i+2 <len(o) and o[i+2].startswith('LETLOCAL ('):
            if TxMatch(o, i, """
                if ((temp[$0] = $1) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                LETLOCAL ( $5 , temp[$0] );
                temp[$0] = 0;
                """, v2): 
                        TxRepl(o, i, """
                            if ((GETLOCAL($5) = $1) == 0) goto label_$10;
                            Py_INCREF(GETLOCAL($5));
                            """, v2) 
                        return True
        
            if TxMatch(o, i, """
                if ((temp[$1] = $11) == 0) goto label_$10;
                Py_INCREF(temp[$1]);
                LETLOCAL ( $5 , temp[$1] );
                if ((temp[$1] = $12) == 0) goto label_$10;
                """, v2): 
                        TxRepl(o, i, """
                            if ((GETLOCAL($5) = $11) == 0) goto label_$10;
                            Py_INCREF(GETLOCAL($5));
                            if ((temp[$1] = $12) == 0) goto label_$10;
                            """, v2) 
                        return True
    
        if i+3 <len(o) and o[i+3].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$0] = $6) == 0) goto label_$10;
            if ((temp[$1] = $7) == 0) goto label_$10;
            temp[$0] = 0;
            LETLOCAL ( $5 , temp[$1] );
            temp[$1] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((temp[$0] = $6) == 0) goto label_$10;
                        if ((GETLOCAL($5) = $7) == 0) goto label_$10;
                        temp[$0] = 0;
                        """, v2) 
                    return True
    
        if 'PyInt_FromLong' in o[i]:
            if TxMatch(o, i, ('if ((temp[$0] = PyInt_FromLong ($1)) == 0) goto label_$2;',), v2):
                TxRepl(o, i, ('temp[$0] = PyInt_FromLong ($1);',), v2)
                return True
        if 'PyInt_FromSsize_t' in o[i]:
            if TxMatch(o, i, """
                if ((temp[$4] = PyInt_FromSsize_t ( $2 )) == 0) goto $1;
                if (PyInt_CheckExact( temp[$3] )) {
                long_$7 = PyInt_AS_LONG ( temp[$3] );
                long_$8 = PyInt_AS_LONG ( temp[$4] );
                long_$9 = long_$7 + long_$8;
                if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^ long_$8 ) < 0) goto $0 ;
                temp[$5] = PyInt_FromLong ( long_$9 );
                } else if (PyFloat_CheckExact( temp[$3] )) {
                temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$3]) + (double)PyInt_AS_LONG ( temp[$4] ));
                } else { $0 :;
                if ((temp[$5] = PyNumber_Add ( temp[$3] , temp[$4] )) == 0) goto $1;
                }
                """, v2):
                TxRepl(o, i, """
                    if ((temp[$4] = PyInt_FromSsize_t ( $2 )) == 0) goto $1;
                    if (PyInt_CheckExact( temp[$3] )) {
                    long_$7 = PyInt_AS_LONG ( temp[$3] );
                    long_$8 = $2;
                    long_$9 = long_$7 + long_$8;
                    if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^ long_$8 ) < 0) goto $0 ;
                    temp[$5] = PyInt_FromLong ( long_$9 );
                    } else if (PyFloat_CheckExact( temp[$3] )) {
                    temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$3]) + (double)$2);
                    } else { $0 :;
                    if ((temp[$5] = PyNumber_Add ( temp[$3] , temp[$4] )) == 0) goto $1;
                    }
                    """, v2)
                return True  
        

            if TxMatch(o, i, """
                if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                if (_self_dict && (temp[$1] = $5) != 0) {
                Py_INCREF(temp[$1]);
                } else {
                if ((temp[$1] = $6) == 0) goto $4;
                }
                if (PyInt_CheckExact( temp[$1] )) {
                $7 = PyInt_AS_LONG ( temp[$0] );
                $8 = PyInt_AS_LONG ( temp[$1] );
                $11 = $7 $9 $8;
                if ($10) goto $3 ;
                temp[$2] = PyInt_FromLong ( $11 );
                } else if (PyFloat_CheckExact( temp[$1] )) {
                temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) - PyFloat_AS_DOUBLE(temp[$1]));
                } else { $3 :;
                if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);     
                """, v2): 
                        TxRepl(o, i, """
                            if (_self_dict && (temp[$1] = $5) != 0) {
                            Py_INCREF(temp[$1]);
                            } else {
                            if ((temp[$1] = $6) == 0) goto $4;
                            }
                            if (PyInt_CheckExact( temp[$1] )) {
                            $7 = $14;
                            $8 = PyInt_AS_LONG ( temp[$1] );
                            $11 = $7 $9 $8;
                            if ($10) goto $3 ;
                            temp[$2] = PyInt_FromLong ( $11 );
                            } else if (PyFloat_CheckExact( temp[$1] )) {
                            temp[$2] = PyFloat_FromDouble((double)($14) - PyFloat_AS_DOUBLE(temp[$1]));
                            } else { $3 :;
                            if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                            if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                            CLEARTEMP($0);
                            }
                            CLEARTEMP($1);   
                            """, v2) 
                        return True
        
            if TxMatch(o, i, """
                if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                if ((temp[$1] = $5) == 0) goto $4;
                Py_INCREF(temp[$1]);
                if (PyInt_CheckExact( temp[$1] )) {
                $7 = PyInt_AS_LONG ( temp[$0] );
                $8 = PyInt_AS_LONG ( temp[$1] );
                $11 = $7 $9 $8;
                if ($10) goto $3 ;
                temp[$2] = PyInt_FromLong ( $11 );
                } else if (PyFloat_CheckExact( temp[$1] )) {
                temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) - PyFloat_AS_DOUBLE(temp[$1]));
                } else { $3 :;
                if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);     
                """, v2): 
                        TxRepl(o, i, """
                            if ((temp[$1] = $5) == 0) goto $4;
                            if (PyInt_CheckExact( temp[$1] )) {
                            $7 = $14;
                            $8 = PyInt_AS_LONG ( temp[$1] );
                            $11 = $7 $9 $8;
                            if ($10) goto $3 ;
                            temp[$2] = PyInt_FromLong ( $11 );
                            } else if (PyFloat_CheckExact( temp[$1] )) {
                            temp[$2] = PyFloat_FromDouble((double)($14) - PyFloat_AS_DOUBLE(temp[$1]));
                            } else { $3 :;
                            if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                            if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                            CLEARTEMP($0);
                            }
                            CLEARTEMP($1);   
                            """, v2) 
                        return True
            if TxMatch(o, i, """
                if ((temp[$3] = PyInt_FromSsize_t ( $1 )) == 0) goto $0;
                long_$13 = PyInt_AS_LONG ( temp[$3] );
                temp[$4] = PyInt_FromLong ( long_$13 $14 );
                CLEARTEMP($3);
                """, v2): 
                        TxRepl(o, i, """
                            temp[$4] = PyInt_FromLong ( ($1) $14 );
                            """, v2) 
                        return True
        
            if TxMatch(o, i, """
                if ((temp[$1] = PyInt_FromSsize_t ( $5 )) == 0) goto $3;
                if (PyInt_CheckExact( temp[$0] )) {
                long_$14 = PyInt_AS_LONG ( temp[$0] );
                long_$15 = $5;
                long_$13 = long_$14 $16 long_$15;
                if ($18) goto $4 ;
                temp[$2] = PyInt_FromLong ( long_$13 );
                } else if (PyFloat_CheckExact( temp[$0] )) {
                temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $16 (double)$5);
                } else { $4 :;
                if ((temp[$2] = PyNumber_$17 ( temp[$0] , temp[$1] )) == 0) goto $3;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2): 
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( temp[$0] )) {
                            long_$14 = PyInt_AS_LONG ( temp[$0] );
                            long_$15 = $5;
                            long_$13 = long_$14 $16 long_$15;
                            if ($18) goto $4 ;
                            temp[$2] = PyInt_FromLong ( long_$13 );
                            } else if (PyFloat_CheckExact( temp[$0] )) {
                            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $16 (double)$5);
                            } else { $4 :;
                            if ((temp[$1] = PyInt_FromSsize_t ( $5 )) == 0) goto $3;
                            if ((temp[$2] = PyNumber_$17 ( temp[$0] , temp[$1] )) == 0) goto $3;
                            CLEARTEMP($1);
                            }
                            CLEARTEMP($0);
                            """, v2) 
                        return True
    ## if '_GET_ITEM' in o[i]:
            ## if TxMatch(o, i, """
                ## if ((temp[$0] = _GET_ITEM_$4 ( $2 )) == 0) goto label_$3;
                ## if ((temp[$1] = _GET_ITEM_$5 ( temp[$0] )) == 0) goto label_$3;
                ## CLEARTEMP($0);
                ## long_$6 = PyInt_AS_LONG ( temp[$1] );
                ## CLEARTEMP($1);
                ## if ( $7 ) {
                ## if ((temp[$0] = _GET_ITEM_$4 ( $2 )) == 0) goto label_$3;
                ## if ((temp[$1] = _GET_ITEM_$5 ( temp[$0] )) == 0) goto label_$3;
                ## CLEARTEMP($0);
                ## $8 PyInt_AS_LONG ( temp[$1] ) $9;
                ## CLEARTEMP($1);
                ## """, v2):
                    ## _s = 'long_' + v2[6]
                    ## if _s not in v2[8] and _s not in v2[9]: 
                        ## TxRepl(o, i, """
                            ## if ((temp[$0] = _GET_ITEM_$4 ( $2 )) == 0) goto label_$3;
                            ## if ((temp[$1] = _GET_ITEM_$5 ( temp[$0] )) == 0) goto label_$3;
                            ## CLEARTEMP($0);
                            ## long_$6 = PyInt_AS_LONG ( temp[$1] );
                            ## CLEARTEMP($1);
                            ## if ( $7 ) {
                            ## $8 long_$6 $9;
                            ## """, v2) 
                        ## return True        
    
        if 'PyObject_Type' in o[i]:
            if TxMatch(o, i, """
                if ((temp[$0] = PyObject_Type ( $11 )) == 0) goto label_$10;
                int_$15 = temp[$0] == loaded_builtin[$14];
                CLEARTEMP($0);
                """, v2): 
                        TxRepl(o, i, """
                            int_$15 = Py_TYPE ( $11 ) == loaded_builtin[$14];
                            """, v2) 
                        return True


    if i+1 < len(o) and 'PyInt_FromSsize_t' in o[i+1]:
        if TxMatch(o, i, ('if (($7 = PyObject_Size ( $3 )) == -1) goto $5;',
            'if ((temp[$1] = PyInt_FromSsize_t ( $7 )) == 0) goto $5;',
            'if (PyInt_CheckExact( $4 )) {',
            '$8 = PyInt_AS_LONG ( temp[$1] );',
            '$9 = PyInt_AS_LONG ( $4 );',
            '$10 = $8 - $9;',
            'if (( $10 ^ $8 ) < 0 && ( $10 ^~ $9 ) < 0) goto $6 ;',
            'temp[$2] = PyInt_FromLong ( $10 );',
            '} else if (PyFloat_CheckExact( $4 )) {',
            'temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$1] ) - PyFloat_AS_DOUBLE($4));',
            '} else { $6 :;',
            'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $4 )) == 0) goto $5;',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (($8 = PyObject_Size ( $3 )) == -1) goto $5;',
                    'if (PyInt_CheckExact( $4 )) {',
                    '$9 = PyInt_AS_LONG ( $4 );',
                    '$10 = $8 - $9;',
                    'if (( $10 ^ $8 ) < 0 && ( $10 ^~ $9 ) < 0) goto $6 ;',
                    'temp[$2] = PyInt_FromLong ( $10 );',
                    '} else { $6 :;',
                    'if ((temp[$1] = PyInt_FromSsize_t ( $8 )) == 0) goto $5;',
                    'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $4 )) == 0) goto $5;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
            
        if TxMatch(o, i, ('if (($7 = PyObject_Size ( $3 )) == -1) goto $5;',
            'if ((temp[$1] = PyInt_FromSsize_t ( $7 )) == 0) goto $5;',
            'if (PyInt_CheckExact( $4 )) {',
            '$8 = PyInt_AS_LONG ( temp[$1] );',
            '$9 = PyInt_AS_LONG ( $4 );',
            '$10 = $8 - $9;',
            'if (( $10 ^ $8 ) < 0 && ( $10 ^~ $9 ) < 0) goto $6 ;',
            'temp[$2] = PyInt_FromLong ( $10 );',
            '} else { $6 :;',
            'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $4 )) == 0) goto $5;',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (($8 = PyObject_Size ( $3 )) == -1) goto $5;',
                    'if (PyInt_CheckExact( $4 )) {',
                    '$9 = PyInt_AS_LONG ( $4 );',
                    '$10 = $8 - $9;',
                    'if (( $10 ^ $8 ) < 0 && ( $10 ^~ $9 ) < 0) goto $6 ;',
                    'temp[$2] = PyInt_FromLong ( $10 );',
                    '} else { $6 :;',
                    'if ((temp[$1] = PyInt_FromSsize_t ( $8 )) == 0) goto $5;',
                    'if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $4 )) == 0) goto $5;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
        if TxMatch(o, i, ('if (($4 = $3) == -1) goto $2;',
            'if ((temp[$0] = PyInt_FromSsize_t ( $4 )) == 0) goto $2;',
            'if (PyInt_CheckExact( $5 )) {',
            '$7 = PyInt_AS_LONG ( $5 );',
            '$8 = PyInt_AS_LONG ( temp[$0] );',
            '$9 = $7 + $8;',
            'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $6 ;',
            'temp[$1] = PyInt_FromLong ( $9 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + (double)PyInt_AS_LONG ( temp[$0] ));',
            '} else { $6 :;',
            'if ((temp[$1] = PyNumber_Add ( $5 , temp[$0] )) == 0) goto $2;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (($4 = $3) == -1) goto $2;',
                    'if (PyInt_CheckExact( $5 )) {',
                    '$7 = PyInt_AS_LONG ( $5 );',
                    '$8 = $4;',
                    '$9 = $7 + $8;',
                    'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $6 ;',
                    'temp[$1] = PyInt_FromLong ( $9 );',
                    '} else { $6 :;',
                    'if ((temp[$0] = PyInt_FromSsize_t ( $4 )) == 0) goto $2;',
                    'if ((temp[$1] = PyNumber_Add ( $5 , temp[$0] )) == 0) goto $2;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True     
            
        if TxMatch(o, i, ('if (($4 = $3) == -1) goto $2;',
            'if ((temp[$0] = PyInt_FromSsize_t ( $4 )) == 0) goto $2;',
            'if (PyInt_CheckExact( $5 )) {',
            '$7 = PyInt_AS_LONG ( $5 );',
            '$8 = PyInt_AS_LONG ( temp[$0] );',
            '$9 = $7 + $8;',
            'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $6 ;',
            'temp[$1] = PyInt_FromLong ( $9 );',
            '} else { $6 :;',
            'if ((temp[$1] = PyNumber_Add ( $5 , temp[$0] )) == 0) goto $2;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (($4 = $3) == -1) goto $2;',
                    'if (PyInt_CheckExact( $5 )) {',
                    '$7 = PyInt_AS_LONG ( $5 );',
                    '$8 = $4;',
                    '$9 = $7 + $8;',
                    'if (( $9 ^ $7 ) < 0 && ( $9 ^ $8 ) < 0) goto $6 ;',
                    'temp[$1] = PyInt_FromLong ( $9 );',
                    '} else { $6 :;',
                    'if ((temp[$0] = PyInt_FromSsize_t ( $4 )) == 0) goto $2;',
                    'if ((temp[$1] = PyNumber_Add ( $5 , temp[$0] )) == 0) goto $2;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True    

        if TxMatch(o, i, """
            if ((Py_ssize_t_$1 = $2) == -1) goto $7;
            if ((temp[$11] = PyInt_FromSsize_t ( Py_ssize_t_$1 )) == 0) goto $7;
            if (PyInt_CheckExact( temp[$10] )) {
            temp[$12] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$10] ) / PyInt_AS_LONG ( temp[$11] ));
            } else {
            if ((temp[$12] = PyNumber_Divide ( temp[$10] , temp[$11] )) == 0) goto $7;
            }
            CLEARTEMP($10);
            CLEARTEMP($11);
            """, v2): 
                    TxRepl(o, i, """
                        if ((Py_ssize_t_$1 = $2) == -1) goto $7;
                        if (PyInt_CheckExact( temp[$10] )) {
                        temp[$12] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$10] ) / (Py_ssize_t_$1));
                        } else {
                        if ((temp[$11] = PyInt_FromSsize_t ( Py_ssize_t_$1 )) == 0) goto $7;
                        if ((temp[$12] = PyNumber_Divide ( temp[$10] , temp[$11] )) == 0) goto $7;
                        CLEARTEMP($11);
                        }
                        CLEARTEMP($10);
                        """, v2) 
                    return True
 
    if '_PyEval_AssignSlice' in o[i]:
        if TxMatch(o, i, ('if ( _PyEval_AssignSlice ( $1 , NULL , NULL , temp[$2] ) == -1) goto $3;',), v2):
                TxRepl(o, i, ('if ( PySequence_SetSlice ( $1 , 0 , PY_SSIZE_T_MAX , temp[$2] ) == -1) goto $3;',), v2)
                return True            
        if TxMatch(o, i, ('if ( _PyEval_AssignSlice ( $1 , NULL , NULL , GETLOCAL($2) ) == -1) goto $3;',), v2):
                TxRepl(o, i, ('if ( PySequence_SetSlice ( $1 , 0 , PY_SSIZE_T_MAX , GETLOCAL($2) ) == -1) goto $3;',), v2)
                return True            
        if TxMatch(o, i, ('if ( _PyEval_AssignSlice ( $1 , NULL , NULL , NULL ) == -1) goto $3;',), v2):
                TxRepl(o, i, ('if ( PySequence_DelSlice ( $1 , 0 , PY_SSIZE_T_MAX ) == -1) goto $3;',), v2)
                return True            

    if o[i].endswith(' ;'):
        if TxMatch(o, i, """
            if ($6) goto label_$19 ;
            temp[$2] = PyInt_FromLong ( long_$18 );
            if (1) {
            } else { label_$19 :;
            >0
            if ((temp[$2] = PyNumber_$5) == 0) goto label_$0;
            <1
            }
            if (PyInt_CheckExact( temp[$2] ) && (long_$4 = PyInt_AS_LONG ( temp[$2] )) < $7 ) {
            temp[$3] = PyInt_FromLong ( long_$4 + $8 );
            } else {
            >2
            }
            CLEARTEMP($2);
            """, v2):
                TxRepl(o, i, """
                    if (!($6) && long_$18 < $7 ) {
                    temp[$3] = PyInt_FromLong ( long_$18 + $8 );
                    } else {
                    >0
                    if ((temp[$2] = PyNumber_$5) == 0) goto label_$0;
                    <1
                    >2
                    CLEARTEMP($2);
                    }
                    """, v2)      
                return True  
        
        if TxMatch(o, i, """
            if ($11) goto label_$5 ;
            temp[$0] = PyInt_FromLong ( $3 );
            if (0) { label_$5 :;
            temp[$2] = PyInt_FromLong ($4);
            if ((temp[$0] = PyNumber_$6) == 0) goto label_$9;
            CLEARTEMP($2);
            }
            if ((temp[$2] = PyObject_GetItem ( GETLOCAL(data) , temp[$0] )) == 0) goto label_$9;
            CLEARTEMP($0);     
            """, v2):
                TxRepl(o, i, """
                    if ($11) goto label_$5 ;
                    temp[$0] = PyInt_FromLong ( $3 );
                    if ((temp[$2] = PyObject_GetItem ( GETLOCAL(data) , temp[$0] )) == 0) goto label_$9;
                    CLEARTEMP($0);     
                    if (0) { label_$5 :;
                    temp[$2] = PyInt_FromLong ($4);
                    if ((temp[$0] = PyNumber_$6) == 0) goto label_$9;
                    CLEARTEMP($2);
                    if ((temp[$2] = PyObject_GetItem ( GETLOCAL(data) , temp[$0] )) == 0) goto label_$9;
                    CLEARTEMP($0);     
                    }
                    """, v2)      
                return True  
        if TxMatch(o, i, """
            if ($10) goto $11 ;
            temp[$0] = PyInt_FromLong ( $12 );
            if (1) {
            } else { $11 :;
            if ((temp[$0] = PyNumber_$13) == 0) goto $14;
            }
            if ((temp[$2] = PyObject_GetItem ( $15 , temp[$0] )) == 0) goto $14;
            CLEARTEMP($0);
            """, v2): 
                TxRepl(o, i, """
                    if ($10) {
                    if ((temp[$0] = PyNumber_$13) == 0) goto $14;
                    if ((temp[$2] = PyObject_GetItem ( $15 , temp[$0] )) == 0) goto $14;
                    CLEARTEMP($0);
                    } else {
                    temp[$0] = PyInt_FromLong ( $12 );
                    if ((temp[$2] = PyObject_GetItem ( $15 , temp[$0] )) == 0) goto $14;
                    CLEARTEMP($0);
                    }
                    """, v2) 
                return True
                
        if TxMatch(o, i, """
            if ($10) goto label_$8 ;
            temp[$0] = PyInt_FromLong ( long_$3 );
            if (1) {
            } else { label_$8 :;
            if ((temp[$0] = PyNumber_$17) == 0) goto label_$11;
            }
            CLEARTEMP($1);
            CLEARTEMP($2);
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( $12 )) {
            long_$14 = PyInt_AS_LONG ( temp[$0] );
            long_$16 = PyInt_AS_LONG ( $12 );
            long_$13 = long_4 + long_6;
            if (( long_$13 ^ long_$14 ) < 0 && ( long_$13 ^ long_$16 ) < 0) goto label_$9 ;
            temp[$10] = PyInt_FromLong ( long_$13 );
            } else { label_$9 :;
            if ((temp[$10] = PyNumber_$18Add ( temp[$0] , $12 )) == 0) goto label_$11;
            }
            CLEARTEMP($0);
                """, v2): 
                    TxRepl(o, i, """
                        if (!($10) && PyInt_CheckExact( $12 )) {
                        CLEARTEMP($1);
                        CLEARTEMP($2);
                        long_$14 = long_$3;
                        long_$16 = PyInt_AS_LONG ( $12 );
                        long_$13 = long_4 + long_6;
                        if (( long_$13 ^ long_$14 ) < 0 && ( long_$13 ^ long_$16 ) < 0) goto label_$9 ;
                        temp[$10] = PyInt_FromLong ( long_$13 );
                        } else { label_$9 :;
                        if ((temp[$0] = PyNumber_$17) == 0) goto label_$11;
                        CLEARTEMP($1);
                        CLEARTEMP($2);
                        if ((temp[$10] = PyNumber_$18Add ( temp[$0] , $12 )) == 0) goto label_$11;
                        CLEARTEMP($0);
                        }
                            """, v2) 
                    return True
    if 'PyObject_SetAttr' in o[i]:
        if TxMatch(o, i, """
            if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
            CLEARTEMP($1);
            if ((temp[$1] = PyObject_GetAttr ( $3 , $4 )) == 0) goto label_$5;
                """, v2): 
                    TxRepl(o, i, """
                        if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
                     """, v2) 
                    return True

        if TxMatch(o, i, """
            if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
            CLEARTEMP($1);
            if ((temp[$0] = PyObject_GetAttr ( $3 , $4 )) == 0) goto label_$5;
                """, v2) and v2[0] != v2[1]: 
##                    print 'Replace temp to temp', i
                    TxRepl(o, i, """
                        if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
                        temp[$0] = temp[$1];
                        temp[$1] = 0;
                            """, v2) 
                    return True
                

    return False

def end_call_1(action, nms, arg, label):
    if arg not in action:
        return False
    for nm in nms:
        if nm not in action:
            continue
        if 'goto' not in action:
            if action.endswith(' = ' + nm + '(' + arg + ');'):
                return True
            if action.endswith(' = ' + nm + '( ' + arg + ' );'):
                return True
            if action.endswith(' = ' + nm + ' ( ' + arg + ' );'):
                return True
        else:
            if action.startswith('if ('):
                if (' = ' + nm + ' ( ' + arg + ' )) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
                if (' = ' + nm + '( ' + arg + ' )) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
                if (' = ' + nm + '(' + arg + ')) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
                if (' = ' + nm + ' (' + arg + ')) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
        
    return False    

def end_call_first_of_two(action, nms, arg, label):
    if arg not in action:
        return False
    for nm in nms:
        if nm not in action:
            continue
        if 'goto' not in action:
            if TextMatch(action, ('*', ' = ' + nm + '(' + arg + ',', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '(' + arg + ' ,', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '( ' + arg + ',', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '( ' + arg + ' ,', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' ( ' + arg + ',', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' ( ' + arg + ' ,', '*', ');'), []):
                return True 
        else:
            if action.startswith('if ('):
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' ( ', arg, ' ,', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '( ', arg, ' ,', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' ( ', arg, ',', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '( ', arg, ',', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', arg, ' ,', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', arg, ',', '*', ') goto ', label, ';'), []):
                    return True
    return False    

def end_call_second_of_two(action, nms, arg, label):
    if arg not in action:
        return False
    for nm in nms:
        if nm not in action:
            continue
        if 'goto' not in action:
            if TextMatch(action, ('*', ' = ' + nm + '(', '*',  ',', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '(', '*', ', ', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '(', '*', ', ', arg, ' );'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' (', '*',  ',', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' (', '*', ', ', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' (', '*', ', ', arg, ' );'), []):
                return True 
        else:
            if action.startswith('if ('):
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ',', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ',', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ', ', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ', ', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ',', arg, ' )) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ',', arg, ' )) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ', ', arg, ' )) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ', ', arg, ' )) == ', '*', ';'), []):
                    return True
    return False    
    
def allowed_no_incref(action, temp, label):
    t_temp = 'temp[' + temp + ']'
    if end_call_1(action, ('PyLong_CheckExact', 'PyTuple_CheckExact', 
                         'PyBool_Check', 'PyList_CheckExact', 
                         'PyGen_CheckExact', 'PyBytes_CheckExact', 
                         'PyComplex_CheckExact', 'PyByteArray_CheckExact', 
                         'PyFile_CheckExact', 'PySet_CheckExact', 
                         'PyAnySet_CheckExact', 'PyDict_CheckExact', 
                         'PyString_CheckExact', 'PyDate_CheckExact', 
                         'PyTime_CheckExact', 'PyDateTime_CheckExact', 
                         'PyType_CheckExact', 'PyUnicode_CheckExact', 
                         'PyModule_CheckExact', 'PyInt_CheckExact', 
                         'PyFloat_CheckExact', 
                         'PyTuple_GET_SIZE', 'PyList_GET_SIZE', 
                         'PyObject_Size', 'PyObject_Str', 
                         'PyNumber_Int'), t_temp, label):
        return True
    if end_call_first_of_two(action, ('_c_BINARY_SUBSCR_Int', 'PyObject_GetItem', 
                         'c_Py_EQ_String', 'c_Py_NE_String', 
                         'c_Py_GT_Int', 'c_Py_GE_Int',
                         'c_Py_LT_Int', 'c_Py_LE_Int',
                         'c_Py_EQ_Int', 'c_Py_NE_Int',
                         'PySequence_GetSlice', 'PyObject_GetAttr',
                         'PySequence_Contains', 'PyDict_Contains', 
                         'PySet_Contains'), t_temp, label):
        return True
    if end_call_second_of_two(action, 
                              ('PySequence_Contains', 'PyDict_Contains', 'PySet_Contains'), 
                              t_temp, label):
        return True
    if ( 'STR_CONCAT_N ( ' in action or 'STR_CONCAT3 ( ' in action or 'STR_CONCAT2 ( ' in action ) and t_temp in action:
        return True
    if  (' = ' + t_temp + ' == calculated_const[') in action or (' = ' + t_temp + ' != calculated_const[') in action:
        return True

    return False    

op_to_oper = {'Py_EQ':' == ', 'Py_NE':' != ', 'Py_LT':' < ', \
              'Py_LE':' <= ', 'Py_GT':' > ', 'Py_GE':' >= '}

def tune_if_sk(o, i):
    v2 = []
    if o[i] == 'if (1) {':
        if TxMatch(o, i, ('if (1) {',
            '$1;'), v2) and not ':' in o[i+1] and not '}' in o[i+1] and not '{' in o[i+1]:
                TxRepl(o, i, ('$1;', 'if (1) {'), v2)
                return True  
        if TxMatch(o, i, ('if (1) {',
            '} else {'), v2):
                TxRepl(o, i, ('if (0) {',), v2)
                return True  
        if TxMatch(o, i, ('if (1) {',
            'long_$6 = PyInt_AS_LONG ( $1 );',
            'long_$7 = PyInt_AS_LONG ( $2 );',
            'long_$8 = long_$6 + long_$7;',
            'if (( long_$8 ^ long_$6 ) < 0 && ( long_$8 ^ long_$7 ) < 0) goto $5 ;',
            'temp[$3] = PyInt_FromLong ( long_$8 );',
            '} else { $5 :;',
            'if ((temp[$3] = PyNumber_Add ( $1 , $2 )) == 0) goto $9;',
            '}'), v2):
                TxRepl(o, i, ('long_$6 = PyInt_AS_LONG ( $1 );',
                    'long_$7 = PyInt_AS_LONG ( $2 );',
                    'long_$8 = long_$6 + long_$7;',
                    'if (( long_$8 ^ long_$6 ) < 0 && ( long_$8 ^ long_$7 ) < 0) {',
                    'if ((temp[$3] = PyNumber_Add ( $1 , $2 )) == 0) goto $9;',
                    '} else {',
                    'temp[$3] = PyInt_FromLong ( long_$8 );',
                    '}'), v2)
                return True   
        if TxMatch(o, i, ('if (1) {',
            'long_$2 = PyInt_AS_LONG ( $1 );',
            'long_$3 = long_$2 + 1;',
            'if (( long_$3 ^ long_$2 ) < 0 && ( long_$3 ^ 1 ) < 0) goto $8 ;',
            'temp[$0] = PyInt_FromLong ( long_$3 );',
            '} else { $8 :;',
            'if ((temp[$0] = PyNumber_Add ( $1 , consts[$11] )) == 0) goto $10;',
            '}'), v2):
                TxRepl(o, i, ('if ((long_$2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                        'temp[$0] = PyInt_FromLong ( long_$2 + 1 );',
                        '} else {',
                        'if ((temp[$0] = PyNumber_Add ( $1 , consts[$11] )) == 0) goto $10;',
                        '}'), v2)
                return True  
            
    if o[i] == 'if (0) {':
        if TxMatch(o, i, ('if (0) {',
            '$1;'), v2) and not ':' in o[i+1] and not '}' in o[i+1] and not '{' in o[i+1]:
                TxRepl(o, i, ('if (0) {',), v2)
                return True  
        if TxMatch(o, i, ('if (0) {',
            '}'), v2):
                TxRepl(o, i, (), v2)
                return True         
    if o[i] == 'if (_self_dict) {':    
        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
            }                     
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         
        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
            }
            f->f_lineno = $5;
            f->f_lasti = $6;            
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
            }                     
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         
        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $2, temp[$0]) == -1) goto label_0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , temp[$0] ) == -1) goto label_$10;
            }
            CLEARTEMP($0);
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $2)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $2 )) == 0) goto label_$10;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $2, temp[$0]) == -1) goto label_0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , temp[$0] ) == -1) goto label_$10;
                    }
                    """, v2)
                return True         

        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $3) == -1) goto label_$0;
            if (PyDict_SetItem(_self_dict, $2, $4) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $3 ) == -1) goto label_$0;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , $4 ) == -1) goto label_$0;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $3) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $2, $4) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $3 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , $4 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         

        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
            if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
            if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $7, $8) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $7 , $8 ) == -1) goto label_$0;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $7, $8) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $7 , $8 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         


        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $5, temp[$0]) == -1) goto label_$7;
            CLEARTEMP($0);
            if (PyDict_SetItem(_self_dict, $6, $12) == -1) goto label_$7;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , temp[$0] ) == -1) goto label_$7;
            CLEARTEMP($0);
            if ( PyObject_SetAttr ( GETLOCAL(self) , $6 , $12 ) == -1) goto label_$7;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $8, $10) == -1) goto label_$7;
            if (PyDict_SetItem(_self_dict, $9, $11) == -1) goto label_$7;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $8 , $10 ) == -1) goto label_$7;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $9 , $11 ) == -1) goto label_$7;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $5, temp[$0]) == -1) goto label_$7;
                    CLEARTEMP($0);
                    if (PyDict_SetItem(_self_dict, $6, $12) == -1) goto label_$7;
                    if (PyDict_SetItem(_self_dict, $8, $10) == -1) goto label_$7;
                    if (PyDict_SetItem(_self_dict, $9, $11) == -1) goto label_$7;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , temp[$0] ) == -1) goto label_$7;
                    CLEARTEMP($0);
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $6 , $12 ) == -1) goto label_$7;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $8 , $10 ) == -1) goto label_$7;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $9 , $11 ) == -1) goto label_$7;
                    }
                    """, v2)
                return True         

    if o[i].startswith('if (_self_dict'):    
        if TxMatch(o, i, """
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $1)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
            }
            LETLOCAL ( $2 , temp[$0] );
            temp[$0] = 0;
            """,v2):
                TxRepl(o, i, """
                    if (_self_dict && (GETLOCAL($2) = PyDict_GetItem(_self_dict, $1)) != 0) {
                    Py_INCREF(GETLOCAL($2));
                    } else {
                    if ((GETLOCAL($2) = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
                    }
                    """, v2)
                return True         
        if TxMatch(o, i, """
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $1)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
            }
            LETLOCAL ( $2 , temp[$0] );
            temp[$0] = 0;
            """,v2):
                TxRepl(o, i, """
                    if (_self_dict && (GETLOCAL($2) = PyDict_GetItem(_self_dict, $1)) != 0) {
                    Py_INCREF(GETLOCAL($2));
                    } else {
                    if ((GETLOCAL($2) = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
                    }
                    """, v2)
                return True         
    
        if TxMatch(o, i, """
            if (_self_dict && (temp[$1] = PyDict_GetItem(_self_dict, $2)) != 0) {
            Py_INCREF(temp[$1]);
            } else {
            if ((temp[$1] = PyObject_GetAttr ( GETLOCAL(self) , $2 )) == 0) goto label_$3;
            }
            if ((temp[$0] = _Direct_$4 ( GETLOCAL(self) $5 temp[$1] )) == 0) goto label_$3;
            CLEARTEMP($1);    
            """,v2):
                TxRepl(o, i, """
                    if ((temp[$0] = _Direct_$4 ( GETLOCAL(self) $5 PyDict_GetItem(_self_dict, $2) )) == 0) goto label_$3;
                    """, v2)
                return True         
    
        if TxMatch(o, i, """
            if (_self_dict && (temp[$1] = PyDict_GetItem(_self_dict, $2)) != 0) {
            Py_INCREF(temp[$1]);
            } else {
            if ((temp[$1] = PyObject_GetAttr ( GETLOCAL(self) , $2 )) == 0) goto label_$3;
            }
            if (_Direct_fn(GETLOCAL(self)$5 temp[$1]) == -1) goto label_$3;
            CLEARTEMP($1);
            temp[$0] = Py_None;
            Py_INCREF(temp[$0]);
            """,v2):
                TxRepl(o, i, """
                    if (_Direct_fn(GETLOCAL(self)$5 PyDict_GetItem(_self_dict, $2)) == -1) goto label_$3;
                    temp[$0] = Py_None;
                    Py_INCREF(temp[$0]);
                    """, v2)
                return True         

        if TxMatch(o, i, """
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $4)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $4 )) == 0) goto label_$3;
            }
            if ((temp[$1] = _Direct_$5 ($9temp[$0]$10)) == 0) goto label_$3;
            CLEARTEMP($0);
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $4, temp[$1]) == -1) goto label_$3;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $4 , temp[$1] ) == -1) goto label_$3;
            }
            CLEARTEMP($1);    
                        """,v2):
                TxRepl(o, i, """
                    if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $4)) != 0) {
                    if ((temp[$1] = _Direct_$5 ($9temp[$0]$10)) == 0) goto label_$3;
                    temp[$0] = 0;
                    if (PyDict_SetItem(_self_dict, $4, temp[$1]) == -1) goto label_$3;
                    CLEARTEMP($1);  
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $4 )) == 0) goto label_$3;
                    if ((temp[$1] = _Direct_$5 ($9temp[$0]$10)) == 0) goto label_$3;
                    CLEARTEMP($0);
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $4 , temp[$1] ) == -1) goto label_$3;
                    CLEARTEMP($1);  
                    }
                    """, v2)
                return True  

        if TxMatch(o, i, """
            if (_$6_dict && (temp[$0] = PyDict_GetItem(_$6_dict, $3)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($6) , $3 )) == 0) goto label_$5;
            }
            if (_$6_dict && (temp[$1] = PyDict_GetItem(_$6_dict, $4)) != 0) {
            Py_INCREF(temp[$1]);
            } else {
            if ((temp[$1] = PyObject_GetAttr ( GETLOCAL($6) , $4 )) == 0) goto label_$5;
            }
            if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$5;
            CLEARTEMP($0);
            CLEARTEMP($1);
            if (_$6_dict) {
            if (PyDict_SetItem(_$6_dict, $8, temp[$2]) == -1) goto label_$5;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($6) , $8 , temp[$2] ) == -1) goto label_$5;
            }
            CLEARTEMP($2);
                        """,v2):
                TxRepl(o, i, """
                    if (_$6_dict && (temp[$0] = PyDict_GetItem(_$6_dict, $3)) != 0 && (temp[$1] = PyDict_GetItem(_$6_dict, $4)) != 0) {
                    if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$5;
                    temp[$0] = 0;
                    temp[$1] = 0;
                    if (PyDict_SetItem(_$6_dict, $8, temp[$2]) == -1) goto label_$5;
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($6) , $3 )) == 0) goto label_$5;
                    if ((temp[$1] = PyObject_GetAttr ( GETLOCAL($6) , $4 )) == 0) goto label_$5;
                    if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$5;
                    CLEARTEMP($0);
                    CLEARTEMP($1);
                    if ( PyObject_SetAttr ( GETLOCAL($6) , $8 , temp[$2] ) == -1) goto label_$5;
                    }
                    CLEARTEMP($2);
                    """, v2)
                return True  
    
    if o[i].endswith('_dict) {'):
        if TxMatch(o, i, """
            if (_$10_dict) {
            if (PyDict_SetItem(_$10_dict, $12, temp[$0]) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($10) , $12 , temp[$0] ) == -1) goto label_$11;
            }
            CLEARTEMP($0);
            if (_$10_dict) {
            if (PyDict_SetItem(_$10_dict, $14, $15) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($10) , $14 , $15 ) == -1) goto label_$11;
            }
            """,v2):
                TxRepl(o, i, """
                    if (_$10_dict) {
                    if (PyDict_SetItem(_$10_dict, $12, temp[$0]) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if (PyDict_SetItem(_$10_dict, $14, $15) == -1) goto label_$11;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL($10) , $12 , temp[$0] ) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if ( PyObject_SetAttr ( GETLOCAL($10) , $14 , $15 ) == -1) goto label_$11;
                    }
                    """, v2)
                return True         
        
    if 'Py_TYPE' in o[i]:    
        if TxMatch(o, i, """
            if ($9) {
            if ((temp[$0] = _Direct_$3 ( $10 )) == 0) goto label_$11;
            } else {
            if ((temp[$1] = PyObject_GetAttr ( $10 , $12 )) == 0) goto label_$11;
            if ((temp[$0] = FastCall0(temp[$1])) == 0) goto label_$11;
            CLEARTEMP($1);
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $13, temp[$0]) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $13 , temp[$0] ) == -1) goto label_$11;
            }
            CLEARTEMP($0);
            if ($9) {
            if ((temp[$0] = _Direct_$4 ( $10 )) == 0) goto label_$11;
            } else {
            if ((temp[$1] = PyObject_GetAttr ( $10 , $14 )) == 0) goto label_$11;
            if ((temp[$0] = FastCall0(temp[$1])) == 0) goto label_$11;
            CLEARTEMP($1);
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $15, temp[$0]) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $15 , temp[$0] ) == -1) goto label_$11;
            }
            CLEARTEMP($0);
            if ($9) {
            if ((temp[$0] = _Direct_$5 ( $10 )) == 0) goto label_$11;
            } else {
            if ((temp[$1] = PyObject_GetAttr ( $10 , $16 )) == 0) goto label_$11;
            if ((temp[$0] = FastCall0(temp[$1])) == 0) goto label_$11;
            CLEARTEMP($1);
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $17, temp[$0]) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $17 , temp[$0] ) == -1) goto label_$11;
            }
            CLEARTEMP($0);
            """,v2):
                TxRepl(o, i, """
                    if ($9) {
                    if (_self_dict) {
                    if ((temp[$0] = _Direct_$3 ( $10 )) == 0) goto label_$11;
                    if (PyDict_SetItem(_self_dict, $13, temp[$0]) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if ((temp[$0] = _Direct_$4 ( $10 )) == 0) goto label_$11;
                    if (PyDict_SetItem(_self_dict, $15, temp[$0]) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if ((temp[$0] = _Direct_$5 ( $10 )) == 0) goto label_$11;
                    if (PyDict_SetItem(_self_dict, $17, temp[$0]) == -1) goto label_$11;
                    } else {
                    if ((temp[$0] = _Direct_$3 ( $10 )) == 0) goto label_$11;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $13 , temp[$0] ) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if ((temp[$0] = _Direct_$4 ( $10 )) == 0) goto label_$11;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $15 , temp[$0] ) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if ((temp[$0] = _Direct_$5 ( $10 )) == 0) goto label_$11;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $17 , temp[$0] ) == -1) goto label_$11;
                    }
                    } else {
                    if ((temp[$1] = PyObject_GetAttr ( $10 , $12 )) == 0) goto label_$11;
                    if ((temp[$0] = FastCall0(temp[$1])) == 0) goto label_$11;
                    CLEARTEMP($1);
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $13, temp[$0]) == -1) goto label_$11;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $13 , temp[$0] ) == -1) goto label_$11;
                    }
                    CLEARTEMP($0);
                    if ((temp[$1] = PyObject_GetAttr ( $10 , $14 )) == 0) goto label_$11;
                    if ((temp[$0] = FastCall0(temp[$1])) == 0) goto label_$11;
                    CLEARTEMP($1);
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $15, temp[$0]) == -1) goto label_$11;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $15 , temp[$0] ) == -1) goto label_$11;
                    }
                    CLEARTEMP($0);
                    if ((temp[$1] = PyObject_GetAttr ( $10 , $16 )) == 0) goto label_$11;
                    if ((temp[$0] = FastCall0(temp[$1])) == 0) goto label_$11;
                    CLEARTEMP($1);
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $17, temp[$0]) == -1) goto label_$11;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $17 , temp[$0] ) == -1) goto label_$11;
                    }
                    }
                    """, v2)
                return True         

    if TxMatch(o, i, """    
        if ($11) {
        >0
        if ( long_$13 < 0) {
        long_$13 += PyString_GET_SIZE($10);
        }
        if (long_$13 < 0 || long_$13 >= PyString_GET_SIZE($10)) goto label_$4;
        temp[$2] = PyString_FromStringAndSize((PyString_AS_STRING ( $3 ) + long_$13), 1);
        <1
        } else {
        >2
        }
        if (PyString_GET_SIZE( temp[$2] ) == 1) {
        temp[$0] = PyInt_FromLong ( (long)((unsigned char)*PyString_AS_STRING ( temp[$2] )) );
        } else {
        >3
        }
        CLEARTEMP($2);
        """, v2):
            TxRepl(o, i, """
                if ($11) {
                >0
                if ( long_$13 < 0) {
                long_$13 += PyString_GET_SIZE($10);
                }
                if (long_$13 < 0 || long_$13 >= PyString_GET_SIZE($10)) goto label_$4;
                temp[$0] = PyInt_FromLong ( (long)((unsigned char)*(PyString_AS_STRING ( $3 ) + long_$13)) );
                <1
                } else {
                >2
                >3
                CLEARTEMP($2);
                }
                """, v2)
            return True

    if TxMatch(o, i, """    
        if ($18) {
        >0
        if ( long_$13 < 0) {
        long_$13 += $14;
        }
        >1
        temp[$0] = PyInt_FromLong ($15);
        } else {
        >2
        }
        long_$16 = PyInt_AS_LONG ( temp[$0] );
        CLEARTEMP($0);
        """, v2):
            TxRepl(o, i, """
                if ($18) {
                >0
                if ( long_$13 < 0) {
                long_$13 += $14;
                }
                >1
                long_$16 = ($15);
                } else {
                >2
                long_$16 = PyInt_AS_LONG ( temp[$0] );
                CLEARTEMP($0);
                }
                """, v2)
            return True
    
    if TxMatch(o, i, """    
        if ($10) {
        >0
        temp[$1] = PyInt_FromLong ( $4 );
        <1
        } else if ($13) {
        >2
        temp[$1] = PyFloat_FromDouble($5);
        <3
        } else { label_$3 :;
        >4
        if ((temp[$1] = $6) == 0) goto label_$9;
        <5
        }
        <6
        if ( PyObject_SetAttr ($8 temp[$1] ) == -1) goto label_$9;
        temp[$0] = temp[$1];
        temp[$1] = 0;
        if ((int_$16 = c_$7_Int ( temp[$0] , $12 , $11 )) == -1) goto label_$9;
        CLEARTEMP($0);""", v2):
            ## if True and v2[7] in op_to_oper:
                ## pass
            v2[14] = op_to_oper[v2[7]]
##            pprint(o[i:])
            TxRepl(o, i, """
                if ($10) {
                >0
                temp[$1] = PyInt_FromLong ( $4 );
                int_$16 = ($4) $14 $12;
                <1
                <6
                } else if ($13) {
                >2
                temp[$1] = PyFloat_FromDouble($5);
                int_$16 = PyFloat_AS_DOUBLE(temp[$1]) $14 $12;
                <3
                <6
                } else { label_$3 :;
                >4
                if ((temp[$1] = $6) == 0) goto label_$9;
                if ((int_$16 = PyObject_RichCompareBool ( temp[$1] , $11 , $7 )) == -1) goto label_$9;
                <5
                <6
                }
                if ( PyObject_SetAttr ($8 temp[$1] ) == -1) goto label_$9;
                CLEARTEMP($1);            
                """, v2)
##            pprint(o[i:])
            return True

    if TxMatch(o, i, """    
        if ($10) {
        >0
        temp[$1] = PyInt_FromLong ( $4 );
        <1
        } else if ($13) {
        >2
        temp[$1] = PyFloat_FromDouble($5);
        <3
        } else {
        >4
        if ((temp[$1] = $6) == 0) goto label_$9;
        <5
        }
        <6
        if ( PyObject_SetAttr ($8 temp[$1] ) == -1) goto label_$9;
        temp[$0] = temp[$1];
        temp[$1] = 0;
        if ((int_$16 = c_$7_Int ( temp[$0] , $12 , $11 )) == -1) goto label_$9;
        CLEARTEMP($0);""", v2):
            ## if True and v2[7] in op_to_oper:
                ## pass
            
            v2[14] = op_to_oper[v2[7]]
##            pprint(o[i:])
            TxRepl(o, i, """
                if ($10) {
                >0
                temp[$1] = PyInt_FromLong ( $4 );
                int_$16 = ($4) $14 $12;
                <1
                <6
                } else if ($13) {
                >2
                temp[$1] = PyFloat_FromDouble($5);
                int_$16 = PyFloat_AS_DOUBLE(temp[$1]) $14 $12;
                <3
                <6
                } else {
                >4
                if ((temp[$1] = $6) == 0) goto label_$9;
                if ((int_$16 = PyObject_RichCompareBool ( temp[$1] , $11 , $7 )) == -1) goto label_$9;
                <5
                <6
                }
                if ( PyObject_SetAttr ($8 temp[$1] ) == -1) goto label_$9;
                CLEARTEMP($1);            
                """, v2)
##            pprint(o[i:])
            return True
   
        
    if TxMatch(o, i, """    
        if ($11) {
        >0
        temp[$10] = PyInt_FromLong ( $12 );
        <1
        } else {
        >2
        if ((temp[$10] = $14) == 0) goto label_$15;
        <3
        }
        <4
        if (PyInt_CheckExact( temp[$10] )) {
        >5
        } else {
        >6
        }
        <7
        """, v2):
            TxRepl(o, i, """
                if ($11) {
                >0
                temp[$10] = PyInt_FromLong ( $12 );
                <1
                <4
                >5
                <7
                } else {
                >2
                if ((temp[$10] = $14) == 0) goto label_$15;
                <3
                <4
                >6  
                <7              
                }
                 """, v2)
            return True
                 
   
    if TxMatch(o, i, """    
        if ($1) {
        >0
        temp[$10] = PyInt_FromLong ( $3 );
        <1
        } else if ($2) {
        >2
        temp[$10] = PyFloat_FromDouble($4);
        <3
        } else { label_$6 :;
        >4
        if ((temp[$10] = $5) == 0) goto label_$7;
        <5
        }
        <6
        if (PyInt_CheckExact( temp[$10] )) {
        >7
        } else if (PyFloat_CheckExact( temp[$10] )) {
        >8
        } else { label_$8 :;
        >9
        }
        <10
        """, v2):
            TxRepl(o, i, """
                if ($1) {
                >0
                temp[$10] = PyInt_FromLong ( $3 );
                <1
                <6
                >7
                <10
                } else if ($2) {
                >2
                temp[$10] = PyFloat_FromDouble($4);
                <3
                <6
                >8
                <10
                } else { label_$6 :;
                >4
                if ((temp[$10] = $5) == 0) goto label_$7;
                <5
                <6
                label_$8 :;
                >9
                <10
                }
                 """, v2)
            return True              
                 
    if TxMatch(o, i, """    
        if ($1) {
        >0
        temp[$10] = PyInt_FromLong ( $3 );
        <1
        } else if ($2) {
        >2
        temp[$10] = PyFloat_FromDouble($4);
        <3
        } else { label_$6 :;
        >4
        if ((temp[$10] = $5) == 0) goto label_$7;
        <5
        }
        <6
        if (PyInt_CheckExact( temp[$10] ) && PyInt_CheckExact( GETLOCAL($11) )) {
        >7
        } else if (PyFloat_CheckExact( temp[$10] ) && PyFloat_CheckExact( GETLOCAL($11) )) {
        >8
        } else { label_$8 :;
        >9
        }
        <10
        """, v2):
            TxRepl(o, i, """
                if ($1 && PyInt_CheckExact( GETLOCAL($11) )) {
                >0
                temp[$10] = PyInt_FromLong ( $3 );
                <1
                <6
                >7
                <10
                } else if ($2 && PyFloat_CheckExact( GETLOCAL($11) )) {
                >2
                temp[$10] = PyFloat_FromDouble($4);
                <3
                <6
                >8
                <10
                } else { label_$6 :;
                >4
                if ((temp[$10] = $5) == 0) goto label_$7;
                <5
                <6
                label_$8 :;
                >9
                <10
                }
                 """, v2)
            return True                       
                 
    if TxMatch(o, i, """    
        if ($0) {
          >0
          temp[$11] = PyInt_FromLong ( $1 );
          <1
        } else if ($2) {
          >2
          temp[$11] = PyFloat_FromDouble($3);
          <3
        } else {
          >4
          if ((temp[$11] = $4) == 0) goto label_$5;
          <5
        }
        <6
        if (PyInt_CheckExact( temp[$11] ) && (long_$6 = PyInt_AS_LONG ( temp[$11] )) $7 $8 && long_$6 $9 $10) {
          >7
          temp[$13] = PyInt_FromLong ( $12 );
          <8
        } else {
          >9
          if ((temp[$13] = $14) == 0) goto label_$5;
          >10
        }
        CLEARTEMP($11);
        """, v2):
            TxRepl(o, i, """
                if ($0) {
                  >0
                  long_$6 = $1;
                  <1
                  <6
                  if (long_$6 $7 $8 && long_$6 $9 $10) {
                    >7
                    temp[$13] = PyInt_FromLong ( $12 );
                    <8
                  } else {
                    temp[$11] = PyInt_FromLong ( long_$6 );
                    >9
                    if ((temp[$13] = $14) == 0) goto label_$5;
                    >10
                    CLEARTEMP($11);
                  }
                } else {
                  >4
                  if ((temp[$11] = $4) == 0) goto label_$5;
                  <5
                  <6
                  >9
                  if ((temp[$13] = $14) == 0) goto label_$5;
                  >10
                  CLEARTEMP($11);
                }
                 """, v2)
            return True              

    if TxMatch(o, i, """    
        if ($0) {
        >0
        temp[$1] = PyInt_FromLong ( $2 );
        <1
        } else {
        >2
        if ((temp[$1] = $3) == 0) goto label_$4;
        <3
        }
        <4
        if ($10 && PyInt_CheckExact( temp[$1] )) {
        >5
        if (( long_4 ^ long_1 ) < 0 && ( long_4 ^ long_2 ) < 0) goto label_$7 ;
        temp[$6] = PyInt_FromLong ( long_4 );
        <6
        } else if ($9 && PyFloat_CheckExact( temp[$1] )) {
        >7
        temp[$6] = PyFloat_FromDouble($8);
        <8
        } else { label_$7 :;
        >9
        if ((temp[$6] = $11) == 0) goto label_$4;
        <10
        }
        CLEARTEMP($5);
        CLEARTEMP($1);
        """, v2):
                TxRepl(o, i, """
                    if ($10 && $0) {
                    >0
                    temp[$1] = PyInt_FromLong ( $2 );
                    <1
                    <4
                    >5
                    if (( long_4 ^ long_1 ) < 0 && ( long_4 ^ long_2 ) < 0) goto label_$7 ;
                    temp[$6] = PyInt_FromLong ( long_4 );
                    <6
                    CLEARTEMP($5);
                    CLEARTEMP($1);                      
                    } else {
                    >2
                    if ((temp[$1] = $3) == 0) goto label_$4;
                    <3
                    <4
                    label_$7 :;
                    >9
                    if ((temp[$6] = $11) == 0) goto label_$4;
                    <10
                    CLEARTEMP($5);
                    CLEARTEMP($1);
                    }
                    """, v2)
                return True

    if TxMatch(o, i, """    
        if ($0) {
        >0
        temp[$2] = PyInt_FromLong ($1);
        <1
        } else {
        >2
        }
        if (PyInt_CheckExact( temp[$2] )) {
        long_$6 = PyInt_AS_LONG ( temp[$2] );
        if ( long_$6 < 0) {
        long_$6 += PyList_GET_SIZE($4);
        }
        if ((temp[$5] = PyList_GetItem ( $4 , long_$6 )) == 0) goto label_$10;
        Py_INCREF(temp[$5]);
        } else {
        if ((temp[$5] = PyObject_GetItem ( $4 , temp[$2] )) == 0) goto label_$10;
        }
        CLEARTEMP($2);
        """, v2):
            TxRepl(o, i, """
                if ($0) {
                >0
                temp[$2] = PyInt_FromLong ($1);
                <1
                long_$6 = PyInt_AS_LONG ( temp[$2] );
                CLEARTEMP($2);
                if ( long_$6 < 0) {
                long_$6 += PyList_GET_SIZE($4);
                }
                if ((temp[$5] = PyList_GetItem ( $4 , long_$6 )) == 0) goto label_$10;
                Py_INCREF(temp[$5]);
                } else {
                >2
                if ((temp[$5] = PyObject_GetItem ( $4 , temp[$2] )) == 0) goto label_$10;
                CLEARTEMP($2);
                }
                    """, v2)
            return True 

    if TxMatch(o, i, """    
        if ($10) {
        >0
        if ($11) {
        >1
        temp[$1] = PyInt_FromLong ( $12 );
        <2
        } else {
        >3
        }
        } else {
        >5
        }
        if (PyInt_CheckExact( temp[$1] )) {
        >7
        } else {
        >8
        }
        CLEARTEMP($1);
        """, v2):
            TxRepl(o, i, """
                if ($10) {
                >0
                if ($11) {
                >1
                temp[$1] = PyInt_FromLong ( $12 );
                <2
                >7
                CLEARTEMP($1);
                } else {
                >3
                >8
                CLEARTEMP($1);
                }
                } else {
                >5
                >8
                CLEARTEMP($1);
                }
                    """, v2)
            return True

    if TxMatch(o, i, """    
        if ($7) {
        >0
        if ($3) goto label_$10 ;
        temp[$1] = PyInt_FromLong ( long_$6 );
        >1
        if ($4) goto label_$11 ;
        CLEARTEMP($1);
        temp[$2] = PyInt_FromLong ( long_$19 );
        } else if ($17) {
        temp[$2] = PyFloat_FromDouble($8);
        } else { label_$10 :;
        if ((temp[$1] = PyNumber_$18) == 0) goto label_$12;
        label_$11 :;
        if ((temp[$2] = PyNumber_$9) == 0) goto label_$12;
        CLEARTEMP($1);
        }
        """, v2):
            TxRepl(o, i, """
                if ($7) {
                >0
                if ($3) goto label_$10 ;
                temp[$1] = PyInt_FromLong ( long_$6 );
                >1
                CLEARTEMP($1);
                if ($4) goto label_$10 ;
                temp[$2] = PyInt_FromLong ( long_$19 );
                } else if ($17) {
                temp[$2] = PyFloat_FromDouble($8);
                } else { label_$10 :;
                if ((temp[$1] = PyNumber_$18) == 0) goto label_$12;
                if ((temp[$2] = PyNumber_$9) == 0) goto label_$12;
                CLEARTEMP($1);
                }                      
                    """, v2)
            return True
        
    if TxMatch(o, i, """  
        if ($1) {
        >2
        temp[$3] = PyInt_FromLong ($4);
        } else {
        >5
        }
        long_$6 = PyInt_AsLong ( temp[$3] );
        CLEARTEMP($3);
        """, v2):
                TxRepl(o, i, """
                    if ($1) {
                    >2
                    temp[$3] = PyInt_FromLong ($4);
                    long_$6 = PyInt_AsLong ( temp[$3] );
                    CLEARTEMP($3);
                    } else {
                    >5
                    long_$6 = PyInt_AsLong ( temp[$3] );
                    CLEARTEMP($3);
                    }
                    """, v2)
                return True 

    if TxMatch(o, i, """  
if ($0) {
>0
temp[$2] = PyInt_FromLong ( $3 );
<1
} else {
>2
}
<3
if ((temp[$1] = $4) == 0) goto label_$10;
if (PyInt_CheckExact( temp[$2] ) && $11) {
>4
} else {
>5
}
        """, v2) and v2[2] != v2[1]:
                TxRepl(o, i, """
if ($0) {
>0
temp[$2] = PyInt_FromLong ( $3 );
<1
<3
if ((temp[$1] = $4) == 0) goto label_$10;
if ($11) {
>4
} else {
>5
}
} else {
>2
<3
if ((temp[$1] = $4) == 0) goto label_$10;
>5
}
                    """, v2)
                return True 

    if TxMatch(o, i, """  
if ($0) {
>1
if ((temp[$2] = PyBool_FromLong ($3)) == 0) goto label_$10;
} else {
>4
}
if ((int_$5 = PyObject_IsTrue ( temp[$2] )) == -1) goto label_$10;
CLEARTEMP($2);
        """, v2):
                TxRepl(o, i, """
if ($0) {
>1
int_$5 = ($3);
} else {
>4
if ((int_$5 = PyObject_IsTrue ( temp[$2] )) == -1) goto label_$10;
CLEARTEMP($2);
}
                    """, v2)
                return True 

    if TxMatch(o, i, """  
if ($0) {
>1
temp[$10] = PyBool_FromLong($2);
} else {
temp[$10] = consts[$11];
Py_INCREF(temp[$10]);
}
int_$3 = PyObject_IsTrue ( temp[$10] );
CLEARTEMP($10);
        """, v2):
                TxRepl(o, i, """
if ($0) {
>1
int_$3 = ($2);
} else {
int_$3 = PyObject_IsTrue ( consts[$11] );
}
                    """, v2)
                return True 
 
    if TxMatch(o, i, """ 
        if ($10) {
        temp[$0] = PyInt_FromLong ( $11 );
        } else {
        >0
        }
        $12 = PyInt_AsLong(temp[$0]);
        CLEARTEMP($0);
        """, v2):
                TxRepl(o, i, """
                    if ($10) {
                    $12 = $11;
                    } else {
                    >0
                    $12 = PyInt_AsLong(temp[$0]);
                    CLEARTEMP($0);
                    }
                    """, v2)
                return True
            
    if 'if (PyInt_CheckExact(' in o[i]:  
        if TxMatch(o, i, """    
            if (PyInt_CheckExact( $0 )) {
            >0
            if ($9) goto label_$4 ;
            temp[$1] = PyInt_FromLong ( long_$7 );
            } else { label_$4 :;
            if ((temp[$1] = PyNumber_$11) == 0) goto label_$6;
            }
            if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( $3 )) {
            long_$13 = PyInt_AS_LONG ( temp[$1] );        
            >1
            if ($10) goto label_$5 ;
            temp[$2] = PyInt_FromLong ( long_$8 );
            } else { label_$5 :;
            if ((temp[$2] = PyNumber_$12) == 0) goto label_$6;
            }
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $3 )) {
                    >0
                    if ($9) goto label_$4 ;
                    long_$13 = long_$7;        
                    >1
                    if ($10) goto label_$4 ;
                    temp[$2] = PyInt_FromLong ( long_$8 );
                    } else { label_$4 :;
                    if ((temp[$1] = PyNumber_$11) == 0) goto label_$6;
                    if ((temp[$2] = PyNumber_$12) == 0) goto label_$6;
                    CLEARTEMP($1);
                    }
                        """, v2)
                return True
          
        if TxMatch(o, i, """    
            if (PyInt_CheckExact( temp[$0] )$4) {
            temp[$1] = PyInt_FromLong ( $5 );
            } else {
            if ((temp[$1] = $6) == 0) goto label_$9;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$2] ) && PyInt_CheckExact( temp[$1] )) {
            temp[$3] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$2] ) $7 PyInt_AS_LONG ( temp[$1] ) );
            } else {
            if ((temp[$3] = PyNumber_$8 ( temp[$2] , temp[$1] )) == 0) goto label_$9;
            }
            CLEARTEMP($2);
            CLEARTEMP($1);
            """, v2) and ('temp[%s]' % v2[0]) not in v2[5]:
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$2] ) && PyInt_CheckExact( temp[$0] )$4) {
                        CLEARTEMP($0); 
                        temp[$3] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$2] ) $7 ($5) );
                        CLEARTEMP($2);
                        } else {
                        if ((temp[$1] = $6) == 0) goto label_$9;
                        CLEARTEMP($0);
                        if ((temp[$3] = PyNumber_$8 ( temp[$2] , temp[$1] )) == 0) goto label_$9;
                        CLEARTEMP($2);
                        CLEARTEMP($1);
                        }
                        """, v2)
                    return True
        if TxMatch(o, i, """    
            if (PyInt_CheckExact( $0 )) {
            >0
            temp[$1] = PyInt_FromLong ( $4 );
            <1
            } else {
            >2
            if ((temp[$1] = $5) == 0) goto label_$3;
            <3
            }
            <4
            if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( temp[$1] )) {
            >5
            if ($11) {
            temp[$2] = PyInt_FromLong ( $12 );
            } else {
            temp[$2] = PyInt_Type.tp_as_number->nb_multiply($13);
            }
            } else {
            if ((temp[$2] = $14) == 0) goto label_$3;
            }
            CLEARTEMP($1);
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 )) {
                        >0
                        temp[$1] = PyInt_FromLong ( $4 );
                        <1
                        <4
                        >5
                        if ($11) {
                        temp[$2] = PyInt_FromLong ( $12 );
                        } else {
                        temp[$2] = PyInt_Type.tp_as_number->nb_multiply($13);
                        }
                        CLEARTEMP($1);
                        } else {
                        >2
                        if ((temp[$1] = $5) == 0) goto label_$3;
                        <3
                        <4
                        if ((temp[$2] = $14) == 0) goto label_$3;
                        CLEARTEMP($1);
                        }
                        """, v2)
                    return True


        if TxMatch(o, i, """
            if ($10) {
            Py_DECREF($11);
            $11 = PyInt_FromLong ( $12 );
            } else {
            >0
            }
            if (PyInt_CheckExact( $11 )) {
            >1
            } else {
            >2
            }
            <3
            """, v2):
                TxRepl(o, i, """
                    if ($10) {
                    Py_DECREF($11);
                    $11 = PyInt_FromLong ( $12 );
                    >1
                    <3
                    } else {
                    >0
                    >2
                    <3
                    }
                       """, v2)
                return True       
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
            'temp[$5] = PyInt_FromLong ( $2 + 1 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
            '} else {',
            'if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $3;',
            '}',
            'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
            'CLEARTEMP($5);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    '$2 = $2 + 1;',
                    'temp[$5] = PyInt_FromLong ( $2 );',
                    'if ((temp[$6] = _c_BINARY_SUBSCR_Int ( $4 , $2 , temp[$5] )) == 0) goto $3;',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $3;',
                    'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
                    '}',
                    'CLEARTEMP($5);'), v2, ('_c_BINARY_SUBSCR_Int',))
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
            'temp[$5] = PyInt_FromLong ( $2 + 1 );',
            '} else {',
            'if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $3;',
            '}',
            'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
            'CLEARTEMP($5);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    '$2 = $2 + 1;',
                    'temp[$5] = PyInt_FromLong ( $2 );',
                    'if ((temp[$6] = _c_BINARY_SUBSCR_Int ( $4 , $2 , temp[$5] )) == 0) goto $3;',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $3;',
                    'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
                    '}',
                    'CLEARTEMP($5);'), v2, ('_c_BINARY_SUBSCR_Int',))
                return True
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
            'temp[$5] = PyInt_FromLong ( $2 - 1 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
            '} else {',
            'if ((temp[$5] = PyNumber_Subtract ( $1 , $7 )) == 0) goto $3;',
            '}',
            'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
            'CLEARTEMP($5);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    '$2 = $2 - 1;',
                    'temp[$5] = PyInt_FromLong ( $2 );',
                    'if ((temp[$6] = _c_BINARY_SUBSCR_Int ( $4 , $2 , temp[$5] )) == 0) goto $3;',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( $1 , $7 )) == 0) goto $3;',
                    'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
                    '}',
                    'CLEARTEMP($5);'), v2, ('_c_BINARY_SUBSCR_Int',))
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
            'temp[$5] = PyInt_FromLong ( $2 - 1 );',
            '} else {',
            'if ((temp[$5] = PyNumber_Subtract ( $1 , $7 )) == 0) goto $3;',
            '}',
            'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
            'CLEARTEMP($5);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    '$2 = $2 - 1;',
                    'temp[$5] = PyInt_FromLong ( $2 );',
                    'if ((temp[$6] = _c_BINARY_SUBSCR_Int ( $4 , $2 , temp[$5] )) == 0) goto $3;',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( $1 , $7 )) == 0) goto $3;',
                    'if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;',
                    '}',
                    'CLEARTEMP($5);'), v2, ('_c_BINARY_SUBSCR_Int',))
                return True
        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($1 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$6) ) {',
            'temp[$3] = PyInt_FromLong ( $1 + $7 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + ((double)$7));',
            '} else {',
            'if ((temp[$3] = PyNumber_Add ( $5 , $8 )) == 0) goto $10;',
            '}',
            'if (PyInt_CheckExact( temp[$3] )) {',
            '$2 = PyInt_AS_LONG ( temp[$3] );',
            'if ( $2 < 0) {',
            '$2 += PyList_GET_SIZE($9);',
            '}',
            'if ((temp[$4] = PyList_GetItem ( $9 , $2 )) == 0) goto $10;',
            'Py_INCREF(temp[$4]);',
            '} else {',
            'if ((temp[$4] = PyObject_GetItem ( $9 , temp[$3] )) == 0) goto $10;',
            '}',
            'CLEARTEMP($3);'), v2) and v2[1] != v2[2]:
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($1 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$6) ) {',
                    '$2 = $1 + $7;',
                    'if ( $2 < 0) {',
                    '$2 += PyList_GET_SIZE($9);',
                    '}',
                    'if ((temp[$4] = PyList_GetItem ( $9 , $2 )) == 0) goto $10;',
                    'Py_INCREF(temp[$4]);',
                    '} else {',
                    'if ((temp[$3] = PyNumber_Add ( $5 , $8 )) == 0) goto $10;',
                    'if ((temp[$4] = PyObject_GetItem ( $9 , temp[$3] )) == 0) goto $10;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($1 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$6) ) {',
            'temp[$3] = PyInt_FromLong ( $1 + $7 );',
            '} else {',
            'if ((temp[$3] = PyNumber_Add ( $5 , $8 )) == 0) goto $10;',
            '}',
            'if (PyInt_CheckExact( temp[$3] )) {',
            '$2 = PyInt_AS_LONG ( temp[$3] );',
            'if ( $2 < 0) {',
            '$2 += PyList_GET_SIZE($9);',
            '}',
            'if ((temp[$4] = PyList_GetItem ( $9 , $2 )) == 0) goto $10;',
            'Py_INCREF(temp[$4]);',
            '} else {',
            'if ((temp[$4] = PyObject_GetItem ( $9 , temp[$3] )) == 0) goto $10;',
            '}',
            'CLEARTEMP($3);'), v2) and v2[1] != v2[2]:
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($1 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$6) ) {',
                    '$2 = $1 + $7;',
                    'if ( $2 < 0) {',
                    '$2 += PyList_GET_SIZE($9);',
                    '}',
                    'if ((temp[$4] = PyList_GetItem ( $9 , $2 )) == 0) goto $10;',
                    'Py_INCREF(temp[$4]);',
                    '} else {',
                    'if ((temp[$3] = PyNumber_Add ( $5 , $8 )) == 0) goto $10;',
                    'if ((temp[$4] = PyObject_GetItem ( $9 , temp[$3] )) == 0) goto $10;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True
            
                            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$4 = PyInt_AS_LONG ( $1 );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE($2);',
            '}',
            'if ((temp[$0] = PyList_GetItem ( $2 , $4 )) == 0) goto $3;',
            'Py_INCREF(temp[$0]);',
            '} else {',
            'if ((temp[$0] = PyObject_GetItem ( $2 , $1 )) == 0) goto $3;',
            '}',
            'if (PyInt_CheckExact( $1 ) && ($5 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
            'temp[$6] = PyInt_FromLong ( $5 - 1 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$6] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
            '} else {',
            'if ((temp[$6] = PyNumber_Subtract ( $1 , consts[$11] )) == 0) goto $3;',
            '}'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($4 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    '$4 = PyInt_AS_LONG ( $1 );',
                    'temp[$6] = PyInt_FromLong ( $4 - 1 );',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE($2);',
                    '}',
                    'if ((temp[$0] = PyList_GetItem ( $2 , $4 )) == 0) goto $3;',
                    'Py_INCREF(temp[$0]);',
                    '} else {',
                    'if ((temp[$0] = PyObject_GetItem ( $2 , $1 )) == 0) goto $3;',
                    'if ((temp[$6] = PyNumber_Subtract ( $1 , consts[$11] )) == 0) goto $3;',
                    '}'), v2)
                return True
                            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$4 = PyInt_AS_LONG ( $1 );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE($2);',
            '}',
            'if ((temp[$0] = PyList_GetItem ( $2 , $4 )) == 0) goto $3;',
            'Py_INCREF(temp[$0]);',
            '} else {',
            'if ((temp[$0] = PyObject_GetItem ( $2 , $1 )) == 0) goto $3;',
            '}',
            'if (PyInt_CheckExact( $1 ) && ($5 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
            'temp[$6] = PyInt_FromLong ( $5 - 1 );',
            '} else {',
            'if ((temp[$6] = PyNumber_Subtract ( $1 , consts[$11] )) == 0) goto $3;',
            '}'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($4 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    '$4 = PyInt_AS_LONG ( $1 );',
                    'temp[$6] = PyInt_FromLong ( $4 - 1 );',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE($2);',
                    '}',
                    'if ((temp[$0] = PyList_GetItem ( $2 , $4 )) == 0) goto $3;',
                    'Py_INCREF(temp[$0]);',
                    '} else {',
                    'if ((temp[$0] = PyObject_GetItem ( $2 , $1 )) == 0) goto $3;',
                    'if ((temp[$6] = PyNumber_Subtract ( $1 , consts[$11] )) == 0) goto $3;',
                    '}'), v2)
                return True
        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            'if ( $2 < 0) {',
            '$2 += PyList_GET_SIZE($0);',
            '}',
            'if ((temp[$4] = PyList_GetItem ( $0 , $2 )) == 0) goto $6;',
            'Py_INCREF(temp[$4]);',
            '} else {',
            'if ((temp[$4] = PyObject_GetItem ( $0 , $1 )) == 0) goto $6;',
            '}',
            'if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
            '$2 = $3 + 1;',
            'if ( $2 < 0) {',
            '$2 += PyList_GET_SIZE($0);',
            '}',
            'if ( PyList_SetItem ( $0 , $2 , temp[$4] ) == -1) goto $6;',
            '} else {',
            'if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $6;',
            'if ( PyObject_SetItem ( $0 , temp[$5] , temp[$4] ) == -1) goto $6;',
            'Py_DECREF(temp[$4]);',
            'CLEARTEMP($5);',
            '}',
            'temp[$4] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 )) {',
                    '$3 = PyInt_AS_LONG ( $1 );',
                    '$2 = $3 + 1;',
                    'if ( $2 < 0) {',
                    '$2 += PyList_GET_SIZE($0);',
                    '}',
                    'if ( $3 < 0) {',
                    '$3 += PyList_GET_SIZE($0);',
                    '}',
                    'if ((temp[$4] = PyList_GetItem ( $0 , $3 )) == 0) goto $6;',
                    'Py_INCREF(temp[$4]);',
                    'if ( PyList_SetItem ( $0 , $2 , temp[$4] ) == -1) goto $6;',
                    '} else {',
                    'if ((temp[$4] = PyObject_GetItem ( $0 , $1 )) == 0) goto $6;',
                    'if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $6;',
                    'if ( PyObject_SetItem ( $0 , temp[$5] , temp[$4] ) == -1) goto $6;',
                    'Py_DECREF(temp[$4]);',
                    'CLEARTEMP($5);',
                    '}',
                    'temp[$4] = 0;'), v2)
                return True                
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($5 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$9) ) {',
            'temp[$4] = PyInt_FromLong ( $5 + $8 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$4] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + ((double)$8));',
            '} else {',
            'if ((temp[$4] = PyNumber_Add ( $2 , $10 )) == 0) goto $7;',
            '}',
            'SETLOCAL ( $1 , temp[$4] );',
            'temp[$4] = 0;',
                        
            'Py_INCREF($3);',
            'if (PyInt_CheckExact( GETLOCAL($1) )) {',
            '$6 = PyInt_AS_LONG ( GETLOCAL($1) );',
            'if ( $6 < 0) {',
            '$6 += PyList_GET_SIZE($11);',
            '}',
            'if ( PyList_SetItem ( $11 , $6 , $3 ) == -1) goto $7;',
            '} else {',
            'if ( PyObject_SetItem ( $11 , GETLOCAL($1) , $3 ) == -1) goto $7;',
            'Py_DECREF($3);',
            '}'), v2) and v2[6] != v2[5]:
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($5 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$9) ) {',
                    '$6 = $5 + $8;',
                    'temp[$4] = PyInt_FromLong ( $6 );',
                    'SETLOCAL ( $1 , temp[$4] );',
                    'temp[$4] = 0;',
                    'if ( $6 < 0) {',
                    '$6 += PyList_GET_SIZE($11);',
                    '}',
                    'Py_INCREF($3);',
                    'if ( PyList_SetItem ( $11 , $6 , $3 ) == -1) goto $7;',
                    '} else {',
                    'if ((temp[$4] = PyNumber_Add ( $2 , $10 )) == 0) goto $7;',
                    'SETLOCAL ( $1 , temp[$4] );',
                    'temp[$4] = 0;',
                    'if ( PyObject_SetItem ( $11 , GETLOCAL($1) , $3 ) == -1) goto $7;',
                    '}'), v2)
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($5 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$9) ) {',
            'temp[$4] = PyInt_FromLong ( $5 + $8 );',
            '} else {',
            'if ((temp[$4] = PyNumber_Add ( $2 , $10 )) == 0) goto $7;',
            '}',
            'SETLOCAL ( $1 , temp[$4] );',
            'temp[$4] = 0;',
                        
            'Py_INCREF($3);',
            'if (PyInt_CheckExact( GETLOCAL($1) )) {',
            '$6 = PyInt_AS_LONG ( GETLOCAL($1) );',
            'if ( $6 < 0) {',
            '$6 += PyList_GET_SIZE($11);',
            '}',
            'if ( PyList_SetItem ( $11 , $6 , $3 ) == -1) goto $7;',
            '} else {',
            'if ( PyObject_SetItem ( $11 , GETLOCAL($1) , $3 ) == -1) goto $7;',
            'Py_DECREF($3);',
            '}'), v2) and v2[6] != v2[5]:
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($5 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$9) ) {',
                    '$6 = $5 + $8;',
                    'temp[$4] = PyInt_FromLong ( $6 );',
                    'SETLOCAL ( $1 , temp[$4] );',
                    'temp[$4] = 0;',
                    'if ( $6 < 0) {',
                    '$6 += PyList_GET_SIZE($11);',
                    '}',
                    'Py_INCREF($3);',
                    'if ( PyList_SetItem ( $11 , $6 , $3 ) == -1) goto $7;',
                    '} else {',
                    'if ((temp[$4] = PyNumber_Add ( $2 , $10 )) == 0) goto $7;',
                    'SETLOCAL ( $1 , temp[$4] );',
                    'temp[$4] = 0;',
                    'if ( PyObject_SetItem ( $11 , GETLOCAL($1) , $3 ) == -1) goto $7;',
                    '}'), v2)
                return True

        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
            'temp[$1] = PyInt_FromLong ( $8 - $11 );',
            '} else if (PyFloat_CheckExact( temp[$0] )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) - ((double)$11));',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
            '}',
            'CLEARTEMP($0);',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$5 = $6 $7 PyInt_AS_LONG ( temp[$1] );',
            '} else {',
            'if ((temp[$3] = PyInt_FromSsize_t($6)) == 0) goto $2;',
            'if (($5 = PyObject_RichCompareBool ( temp[$3] , temp[$1] , $4 )) == -1) goto $2;',
            'CLEARTEMP($3);',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
                    'CLEARTEMP($0);',
                    '$5 = $6 $7 ($8 - $11);',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
                    'CLEARTEMP($0);',
                    'if ((temp[$3] = PyInt_FromSsize_t($6)) == 0) goto $2;',
                    'if (($5 = PyObject_RichCompareBool ( temp[$3] , temp[$1] , $4 )) == -1) goto $2;',
                    'CLEARTEMP($1);',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True  
        
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
            'temp[$1] = PyInt_FromLong ( $8 - $11 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
            '}',
            'CLEARTEMP($0);',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$5 = $6 $7 PyInt_AS_LONG ( temp[$1] );',
            '} else {',
            'if ((temp[$3] = PyInt_FromSsize_t($6)) == 0) goto $2;',
            'if (($5 = PyObject_RichCompareBool ( temp[$3] , temp[$1] , $4 )) == -1) goto $2;',
            'CLEARTEMP($3);',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
                    'CLEARTEMP($0);',
                    '$5 = $6 $7 ($8 - $11);',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
                    'CLEARTEMP($0);',
                    'if ((temp[$3] = PyInt_FromSsize_t($6)) == 0) goto $2;',
                    'if (($5 = PyObject_RichCompareBool ( temp[$3] , temp[$1] , $4 )) == -1) goto $2;',
                    'CLEARTEMP($1);',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True  
                            
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
            'temp[$1] = PyInt_FromLong ( $8 - $11 );',
            '} else if (PyFloat_CheckExact( temp[$0] )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) - ((double)$11));',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
            '}',
            'CLEARTEMP($0);',
            '$6 = PyInt_AsSsize_t ( temp[$1] );',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
                    'CLEARTEMP($0);',
                    '$6 = $8 - $11;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
                    'CLEARTEMP($0);',
                    '$6 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True              
        
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
            'temp[$1] = PyInt_FromLong ( $8 - $11 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
            '}',
            'CLEARTEMP($0);',
            '$6 = PyInt_AsSsize_t ( temp[$1] );',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {',
                    'CLEARTEMP($0);',
                    '$6 = $8 - $11;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;',
                    'CLEARTEMP($0);',
                    '$6 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True              

        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$1] )) {',
            'temp[$2] = PyInt_FromLong (PyInt_AS_LONG ( temp[$1] )&$8);',
            '} else {',
            'if ((temp[$2] = PyNumber_And ( temp[$1] , $7 )) == 0) goto $5;',
            '}',
            'CLEARTEMP($1);',
            'if (PyInt_CheckExact( temp[$2] )) {',
            '$4 = PyInt_AS_LONG ( temp[$2] );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE($6);',
            '}',
            'if ((temp[$3] = PyList_GetItem ( $6 , $4 )) == 0) goto $5;',
            'Py_INCREF(temp[$3]);',
            '} else {',
            'if ((temp[$3] = PyObject_GetItem ( $6 , temp[$2] )) == 0) goto $5;',
            '}',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$1] )) {',
                    '$4 = PyInt_AS_LONG ( temp[$1] )&$8;',
                    'CLEARTEMP($1);',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE($6);',
                    '}',
                    'if ((temp[$3] = PyList_GetItem ( $6 , $4 )) == 0) goto $5;',
                    'Py_INCREF(temp[$3]);',
                    '} else {',
                    'if ((temp[$2] = PyNumber_And ( temp[$1] , $7 )) == 0) goto $5;',
                    'CLEARTEMP($1);',
                    'if ((temp[$3] = PyObject_GetItem ( $6 , temp[$2] )) == 0) goto $5;',
                    '}',
                    'CLEARTEMP($2);'), v2)
                return True      
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < $5 ) {',
            'temp[$9] = PyInt_FromLong ( $3 + $6 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$9] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$6));',
            '} else {',
            'if ((temp[$9] = PyNumber_Add ( $1 , $7 )) == 0) goto $8;',
            '}',
            'if (PyInt_CheckExact( temp[$9] )) {',
            '$4 = PyInt_AS_LONG ( temp[$9] );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE($2);',
            '}',
            'if ( PyList_SetItem ( $2 , $4 , temp[$10] ) == -1) goto $8;',
            '} else {',
            'if ( PyObject_SetItem ( $2 , temp[$9] , temp[$10] ) == -1) goto $8;',
            'Py_DECREF(temp[$10]);',
            '}',
            'CLEARTEMP($9);',
            'temp[$10] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < $5 ) {',
                    '$4 = $3 + $6;',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE($2);',
                    '}',
                    'if ( PyList_SetItem ( $2 , $4 , temp[$10] ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$9] = PyNumber_Add ( $1 , $7 )) == 0) goto $8;',
                    'if ( PyObject_SetItem ( $2 , temp[$9] , temp[$10] ) == -1) goto $8;',
                    'Py_DECREF(temp[$10]);',
                    'CLEARTEMP($9);',
                    '}',
                    'temp[$10] = 0;'), v2)
                return True    
            
                            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < $5 ) {',
            'temp[$9] = PyInt_FromLong ( $3 + $6 );',
            '} else {',
            'if ((temp[$9] = PyNumber_Add ( $1 , $7 )) == 0) goto $8;',
            '}',
            'if (PyInt_CheckExact( temp[$9] )) {',
            '$4 = PyInt_AS_LONG ( temp[$9] );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE($2);',
            '}',
            'if ( PyList_SetItem ( $2 , $4 , temp[$10] ) == -1) goto $8;',
            '} else {',
            'if ( PyObject_SetItem ( $2 , temp[$9] , temp[$10] ) == -1) goto $8;',
            'Py_DECREF(temp[$10]);',
            '}',
            'CLEARTEMP($9);',
            'temp[$10] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < $5 ) {',
                    '$4 = $3 + $6;',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE($2);',
                    '}',
                    'if ( PyList_SetItem ( $2 , $4 , temp[$10] ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$9] = PyNumber_Add ( $1 , $7 )) == 0) goto $8;',
                    'if ( PyObject_SetItem ( $2 , temp[$9] , temp[$10] ) == -1) goto $8;',
                    'Py_DECREF(temp[$10]);',
                    'CLEARTEMP($9);',
                    '}',
                    'temp[$10] = 0;'), v2)
                return True    
                        
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$1] ) && ($4 = PyInt_AS_LONG ( temp[$1] )) < $5 ) {',
            'temp[$2] = PyInt_FromLong ( $4 + $6 );',
            '} else if (PyFloat_CheckExact( temp[$1] )) {',
            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) + ((double)$6));',
            '} else {',
            'if ((temp[$2] = PyNumber_Add ( temp[$1] , $7 )) == 0) goto $8;',
            '}',
            'CLEARTEMP($1);',
            'if (PyInt_CheckExact( temp[$2] )) {',
            '$9 = PyInt_AS_LONG ( temp[$2] );',
            '$9 = Py_ARITHMETIC_RIGHT_SHIFT(long, $9, $10);',
            'temp[$3] = PyInt_FromLong ($9);',
            '} else {',
            'if ((temp[$3] = PyNumber_Rshift(temp[$2], $11)) == 0) goto $8;',
            '}',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$1] ) && ($4 = PyInt_AS_LONG ( temp[$1] )) < $5 ) {',
                    'CLEARTEMP($1);',
                    '$9 = $4 + $6;',
                    '$9 = Py_ARITHMETIC_RIGHT_SHIFT(long, $9, $10);',
                    'temp[$3] = PyInt_FromLong ($9);',
                    '} else {',
                    'if ((temp[$2] = PyNumber_Add ( temp[$1] , $7 )) == 0) goto $8;',
                    'CLEARTEMP($1);',
                    'if ((temp[$3] = PyNumber_Rshift(temp[$2], $11)) == 0) goto $8;',
                    'CLEARTEMP($2);',
                    '}'), v2)
                return True    
        
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$1] ) && ($4 = PyInt_AS_LONG ( temp[$1] )) < $5 ) {',
            'temp[$2] = PyInt_FromLong ( $4 + $6 );',
            '} else {',
            'if ((temp[$2] = PyNumber_Add ( temp[$1] , $7 )) == 0) goto $8;',
            '}',
            'CLEARTEMP($1);',
            'if (PyInt_CheckExact( temp[$2] )) {',
            '$9 = PyInt_AS_LONG ( temp[$2] );',
            '$9 = Py_ARITHMETIC_RIGHT_SHIFT(long, $9, $10);',
            'temp[$3] = PyInt_FromLong ($9);',
            '} else {',
            'if ((temp[$3] = PyNumber_Rshift(temp[$2], $11)) == 0) goto $8;',
            '}',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$1] ) && ($4 = PyInt_AS_LONG ( temp[$1] )) < $5 ) {',
                    'CLEARTEMP($1);',
                    '$9 = $4 + $6;',
                    '$9 = Py_ARITHMETIC_RIGHT_SHIFT(long, $9, $10);',
                    'temp[$3] = PyInt_FromLong ($9);',
                    '} else {',
                    'if ((temp[$2] = PyNumber_Add ( temp[$1] , $7 )) == 0) goto $8;',
                    'CLEARTEMP($1);',
                    'if ((temp[$3] = PyNumber_Rshift(temp[$2], $11)) == 0) goto $8;',
                    'CLEARTEMP($2);',
                    '}'), v2)
                return True    
                    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
            'temp[$3] = PyInt_FromLong ( $2 - 1 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
            '} else {',
            'if ((temp[$3] = PyNumber_Subtract ( $1 , $5 )) == 0) goto $4;',
            '}',
            'if (PyInt_CheckExact( temp[$3] )) {',
            '$6 = PyInt_AS_LONG ( temp[$3] );',
            'if ( $6 < 0) {',
            '$6 += PyList_GET_SIZE($7);',
            '}',
            'if ((temp[$8] = PyList_GetItem ( $7 , $6 )) == 0) goto $4;',
            'Py_INCREF(temp[$8]);',
            '} else {',
            'if ((temp[$8] = PyObject_GetItem ( $7 , temp[$3] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($3);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    '$6 = $2 - 1;',
                    'if ( $6 < 0) {',
                    '$6 += PyList_GET_SIZE($7);',
                    '}',
                    'if ((temp[$8] = PyList_GetItem ( $7 , $6 )) == 0) goto $4;',
                    'Py_INCREF(temp[$8]);',
                    'temp[$3] = 0;',
                    '} else {',
                    'if ((temp[$3] = PyNumber_Subtract ( $1 , $5 )) == 0) goto $4;',
                    'if ((temp[$8] = PyObject_GetItem ( $7 , temp[$3] )) == 0) goto $4;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
            'temp[$3] = PyInt_FromLong ( $2 - 1 );',
            '} else {',
            'if ((temp[$3] = PyNumber_Subtract ( $1 , $5 )) == 0) goto $4;',
            '}',
            'if (PyInt_CheckExact( temp[$3] )) {',
            '$6 = PyInt_AS_LONG ( temp[$3] );',
            'if ( $6 < 0) {',
            '$6 += PyList_GET_SIZE($7);',
            '}',
            'if ((temp[$8] = PyList_GetItem ( $7 , $6 )) == 0) goto $4;',
            'Py_INCREF(temp[$8]);',
            '} else {',
            'if ((temp[$8] = PyObject_GetItem ( $7 , temp[$3] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($3);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    '$6 = $2 - 1;',
                    'if ( $6 < 0) {',
                    '$6 += PyList_GET_SIZE($7);',
                    '}',
                    'if ((temp[$8] = PyList_GetItem ( $7 , $6 )) == 0) goto $4;',
                    'Py_INCREF(temp[$8]);',
                    'temp[$3] = 0;',
                    '} else {',
                    'if ((temp[$3] = PyNumber_Subtract ( $1 , $5 )) == 0) goto $4;',
                    'if ((temp[$8] = PyObject_GetItem ( $7 , temp[$3] )) == 0) goto $4;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True    
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            'long_$2 = PyInt_AS_LONG ( $1 );',
            'long_$2 = Py_ARITHMETIC_RIGHT_SHIFT(long, long_$2, $3);',
            'temp[$5] = PyInt_FromLong (long_$2);',
            '} else {',
            'if ((temp[$5] = PyNumber_Rshift($1, consts[$4])) == 0) goto $6;',
            '}',
            'if (PyInt_CheckExact( temp[$5] )) {',
            'temp[$0] = PyInt_FromLong ($8);',
            '} else {',
            'if ((temp[$0] = $9 ( temp[$5] , consts[$7] )) == 0) goto $6;',
            '}',
            'CLEARTEMP($5);'), v2):
                fr = ('PyInt_AS_LONG ( temp[' + v2[5] +'] )')
                if fr in v2[8]:
                    v2[8] = v2[8].replace(fr, 'long_' + v2[2])
                    TxRepl(o, i, ('if (PyInt_CheckExact( $1 )) {',
                        'long_$2 = PyInt_AS_LONG ( $1 );',
                        'long_$2 = Py_ARITHMETIC_RIGHT_SHIFT(long, long_$2, $3);',
                        'temp[$0] = PyInt_FromLong ($8);',
                        '} else {',
                        'if ((temp[$5] = PyNumber_Rshift($1, consts[$4])) == 0) goto $6;',
                        'if ((temp[$0] = $9 ( temp[$5] , consts[$7] )) == 0) goto $6;',
                        'CLEARTEMP($5);',
                        '}'), v2)
                    return True    
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            'if ( $2 < 0) {',
            '$2 += PyList_GET_SIZE($0);',
            '}',
            'if ((temp[$4] = PyList_GetItem ( $0 , $2 )) == 0) goto $3;',
            'Py_INCREF(temp[$4]);',
            '} else {',
            'if ((temp[$4] = PyObject_GetItem ( $0 , $1 )) == 0) goto $3;',
            '}',
            'if ((int_$11 = PyObject_RichCompareBool ( temp[$4] , $5 , $6 )) == -1) goto $3;',
            'CLEARTEMP($4);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 )) {',
                    '$2 = PyInt_AS_LONG ( $1 );',
                    'if ( $2 < 0) {',
                    '$2 += PyList_GET_SIZE($0);',
                    '}',
                    'if ((temp[$4] = PyList_GetItem ( $0 , $2 )) == 0) goto $3;',
                    'if ((int_$11 = PyObject_RichCompareBool ( temp[$4] , $5 , $6 )) == -1) goto $3;',
                    'temp[$4] = 0;',
                    '} else {',
                    'if ((temp[$4] = PyObject_GetItem ( $0 , $1 )) == 0) goto $3;',
                    'if ((int_$11 = PyObject_RichCompareBool ( temp[$4] , $5 , $6 )) == -1) goto $3;',
                    'CLEARTEMP($4);',
                    '}'), v2)
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - 1 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - 1 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - 1 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)1));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - 1 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)$0));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > (INT_MIN+$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - $0 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)$0));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True  
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > (INT_MIN+$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - $0 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True  
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)$0));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > (INT_MIN+$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - $0 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - ((double)$0));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True  
                        
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 - $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > (INT_MIN+$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - $0 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceSubtract ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True  
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$1] )) {',
            '$2 = PyInt_AS_LONG ( temp[$1] );',
            '$3 = $2 - $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Subtract ( temp[$1] , consts[$7] )) == 0) goto $6;',
            '}',
            'CLEARTEMP($1);'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$1] ) && ($2 = PyInt_AS_LONG ( temp[$1] )) > (INT_MIN+$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - $0 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Subtract ( temp[$1] , consts[$7] )) == 0) goto $6;',
                    '}',
                    'CLEARTEMP($1);'), v2)
                return True  
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$1] )) {',
            '$2 = PyInt_AS_LONG ( temp[$1] );',
            '$3 = $2 - $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^~ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceSubtract ( temp[$1] , consts[$7] )) == 0) goto $6;',
            '}',
            'CLEARTEMP($1);'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( temp[$1] ) && ($2 = PyInt_AS_LONG ( temp[$1] )) > (INT_MIN+$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 - $0 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceSubtract ( temp[$1] , consts[$7] )) == 0) goto $6;',
                    '}',
                    'CLEARTEMP($1);'), v2)
                return True  
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 + 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    'temp[$5] = PyInt_FromLong ( $2 + 1 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 + 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    'temp[$5] = PyInt_FromLong ( $2 + 1 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 + 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceAdd ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    'temp[$5] = PyInt_FromLong ( $2 + 1 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceAdd ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 + 1;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^ 1 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_InPlaceAdd ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2): 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    'temp[$5] = PyInt_FromLong ( $2 + 1 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_InPlaceAdd ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 + $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$0));',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < (INT_MAX-$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 + $0 );',
                    '} else if (PyFloat_CheckExact( $1 )) {',
                    'temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$0));',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $2 + $0;',
            'if (( $3 ^ $2 ) < 0 && ( $3 ^ $0 ) < 0) goto $4 ;',
            'temp[$5] = PyInt_FromLong ( $3 );',
            '} else { $4 :;',
            'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
            '}'), v2) and int(v2[0]) > 0: 
                v2[8] = str(int(v2[0])-1) 
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < (INT_MAX-$8) ) {',
                    'temp[$5] = PyInt_FromLong ( $2 + $0 );',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $1 , consts[$7] )) == 0) goto $6;',
                    '}'), v2)
                return True    
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( temp[$1] )) {',
            'temp[$2] = PyInt_FromLong ($3);',
            '} else {',
            'if ((temp[$2] = $5) == 0) goto label_$11;',
            '}',
            'CLEARTEMP($1);',
            'long_$4 = PyInt_AsLong ( temp[$2] );',
            'CLEARTEMP($2);'), v2):
            TxRepl(o, i, ('if (PyInt_CheckExact( temp[$1] )) {',
                'long_$4 = ($3);',
                '} else {',
                'if ((temp[$2] = $5) == 0) goto label_$11;',
                'long_$4 = PyInt_AsLong ( temp[$2] );',
                'CLEARTEMP($2);',
                '}',
                'CLEARTEMP($1);'), v2)                
            return True    
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
            'temp[$0] = PyInt_FromLong ( $3 + 1 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + ((double)1));',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $5;',
            '}',
            'if (PyInt_CheckExact( temp[$0] )) {',
            '$4 = PyInt_AS_LONG ( temp[$0] );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE(GETLOCAL(cmds));',
            '}',
            'if ((temp[$1] = PyList_GetItem ( GETLOCAL(cmds) , $4 )) == 0) goto $5;',
            'Py_INCREF(temp[$1]);',
            '} else {',
            'if ((temp[$1] = PyObject_GetItem ( GETLOCAL(cmds) , temp[$0] )) == 0) goto $5;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
                    '$4 = $3 + 1;',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE(GETLOCAL(cmds));',
                    '}',
                    'if ((temp[$1] = PyList_GetItem ( GETLOCAL(cmds) , $4 )) == 0) goto $5;',
                    'Py_INCREF(temp[$1]);',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $5;',
                    'if ((temp[$1] = PyObject_GetItem ( GETLOCAL(cmds) , temp[$0] )) == 0) goto $5;',
                    'CLEARTEMP($0);'
                    '}'), v2)
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
            'temp[$0] = PyInt_FromLong ( $3 + 1 );',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $5;',
            '}',
            'if (PyInt_CheckExact( temp[$0] )) {',
            '$4 = PyInt_AS_LONG ( temp[$0] );',
            'if ( $4 < 0) {',
            '$4 += PyList_GET_SIZE(GETLOCAL(cmds));',
            '}',
            'if ((temp[$1] = PyList_GetItem ( GETLOCAL(cmds) , $4 )) == 0) goto $5;',
            'Py_INCREF(temp[$1]);',
            '} else {',
            'if ((temp[$1] = PyObject_GetItem ( GETLOCAL(cmds) , temp[$0] )) == 0) goto $5;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
                    '$4 = $3 + 1;',
                    'if ( $4 < 0) {',
                    '$4 += PyList_GET_SIZE(GETLOCAL(cmds));',
                    '}',
                    'if ((temp[$1] = PyList_GetItem ( GETLOCAL(cmds) , $4 )) == 0) goto $5;',
                    'Py_INCREF(temp[$1]);',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $5;',
                    'if ((temp[$1] = PyObject_GetItem ( GETLOCAL(cmds) , temp[$0] )) == 0) goto $5;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $4 + 1 );',
            '} else if (PyFloat_CheckExact( $3 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $3 , $7 )) == 0) goto $5;',
            '}',
            'if ((temp[$2] = _PyEval_ApplySlice ( $6 , temp[$1] , NULL )) == 0) goto $5;',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
                    'if ((temp[$2] = PySequence_GetSlice ( $6 , $4 + 1 , PY_SSIZE_T_MAX )) == 0) goto $5;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $3 , $7 )) == 0) goto $5;',
                    'if ((temp[$2] = _PyEval_ApplySlice ( $6 , temp[$1] , NULL )) == 0) goto $5;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
                
        if TxMatch(o, i, """   
            if ($1) {
            >0
            temp[$10] = PyInt_FromLong ( $15 );
            <1
            } else {
            >2
            if ((temp[$10] = $14) == 0) goto label_$12;
            <3
            }
            <4
            if ((temp[$11] = _PyEval_ApplySlice ( $16 , temp[$10] , NULL )) == 0) goto label_$12;
            <5
            CLEARTEMP($10);
            """, v2):
                TxRepl(o, i, """
                    if ($1) {
                    >0
                    <1
                    if ((temp[$11] = PySequence_GetSlice ( $16 , $15 , PY_SSIZE_T_MAX )) == 0) goto label_$12;
                    <4
                    <5
                    } else {
                    >2
                    if ((temp[$10] = $14) == 0) goto label_$12;
                    <3
                    <4
                    if ((temp[$11] = _PyEval_ApplySlice ( $16 , temp[$10] , NULL )) == 0) goto label_$12;
                    <5
                    CLEARTEMP($10);
                    }
                    """, v2)
                return True

        if TxMatch(o, i, """            
            if ($10) {
            >0
            if ($11) goto label_$4 ;
            temp[$4] = PyInt_FromLong ($12);
            <2
            } else if ($14) {
            >5
            temp[$4] = PyFloat_FromDouble($15);
            <3
            } else { label_$4 :;
            >6
            if ((temp[$4] = PyNumber_$18 ($16)) == 0) goto label_$0;
            <4
            }
            <1
            if ((temp[$17] = PyObject_GetIter ( temp[$4] )) == 0) goto label_$0;
            CLEARTEMP($4);
            """, v2):
                TxRepl(o, i, """            
                    >6
                    if ((temp[$4] = PyNumber_$18 ($16)) == 0) goto label_$0;
                    <4
                    <1
                    if ((temp[$17] = PyObject_GetIter ( temp[$4] )) == 0) goto label_$0;
                    CLEARTEMP($4);
                    """, v2)
                return True

        if TxMatch(o, i, """            
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) < (INT_MAX-$2) ) {
            temp[$5] = PyInt_FromLong ( long_$1 + $3 );
            } else {
            if ((temp[$5] = PyNumber_Add ( $0 , $4 )) == 0) goto label_$7;
            }
            if ((temp[$6] = _PyEval_ApplySlice ( $8 , $0 , temp[$5] )) == 0) goto label_$7;
            CLEARTEMP($5);
            """, v2):
                TxRepl(o, i, """            
                    if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) < (INT_MAX-$2) ) {
                    if ((temp[$6] = PySequence_GetSlice ( $8 , long_$1 , long_$1 + $3 )) == 0) goto label_$7;
                    } else {
                    if ((temp[$5] = PyNumber_Add ( $0 , $4 )) == 0) goto label_$7;
                    if ((temp[$6] = _PyEval_ApplySlice ( $8 , $0 , temp[$5] )) == 0) goto label_$7;
                    CLEARTEMP($5);
                    }
                    """, v2)
                return True
            
            
        if TxMatch(o, i, """            
            if (PyInt_CheckExact( $0 )) {
            long_$4 = PyInt_AS_LONG ( $1 );
            long_$5 = PyInt_AS_LONG ( $0 );
            long_$6 = long_$4 $11 long_$5;
            if ($10) goto label_$2 ;
            temp[$7] = PyInt_FromLong ( long_$6 );
            } else { label_$2 :;
            if ((temp[$7] = PyNumber_$12 ( $1 , $0 )) == 0) goto label_$3;
            }
            if ((temp[$8] = _PyEval_ApplySlice ( $9 , $1 , temp[$7] )) == 0) goto label_$3;
            CLEARTEMP($7);            
            """, v2):
                TxRepl(o, i, """            
                    if (PyInt_CheckExact( $0 )) {
                    long_$4 = PyInt_AS_LONG ( $1 );
                    long_$5 = PyInt_AS_LONG ( $0 );
                    long_$6 = long_$4 $11 long_$5;
                    if ($10) goto label_$2 ;
                    if ((temp[$8] = PySequence_GetSlice ( $9 , long_$4 , long_$6 )) == 0) goto label_$3;
                    } else { label_$2 :;
                    if ((temp[$7] = PyNumber_$12 ( $1 , $0 )) == 0) goto label_$3;
                    if ((temp[$8] = _PyEval_ApplySlice ( $9 , $1 , temp[$7] )) == 0) goto label_$3;
                    CLEARTEMP($7);            
                    }
                    """, v2)
                return True
            
        if TxMatch(o, i, """            
            if (PyInt_CheckExact( $0 )) {
            long_$5 = PyInt_AS_LONG ( $0 );
            long_$6 = $8;
            long_$7 = long_$5 + long_$6;
            if (( long_$7 ^ long_$5 ) < 0 && ( long_$7 ^ long_$6 ) < 0) goto label_$3 ;
            temp[$9] = PyInt_FromLong ( long_$7 );
            } else { label_$3 :;
            temp[$10] = PyInt_FromLong ($8);
            if ((temp[$9] = PyNumber_Add ( $0 , temp[$10] )) == 0) goto label_$4;
            CLEARTEMP($10);
            }
            if (($1 = _PyEval_ApplySlice ( $2 , $0 , temp[$9] )) == 0) goto label_$4;
            CLEARTEMP($9);            
            """, v2):
                TxRepl(o, i, """            
                    if (PyInt_CheckExact( $0 )) {
                    long_$5 = PyInt_AS_LONG ( $0 );
                    long_$6 = $8;
                    long_$7 = long_$5 + long_$6;
                    if (( long_$7 ^ long_$5 ) < 0 && ( long_$7 ^ long_$6 ) < 0) goto label_$3 ;
                    if (($1 = PySequence_GetSlice ( $2 , long_$5 , long_$7 )) == 0) goto label_$4;
                    } else { label_$3 :;
                    temp[$10] = PyInt_FromLong ($8);
                    if ((temp[$9] = PyNumber_Add ( $0 , temp[$10] )) == 0) goto label_$4;
                    CLEARTEMP($10);
                    if (($1 = _PyEval_ApplySlice ( $2 , $0 , temp[$9] )) == 0) goto label_$4;
                    CLEARTEMP($9);     
                    }
                    """, v2)
                return True
            
        if TxMatch(o, i, """            
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $5 $2 ) {
            temp[$3] = PyInt_FromLong ($4);
            } else {
            if ((temp[$3] = PyNumber_$7 ( $0 , $6 )) == 0) goto label_$8;
            }
            if ((temp[$9] = _PyEval_ApplySlice ( $10 , $11 , temp[$3] )) == 0) goto label_$8;
            CLEARTEMP($3);            
            """, v2) and v2[0] != v2[11] and not 'NULL' in v2[11]:
                TxRepl(o, i, """            
                    if (PyInt_CheckExact( $11 ) && PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $5 $2 ) {
                    if ((temp[$9] = PySequence_GetSlice ( $10 , PyInt_AS_LONG ( $11 ) , $4 )) == 0) goto label_$8;
                    } else {
                    if ((temp[$3] = PyNumber_$7 ( $0 , $6 )) == 0) goto label_$8;
                    if ((temp[$9] = _PyEval_ApplySlice ( $10 , $11 , temp[$3] )) == 0) goto label_$8;
                    CLEARTEMP($3);            
                    }
                    """, v2)
                return True
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $4 + 1 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $3 , $7 )) == 0) goto $5;',
            '}',
            'if ((temp[$2] = _PyEval_ApplySlice ( $6 , temp[$1] , NULL )) == 0) goto $5;',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
                    'if ((temp[$2] = PySequence_GetSlice ( $6 , $4 + 1 , PY_SSIZE_T_MAX )) == 0) goto $5;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $3 , $7 )) == 0) goto $5;',
                    'if ((temp[$2] = _PyEval_ApplySlice ( $6 , temp[$1] , NULL )) == 0) goto $5;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($5 = PyInt_AS_LONG ( $3 )) > INT_MIN ) {',
            'temp[$1] = PyInt_FromLong ( $5 - 1 );',
            '} else if (PyFloat_CheckExact( $3 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( $3 , $4 )) == 0) goto $6;',
            '}',
            'if (($8 = PyObject_Size ( $10 )) == -1) goto $6;',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$9 = PyInt_AS_LONG ( temp[$1] ) $15 $8;',
            '} else {',
            'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $6;',
            'if (($9 = PyObject_RichCompareBool ( temp[$1] , temp[$2] , Py_$7 )) == -1) goto $6;',
            'CLEARTEMP($2);',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($5 = PyInt_AS_LONG ( $3 )) > INT_MIN ) {',
                    'if (($8 = PyObject_Size ( $10 )) == -1) goto $6;',
                    '$9 = ($5 - 1) $15 $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( $3 , $4 )) == 0) goto $6;',
                    'if (($8 = PyObject_Size ( $10 )) == -1) goto $6;',
                    'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $6;',
                    'if (($9 = PyObject_RichCompareBool ( temp[$1] , temp[$2] , Py_$7 )) == -1) goto $6;',
                    'CLEARTEMP($2);',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($5 = PyInt_AS_LONG ( $3 )) > INT_MIN ) {',
            'temp[$1] = PyInt_FromLong ( $5 - 1 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( $3 , $4 )) == 0) goto $6;',
            '}',
            'if (($8 = PyObject_Size ( $10 )) == -1) goto $6;',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$9 = PyInt_AS_LONG ( temp[$1] ) $15 $8;',
            '} else {',
            'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $6;',
            'if (($9 = PyObject_RichCompareBool ( temp[$1] , temp[$2] , Py_$7 )) == -1) goto $6;',
            'CLEARTEMP($2);',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($5 = PyInt_AS_LONG ( $3 )) > INT_MIN ) {',
                    'if (($8 = PyObject_Size ( $10 )) == -1) goto $6;',
                    '$9 = ($5 - 1) $15 $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( $3 , $4 )) == 0) goto $6;',
                    'if (($8 = PyObject_Size ( $10 )) == -1) goto $6;',
                    'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $6;',
                    'if (($9 = PyObject_RichCompareBool ( temp[$1] , temp[$2] , Py_$7 )) == -1) goto $6;',
                    'CLEARTEMP($2);',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
                
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $6 ) && ($17 = PyInt_AS_LONG ( $6 )) > INT_MIN ) {',
            'temp[$1] = PyInt_FromLong ( $17 - 1 );',
            '} else if (PyFloat_CheckExact( $6 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) - ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( $6 , $10 )) == 0) goto $4;',
            '}',
            'if (($12 = PyObject_Size ( $11 )) == -1) goto $4;',
            'if ((temp[$2] = PyInt_FromSsize_t ( $12 )) == 0) goto $4;',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$7 = PyInt_AS_LONG ( temp[$1] );',
            '$8 = PyInt_AS_LONG ( temp[$2] );',
            '$9 = $7 - $8;',
            'if (( $9 ^ $7 ) < 0 && ( $9 ^~ $8 ) < 0) goto $5 ;',
            'temp[$3] = PyInt_FromLong ( $9 );',
            '} else if (PyFloat_CheckExact( temp[$1] )) {',
            'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) - (double)PyInt_AS_LONG ( temp[$2] ));',
            '} else { $5 :;',
            'if ((temp[$3] = PyNumber_Subtract ( temp[$1] , temp[$2] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($1);',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $6 ) && ($7 = PyInt_AS_LONG ( $6 )) > INT_MIN ) {',
                    '$7 = $7 - 1;',   
                    'if (($8 = PyObject_Size ( $11 )) == -1) goto $4;',
                    '$9 = $7 - $8;',
                    'if (( $9 ^ $7 ) < 0 && ( $9 ^~ $8 ) < 0) goto $5 ;',
                    'temp[$3] = PyInt_FromLong ( $9 );',
                    '} else { $5 :;',
                    'if ((temp[$1] = PyNumber_Subtract ( $6 , $10 )) == 0) goto $4;',
                    'if (($12 = PyObject_Size ( $11 )) == -1) goto $4;',
                    'if ((temp[$2] = PyInt_FromSsize_t ( $12 )) == 0) goto $4;',
                    'if ((temp[$3] = PyNumber_Subtract ( temp[$1] , temp[$2] )) == 0) goto $4;',
                    '}',
                    'CLEARTEMP($1);',
                    'CLEARTEMP($2);'), v2)
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {',
            'temp[$1] = PyInt_FromLong ( $3 - 1 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) - ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( $2 , $5 )) == 0) goto $4;',
            '}',
            '$6 = PyInt_AsSsize_t ( temp[$1] );',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {',
                    '$6 = $3 - 1;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( $2 , $5 )) == 0) goto $4;',
                    '$6 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {',
            'temp[$1] = PyInt_FromLong ( $3 - 1 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( $2 , $5 )) == 0) goto $4;',
            '}',
            '$6 = PyInt_AsSsize_t ( temp[$1] );',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {',
                    '$6 = $3 - 1;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( $2 , $5 )) == 0) goto $4;',
                    '$6 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 )) {',
            '$5 = PyInt_AS_LONG ( $2 );',
            '$6 = 1 - $5;',
            'if (( $6 ^ 1 ) < 0 && ( $6 ^~ $5 ) < 0) goto $3 ;',
            'temp[$0] = PyInt_FromLong ( $6 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$0] = PyFloat_FromDouble(((double)1) - PyFloat_AS_DOUBLE($2));',
            '} else { $3 :;',
            'if ((temp[$0] = PyNumber_Subtract ( $7 , $2 )) == 0) goto $4;',
            '}',
            'if (PyFloat_CheckExact( $2 ) && PyFloat_CheckExact( temp[$0] )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) * PyFloat_AS_DOUBLE(temp[$0]));',
            '} else if (PyInt_CheckExact( $2 ) && PyInt_CheckExact( temp[$0] )) {',
            'temp[$1] = PyInt_Type.tp_as_number->nb_multiply($2, temp[$0]);',
            '} else {',
            'if ((temp[$1] = PyNumber_Multiply ( $2 , temp[$0] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 )) {',
                    '$5 = PyInt_AS_LONG ( $2 );',
                    '$6 = 1 - $5;',
                    'if (( $6 ^ 1 ) < 0 && ( $6 ^~ $5 ) < 0) goto $3 ;',
                    'if ($6 != 0 && $5 == (($5 * $6) / $6)) {',
                    'temp[$1] = PyInt_FromLong ( $5 * $6 );',
                    '} else {',
                    'temp[$0] = PyInt_FromLong ( $6 );',
                    'temp[$1] = PyInt_Type.tp_as_number->nb_multiply($2, temp[$0]);',
                    'CLEARTEMP($0);',
                    '}',
                    '} else if (PyFloat_CheckExact( $2 )) {',
                    'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) * (((double)1) - PyFloat_AS_DOUBLE($2)));',
                    '} else { $3 :;',
                    'if ((temp[$0] = PyNumber_Subtract ( $7 , $2 )) == 0) goto $4;',
                    'if ((temp[$1] = PyNumber_Multiply ( $2 , temp[$0] )) == 0) goto $4;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $4 + 1 );',
            '} else if (PyFloat_CheckExact( $3 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $3 , $8 )) == 0) goto $7;',
            '}',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$5 = PyInt_AS_LONG ( temp[$1] );',
            'if ( $5 < 0) {',
            '$5 += $10;',
            '}',
            '$6 = $11[$5];',
            'temp[$2] = PyString_FromStringAndSize(&$6, 1);',
            '} else {',
            'if ((temp[$2] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto $7;',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
                    '$5 = $4 + 1;',
                    'if ( $5 < 0) {',
                    '$5 += $10;',
                    '}',
                    '$6 = $11[$5];',
                    'temp[$2] = PyString_FromStringAndSize(&$6, 1);',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $3 , $8 )) == 0) goto $7;',
                    'if ((temp[$2] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto $7;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $4 + 1 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $3 , $8 )) == 0) goto $7;',
            '}',
            'if (PyInt_CheckExact( temp[$1] )) {',
            '$5 = PyInt_AS_LONG ( temp[$1] );',
            'if ( $5 < 0) {',
            '$5 += $10;',
            '}',
            '$6 = $11[$5];',
            'temp[$2] = PyString_FromStringAndSize(&$6, 1);',
            '} else {',
            'if ((temp[$2] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto $7;',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {',
                    '$5 = $4 + 1;',
                    'if ( $5 < 0) {',
                    '$5 += $10;',
                    '}',
                    '$6 = $11[$5];',
                    'temp[$2] = PyString_FromStringAndSize(&$6, 1);',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $3 , $8 )) == 0) goto $7;',
                    'if ((temp[$2] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto $7;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True

        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
            '$3 = $3 + 1;',
            'temp[$0] = PyInt_FromLong ( $3 );',
            'if ((temp[$1] = _c_BINARY_SUBSCR_Int ( $5 , $3 , temp[$0] )) == 0) goto $4;',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $4;',
            'if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
                    '$3 = $3 + 1;',
                    'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $5 , $3 )) == 0) goto $4;',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $4;',
                    'if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;',
                    'CLEARTEMP($0);',
                    '}'), v2, ('__c_BINARY_SUBSCR_Int',))
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {',
            '$3 = $3 - 1;',
            'temp[$0] = PyInt_FromLong ( $3 );',
            'if ((temp[$1] = _c_BINARY_SUBSCR_Int ( $5 , $3 , temp[$0] )) == 0) goto $4;',
            '} else {',
            'if ((temp[$0] = PyNumber_Subtract ( $2 , $6 )) == 0) goto $4;',
            'if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;',
            '}',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {',
                    '$3 = $3 - 1;',
                    'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $5 , $3 )) == 0) goto $4;',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Subtract ( $2 , $6 )) == 0) goto $4;',
                    'if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;',
                    'CLEARTEMP($0);',
                    '}'), v2, ('__c_BINARY_SUBSCR_Int',))
                return True     


        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($7 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$4) ) {',
            'temp[$0] = PyInt_FromLong ( $7 + $5 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + ((double)$5));',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $3;',
            '}',
            'if ((temp[$1] = PyObject_GetItem ( $9 , temp[$0] )) == 0) goto $3;',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($7 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$4) ) {',
                    'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $9 , $7 + $5 )) == 0) goto $3;',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $3;',
                    'if ((temp[$1] = PyObject_GetItem ( $9 , temp[$0] )) == 0) goto $3;',
                    'CLEARTEMP($0);',
                    '}'), v2, ('__c_BINARY_SUBSCR_Int',))
                return True   
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($7 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$4) ) {',
            'temp[$0] = PyInt_FromLong ( $7 + $5 );',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $3;',
            '}',
            'if ((temp[$1] = PyObject_GetItem ( $9 , temp[$0] )) == 0) goto $3;',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($7 = PyInt_AS_LONG ( $2 )) < (INT_MAX-$4) ) {',
                    'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $9 , $7 + $5 )) == 0) goto $3;',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $3;',
                    'if ((temp[$1] = PyObject_GetItem ( $9 , temp[$0] )) == 0) goto $3;',
                    'CLEARTEMP($0);',
                    '}'), v2, ('__c_BINARY_SUBSCR_Int',))
                return True   
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
            'temp[$0] = PyInt_FromLong ( $3 + 1 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto $4;',
            '}',
            'SETLOCAL ( $2 , temp[$0] );',
            'temp[$0] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    'temp[$0] = PyInt_FromLong ( $3 + 1 );',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto $4;',
                    '}',
                    'SETLOCAL ( $2 , temp[$0] );',
                    'temp[$0] = 0;'), v2)                
                return True    
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
            'temp[$0] = PyInt_FromLong ( $3 + 1 );',
            '} else if (PyFloat_CheckExact( $1 )) {',
            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));',
            '} else {',
            'if ((temp[$0] = PyNumber_InPlaceAdd ( $1 , $5 )) == 0) goto $4;',
            '}',
            'SETLOCAL ( $2 , temp[$0] );',
            'temp[$0] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < INT_MAX ) {',
                    'temp[$0] = PyInt_FromLong ( $3 + 1 );',
                    '} else {',
                    'if ((temp[$0] = PyNumber_InPlaceAdd ( $1 , $5 )) == 0) goto $4;',
                    '}',
                    'SETLOCAL ( $2 , temp[$0] );',
                    'temp[$0] = 0;'), v2)                
                return True  
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($4 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
            'temp[$0] = PyInt_FromLong ( $4 + 1 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + ((double)1));',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $2 , $5 )) == 0) goto $3;',
            '}',
            'if ((temp[$1] = _PyEval_ApplySlice ( $6 , $7 , temp[$0] )) == 0) goto $3;',
            'CLEARTEMP(0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($4 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
                    'temp[$0] = PyInt_FromLong ( $4 + 1 );',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $2 , $5 )) == 0) goto $3;',
                    '}',
                    'if ((temp[$1] = _PyEval_ApplySlice ( $6 , $7 , temp[$0] )) == 0) goto $3;',
                    'CLEARTEMP(0);'), v2)                
                return True  
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($6 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
            'temp[$2] = PyInt_FromLong ( $6 - 1 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) - ((double)1));',
            '} else {',
            'if ((temp[$2] = PyNumber_Subtract ( $5 , $15 )) == 0) goto $7;',
            '}',
            'if (PyInt_CheckExact( temp[$2] )) {',
            '$11 = PyInt_AS_LONG ( temp[$2] );',
            'if ( $11 < 0) {',
            '$11 += PyList_GET_SIZE($8);',
            '}',
            'if ( PyList_SetItem ( $8 , $11 , temp[$1] ) == -1) goto $7;',
            '} else {',
            'if ( PyObject_SetItem ( $8 , temp[$2] , temp[$1] ) == -1) goto $7;',
            'Py_DECREF(temp[$1]);',
            '}',
            'CLEARTEMP($2);',
            'temp[$1] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($6 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
                    '$11 = $6 - 1;',
                    'if ( $11 < 0) {',
                    '$11 += PyList_GET_SIZE($8);',
                    '}',
                    'if ( PyList_SetItem ( $8 , $11 , temp[$1] ) == -1) goto $7;',
                    '} else {',
                    'if ((temp[$2] = PyNumber_Subtract ( $5 , $15 )) == 0) goto $7;',
                    'if ( PyObject_SetItem ( $8 , temp[$2] , temp[$1] ) == -1) goto $7;',
                    'Py_DECREF(temp[$1]);',
                    'CLEARTEMP($2);',
                    '}'), v2)
                return True  
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($6 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
            'temp[$2] = PyInt_FromLong ( $6 - 1 );',
            '} else {',
            'if ((temp[$2] = PyNumber_Subtract ( $5 , $15 )) == 0) goto $7;',
            '}',
            'if (PyInt_CheckExact( temp[$2] )) {',
            '$11 = PyInt_AS_LONG ( temp[$2] );',
            'if ( $11 < 0) {',
            '$11 += PyList_GET_SIZE($8);',
            '}',
            'if ( PyList_SetItem ( $8 , $11 , temp[$1] ) == -1) goto $7;',
            '} else {',
            'if ( PyObject_SetItem ( $8 , temp[$2] , temp[$1] ) == -1) goto $7;',
            'Py_DECREF(temp[$1]);',
            '}',
            'CLEARTEMP($2);',
            'temp[$1] = 0;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($6 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {',
                    '$11 = $6 - 1;',
                    'if ( $11 < 0) {',
                    '$11 += PyList_GET_SIZE($8);',
                    '}',
                    'if ( PyList_SetItem ( $8 , $11 , temp[$1] ) == -1) goto $7;',
                    '} else {',
                    'if ((temp[$2] = PyNumber_Subtract ( $5 , $15 )) == 0) goto $7;',
                    'if ( PyObject_SetItem ( $8 , temp[$2] , temp[$1] ) == -1) goto $7;',
                    'Py_DECREF(temp[$1]);',
                    'CLEARTEMP($2);',
                    '}'), v2)
                return True  
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( $5 )) {',
            '$6 = PyInt_AS_LONG ( $4 );',
            '$7 = PyInt_AS_LONG ( $5 );',
            '$8 = $6 + $7;',
            'if (( $8 ^ $6 ) < 0 && ( $8 ^ $7 ) < 0) goto $9 ;',
            'temp[$2] = PyInt_FromLong ( $8 );',
            '} else if (PyFloat_CheckExact( $4 ) && PyFloat_CheckExact( $5 )) {',
            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) + PyFloat_AS_DOUBLE($5));',
            '} else { $9 :;',
            'if ((temp[$2] = PyNumber_Add ( $4 , $5 )) == 0) goto $10;',
            '}',
            'if ((temp[$3] = PyObject_GetItem ( $1 , temp[$2] )) == 0) goto $10;',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( $5 )) {',
                    '$6 = PyInt_AS_LONG ( $4 );',
                    '$7 = PyInt_AS_LONG ( $5 );',
                    '$8 = $6 + $7;',
                    'if (( $8 ^ $6 ) < 0 && ( $8 ^ $7 ) < 0) goto $9 ;',
                    'if ((temp[$3] = __c_BINARY_SUBSCR_Int ( $1 , $8 )) == 0) goto $10;',
                    '} else { $9 :;',
                    'if ((temp[$2] = PyNumber_Add ( $4 , $5 )) == 0) goto $10;',
                    'if ((temp[$3] = PyObject_GetItem ( $1 , temp[$2] )) == 0) goto $10;',
                    'CLEARTEMP($2);',
                    '}'), v2, ('__c_BINARY_SUBSCR_Int',))
                return True  
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( $5 )) {',
            '$6 = PyInt_AS_LONG ( $4 );',
            '$7 = PyInt_AS_LONG ( $5 );',
            '$8 = $6 + $7;',
            'if (( $8 ^ $6 ) < 0 && ( $8 ^ $7 ) < 0) goto $9 ;',
            'temp[$2] = PyInt_FromLong ( $8 );',
            '} else { $9 :;',
            'if ((temp[$2] = PyNumber_Add ( $4 , $5 )) == 0) goto $10;',
            '}',
            'if ((temp[$3] = PyObject_GetItem ( $1 , temp[$2] )) == 0) goto $10;',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( $5 )) {',
                    '$6 = PyInt_AS_LONG ( $4 );',
                    '$7 = PyInt_AS_LONG ( $5 );',
                    '$8 = $6 + $7;',
                    'if (( $8 ^ $6 ) < 0 && ( $8 ^ $7 ) < 0) goto $9 ;',
                    'if ((temp[$3] = __c_BINARY_SUBSCR_Int ( $1 , $8 )) == 0) goto $10;',
                    '} else { $9 :;',
                    'if ((temp[$2] = PyNumber_Add ( $4 , $5 )) == 0) goto $10;',
                    'if ((temp[$3] = PyObject_GetItem ( $1 , temp[$2] )) == 0) goto $10;',
                    'CLEARTEMP($2);',
                    '}'), v2, ('__c_BINARY_SUBSCR_Int',))
                return True  
                    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( $2 )) {',
            '$4 = PyInt_AS_LONG ( $1 );',
            '$5 = PyInt_AS_LONG ( $2 );',
            '$6 = $4 - $5;',
            'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
            'temp[$3] = PyInt_FromLong ( $6 );',
            '} else if (PyFloat_CheckExact( $1 ) && PyFloat_CheckExact( $2 )) {',
            'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) - PyFloat_AS_DOUBLE($2));',
            '} else { $7 :;',
            'if ((temp[$3] = PyNumber_Subtract ( $1 , $2 )) == 0) goto $8;',
            '}',
            'if (($11 = PyObject_RichCompareBool ( temp[$3] , $9 , $12 )) == -1) goto $8;',
            'CLEARTEMP($3);'), v2) and v2[12] in op_to_oper:
                v2[15] = op_to_oper[v2[12]].strip()
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( $2 ) && PyInt_CheckExact( $9 )) {',
                    '$4 = PyInt_AS_LONG ( $1 );',
                    '$5 = PyInt_AS_LONG ( $2 );',
                    '$6 = $4 - $5;',
                    'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                    '$11 = $6 $15 PyInt_AS_LONG ( $9 );',
                    '} else if (PyFloat_CheckExact( $1 ) && PyFloat_CheckExact( $2 ) && PyFloat_CheckExact( $9 )) {',
                    '$11 = (PyFloat_AS_DOUBLE($1) - PyFloat_AS_DOUBLE($2)) $15 PyFloat_AS_DOUBLE($9);',
                    '} else { $7 :;',
                    'if ((temp[$3] = PyNumber_Subtract ( $1 , $2 )) == 0) goto $8;',
                    'if (($11 = PyObject_RichCompareBool ( temp[$3] , $9 , $12 )) == -1) goto $8;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True        
            
                        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( $2 )) {',
            '$4 = PyInt_AS_LONG ( $1 );',
            '$5 = PyInt_AS_LONG ( $2 );',
            '$6 = $4 - $5;',
            'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
            'temp[$3] = PyInt_FromLong ( $6 );',
            '} else { $7 :;',
            'if ((temp[$3] = PyNumber_Subtract ( $1 , $2 )) == 0) goto $8;',
            '}',
            'if (($11 = PyObject_RichCompareBool ( temp[$3] , $9 , $12 )) == -1) goto $8;',
            'CLEARTEMP($3);'), v2) and v2[12] in op_to_oper:
                v2[15] = op_to_oper[v2[12]].strip()
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( $2 ) && PyInt_CheckExact( $9 )) {',
                    '$4 = PyInt_AS_LONG ( $1 );',
                    '$5 = PyInt_AS_LONG ( $2 );',
                    '$6 = $4 - $5;',
                    'if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;',
                    '$11 = $6 $15 PyInt_AS_LONG ( $9 );',
                    '} else { $7 :;',
                    'if ((temp[$3] = PyNumber_Subtract ( $1 , $2 )) == 0) goto $8;',
                    'if (($11 = PyObject_RichCompareBool ( temp[$3] , $9 , $12 )) == -1) goto $8;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True        
            
                        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $3 + 1 );',
            '} else if (PyFloat_CheckExact( $2 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $2 , $5 )) == 0) goto $4;',
            '}',
            'if (($6 = PyObject_RichCompareBool ( $7 , temp[$1] , $12 )) == -1) goto $4;',
            'CLEARTEMP($1);'), v2) and v2[12] in op_to_oper:
                v2[15] = op_to_oper[v2[12]].strip()
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX && PyInt_CheckExact( $7 )) {',
                    '$6 = PyInt_AS_LONG ( $7 ) $15 $3;',
                    '} else if (PyFloat_CheckExact( $2 ) && PyFloat_CheckExact( $7 )) {',
                    '$6 = PyFloat_AS_DOUBLE ( $7 ) $15 (PyFloat_AS_DOUBLE($2) + ((double)1));',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $2 , $5 )) == 0) goto $4;',
                    'if (($6 = PyObject_RichCompareBool ( $7 , temp[$1] , $12 )) == -1) goto $4;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True   
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $3 + 1 );',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $2 , $5 )) == 0) goto $4;',
            '}',
            'if (($6 = PyObject_RichCompareBool ( $7 , temp[$1] , $12 )) == -1) goto $4;',
            'CLEARTEMP($1);'), v2) and v2[12] in op_to_oper:
                v2[15] = op_to_oper[v2[12]].strip()
                TxRepl(o, i, ('if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < INT_MAX && PyInt_CheckExact( $7 )) {',
                    '$6 = PyInt_AS_LONG ( $7 ) $15 $3;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $2 , $5 )) == 0) goto $4;',
                    'if (($6 = PyObject_RichCompareBool ( $7 , temp[$1] , $12 )) == -1) goto $4;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True   
            
                        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < (INT_MAX-$6) ) {',
            'temp[$0] = PyInt_FromLong ( $4 + $7 );',
            '} else if (PyFloat_CheckExact( $3 )) {',
            'temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + ((double)$7));',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $3 , $9 )) == 0) goto $5;',
            '}',
            'if (($1 = PyObject_RichCompareBool ( $8 , temp[$0] , $10 )) == -1) goto $5;',
            'CLEARTEMP($0);'), v2) and v2[10] in op_to_oper:
                v2[15] = op_to_oper[v2[10]].strip()
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < (INT_MAX-$6) && PyInt_CheckExact( $8 )) {',
                    '$1 = PyInt_AS_LONG ( $8 ) $15 ( $4 + $7 );',
                    '} else if (PyFloat_CheckExact( $3 ) && PyFloat_CheckExact( $8 )) {',
                    '$1 = PyFloat_AS_DOUBLE ( $8 ) $15 (PyFloat_AS_DOUBLE($3) + ((double)$7));',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $3 , $9 )) == 0) goto $5;',
                    'if (($1 = PyObject_RichCompareBool ( $8 , temp[$0] , $10 )) == -1) goto $5;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True   
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < (INT_MAX-$6) ) {',
            'temp[$0] = PyInt_FromLong ( $4 + $7 );',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $3 , $9 )) == 0) goto $5;',
            '}',
            'if (($1 = PyObject_RichCompareBool ( $8 , temp[$0] , $10 )) == -1) goto $5;',
            'CLEARTEMP($0);'), v2) and v2[10] in op_to_oper:
                v2[15] = op_to_oper[v2[10]].strip()
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < (INT_MAX-$6) && PyInt_CheckExact( $8 )) {',
                    '$1 = PyInt_AS_LONG ( $8 ) $15 ( $4 + $7 );',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $3 , $9 )) == 0) goto $5;',
                    'if (($1 = PyObject_RichCompareBool ( $8 , temp[$0] , $10 )) == -1) goto $5;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True   

        if TxMatch(o, i, ('if (PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $1 );',
            '$3 = $9;',
            '$4 = $2 + $3;',
            'if (( $4 ^ $2 ) < 0 && ( $4 ^ $3 ) < 0) goto $5 ;',
            'temp[$6] = PyInt_FromLong ( $4 );',
            '} else { $5 :;',
            'if ((temp[$7] = $10) == 0) goto $8;',
            'if ((temp[$6] = PyNumber_Add ( $1 , temp[$7] )) == 0) goto $8;',
            'CLEARTEMP($7);',
            '}',
            'if ((temp[$17] = _PyEval_ApplySlice ( $11 , $1 , temp[$6] )) == 0) goto $8;',
            'CLEARTEMP($6);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $1 )) {',
                    '$2 = PyInt_AS_LONG ( $1 );',
                    '$3 = $9;',
                    '$4 = $2 + $3;',
                    'if (( $4 ^ $2 ) < 0 && ( $4 ^ $3 ) < 0) goto $5 ;',
                    'if ((temp[$17] = PySequence_GetSlice ( $11 , $2 , $4 )) == 0) goto $8;',
                    '} else { $5 :;',
                    'if ((temp[$7] = $10) == 0) goto $8;',
                    'if ((temp[$6] = PyNumber_Add ( $1 , temp[$7] )) == 0) goto $8;',
                    'CLEARTEMP($7);',
                    'if ((temp[$17] = _PyEval_ApplySlice ( $11 , $1 , temp[$6] )) == 0) goto $8;',
                    'CLEARTEMP($6);',
                    '}'), v2)
                return True 
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $0 ) && ($2 = PyInt_AS_LONG ( $0 )) < (INT_MAX-$3) ) {',
            'temp[$5] = PyInt_FromLong ( $2 + $4 );',
            '} else {',
            'if ((temp[$5] = PyNumber_Add ( $0 , $11 )) == 0) goto $1;',
            '}',
            'if ((temp[$6] = _PyEval_ApplySlice ( temp[$7] , $0 , temp[$5] )) == 0) goto $1;',
            'CLEARTEMP($7);',
            'CLEARTEMP($5);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $0 ) && ($2 = PyInt_AS_LONG ( $0 )) < (INT_MAX-$3) ) {',
                    'if ((temp[$6] = PySequence_GetSlice ( temp[$7] , $2 , $2 + $4 )) == 0) goto $1;',
                    '} else {',
                    'if ((temp[$5] = PyNumber_Add ( $0 , $11 )) == 0) goto $1;',
                    'if ((temp[$6] = _PyEval_ApplySlice ( temp[$7] , $0 , temp[$5] )) == 0) goto $1;',
                    'CLEARTEMP($5);',
                    '}',
                    'CLEARTEMP($7);'), v2)
                return True 
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $0 );',
            '$3 = PyInt_AS_LONG ( $1 );',
            '$4 = $2 + $3;',
            'if (( $4 ^ $2 ) < 0 && ( $4 ^ $3 ) < 0) goto $5 ;',
            'temp[$6] = PyInt_FromLong ( $4 );',
            '} else { $5 :;',
            'if ((temp[$6] = PyNumber_Add ( $0 , $1 )) == 0) goto $7;',
            '}',
            'if ((temp[$11] = _PyEval_ApplySlice ( temp[$8] , $0 , temp[$6] )) == 0) goto $7;',
            'CLEARTEMP($8);',
            'CLEARTEMP($6);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {',
                    '$2 = PyInt_AS_LONG ( $0 );',
                    '$3 = PyInt_AS_LONG ( $1 );',
                    '$4 = $2 + $3;',
                    'if (( $4 ^ $2 ) < 0 && ( $4 ^ $3 ) < 0) goto $5 ;',
                    'if ((temp[$11] = PySequence_GetSlice ( temp[$8] , $2 , $4 )) == 0) goto $7;',
                    '} else { $5 :;',
                    'if ((temp[$6] = PyNumber_Add ( $0 , $1 )) == 0) goto $7;',
                    'if ((temp[$11] = _PyEval_ApplySlice ( temp[$8] , $0 , temp[$6] )) == 0) goto $7;',
                    'CLEARTEMP($6);',
                    '}',
                    'CLEARTEMP($8);'), v2)
                return True 

        if TxMatch(o, i, """if ($1)) {
            long_$5 = $3;
            long_$6 = $4;
            long_$7 = long_$5 - long_$6;
            if (( long_$7 ^ long_$5 ) < 0 && ( long_$7 ^~ long_$6 ) < 0) goto label_$8 ;
            temp[$9] = PyInt_FromLong ( long_$7 );
            } else if ($2)) {
            temp[$9] = PyFloat_FromDouble($10);
            } else { label_$8 :;
            temp[$11] = PyInt_FromLong ($12);
            if ((temp[$9] = PyNumber_Subtract ( temp[$11] , $13 )) == 0) goto label_$14;
            CLEARTEMP($11);
            }
            SETLOCAL ( $17 , temp[$9] );
            temp[$9] = 0;
            if ((temp[$15] = _PyEval_ApplySlice ( $16 , GETLOCAL($16) , NULL )) == 0) goto label_$14;""", v2):
                TxRepl(o, i, """if ($1)) {
                    long_$5 = $3;
                    long_$6 = $4;
                    long_$7 = long_$5 - long_$6;
                    if (( long_$7 ^ long_$5 ) < 0 && ( long_$7 ^~ long_$6 ) < 0) goto label_$8 ;
                    SETLOCAL ( $17 , PyInt_FromLong ( long_$7 ) );
                    if ((temp[$15] = PySequence_GetSlice ( $16 , long_$7 , PY_SSIZE_T_MAX )) == 0) goto $label_$14;',
                    } else { label_$8 :;
                    temp[$11] = PyInt_FromLong ($12);
                    if ((temp[$9] = PyNumber_Subtract ( temp[$11] , $13 )) == 0) goto label_$14;
                    CLEARTEMP($11);
                    SETLOCAL ( $17 , temp[$9] );
                    temp[$9] = 0;
                    if ((temp[$15] = _PyEval_ApplySlice ( $16 , GETLOCAL($16) , NULL )) == 0) goto label_$14;
                    }""", v2)
                return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $8 ) && (long_$6 = PyInt_AS_LONG ( GETLOCAL(i) )) < $5 ) {
            temp[$2] = PyInt_FromLong ( long_$6 + $7 );
            } else {
            if ((temp[$2] = PyNumber_Add ( $8 , $9 )) == 0) goto label_$4;
            }
            if ((temp[$3] = _PyEval_ApplySlice ( temp[$0] , temp[$2] , NULL )) == 0) goto label_$4;
            CLEARTEMP($0);
            CLEARTEMP($2);
            """, v2):
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $8 ) && (long_$6 = PyInt_AS_LONG ( GETLOCAL(i) )) < $5 ) {
                    if ((temp[$3] = PySequence_GetSlice ( temp[$0] , long_$6 + $7 , PY_SSIZE_T_MAX )) == 0) goto label_$4;
                    CLEARTEMP($0);
                    } else {
                    if ((temp[$2] = PyNumber_Add ( $8 , $9 )) == 0) goto label_$4;
                    if ((temp[$3] = _PyEval_ApplySlice ( temp[$0] , temp[$2] , NULL )) == 0) goto label_$4;
                    CLEARTEMP($0);
                    CLEARTEMP($2);
                    }
                    """, v2)
                return True 


        if TxMatch(o, i, ('if (PyInt_CheckExact( $7 ) && ($4 = PyInt_AS_LONG ( $7 )) > INT_MIN ) {',
            '$4 = $4 - 1;',
            'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $6 , $4 )) == 0) goto $5;',
            '} else {',
            'if ((temp[$0] = PyNumber_Subtract ( $7 , consts[$3] )) == 0) goto $5;',
            'if ((temp[$1] = PyObject_GetItem ( $6 , temp[$0] )) == 0) goto $5;',
            'CLEARTEMP($0);',
            '}',
            'if ((temp[$9] = PyObject_GetItem ( $6 , $7 )) == 0) goto $5;'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $7 ) && ($4 = PyInt_AS_LONG ( $7 )) > INT_MIN ) {',
                    'if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $6 , $4 - 1 )) == 0) goto $5;',
                    'if ((temp[$9] = _c_BINARY_SUBSCR_Int ( $6 , $4 , $7 )) == 0) goto $5;',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Subtract ( $7 , consts[$3] )) == 0) goto $5;',
                    'if ((temp[$1] = PyObject_GetItem ( $6 , temp[$0] )) == 0) goto $5;',
                    'CLEARTEMP($0);',
                    'if ((temp[$9] = PyObject_GetItem ( $6 , $7 )) == 0) goto $5;',
                    '}'), v2)
                return True    

        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $7 + 1 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
            '}',
            'if ( _PyEval_AssignSlice ( $6 , temp[$1] , NULL , temp[$0] ) == -1) goto $8;',
            'CLEARTEMP($0);',
            'CLEARTEMP($1);',
            'temp[$0] = 0;'), v2):       
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < INT_MAX ) {',
                    'if ( PySequence_SetSlice ( $6 , $7 + 1 , PY_SSIZE_T_MAX , temp[$0] ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
                    'if ( _PyEval_AssignSlice ( $6 , temp[$1] , NULL , temp[$0] ) == -1) goto $8;',
                    'CLEARTEMP($1);',
                    '}',
                    'CLEARTEMP($0);'), v2)
                return True            

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) < $6 ) {
            temp[$0] = PyInt_FromLong ( long_$2 + $4 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$4));
            } else {
            if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto label_$3;
            }
            if ( _PyEval_AssignSlice ( $7 , $1 , temp[$0] , NULL ) == -1) goto label_$3;
            CLEARTEMP($0);
            """, v2):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) < $6 ) {
                    if ( PySequence_DelSlice ( $7 , long_$2 , long_$2 + $4 ) == -1) goto label_$3;
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto label_$3;
                    if ( _PyEval_AssignSlice ( $7 , $1 , temp[$0] , NULL ) == -1) goto label_$3;
                    CLEARTEMP($0);
                    }
                    """, v2)
                return True            
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $4 ) && (long_$3 = PyInt_AS_LONG ( $4 )) > $5 ) {
            temp[$0] = PyInt_FromLong ( long_$3 - $6 );
            } else if (PyFloat_CheckExact( $4 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) - ((double)$6));
            } else {
            if ((temp[$0] = PyNumber_Subtract ( $4 , $7 )) == 0) goto label_$2;
            }
            if (PyInt_CheckExact( $4 ) && (long_$3 = PyInt_AS_LONG ( $4 )) > $8 ) {
            temp[$1] = PyInt_FromLong ( long_$3 - $9 );
            } else if (PyFloat_CheckExact( $4 )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) - ((double)$9));
            } else {
            if ((temp[$1] = PyNumber_Subtract ( $4 , $10 )) == 0) goto label_$2;
            }
            if ( _PyEval_AssignSlice ( $11 , temp[$0] , temp[$1] , NULL ) == -1) goto label_$2;
            CLEARTEMP($0);
            CLEARTEMP($1);
            """, v2) and v2[6].isdigit() and v2[9].isdigit() and int(v2[6]) >= int(v2[9]):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $4 ) && (long_$3 = PyInt_AS_LONG ( $4 )) > $5 ) {
                    if ( PySequence_DelSlice ( $11 , long_$3 - $6 , long_$3 - $9 ) == -1) goto label_$2;
                    } else {
                    if ((temp[$0] = PyNumber_Subtract ( $4 , $7 )) == 0) goto label_$2;
                    if ((temp[$1] = PyNumber_Subtract ( $4 , $10 )) == 0) goto label_$2;
                    if ( _PyEval_AssignSlice ( $11 , temp[$0] , temp[$1] , NULL ) == -1) goto label_$2;
                    CLEARTEMP($0);
                    CLEARTEMP($1);                       
                    }
                    """, v2)
                return True            
            
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) < INT_MAX ) {
            temp[$2] = PyInt_FromLong ( long_$1 + 1 );
            } else if (PyFloat_CheckExact( $0 )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) + ((double)1));
            } else {
            if ((temp[$2] = PyNumber_Add ( $0 , $7 )) == 0) goto label_$4;
            }
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) < (INT_MAX-$9) ) {
            temp[$3] = PyInt_FromLong ( long_$1 + $10 );
            } else if (PyFloat_CheckExact( $0 )) {
            temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) + ((double)$10));
            } else {
            if ((temp[$3] = PyNumber_Add ( $0 , $8 )) == 0) goto label_$4;
            }
            if ( _PyEval_AssignSlice ( $5 , temp[$2] , temp[$3] , $6 ) == -1) goto label_$4;
            CLEARTEMP($2);
            CLEARTEMP($3);""", v2):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) < (INT_MAX-$9) ) {
                    if ( PySequence_SetSlice ( $5 , long_$1 + 1 , long_$1 + $10 , $6 ) == -1) goto label_$4;
                    } else {
                    if ((temp[$2] = PyNumber_Add ( $0 , $7 )) == 0) goto label_$4;
                    if ((temp[$3] = PyNumber_Add ( $0 , $8 )) == 0) goto label_$4;
                    if ( _PyEval_AssignSlice ( $5 , temp[$2] , temp[$3] , $6 ) == -1) goto label_$4;
                    CLEARTEMP($2);
                    CLEARTEMP($3);
                    }""", v2)
                return True            

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 ) && (long_$4 = PyInt_AS_LONG ( $3 )) < INT_MAX ) {
            temp[$1] = PyInt_FromLong ( long_$4 + $9 );
            } else if (PyFloat_CheckExact( $3 )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + ((double)$9));
            } else {
            if ((temp[$1] = PyNumber_Add ( $3 , $11 )) == 0) goto label_$6;
            }
            if (PyInt_CheckExact( $3 ) && (long_$4 = PyInt_AS_LONG ( $3 )) < $8 ) {
            temp[$2] = PyInt_FromLong ( long_$4 + $10 );
            } else if (PyFloat_CheckExact( $3 )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + ((double)$10));
            } else {
            if ((temp[$2] = PyNumber_Add ( $3 , $12 )) == 0) goto label_$6;
            }
            if ( _PyEval_AssignSlice ( $5 , temp[$1] , temp[$2] , temp[$0] ) == -1) goto label_$6;
            CLEARTEMP($0);
            CLEARTEMP($1);
            CLEARTEMP($2);
            """, v2):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $3 ) && (long_$4 = PyInt_AS_LONG ( $3 )) < $8 ) {
                    if ( PySequence_SetSlice ( $5 , long_$4 + $9 , long_$4 + $10 , temp[$0] ) == -1) goto label_$6;
                    CLEARTEMP($0);
                    } else {
                    if ((temp[$1] = PyNumber_Add ( $3 , $11 )) == 0) goto label_$6;
                    if ((temp[$2] = PyNumber_Add ( $3 , $12 )) == 0) goto label_$6;
                    if ( _PyEval_AssignSlice ( $5 , temp[$1] , temp[$2] , temp[$0] ) == -1) goto label_$6;
                    CLEARTEMP($1);
                    CLEARTEMP($2); 
                    CLEARTEMP($0);
                    }""", v2)
                return True   


        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 )) {
            long_$7 = PyInt_AS_LONG ( $1 );
            long_$8 = PyInt_AS_LONG ( $0 );
            long_$9 = long_$7 + long_$8;
            if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^ long_$8 ) < 0) goto label_$2 ;
            temp[$6] = PyInt_FromLong ( long_$9 );
            } else if (PyFloat_CheckExact( $0 )) {
            temp[$6] = PyFloat_FromDouble((double)PyInt_AS_LONG ( $1 ) + PyFloat_AS_DOUBLE($0));
            } else { label_$2 :;
            if ((temp[$6] = PyNumber_Add ( $1 , $0 )) == 0) goto label_$3;
            }
            if ( _PyEval_AssignSlice ( $4 , $1 , temp[$6] , $5 ) == -1) goto label_$3;
            CLEARTEMP($6);""", v2):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $0 )) {
                    long_$7 = PyInt_AS_LONG ( $1 );
                    long_$8 = PyInt_AS_LONG ( $0 );
                    long_$9 = long_$7 + long_$8;
                    if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^ long_$8 ) < 0) goto label_$2 ;
                    if ( PySequence_SetSlice ( $4 , long_$7 , long_$9 , $5 ) == -1) goto label_$3;
                    } else { label_$2 :;
                    if ((temp[$6] = PyNumber_Add ( $1 , $0 )) == 0) goto label_$3;
                    if ( _PyEval_AssignSlice ( $4 , $1 , temp[$6] , $5 ) == -1) goto label_$3;
                    CLEARTEMP($6);
                    }""", v2)
                return True            

                        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $7 + 1 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
            '}',
            'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , temp[$0] ) == -1) goto $8;',
            'CLEARTEMP($0);',
            'CLEARTEMP($1);',
            'temp[$0] = 0;'), v2):         
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < INT_MAX ) {',
                    'if ( PySequence_SetSlice ( $6 , $7 , $7 + 1 , temp[$0] ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
                    'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , temp[$0] ) == -1) goto $8;',
                    'CLEARTEMP($1);',
                    '}',
                    'CLEARTEMP($0);'), v2)
                return True
            
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < INT_MAX ) {',
            'temp[$1] = PyInt_FromLong ( $7 + 1 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + ((double)1));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
            '}',
            'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , GETLOCAL($0) ) == -1) goto $8;',
            'CLEARTEMP($1);'), v2):         
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < INT_MAX ) {',
                    'if ( PySequence_SetSlice ( $6 , $7 , $7 + 1 , GETLOCAL($0) ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
                    'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , GETLOCAL($0) ) == -1) goto $8;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$11) ) {',
            'temp[$1] = PyInt_FromLong ( $7 + $12 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + ((double)$12));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
            '}',
            'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , temp[$0] ) == -1) goto $8;',
            'CLEARTEMP($0);',
            'CLEARTEMP($1);',
            'temp[$0] = 0;'), v2):         
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$11) ) {',
                    'if ( PySequence_SetSlice ( $6 , $7 , $7 + $12 , temp[$0] ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
                    'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , temp[$0] ) == -1) goto $8;',
                    'CLEARTEMP($1);',
                    '}',
                    'CLEARTEMP($0);'), v2)                    
                return True                 
            
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$11) ) {',
            'temp[$1] = PyInt_FromLong ( $7 + $12 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + ((double)$12));',
            '} else {',
            'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
            '}',
            'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , GETLOCAL($0) ) == -1) goto $8;',
            'CLEARTEMP($1);'), v2):         
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 ) && ($7 = PyInt_AS_LONG ( $5 )) < (INT_MAX-$11) ) {',
                    'if ( PySequence_SetSlice ( $6 , $7 , $7 + $12 , GETLOCAL($0) ) == -1) goto $8;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Add ( $5 , consts[$9] )) == 0) goto $8;',
                    'if ( _PyEval_AssignSlice ( $6 , $5 , temp[$1] , GETLOCAL($0) ) == -1) goto $8;',
                    'CLEARTEMP($1);',
                    '}'), v2)                    
                return True     

        if TxMatch(o, i, """                        
            if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) < $3 ) {
            temp[$0] = PyInt_FromLong ( long_$2 + $4 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$4));
            } else {
            if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto label_$6;
            }
            if ( _PyEval_AssignSlice ( $7 , $1 , temp[$0] , NULL ) == -1) goto label_$6;
            CLEARTEMP($0);
            """, v2):                        
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) < $3 ) {
                    if ( PySequence_DelSlice ( $7 , long_$2 , long_$2 + $4 ) == -1) goto label_$6;
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto label_$6;
                    if ( _PyEval_AssignSlice ( $7 , $1 , temp[$0] , NULL ) == -1) goto label_$6;
                    CLEARTEMP($0);
                    }
                    """, v2)                    
                return True     
                        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $5 )) {',
            '$7 = PyInt_AS_LONG ( $5 );',
            '$12 = $9;',
            '$14 = $7 + $12;',
            'if (( $14 ^ $7 ) < 0 && ( $14 ^ $12 ) < 0) goto $11 ;',
            'temp[$1] = PyInt_FromLong ( $14 );',
            '} else if (PyFloat_CheckExact( $5 )) {',
            'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) + (double)$9);',
            '} else { $11 :;',
            'temp[$0] = $10;',
            'if ((temp[$1] = PyNumber_Add ( $5 , temp[$0] )) == 0) goto $8;',
            'CLEARTEMP($0);',
            '}',
            'if ( _PyEval_AssignSlice ( $17 , $5 , temp[$1] , $15 ) == -1) goto $8;',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $5 )) {',
                    '$7 = PyInt_AS_LONG ( $5 );',
                    '$12 = $9;',
                    '$14 = $7 + $12;',
                    'if (( $14 ^ $7 ) < 0 && ( $14 ^ $12 ) < 0) goto $11 ;',
                    'if ( PySequence_SetSlice ( $17 , $7 , $14 , $15 ) == -1) goto $8;',
                    '} else { $11 :;',
                    'temp[$0] = $10;',
                    'if ((temp[$1] = PyNumber_Add ( $5 , temp[$0] )) == 0) goto $8;',
                    'CLEARTEMP($0);',
                    'if ( _PyEval_AssignSlice ( $17 , $5 , temp[$1] , $15 ) == -1) goto $8;',
                    'CLEARTEMP($1);',
                    '}'), v2)                    
                return True  
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $10 ) && ($12 = PyInt_AS_LONG ( $10 )) < INT_MAX ) {',
            'temp[$0] = PyInt_FromLong ( $12 + 1 );',
            '} else {',
            'if ((temp[$0] = PyNumber_Add ( $10 , $16 )) == 0) goto $14;',
            '}',
            'if (PyInt_CheckExact( temp[$0] )) {',
            '$15 = PyInt_AS_LONG ( temp[$0] );',
            'if ( $15 < 0) {',
            '$15 += PyList_GET_SIZE($11);',
            '}',
            'if ((temp[$4] = PyList_GetItem ( $11 , $15 )) == 0) goto $14;',
            'Py_INCREF(temp[$4]);',
            '} else {',
            'if ((temp[$4] = PyObject_GetItem ( $11 , temp[$0] )) == 0) goto $14;',
            '}',
            'CLEARTEMP(0);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $10 ) && ($12 = PyInt_AS_LONG ( $10 )) < INT_MAX ) {',
                    '$15 = $12 + 1;',
                    'if ( $15 < 0) {',
                    '$15 += PyList_GET_SIZE($11);',
                    '}',
                    'if ((temp[$4] = PyList_GetItem ( $11 , $15 )) == 0) goto $14;',
                    'Py_INCREF(temp[$4]);',
                    '} else {',
                    'if ((temp[$0] = PyNumber_Add ( $10 , $16 )) == 0) goto $14;',
                    'if ((temp[$4] = PyObject_GetItem ( $11 , temp[$0] )) == 0) goto $14;',
                    'CLEARTEMP(0);',
                    '}'), v2)
                return True            
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 ) && PyInt_CheckExact( $4 )) {
            $5 = PyInt_AS_LONG ( $3 );
            $6 = PyInt_AS_LONG ( $4 );
            $7 = $5 - $6;
            if (( $7 ^ $5 ) < 0 && ( $7 ^~ $6 ) < 0) goto $12 ;
            temp[$0] = PyInt_FromLong ( $7 );
            } else if (PyFloat_CheckExact( $3 ) && PyFloat_CheckExact( $4 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - PyFloat_AS_DOUBLE($4));
            } else { $12 :;
            if ((temp[$0] = PyNumber_Subtract ( $3 , $4 )) == 0) goto $11;
            }
            if ((temp[$1] = PyInt_FromSsize_t ( $15 )) == 0) goto $11;
            if (PyInt_CheckExact( temp[$0] )) {
            $8 = PyInt_AS_LONG ( temp[$0] );
            $9 = PyInt_AS_LONG ( temp[$1] );
            $10 = $8 + $9;
            if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $13 ;
            temp[$2] = PyInt_FromLong ( $10 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) + (double)PyInt_AS_LONG ( temp[$1] ));
            } else { $13 :;
            if ((temp[$2] = PyNumber_Add ( temp[$0] , temp[$1] )) == 0) goto $11;
            }
            CLEARTEMP($0);
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $3 ) && PyInt_CheckExact( $4 )) {',
                    '$5 = PyInt_AS_LONG ( $3 );',
                    '$6 = PyInt_AS_LONG ( $4 );',
                    '$7 = $5 - $6;',
                    'if (( $7 ^ $5 ) < 0 && ( $7 ^~ $6 ) < 0) goto $12 ;',
                    '$8 = $7;',
                    '$9 = $15;',
                    '$10 = $8 + $9;',
                    'if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $12 ;',
                    'temp[$2] = PyInt_FromLong ( $10 );',
                    '} else if (PyFloat_CheckExact( $3 ) && PyFloat_CheckExact( $4 )) {',
                    'temp[$2] = PyFloat_FromDouble((PyFloat_AS_DOUBLE($3) - PyFloat_AS_DOUBLE($4)) + (double)$15);',
                    '} else { $12 :;',
                    'if ((temp[$0] = PyNumber_Subtract ( $3 , $4 )) == 0) goto $11;',
                    'if ((temp[$1] = PyInt_FromSsize_t ( $15 )) == 0) goto $11;',
                    'if ((temp[$2] = PyNumber_Add ( temp[$0] , temp[$1] )) == 0) goto $11;',
                    'CLEARTEMP($0);',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True    
    
        if TxMatch(o, i, ('if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {',
            '$4 = PyInt_AS_LONG ( $0 );',
            '$5 = PyInt_AS_LONG ( $1 );',
            '$6 = $4 + $5;',
            'if (( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) goto $7 ;',
            'temp[$2] = PyInt_FromLong ( $6 );',
            '} else if (PyFloat_CheckExact( $0 ) && PyFloat_CheckExact( $1 )) {',
            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) + PyFloat_AS_DOUBLE($1));',
            '} else { $7 :;',
            'if ((temp[$2] = PyNumber_Add ( $0 , $1 )) == 0) goto $8;',
            '}',
            'if (PyInt_CheckExact( temp[$2] ) && ($4 = PyInt_AS_LONG ( temp[$2] )) < (INT_MAX-$9) ) {',
            'temp[$3] = PyInt_FromLong ( $4 + $10 );',
            '} else if (PyFloat_CheckExact( temp[$2] )) {',
            'temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$2]) + ((double)$10));',
            '} else {',
            'if ((temp[$3] = PyNumber_Add ( temp[$2] , $11 )) == 0) goto $8;',
            '}',
            'CLEARTEMP($2);'), v2):
                TxRepl(o, i, ('if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {',
                    '$4 = PyInt_AS_LONG ( $0 );',
                    '$5 = PyInt_AS_LONG ( $1 );',
                    '$6 = $4 + $5;',
                    'if ((( $6 ^ $4 ) < 0 && ( $6 ^ $5 ) < 0) || $6 >= (INT_MAX-$9) ) goto $7 ;',
                    'temp[$3] = PyInt_FromLong ( $4 + $10 );',
                    '} else if (PyFloat_CheckExact( $0 ) && PyFloat_CheckExact( $1 )) {',
                    'temp[$3] = PyFloat_FromDouble((PyFloat_AS_DOUBLE($0) + PyFloat_AS_DOUBLE($1)) + ((double)$10));',
                    '} else { $7 :;',
                    'if ((temp[$2] = PyNumber_Add ( $0 , $1 )) == 0) goto $8;',
                    'if ((temp[$3] = PyNumber_Add ( temp[$2] , $11 )) == 0) goto $8;',
                    'CLEARTEMP($2);',
                    '}'), v2)
                return True             
        if TxMatch(o, i, ('if (PyInt_CheckExact( $0 ) && ($1 = PyInt_AS_LONG ( $0 )) > INT_MIN ) {',
            'temp[$2] = PyInt_FromLong ( $1 - 1 );',
            '} else if (PyFloat_CheckExact( $0 )) {',
            'temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) - ((double)1));',
            '} else {',
            'if ((temp[$2] = PyNumber_Subtract ( $0 , $5 )) == 0) goto $4;',
            '}',
            'if ( PyObject_SetItem ( $6 , temp[$2] , temp[$3] ) == -1) goto $4;',
            'CLEARTEMP($3);',
            'CLEARTEMP($2);',
            'temp[$3] = 0;'), v2):  
                TxRepl(o, i, ('if (PyInt_CheckExact( $0 ) && ($1 = PyInt_AS_LONG ( $0 )) > INT_MIN ) {',
                    'temp[$2] = PyInt_FromLong ( $1 - 1 );',
                    '} else {',
                    'if ((temp[$2] = PyNumber_Subtract ( $0 , $5 )) == 0) goto $4;',
                    '}',
                    'if ( PyObject_SetItem ( $6 , temp[$2] , temp[$3] ) == -1) goto $4;',
                    'CLEARTEMP($3);',
                    'CLEARTEMP($2);',
                    'temp[$3] = 0;'), v2)
                return True     
        
        if TxMatch(o, i, ('if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {',
            '$2 = PyInt_AS_LONG ( $0 );',
            '$3 = PyInt_AS_LONG ( $1 );',
            '$4 = $2 $14 $3;',
            'if (( $4 $15) goto $6 ;',
            'temp[$7] = PyInt_FromLong ( $4 );',
            '} else if (PyFloat_CheckExact( $0 ) && PyFloat_CheckExact( $1 )) {',
            'temp[$7] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) $14 PyFloat_AS_DOUBLE($1));',
            '} else { $6 :;',
            'if ((temp[$7] = PyNumber_$13 ( $0 , $1 )) == 0) goto $5;',
            '}',
            'if (PyFloat_CheckExact( temp[$7] )) {',
            'temp[$8] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$7]) $11 $10);',
            '} else {',
            'temp[$9] = PyFloat_FromDouble ($10);',
            'if ((temp[$8] = PyNumber_$12 ( temp[$7] , temp[$9] )) == 0) goto $5;',
            'CLEARTEMP($9);',
            '}',
            'CLEARTEMP($7);'), v2):
                TxRepl(o, i, ('if (PyFloat_CheckExact( $0 ) && PyFloat_CheckExact( $1 )) {',
                    'temp[$8] = PyFloat_FromDouble((PyFloat_AS_DOUBLE($0) $14 PyFloat_AS_DOUBLE($1)) $11 $10);',
                    '} else {',
                    'if ((temp[$7] = PyNumber_$13 ( $0 , $1 )) == 0) goto $5;',
                    'temp[$9] = PyFloat_FromDouble ($10);',
                    'if ((temp[$8] = PyNumber_$12 ( temp[$7] , temp[$9] )) == 0) goto $5;',
                    'CLEARTEMP($9);',
                    'CLEARTEMP($7);',
                    '}'), v2)
                return True     
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ($3);
            } else {
            if ((temp[$1] = PyNumber_$4) == 0) goto $5;
            }
            CLEARTEMP($0);
            if ((int_$6 = c_Py_EQ_Int ( temp[$1] , $7 , $8 )) == -1) goto $5;
            CLEARTEMP($1);
            """, v2):         
                TxRepl(o, i, """
                    if (PyInt_CheckExact( temp[$0] )) {
                    int_$6 = ($3) == $7;
                    CLEARTEMP($0);
                    } else {
                    if ((temp[$1] = PyNumber_$4) == 0) goto $5;
                    CLEARTEMP($0);
                    if ((int_$6 = c_Py_EQ_Int ( temp[$1] , $7 , $8 )) == -1) goto $5;
                    CLEARTEMP($1);
                    }
                    """, v2)
                return True   

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 )) {
            temp[$0] = PyInt_FromLong ($1 $3 PyInt_AS_LONG ( $10 ));
            } else {
            if ((temp[$0] = PyNumber_Or ( $2 , $10 )) == 0) goto $4;
            }
            long_$5 = PyInt_AsLong ( temp[$0] );
            CLEARTEMP($0);        
            """, v2) and v2[0] != v2[3]: 
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $10 )) {
                    long_$5 = $1 $3 PyInt_AS_LONG ( $10 );
                    } else {
                    if ((temp[$0] = PyNumber_Or ( $2 , $10 )) == 0) goto $4;
                    long_$5 = PyInt_AsLong ( temp[$0] );
                    CLEARTEMP($0);   
                    }
                    """, v2)  
                return True   

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 )) {
            temp[$0] = PyInt_FromLong (PyInt_AS_LONG ( $3 ) $5);
            } else {
            if ((temp[$0] = PyNumber_$6 ( $3 , $7 )) == 0) goto label_$4;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ($8 PyInt_AS_LONG ( temp[$0] ));
            } else {
            if ((temp[$1] = PyNumber_$9 ( $10 , temp[$0] )) == 0) goto label_$4;
            }
            CLEARTEMP($0);        
            """, v2): 
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $3 )) {
                    temp[$1] = PyInt_FromLong ($8 (PyInt_AS_LONG ( $3 ) $5));
                    } else {
                    if ((temp[$0] = PyNumber_$6 ( $3 , $7 )) == 0) goto label_$4;
                    if ((temp[$1] = PyNumber_$9 ( $10 , temp[$0] )) == 0) goto label_$4;
                    CLEARTEMP($0);    
                    }
                    """, v2)  
                return True   
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $2 )) {
            temp[$0] = PyInt_FromLong (PyInt_AS_LONG ( $2 ) $3);
            } else {
            if ((temp[$0] = PyNumber_$9 ( $2 , $8 )) == 0) goto $4;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            $6 = PyInt_AS_LONG ( temp[$0] );
            $7 = $10;
            if ($15) goto $5 ;
            temp[$1] = PyInt_FromLong ( $7 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble($12);
            } else { $5 :;
            if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto $4;
            }
            CLEARTEMP($0);        
            """, v2): 
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $2 )) {
                    $6 = (PyInt_AS_LONG ( $2 ) $3);
                    $7 = $10;
                    if ($15) goto $5 ;
                    temp[$1] = PyInt_FromLong ( $7 );
                    } else { $5 :;
                    if ((temp[$0] = PyNumber_$9 ( $2 , $8 )) == 0) goto $4;
                    if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto $4;
                    CLEARTEMP($0);   
                    }
                    """, v2)  
                return True   
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 )) {
            temp[$1] = PyInt_FromLong ( $6 );
            } else {
            if ((temp[$1] = PyNumber_$11 ( $7 )) == 0) goto $5;
            }
            if (PyInt_CheckExact( $3 ) && PyInt_CheckExact( temp[$1] )) {
            $8 = PyInt_AS_LONG ( $3 );
            $9 = PyInt_AS_LONG ( temp[$1] );
            $10 = $8 - $9;
            if (( $10 ^ $8 ) < 0 && ( $10 ^~ $9 ) < 0) goto $4 ;
            temp[$2] = PyInt_FromLong ( $10 );
            } else { $4 :;
            if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $5;
            }
            CLEARTEMP($1);        
            """, v2): 
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $3 )) {
                    $8 = PyInt_AS_LONG ( $3 );
                    $9 = $6;
                    $10 = $8 - $9;
                    if (( $10 ^ $8 ) < 0 && ( $10 ^~ $9 ) < 0) goto $4 ;
                    temp[$2] = PyInt_FromLong ( $10 );
                    } else { $4 :;
                    if ((temp[$1] = PyNumber_$11 ( $7 )) == 0) goto $5;
                    if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $5;
                    CLEARTEMP($1);   
                    }
                    """, v2)  
                return True   
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 ) && PyInt_CheckExact( temp[$2] )) {
            long_$8;
            long_$9;
            long_$10;
            if ($11) goto $5 ;
            temp[$0] = PyInt_FromLong ( long_$12 );
            } else { $5 :;
            if ((temp[$0] = PyNumber_$18 ( $3 , temp[$2] )) == 0) goto $4;
            }
            CLEARTEMP($2);
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( $7 )) {
            long_$13 = PyInt_AS_LONG ( temp[$0] );
            long_$14 = PyInt_AS_LONG ( $7 );
            long_$15;
            if ($16) goto $6 ;
            temp[$1] = PyInt_FromLong ( long_$17 );
            } else { $6 :;
            if ((temp[$1] = PyNumber_$19 ( temp[$0] , $7 )) == 0) goto $4;
            }
            CLEARTEMP($0);
            """, v2): 
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $3 ) && PyInt_CheckExact( temp[$2] ) && PyInt_CheckExact( $7 )) {
                    long_$8;
                    long_$9;
                    long_$10;
                    if ($11) goto $5 ;
                    long_$13 = long_$12;
                    long_$14 = PyInt_AS_LONG ( $7 );
                    long_$15;
                    if ($16) goto $5 ;
                    temp[$1] = PyInt_FromLong ( long_$17 );
                    } else { $5 :;
                    if ((temp[$0] = PyNumber_$18 ( $3 , temp[$2] )) == 0) goto $4;
                    CLEARTEMP($2);
                    if ((temp[$1] = PyNumber_$19 ( temp[$0] , $7 )) == 0) goto $4;
                    CLEARTEMP($0);
                    }
                    """, v2)  
                return True   

        if TxMatch(o, i, """
            if (PyInt_CheckExact($1)) {
            temp[$0] = PyInt_FromLong ($3);
            } else {
            if ((temp[$0] = PyNumber_$4) == 0) goto $2;
            }
            long_$5 = PyInt_AsLong ( temp[$0] );
            CLEARTEMP($0);
            """, v2): 
                TxRepl(o, i, """
                    if (PyInt_CheckExact($1)) {
                    long_$5 = ($3);
                    } else {
                    if ((temp[$0] = PyNumber_$4) == 0) goto $2;
                    long_$5 = PyInt_AsLong ( temp[$0] );
                    CLEARTEMP($0);
                    }
                    """, v2) 
                return True   

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$2] ) && ($4 = PyInt_AS_LONG ( temp[$2] )) < INT_MAX ) {
            temp[$0] = PyInt_FromLong ( $4 + 1 );
            } else if (PyFloat_CheckExact( temp[$2] )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$2]) + ((double)1));
            } else {
            if ((temp[$0] = PyNumber_Add ( temp[$2] , $5 )) == 0) goto $3;
            }
            CLEARTEMP($2);
            Py_ssize_t_$7 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);        
            """, v2): 
                    TxRepl(o, i, """
                        Py_ssize_t_$7 = PyInt_AS_LONG ( temp[$2] ) + 1;
                        CLEARTEMP($2);
                        """, v2) 
                    return True   

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$2] ) && ($1 = PyInt_AS_LONG ( temp[$2] )) < $5) {
            temp[$3] = PyInt_FromLong ( $1 + $6 );
            } else if (PyFloat_CheckExact( temp[$2] )) {
            temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$2]) + ((double)$6));
            } else {
            if ((temp[$3] = PyNumber_$7 ( temp[$2] , $8 )) == 0) goto $14;
            }
            CLEARTEMP($2);
            if (PyInt_CheckExact( temp[$3] )) {
            temp[$12] = PyInt_FromLong (PyInt_AS_LONG ( temp[$3] ) $15);
            } else {
            if ((temp[$12] = PyNumber_$16 ( temp[$3] , $13 )) == 0) goto $14;
            }
            CLEARTEMP($3);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$2] ) && ($1 = PyInt_AS_LONG ( temp[$2] )) < $5) {
                        CLEARTEMP($2);
                        temp[$12] = PyInt_FromLong (( $1 + $6 ) $15);
                        } else {
                        if ((temp[$3] = PyNumber_$7 ( temp[$2] , $8 )) == 0) goto $14;
                        CLEARTEMP($2);
                        if ((temp[$12] = PyNumber_$16 ( temp[$3] , $13 )) == 0) goto $14;
                        CLEARTEMP($3);
                        }
                        """, v2) 
                    return True
                    
                    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $2 ) && (($12 = PyInt_AS_LONG ( $2 )), $12 == (($12 * $6) / $6))) {
            temp[$4] = PyInt_FromLong ($12 * $6);
            } else {
            if ((temp[$4] = PyNumber_Multiply ( $2 , $7 )) == 0) goto $1;
            }
            if (PyInt_CheckExact( temp[$4] ) && ($8 = PyInt_AS_LONG ( temp[$4] )) $9 ) {
            temp[$5] = PyInt_FromLong ( $8 $10 );
            } else {
            if ((temp[$5] = PyNumber_$15 ( temp[$4] , $11 )) == 0) goto $1;
            }
            CLEARTEMP($4);                
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $2 ) && (($12 = PyInt_AS_LONG ( $2 )), $12 == (($12 * $6) / $6)) && ($8 = ($12 * $6)) $9 ) {
                        temp[$5] = PyInt_FromLong ( $8 $10 );
                        } else {
                        if ((temp[$4] = PyNumber_Multiply ( $2 , $7 )) == 0) goto $1;
                        if ((temp[$5] = PyNumber_$15 ( temp[$4] , $11 )) == 0) goto $1;
                        CLEARTEMP($4);                
                        }
                        """, v2) 
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] ) & $3);
            } else {
            if ((temp[$1] = PyNumber_And ( temp[$0] , $4 )) == 0) goto $5;
            }
            CLEARTEMP($0);
            if ((int_$6 = PyObject_Not ( temp[$1] )) == -1) goto $5;
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        int_$6 = !(PyInt_AS_LONG ( temp[$0] ) & $3);
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_And ( temp[$0] , $4 )) == 0) goto $5;
                        CLEARTEMP($0);
                        if ((int_$6 = PyObject_Not ( temp[$1] )) == -1) goto $5;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] ) $3);
            } else {
            if ((temp[$1] = PyNumber_$11 ( temp[$0] , $4 )) == 0) goto $5;
            }
            CLEARTEMP($0);
            if ((int_$6 = PyObject_Not ( temp[$1] )) == -1) goto $5;
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        int_$6 = !(PyInt_AS_LONG ( temp[$0] ) $3);
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$11 ( temp[$0] , $4 )) == 0) goto $5;
                        CLEARTEMP($0);
                        if ((int_$6 = PyObject_Not ( temp[$1] )) == -1) goto $5;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong (PyInt_AS_LONG ( temp[$0] ) $3);
            } else {
            if ((temp[$1] = PyNumber_$11 ( temp[$0] , $4 )) == 0) goto $5;
            }
            CLEARTEMP($0);
            if ((int_$6 = PyObject_IsTrue ( temp[$1] )) == -1) goto $5;
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        int_$6 = (PyInt_AS_LONG ( temp[$0] ) $3);
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$11 ( temp[$0] , $4 )) == 0) goto $5;
                        CLEARTEMP($0);
                        if ((int_$6 = PyObject_IsTrue ( temp[$1] )) == -1) goto $5;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {
            $2 = PyInt_AS_LONG ( $0 );
            $3 = PyInt_AS_LONG ( $1 );
            $4 = $2 $12 $3;
            if ($12) goto $5 ;
            temp[$8] = PyInt_FromLong ( $4 );
            } else if (PyFloat_CheckExact( $0 ) && PyFloat_CheckExact( $1 )) {
            temp[$8] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) $12 PyFloat_AS_DOUBLE($1));
            } else { $5 :;
            if ((temp[$8] = PyNumber_$14 ( $0 , $1 )) == 0) goto $6;
            }
            if (($10 = PyObject_Size ( $9 )) == -1) goto $6;
            if (PyInt_CheckExact( temp[$8] )) {
            $2 = PyInt_AS_LONG ( temp[$8] );
            $3 = $10;
            $4 = $2 $15 $3;
            if ($16) goto $7 ;
            temp[$11] = PyInt_FromLong ( $4 );
            } else if (PyFloat_CheckExact( temp[$8] )) {
            temp[$11] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$8]) $15 (double)$10);
            } else { $7 :;
            if ((temp[$18] = PyInt_FromSsize_t ( $10 )) == 0) goto $6;
            if ((temp[$11] = PyNumber_$17 ( temp[$8] , temp[$18] )) == 0) goto $6;
            CLEARTEMP($18);
            }
            CLEARTEMP($8);  
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( $1 )) {
                        $2 = PyInt_AS_LONG ( $0 );
                        $3 = PyInt_AS_LONG ( $1 );
                        $4 = $2 $12 $3;
                        if ($12) goto $5 ;
                        if (($10 = PyObject_Size ( $9 )) == -1) goto $6;
                        $2 = $4;
                        $3 = $10;
                        $4 = $2 $15 $3;
                        if ($16) goto $5 ;
                        temp[$11] = PyInt_FromLong ( $4 );
                        } else if (PyFloat_CheckExact( $0 ) && PyFloat_CheckExact( $1 )) {
                        if (($10 = PyObject_Size ( $9 )) == -1) goto $6;
                        temp[$11] = PyFloat_FromDouble((PyFloat_AS_DOUBLE($0) $12 PyFloat_AS_DOUBLE($1)) $15 (double)$10);
                        } else { $5 :;
                        if ((temp[$8] = PyNumber_$14 ( $0 , $1 )) == 0) goto $6;
                        if (($10 = PyObject_Size ( $9 )) == -1) goto $6;
                        if ((temp[$18] = PyInt_FromSsize_t ( $10 )) == 0) goto $6;
                        if ((temp[$11] = PyNumber_$17 ( temp[$8] , temp[$18] )) == 0) goto $6;
                        CLEARTEMP($18);
                        CLEARTEMP($8);                         
                        }
                        """, v2) 
                    return True
    
   
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 )) {
            long_$4 = PyInt_AS_LONG ( $3 );
            long_$4 = $5;
            temp[$0] = PyInt_FromLong (long_$4);
            } else {
            if ((temp[$0] = PyNumber_$6) == 0) goto $7;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$8 = $9 PyInt_AS_LONG ( temp[$0] );
            } else {
            if ((temp[2] = PyNumber_$10 temp[$0] )) == 0) goto $7;
            long_$8 = PyInt_AsLong ( temp[$2] );
            CLEARTEMP($2);
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $3 )) {
                        long_$4 = PyInt_AS_LONG ( $3 );
                        long_$4 = $5;
                        long_$8 = $9 long_$4;
                        } else {
                        if ((temp[$0] = PyNumber_$6) == 0) goto $7;
                        if ((temp[2] = PyNumber_$10 temp[$0] )) == 0) goto $7;
                        CLEARTEMP($0);
                        long_$8 = PyInt_AsLong ( temp[$2] );
                        CLEARTEMP($2);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $5 )) {
            temp[$0] = PyInt_FromLong ( $6 );
            } else {
            if ((temp[$0] = PyNumber_$7) == 0) goto $8;
            }
            $9 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $5 )) {
                        $9 = $6;
                        } else {
                        if ((temp[$0] = PyNumber_$7) == 0) goto $8;
                        $9 = PyInt_AsSsize_t ( temp[$0] );
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 )) {
            temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( $10 ) $11 );
            } else {
            if ((temp[$0] = PyNumber_$12 ( $10 , $13 )) == 0) goto $14;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$4 = PyInt_AS_LONG ( temp[$0] );
            long_$3 = $16;
            if ($17) goto $15 ;
            temp[$1] = PyInt_FromLong ( long_$3 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble($18);
            } else { $15 :;
            if ((temp[$1] = PyNumber_$19) == 0) goto $14;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $10 )) {
                        long_$4 = PyInt_AS_LONG ( $10 ) $11;
                        long_$3 = $16;
                        if ($17) goto $15 ;
                        temp[$1] = PyInt_FromLong ( long_$3 );
                        } else { $15 :;
                        if ((temp[$0] = PyNumber_$12 ( $10 , $13 )) == 0) goto $14;
                        if ((temp[$1] = PyNumber_$19) == 0) goto $14;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $2 )) {
            long_$4 = PyInt_AS_LONG ( $2 ) $5;
            long_$3 = $6;
            if ($7) goto $8 ;
            temp[$1] = PyInt_FromLong ( long_$3 );
            } else { $8 :;
            if ((temp[$0] = PyNumber_$9) == 0) goto $11;
            if ((temp[$1] = PyNumber_$10) == 0) goto $11;
            CLEARTEMP($0);
            }
            if (PyInt_CheckExact( temp[$1] )) {
            temp[$12] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $13 );
            } else {
            if ((temp[$12] = PyNumber_$14) == 0) goto $11;
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $2 )) {
                        long_$4 = PyInt_AS_LONG ( $2 ) $5;
                        long_$3 = $6;
                        if ($7) goto $8 ;
                        temp[$12] = PyInt_FromLong ( long_$3 $13 );
                        } else { $8 :;
                        if ((temp[$0] = PyNumber_$9) == 0) goto $11;
                        if ((temp[$1] = PyNumber_$10) == 0) goto $11;
                        CLEARTEMP($0);
                        if ((temp[$12] = PyNumber_$14) == 0) goto $11;
                        CLEARTEMP($1);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            long_$3 = PyInt_AS_LONG ( temp[$0] );
            long_$2 = $4;
            if ($6) goto $5 ;
            temp[$1] = PyInt_FromLong ( long_$2 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble($7);
            } else { $5 :;
            if ((temp[$1] = PyNumber_$8) == 0) goto $9;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            temp[$10] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $11 );
            } else {
            if ((temp[$10] = PyNumber_$12) == 0) goto $9;
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        long_$3 = PyInt_AS_LONG ( temp[$0] );
                        long_$2 = $4;
                        if ($6) goto $5 ;
                        temp[$10] = PyInt_FromLong ( long_$2 $11 );
                        } else { $5 :;
                        if ((temp[$1] = PyNumber_$8) == 0) goto $9;
                        CLEARTEMP($0);
                        if ((temp[$10] = PyNumber_$12) == 0) goto $9;
                        CLEARTEMP($1);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 )) {
            temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( $10 ) $11 );
            } else {
            if ((temp[$0] = PyNumber_$12) == 0) goto $13;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ( $14 PyInt_AS_LONG ( temp[$0] ) );
            } else {
            if ((temp[$1] = PyNumber_$15 ( $16 , temp[$0] )) == 0) goto $13;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $10 )) {
                        temp[$1] = PyInt_FromLong ( $14 (PyInt_AS_LONG ( $10 ) $11) );
                        } else {
                        if ((temp[$0] = PyNumber_$12) == 0) goto $13;
                        if ((temp[$1] = PyNumber_$15 ( $16 , temp[$0] )) == 0) goto $13;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $5 )) {
            long_$2 = PyInt_AS_LONG ( $5 );
            long_$2 = $3;
            temp[$0] = PyInt_FromLong ( long_$2 );
            } else {
            if ((temp[$0] = PyNumber_$6) == 0) goto $7;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$8 = ( $9 PyInt_AS_LONG ( temp[$0] ) );
            } else {
            if ((temp[$12] = PyNumber_$13) == 0) goto $7;
            long_$8 = PyInt_AsLong ( temp[$12] );
            CLEARTEMP($12);
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $5 )) {
                        long_$2 = PyInt_AS_LONG ( $5 );
                        long_$2 = $3;
                        long_$8 = ( $9 long_$2 );
                        } else {
                        if ((temp[$0] = PyNumber_$6) == 0) goto $7;
                        if ((temp[$12] = PyNumber_$13) == 0) goto $7;
                        CLEARTEMP($0);
                        long_$8 = PyInt_AsLong ( temp[$12] );
                        CLEARTEMP($12);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $5 )) {
            long_$3 = PyInt_AS_LONG ( $5 );
            long_$3 = $4;
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else {
            if ((temp[$0] = PyNumber_$6) == 0) goto $7;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$8 = ( PyInt_AS_LONG ( temp[$0] ) $9 );
            } else {
            if ((temp[$11] = PyNumber_$10) == 0) goto $7;
            long_$8 = PyInt_AsLong ( temp[$11] );
            CLEARTEMP($11);
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $5 )) {
                        long_$3 = PyInt_AS_LONG ( $5 );
                        long_$3 = $4;
                        long_$8 = ( long_$3 $9 );
                        } else {
                        if ((temp[$0] = PyNumber_$6) == 0) goto $7;
                        if ((temp[$11] = PyNumber_$10) == 0) goto $7;
                        CLEARTEMP($0);
                        long_$8 = PyInt_AsLong ( temp[$11] );
                        CLEARTEMP($11);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 ) && PyInt_CheckExact( $11 )) {
            long_$2 = PyInt_AS_LONG ( $10 );
            long_$6 = PyInt_AS_LONG ( $11 );
            long_$1 = long_$2 $12 long_$6;
            if ($13) < 0) goto $14 ;
            temp[$0] = PyInt_FromLong ( long_$1 );
            } else { $14 :;
            if ((temp[$0] = PyNumber_$15) == 0) goto $16;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            int_$8 = $17 $18 PyInt_AS_LONG ( temp[$0] );
            } else {
            temp[$19] = PyInt_FromLong ( $17 );
            if ((int_$8 = PyObject_RichCompareBool ( temp[$19] , temp[$0] , $18 )) == -1) goto $16;
            CLEARTEMP($19);
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $10 ) && PyInt_CheckExact( $11 )) {
                        long_$2 = PyInt_AS_LONG ( $10 );
                        long_$6 = PyInt_AS_LONG ( $11 );
                        long_$1 = long_$2 $12 long_$6;
                        if ($13) < 0) goto $14 ;
                        int_$8 = $17 $18 long_$1;
                        } else { $14 :;
                        if ((temp[$0] = PyNumber_$15) == 0) goto $16;
                        temp[$19] = PyInt_FromLong ( $17 );
                        if ((int_$8 = PyObject_RichCompareBool ( temp[$19] , temp[$0] , $18 )) == -1) goto $16;
                        CLEARTEMP($19);
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
                    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 )) {
            long_$4 = PyInt_AS_LONG ( $1 );
            long_$3 = $6 long_$4;
            if ($5) goto label_$14 ;
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else { label_$14 :;
            if ((temp[$0] = PyNumber_$9) == 0) goto label_$8;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            int_$7 = $11 $12 PyInt_AS_LONG ( temp[$0] );
            } else {
            temp[$2] = PyInt_FromLong ( $11 );
            if ((int_$7 = PyObject_RichCompareBool ( temp[$2] , temp[$0] , $15 )) == -1) goto label_$8;
            CLEARTEMP($2);
            }
            CLEARTEMP($0);                
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $1 )) {
                        long_$4 = PyInt_AS_LONG ( $1 );
                        long_$3 = $6 long_$4;
                        if ($5) goto label_$14 ;
                        int_$7 = $11 $12 long_$3;
                        } else { label_$14 :;
                        if ((temp[$0] = PyNumber_$9) == 0) goto label_$8;
                        temp[$2] = PyInt_FromLong ( $11 );
                        if ((int_$7 = PyObject_RichCompareBool ( temp[$2] , temp[$0] , $15 )) == -1) goto label_$8;
                        CLEARTEMP($2);
                        CLEARTEMP($0);                
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $4 ) && (long_$5 = PyInt_AS_LONG ( $4 )) $7 ) {
            temp[$1] = PyInt_FromLong ( $8 );
            } else {
            if ((temp[$1] = PyNumber_$9) == 0) goto label_$10;
            }
            if ((temp[$2] = $13) == 0) goto label_$10;
            if ((Py_ssize_t_$3 = $14 ( temp[$2] )) == -1) goto label_$10;
            CLEARTEMP($2);
            if (PyInt_CheckExact( temp[$1] )) {
            int_$6 = PyInt_AS_LONG ( temp[$1] ) $15 Py_ssize_t_$3;
            } else {
            temp[$11] = PyInt_FromLong ( Py_ssize_t_$3 );
            if ((int_$6 = PyObject_RichCompareBool ( temp[$1] , temp[$11] , $16 )) == -1) goto label_$10;
            CLEARTEMP($11);
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $4 ) && (long_$5 = PyInt_AS_LONG ( $4 )) $7 ) {
                        if ((temp[$2] = $13) == 0) goto label_$10;
                        if ((Py_ssize_t_$3 = $14 ( temp[$2] )) == -1) goto label_$10;
                        CLEARTEMP($2);
                        int_$6 = ($8) $15 Py_ssize_t_$3;
                        } else {
                        if ((temp[$1] = PyNumber_$9) == 0) goto label_$10;
                        if ((temp[$2] = $13) == 0) goto label_$10;
                        if ((Py_ssize_t_$3 = $14 ( temp[$2] )) == -1) goto label_$10;
                        CLEARTEMP($2);
                        temp[$11] = PyInt_FromLong ( Py_ssize_t_$3 );
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$11] , temp[$2] , $16 )) == -1) goto label_$10;
                        CLEARTEMP($11);
                        CLEARTEMP($1);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $3 ) && (long_$5 = PyInt_AS_LONG ( $3 )) $6 ) {
            temp[$0] = PyInt_FromLong ( $7 );
            } else {
            if ((temp[$0] = PyNumber_$8) == 0) goto $2;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$9 = PyInt_AS_LONG ( temp[$0] );
            CLEARTEMP($0);
            if ( long_$9 < 0) {
            long_$9 += PyList_GET_SIZE($4);
            }
            if ((temp[$1] = PyList_GetItem ( $4 , long_$9 )) == 0) goto $2;
            Py_INCREF(temp[$1]);
            } else {
            if ((temp[$1] = PyObject_GetItem ( $4 , temp[$0] )) == 0) goto $2;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $3 ) && (long_$5 = PyInt_AS_LONG ( $3 )) $6 ) {
                        long_$9 = $7;
                        if ( long_$9 < 0) {
                        long_$9 += PyList_GET_SIZE($4);
                        }
                        if ((temp[$1] = PyList_GetItem ( $4 , long_$9 )) == 0) goto $2;
                        Py_INCREF(temp[$1]);
                        } else {
                        if ((temp[$0] = PyNumber_$8) == 0) goto $2;
                        if ((temp[$1] = PyObject_GetItem ( $4 , temp[$0] )) == 0) goto $2;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $2 )) {
            long_$3 = PyInt_AS_LONG ( $2 );
            long_$3 = $5;
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else {
            if ((temp[$0] = PyNumber_$9) == 0) goto $6;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $7 );
            } else {
            if ((temp[$1] = PyNumber_$8) == 0) goto $6;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $2 )) {
                        long_$3 = PyInt_AS_LONG ( $2 );
                        long_$3 = $5;
                        temp[$1] = PyInt_FromLong ( long_$3 $7 );
                        } else {
                        if ((temp[$0] = PyNumber_$9) == 0) goto $6;
                        if ((temp[$1] = PyNumber_$8) == 0) goto $6;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 ) && (long_$5 = PyInt_AS_LONG ( $10 )) $6 ) {
            temp[$1] = PyInt_FromLong ( $7 );
            } else {
            if ((temp[$1] = PyNumber_$8) == 0) goto $9;
            }
            if ((temp[$2] = PyObject_$10) == 0) goto $9;
            if ((Py_ssize_t_$3 = $11 ( temp[$2] )) == -1) goto $9;
            CLEARTEMP($2);
            if (PyInt_CheckExact( temp[$1] )) {
            int_$15 = PyInt_AS_LONG ( temp[$1] ) $12 Py_ssize_t_$3;
            } else {
            temp[$13] = PyInt_FromLong ( Py_ssize_t_$3 );
            if ((int_$15 = PyObject_RichCompareBool ( temp[$1] , temp[$13] , $14 )) == -1) goto $9;
            CLEARTEMP($13);
            }
            CLEARTEMP($1);    
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $10 ) && (long_$5 = PyInt_AS_LONG ( $10 )) $6 ) {
                        if ((temp[$2] = PyObject_$10) == 0) goto $9;
                        if ((Py_ssize_t_$3 = $11 ( temp[$2] )) == -1) goto $9;
                        CLEARTEMP($2);
                        int_$15 = ($7) $12 Py_ssize_t_$3;
                        } else {
                        if ((temp[$1] = PyNumber_$8) == 0) goto $9;
                        if ((temp[$2] = PyObject_$10) == 0) goto $9;
                        if ((Py_ssize_t_$3 = $11 ( temp[$2] )) == -1) goto $9;
                        CLEARTEMP($2);
                        temp[$13] = PyInt_FromLong ( Py_ssize_t_$3 );
                        if ((int_$15 = PyObject_RichCompareBool ( temp[$1] , temp[$13] , $14 )) == -1) goto $9;
                        CLEARTEMP($13);
                        CLEARTEMP($1);    
                        }
                        """, v2) 
                    return True

        if TxMatch(o, i, """
            if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$5 = PyInt_AS_LONG ( GETLOCAL($1) )) < INT_MAX ) {
            temp[$0] = PyInt_FromLong ( long_$5 + 1 );
            } else {
            if ((temp[$0] = PyNumber_$10Add ( GETLOCAL($1) , consts[$11] )) == 0) goto label_$12;
            }
            SETLOCAL ( $1 , temp[$0] );
            temp[$0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$5 = PyInt_AS_LONG ( GETLOCAL($1) )) < INT_MAX ) {
                        Py_DECREF(GETLOCAL($1));
                        GETLOCAL($1) = PyInt_FromLong ( long_$5 + 1 );
                        } else {
                        SETLOCAL ( $1 , PyNumber_$10Add ( GETLOCAL($1) , consts[$11] ) );
                        if (GETLOCAL($1) == 0) goto label_$12;
                        }
                        """, v2) 
                    return True

        if TxMatch(o, i, """
            if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$4 = PyInt_AS_LONG ( GETLOCAL($1) )) < INT_MAX ) {
            long_$4 = long_$4 + 1;
            if ((temp[$10] = __c_BINARY_SUBSCR_Int ( $3 , long_$4 )) == 0) goto label_$12;
            } else {
            if ((temp[$0] = PyNumber_Add ( GETLOCAL($1) , consts[$11] )) == 0) goto label_$12;
            if ((temp[$10] = PyObject_GetItem ( $3 , temp[$0] )) == 0) goto label_$12;
            CLEARTEMP($0);
            }
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$4 = PyInt_AS_LONG ( GETLOCAL($1) )) < INT_MAX ) {
                        if ((temp[$10] = __c_BINARY_SUBSCR_Int ( $3 , long_$4 + 1 )) == 0) goto label_$12;
                        } else {
                        if ((temp[$0] = PyNumber_Add ( GETLOCAL($1) , consts[$11] )) == 0) goto label_$12;
                        if ((temp[$10] = PyObject_GetItem ( $3 , temp[$0] )) == 0) goto label_$12;
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True

        if TxMatch(o, i, """
            if (PyInt_CheckExact( GETLOCAL($11) )) {
            int_$1 = PyInt_AS_LONG ( GETLOCAL($11) ) < $2;
            } else {
            temp[$10] = PyInt_FromLong ( $2 );
            if ((int_$1 = PyObject_RichCompareBool ( GETLOCAL($11) , temp[$10] , Py_LT )) == -1) goto label_$0;
            CLEARTEMP($10);
            }
            if (!( int_$1 )) break;
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( GETLOCAL($11) )) {
                        if (PyInt_AS_LONG ( GETLOCAL($11) ) >= $2) break;
                        } else {
                        temp[$10] = PyInt_FromLong ( $2 );
                        if ((int_$1 = PyObject_RichCompareBool ( GETLOCAL($11) , temp[$10] , Py_LT )) == -1) goto label_$0;
                        CLEARTEMP($10);
                        if (!int_$1) break;
                        }
                        """, v2) 
                    return True

        if TxMatch(o, i, """
            if (PyInt_CheckExact( GETLOCAL($11) )) {
            int_$1 = PyInt_AS_LONG ( GETLOCAL($11) ) < ($2);
            } else {
            temp[$10] = PyInt_FromLong ( $2 );
            if ((int_$1 = PyObject_RichCompareBool ( GETLOCAL($11) , temp[$10] , Py_LT )) == -1) goto label_$0;
            CLEARTEMP($10);
            }
            if (!( int_$1 )) break;
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( GETLOCAL($11) )) {
                        if (PyInt_AS_LONG ( GETLOCAL($11) ) >= ($2)) break;
                        } else {
                        temp[$10] = PyInt_FromLong ( $2 );
                        if ((int_$1 = PyObject_RichCompareBool ( GETLOCAL($11) , temp[$10] , Py_LT )) == -1) goto label_$0;
                        CLEARTEMP($10);
                        if (!int_$1) break;
                        }
                        """, v2) 
                    return True


        if TxMatch(o, i, """
            if (PyInt_CheckExact( GETLOCAL($10) ) && PyInt_CheckExact( $11 )) {
            $14 = PyInt_AS_LONG ( GETLOCAL($10) );
            $15 = PyInt_AS_LONG ( $11 );
            $16 = $14 + $15;
            if (( $16 ^ $14 ) < 0 && ( $16 ^ $15 ) < 0) goto $12 ;
            temp[$17] = PyInt_FromLong ( $16 );
            } else if (PyFloat_CheckExact( GETLOCAL($10) ) && PyFloat_CheckExact( $11 )) {
            temp[$17] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(GETLOCAL($10)) + PyFloat_AS_DOUBLE($11));
            } else { $12 :;
            if ((temp[$17] = PyNumber_$5Add ( GETLOCAL($10) , $11 )) == 0) goto $13;
            }
            SETLOCAL ( $10 , temp[$17] );
            temp[$17] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( GETLOCAL($10) ) && PyInt_CheckExact( $11 )) {
                        $14 = PyInt_AS_LONG ( GETLOCAL($10) );
                        $15 = PyInt_AS_LONG ( $11 );
                        $16 = $14 + $15;
                        if (( $16 ^ $14 ) < 0 && ( $16 ^ $15 ) < 0) goto $12 ;
                        Py_DECREF(GETLOCAL($10));
                        GETLOCAL($10) = PyInt_FromLong ( $16 );
                        } else if (PyFloat_CheckExact( GETLOCAL($10) ) && PyFloat_CheckExact( $11 )) {
                        SETLOCAL ( $10 , PyFloat_FromDouble(PyFloat_AS_DOUBLE(GETLOCAL($10)) + PyFloat_AS_DOUBLE($11)) );
                        if (GETLOCAL($10) == 0) goto $13;
                        } else { $12 :;
                        SETLOCAL ( $10 , PyNumber_$5Add ( GETLOCAL($10) , $11 ) );
                        if (GETLOCAL($10) == 0) goto $13;
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 )) {
            long_$2 = PyInt_AS_LONG ( $1 );
            long_$3 = PyInt_AS_LONG ( $0 );
            long_$4 = long_$2 $6 long_$3;
            if ($5) goto label_$7 ;
            temp[$9] = PyInt_FromLong ( long_$4 );
            } else if (PyFloat_CheckExact( $0 )) {
            temp[$9] = PyFloat_FromDouble((double)PyInt_AS_LONG ( $1 ) $6 PyFloat_AS_DOUBLE($0));
            } else { label_$7 :;
            if ((temp[$9] = PyNumber_$10 ( $1 , $0 )) == 0) goto label_$8;
            }
            if (PyInt_CheckExact( temp[$9] )) {
            long_$11 = PyInt_AS_LONG ( temp[$9] );
            long_$12 = long_$11 $18 $15;
            if ($17) goto label_$13 ;
            temp[$14] = PyInt_FromLong ( long_$12 );
            } else if (PyFloat_CheckExact( temp[$9] )) {
            temp[$14] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$9]) $18 ((double)$15));
            } else { label_$13 :;
            if ((temp[$14] = PyNumber_$19 ( temp[$9] , $16 )) == 0) goto label_$8;
            }
            CLEARTEMP($9);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 )) {
                        long_$2 = PyInt_AS_LONG ( $1 );
                        long_$3 = PyInt_AS_LONG ( $0 );
                        long_$4 = long_$2 $6 long_$3;
                        if ($5) goto label_$7 ;
                        long_$11 = long_$4;
                        long_$12 = long_$11 $18 $15;
                        if ($17) goto label_$7 ;
                        temp[$14] = PyInt_FromLong ( long_$12 );
                        } else if (PyFloat_CheckExact( $0 )) {
                        temp[$14] = PyFloat_FromDouble(((double)PyInt_AS_LONG ( $1 ) $6 PyFloat_AS_DOUBLE($0)) $18 ((double)$15));
                        } else { label_$7 :;
                        if ((temp[$9] = PyNumber_$10 ( $1 , $0 )) == 0) goto label_$8;
                        if ((temp[$14] = PyNumber_$19 ( temp[$9] , $16 )) == 0) goto label_$8;
                        CLEARTEMP($9);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $10 );
            } else {
            if ((temp[$1] = PyNumber_$12 ( temp[$0] , $13 )) == 0) goto label_$11;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            temp[$2] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $14 );
            } else {
            if ((temp[$2] = PyNumber_$16 ( temp[$1] , $15 )) == 0) goto label_$11;
            }
            CLEARTEMP($1);                
            """, v2): 
                    TxRepl(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$2] = PyInt_FromLong ( (PyInt_AS_LONG ( temp[$0] ) $10) $14 );
            } else {
            if ((temp[$1] = PyNumber_$12 ( temp[$0] , $13 )) == 0) goto label_$11;
            CLEARTEMP($0);
            if ((temp[$2] = PyNumber_$16 ( temp[$1] , $15 )) == 0) goto label_$11;
            CLEARTEMP($1);                
            }
            """, v2) 
                    return True 
                
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            long_$5 = PyInt_AS_LONG ( temp[$0] );
            long_$6 = $12long_$5;
            if ($10) goto label_$3 ;
            temp[$1] = PyInt_FromLong ( long_$6 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble($14PyFloat_AS_DOUBLE(temp[$0]));
            } else { label_$3 :;
            if ((temp[$1] = PyNumber_Add ( $16 , temp[$0] )) == 0) goto label_$4;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            long_$7 = PyInt_AS_LONG ( temp[$1] );
            long_$8 = long_$7 $13;
            if ($11) goto label_$9 ;
            temp[$2] = PyInt_FromLong ( long_$6 );
            } else if (PyFloat_CheckExact( temp[$1] )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1])$15);
            } else { label_$9 :;
            if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $17 )) == 0) goto label_$4;
            }
            CLEARTEMP($1);                
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        long_$5 = PyInt_AS_LONG ( temp[$0] );
                        long_$6 = $12long_$5;
                        if ($10) goto label_$3 ;
                        long_$7 = long_$6;
                        long_$8 = long_$7 $13;
                        if ($11) goto label_$3 ;
                        temp[$2] = PyInt_FromLong ( long_$6 );
                        } else if (PyFloat_CheckExact( temp[$0] )) {
                        temp[$2] = PyFloat_FromDouble(($14PyFloat_AS_DOUBLE(temp[$0]))$15);
                        } else { label_$3 :;
                        if ((temp[$1] = PyNumber_Add ( $16 , temp[$0] )) == 0) goto label_$4;
                        CLEARTEMP($0);
                        if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $17 )) == 0) goto label_$4;
                        CLEARTEMP($1);    
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $14 )) {
            long_$15 = PyInt_AS_LONG ( $14 );
            long_$16 = long_$15 + $13;
            if (( long_$16 ^ long_$15 ) < 0 && ( long_$16 ^ $13 ) < 0) goto label_$11 ;
            temp[$18] = PyInt_FromLong ( long_$16 );
            } else if (PyFloat_CheckExact( $14 )) {
            temp[$18] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($14) + (double)$13);
            } else { label_$11 :;
            temp[$17] = PyInt_FromLong ($13);
            if ((temp[$18] = PyNumber_Add ( $14 , temp[$17] )) == 0) goto label_$7;
            CLEARTEMP($17);
            }
            if (PyInt_CheckExact( temp[$18] )) {
            long_$19 = PyInt_AS_LONG ( temp[$18] );
            long_$10 = long_$19 + 1;
            if (( long_$10 ^ long_$19 ) < 0 && ( long_$10 ^ 1 ) < 0) goto label_$12 ;
            temp[$9] = PyInt_FromLong ( long_$10 );
            } else if (PyFloat_CheckExact( temp[$18] )) {
            temp[$9] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$18]) + ((double)1));
            } else { label_$12 :;
            if ((temp[$9] = PyNumber_Add ( temp[$18] , $8 )) == 0) goto label_$7;
            }
            CLEARTEMP($18);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $14 )) {
                        long_$15 = PyInt_AS_LONG ( $14 );
                        long_$16 = long_$15 + $13;
                        if (( long_$16 ^ long_$15 ) < 0 && ( long_$16 ^ $13 ) < 0) goto label_$11 ;
                        long_$19 = long_$16;
                        long_$10 = long_$19 + 1;
                        if (( long_$10 ^ long_$19 ) < 0 && ( long_$10 ^ 1 ) < 0) goto label_$11 ;
                        temp[$9] = PyInt_FromLong ( long_$10 );
                        } else if (PyFloat_CheckExact( $14 )) {
                        temp[$9] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($14) + (double)$13 + ((double)1));
                        } else { label_$11 :;
                        temp[$17] = PyInt_FromLong ($13);
                        if ((temp[$18] = PyNumber_Add ( $14 , temp[$17] )) == 0) goto label_$7;
                        CLEARTEMP($17);
                        if ((temp[$9] = PyNumber_Add ( temp[$18] , $8 )) == 0) goto label_$7;
                        CLEARTEMP($18);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$2] )) {
            long_$5 = PyInt_AS_LONG ( temp[$2] );
            long_$6 = long_$5 + $7;
            if (( long_$6 ^ long_$5 ) < 0 && ( long_$6 ^ $7 ) < 0) goto label_$4 ;
            temp[$0] = PyInt_FromLong ( long_$6 );
            } else if (PyFloat_CheckExact( temp[$2] )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$2]) + ((double)$7));
            } else { label_$4 :;
            if ((temp[$0] = PyNumber_Add ( temp[$2] , $8 )) == 0) goto label_$1;
            }
            CLEARTEMP($2);
            Py_ssize_t_$15 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$2] )) {
                        long_$5 = PyInt_AS_LONG ( temp[$2] );
                        long_$6 = long_$5 + $7;
                        if (( long_$6 ^ long_$5 ) < 0 && ( long_$6 ^ $7 ) < 0) goto label_$4 ;
                        CLEARTEMP($2);
                        Py_ssize_t_$15 = long_$6;
                        } else { label_$4 :;
                        if ((temp[$0] = PyNumber_Add ( temp[$2] , $8 )) == 0) goto label_$1;
                        CLEARTEMP($2);
                        Py_ssize_t_$15 = PyInt_AsSsize_t ( temp[$0] );
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
                if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( $2 )) {
                long_$5 = PyInt_AS_LONG ( $1 );
                long_$6 = PyInt_AS_LONG ( $2 );
                long_$7 = long_$5 + long_$6;
                if (( long_$7 ^ long_$5 ) < 0 && ( long_$7 ^ long_$6 ) < 0) goto label_$4 ;
                temp[$0] = PyInt_FromLong ( long_$7 );
                } else if (PyFloat_CheckExact( $1 ) && PyFloat_CheckExact( $2 )) {
                temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + PyFloat_AS_DOUBLE($2));
                } else { label_$4 :;
                if ((temp[$0] = PyNumber_Add ( $1 , $2 )) == 0) goto label_$3;
                }
                if ((int_$8 = c_$9_Int ( temp[$0] , $10 , $11 )) == -1) goto label_$3;
                CLEARTEMP($0);
            """, v2) and v2[9] in c_2_op_op: 
                    v2[12] = c_2_op_op[v2[9]]
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $1 ) && PyInt_CheckExact( $2 )) {
                        long_$5 = PyInt_AS_LONG ( $1 );
                        long_$6 = PyInt_AS_LONG ( $2 );
                        long_$7 = long_$5 + long_$6;
                        if (( long_$7 ^ long_$5 ) < 0 && ( long_$7 ^ long_$6 ) < 0) goto label_$4 ;
                        int_$8 = long_$7 $12 $10;
                        } else if (PyFloat_CheckExact( $1 ) && PyFloat_CheckExact( $2 )) {
                        int_$8 = (PyFloat_AS_DOUBLE($1) + PyFloat_AS_DOUBLE($2)) $12 $10;
                        } else { label_$4 :;
                        if ((temp[$0] = PyNumber_Add ( $1 , $2 )) == 0) goto label_$3;
                        if ((int_$8 = PyObject_RichCompareBool ( temp[$0] , $11 , $9 )) == -1) goto label_$3;
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 )) {
            long_$3 = PyInt_AS_LONG ( $10 );
            long_$4 = PyInt_AS_LONG ( $10 );
            long_$5 = long_$3 + long_$4;
            if (( long_$5 ^ long_$3 ) < 0 && ( long_$5 ^ long_$4 ) < 0) goto label_$6 ;
            temp[$0] = PyInt_FromLong ( long_$5 );
            } else if (PyFloat_CheckExact( $10 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($10) + PyFloat_AS_DOUBLE($10));
            } else { label_$6 :;
            if ((temp[$0] = PyNumber_Add ( $10 , $10 )) == 0) goto label_$7;
            }
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) + $8);
            } else {
            temp[$1] = PyFloat_FromDouble ($8);
            if ((temp[$2] = PyNumber_Add ( temp[$0] , temp[$1] )) == 0) goto label_$7;
            CLEARTEMP($1);
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyFloat_CheckExact( $10 )) {
                        temp[$2] = PyFloat_FromDouble((PyFloat_AS_DOUBLE($10) * 2) + $8);
                        } else {
                        if ((temp[$0] = PyNumber_Add ( $10 , $10 )) == 0) goto label_$7;
                        temp[$1] = PyFloat_FromDouble ($8);
                        if ((temp[$2] = PyNumber_Add ( temp[$0] , temp[$1] )) == 0) goto label_$7;
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] ) && (long_$3 = PyInt_AS_LONG ( temp[$0] )) > $4 ) {
            temp[$1] = PyInt_FromLong ( long_$3 $5 $6 );
            } else {
            if ((temp[$1] = PyNumber_$7 ( temp[$0] , $8 )) == 0) goto label_$9;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            int_$10 = $11 $12 PyInt_AS_LONG ( temp[$1] );
            } else {
            temp[$2] = PyInt_FromLong ( $11 );
            if ((int_$10 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , $13 )) == -1) goto label_$9;
            CLEARTEMP($2);
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] ) && (long_$3 = PyInt_AS_LONG ( temp[$0] )) > $4 ) {
                        CLEARTEMP($0);
                        int_$10 = $11 $12 ( long_$3 $5 $6 );
                        } else {
                        if ((temp[$1] = PyNumber_$7 ( temp[$0] , $8 )) == 0) goto label_$9;
                        CLEARTEMP($0);
                        temp[$2] = PyInt_FromLong ( $11 );
                        if ((int_$10 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , $13 )) == -1) goto label_$9;
                        CLEARTEMP($2);
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            long_$4 = PyInt_AS_LONG ( temp[$0] );
            long_$5 = long_$4 $6 $7;
            if ($8) goto label_$2 ;
            temp[$1] = PyInt_FromLong ( long_$5 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $6 ((double)$7));
            } else { label_$2 :;
            if ((temp[$1] = PyNumber_$10 ( temp[$0] , $11 )) == 0) goto label_$3;
            }
            CLEARTEMP($0);
            Py_ssize_t_$12 = PyInt_AsSsize_t ( temp[$1] );
            CLEARTEMP($1);            
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        long_$4 = PyInt_AS_LONG ( temp[$0] );
                        long_$5 = long_$4 $6 $7;
                        if ($8) goto label_$2 ;
                        CLEARTEMP($0);
                        Py_ssize_t_$12 = long_$5;
                        } else { label_$2 :;
                        if ((temp[$1] = PyNumber_$10 ( temp[$0] , $11 )) == 0) goto label_$3;
                        CLEARTEMP($0);
                        Py_ssize_t_$12 = PyInt_AsSsize_t ( temp[$1] );
                        CLEARTEMP($1);            
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            long_$4 = PyInt_AS_LONG ( temp[$0] );
            long_$5 = long_$4 $6 $7;
            if ($8) goto label_$2 ;
            temp[$1] = PyInt_FromLong ( long_$5 );
            temp[$0] = 0;
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $6 ((double)$7));
            temp[$0] = 0;
            } else { label_$2 :;
            Py_INCREF(temp[$0]);
            if ((temp[$1] = PyNumber_$10 ( temp[$0] , $11 )) == 0) goto label_$3;
            CLEARTEMP($0);
            }
            Py_ssize_t_$12 = PyInt_AsSsize_t ( temp[$1] );
            CLEARTEMP($1);            
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        long_$4 = PyInt_AS_LONG ( temp[$0] );
                        long_$5 = long_$4 $6 $7;
                        if ($8) goto label_$2 ;
                        temp[$0] = 0;
                        Py_ssize_t_$12 = long_$5;
                        } else { label_$2 :;
                        Py_INCREF(temp[$0]);
                        if ((temp[$1] = PyNumber_$10 ( temp[$0] , $11 )) == 0) goto label_$3;
                        CLEARTEMP($0);
                        Py_ssize_t_$12 = PyInt_AsSsize_t ( temp[$1] );
                        CLEARTEMP($1);            
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 )) {
            long_$11 = PyInt_AS_LONG ( $10 );
            long_$12 = $14 - long_$11;
            if (( long_$12 ^ $14 ) < 0 && ( long_$12 ^~ long_$11 ) < 0) goto label_$13 ;
            temp[$0] = PyInt_FromLong ( long_$12 );
            } else if (PyFloat_CheckExact( $10 )) {
            temp[$0] = PyFloat_FromDouble(((double)$14) - PyFloat_AS_DOUBLE($10));
            } else { label_$13 :;
            if ((temp[$0] = PyNumber_Subtract ( $15 , $10 )) == 0) goto label_$16;
            }
            if (PyFloat_CheckExact( $10 ) && PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($10) * PyFloat_AS_DOUBLE(temp[$0]));
            } else if (PyInt_CheckExact( $10 ) && PyInt_CheckExact( temp[$0] )) {
            long_$17 = PyInt_AS_LONG ( $10 );
            long_$18 = PyInt_AS_LONG ( temp[$0] );
            if (long_$17 && long_$18 && (long_$17 * long_$18) / long_$18 == long_$17) {
            temp[$1] = PyInt_FromLong ( long_$17 * long_$18 );
            } else {
            temp[$1] = PyInt_Type.tp_as_number->nb_multiply($10, temp[$0]);
            }
            } else {
            if ((temp[$1] = PyNumber_Multiply ( $10 , temp[$0] )) == 0) goto label_$16;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $10 )) {
                        long_$11 = PyInt_AS_LONG ( $10 );
                        long_$12 = $14 - long_$11;
                        if (( long_$12 ^ $14 ) < 0 && ( long_$12 ^~ long_$11 ) < 0) goto label_$13 ;
                        long_$18 = long_$12;
                        long_$17 = PyInt_AS_LONG ( $10 );
                        if (long_$17 && long_$18 && (long_$17 * long_$18) / long_$18 == long_$17) {
                        temp[$1] = PyInt_FromLong ( long_$17 * long_$18 );
                        } else { goto label_$13 ; }
                        } else if (PyFloat_CheckExact( $10 )) {
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($10) * (((double)$14) - PyFloat_AS_DOUBLE($10)));
                        } else { label_$13 :;
                        if ((temp[$0] = PyNumber_Subtract ( $15 , $10 )) == 0) goto label_$16;
                        if ((temp[$1] = PyNumber_Multiply ( $10 , temp[$0] )) == 0) goto label_$16;
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( $4 )) {
            long_$7 = PyInt_AS_LONG ( temp[$0] );
            long_$8 = PyInt_AS_LONG ( $4 );
            long_$9 = long_$7 - long_$8;
            if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^~ long_$8 ) < 0) goto label_$6 ;
            temp[$2] = PyInt_FromLong ( long_$9 );
            } else if (PyFloat_CheckExact( temp[$0] ) && PyFloat_CheckExact( $4 )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) - PyFloat_AS_DOUBLE($4));
            } else { label_$6 :;
            if ((temp[$2] = PyNumber_Subtract ( temp[$0] , $4 )) == 0) goto label_$5;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$3] ) && PyFloat_CheckExact( temp[$2] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$3]) * PyFloat_AS_DOUBLE(temp[$2]));
            } else if (PyInt_CheckExact( temp[$3] ) && PyInt_CheckExact( temp[$2] )) {
            long_$10 = PyInt_AS_LONG ( temp[$3] );
            long_$11 = PyInt_AS_LONG ( temp[$2] );
            if (long_$10 && long_$11 && (long_$10 * long_$11) / long_$11 == long_$10) {
            temp[$1] = PyInt_FromLong ( long_$10 * long_$11 );
            } else {
            temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$3], temp[$2]);
            }
            } else {
            if ((temp[$1] = PyNumber_Multiply ( temp[$3] , temp[$2] )) == 0) goto label_$5;
            }
            CLEARTEMP($3);
            CLEARTEMP($2);
            if ( PyList_SetItem ( $15 , $16 , temp[$1] ) == -1) goto label_$5;
            temp[$1] = 0;            
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( $4 ) && PyInt_CheckExact( temp[$3] )) {
                        long_$7 = PyInt_AS_LONG ( temp[$0] );
                        long_$8 = PyInt_AS_LONG ( $4 );
                        long_$9 = long_$7 - long_$8;
                        if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^~ long_$8 ) < 0) goto label_$6 ;
                        long_$11 = long_$9;
                        long_$10 = PyInt_AS_LONG ( temp[$3] );
                        if (long_$10 && long_$11 && (long_$10 * long_$11) / long_$11 == long_$10) {
                        CLEARTEMP($0);
                        CLEARTEMP($3);
                        if ( PyList_SetItem ( $15 , $16 , PyInt_FromLong ( long_$10 * long_$11 ) ) == -1) goto label_$5;
                        } else { goto label_$6 ; }
                        } else if (PyFloat_CheckExact( temp[$0] ) && PyFloat_CheckExact( $4 ) && PyFloat_CheckExact( temp[$3] )) {
                        if ( PyList_SetItem ( $15 , $16 , PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$3]) * (PyFloat_AS_DOUBLE(temp[$0]) - PyFloat_AS_DOUBLE($4))) ) == -1) goto label_$5;
                        CLEARTEMP($0);
                        CLEARTEMP($3);
                        } else { label_$6 :;
                        if ((temp[$2] = PyNumber_Subtract ( temp[$0] , $4 )) == 0) goto label_$5;
                        CLEARTEMP($0);
                        if ((temp[$1] = PyNumber_Multiply ( temp[$3] , temp[$2] )) == 0) goto label_$5;
                        CLEARTEMP($2);
                        CLEARTEMP($3);
                        if ( PyList_SetItem ( $15 , $16 , temp[$1] ) == -1) goto label_$5;
                        temp[$1] = 0;            
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 )) {
            temp[$0] = $6;
            } else {
            if ((temp[$0] = $7) == 0) goto label_$3;
            }
            if ( _PyEval_PRINT_ITEM_1 ( temp[$0] ) == -1) goto label_$3;
            CLEARTEMP($0);
            if ( _PyEval_PRINT_NEWLINE_TO_1 ( NULL ) == -1) goto label_$3;
            if (PyInt_CheckExact( $1 )) {
            temp[$0] = $6;
            } else {
            if ((temp[$0] = $7) == 0) goto label_$3;
            }
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $1 )) {
                        temp[$0] = $6;
                        } else {
                        if ((temp[$0] = $7) == 0) goto label_$3;
                        }
                        if ( _PyEval_PRINT_ITEM_1 ( temp[$0] ) == -1) goto label_$3;
                        if ( _PyEval_PRINT_NEWLINE_TO_1 ( NULL ) == -1) goto label_$3;
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$2 = PyInt_AS_LONG ( GETLOCAL($1) )) < (INT_MAX >> $3) && long_$2 >= 0) {
            temp[$0] = PyInt_FromLong ( long_$2 << $3 );
            } else {
            if ((temp[$0] = PyNumber_$5Lshift(GETLOCAL($1), $4)) == 0) goto label_$6;
            }
            SETLOCAL ( $1 , temp[$0] );
            temp[$0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$2 = PyInt_AS_LONG ( GETLOCAL($1) )) < (INT_MAX >> $3) && long_$2 >= 0) {
                        Py_DECREF(GETLOCAL($1));
                        GETLOCAL($1) = PyInt_FromLong ( long_$2 << $3 );
                        } else {
                        if ((temp[$0] = PyNumber_$5Lshift(GETLOCAL($1), $4)) == 0) goto label_$6;
                        SETLOCAL ( $1 , temp[$0] );
                        temp[$0] = 0;
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            long_$3 = PyInt_AS_LONG ( temp[$0] );
            long_$4 = long_$3 + $7;
            if (( long_$4 ^ long_$3 ) < 0 && ( long_$4 ^ $7 ) < 0) goto label_$5 ;
            temp[$1] = PyInt_FromLong ( long_$4 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) + ((double)$7));
            } else { label_$5 :;
            if ((temp[$1] = PyNumber_Add ( temp[$0] , $9 )) == 0) goto label_$11;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            long_$3 = PyInt_AS_LONG ( temp[$1] );
            long_$4 = $8 + long_$3;
            if (( long_$4 ^ $8 ) < 0 && ( long_$4 ^ long_$3 ) < 0) goto label_$6 ;
            temp[$2] = PyInt_FromLong ( long_$4 );
            } else if (PyFloat_CheckExact( temp[$1] )) {
            temp[$2] = PyFloat_FromDouble(((double)$8) + PyFloat_AS_DOUBLE(temp[$1]));
            } else { label_$6 :;
            if ((temp[$2] = PyNumber_Add ( $10 , temp[$1] )) == 0) goto label_$11;
            }
            CLEARTEMP($1);
            """, v2) and v2[7].isdigit() and v2[8].isdigit(): 
                    v2[12] = '(' + v2[7] + ' + ' + v2[8] + ')'
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        long_$3 = PyInt_AS_LONG ( temp[$0] );
                        long_$4 = long_$3 + $12;
                        if (( long_$4 ^ long_$3 ) < 0 && ( long_$4 ^ $12 ) < 0) goto label_$5 ;
                        CLEARTEMP($0);
                        temp[$2] = PyInt_FromLong ( long_$4 );
                        } else { label_$5 :;
                        if ((temp[$1] = PyNumber_Add ( temp[$0] , $9 )) == 0) goto label_$11;
                        CLEARTEMP($0);
                        if ((temp[$2] = PyNumber_Add ( $10 , temp[$1] )) == 0) goto label_$11;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if ($9) {
            temp[$0] = PyInt_FromLong ( $10 );
            } else {
            if ((temp[$0] = PyNumber_$11) == 0) goto label_$12;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$5 = PyInt_AS_LONG ( temp[$0] );
            long_$6 = long_$5 $15 $14;
            if ($16) goto label_$13 ;
            temp[$1] = PyInt_FromLong ( long_$6 );
            } else if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $15 ((double)$14));
            } else { label_$13 :;
            if ((temp[$1] = PyNumber_$17 ( temp[$0] , $18 )) == 0) goto label_$12;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if ($9) {
                        long_$5 = $10;
                        long_$6 = long_$5 $15 $14;
                        if ($16) goto label_$13 ;
                        temp[$1] = PyInt_FromLong ( long_$6 );
                        } else { label_$13 :;
                        if ((temp[$0] = PyNumber_$11) == 0) goto label_$12;
                        if ((temp[$1] = PyNumber_$17 ( temp[$0] , $18 )) == 0) goto label_$12;
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 ) && (long_$3 = PyInt_AS_LONG ( $1 )) $6 ) {
            temp[$0] = PyInt_FromLong ( long_$3 $7 );
            } else {
            if ((temp[$0] = PyNumber_$8 ( $1 , $9 )) == 0) goto label_$5;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$4 = PyInt_AS_LONG ( temp[$0] );
            if ( long_$4 < 0) {
            long_$4 += PyString_GET_SIZE($10);
            }
            if (long_$4 < 0 || long_$4 >= PyString_GET_SIZE($10)) goto label_$18;
            temp[$2] = PyString_FromStringAndSize((PyString_AS_STRING ( $10 ) + long_$4), 1);
            } else {
            if ((temp[$2] = PyObject_GetItem ( $10 , temp[$0] )) == 0) goto label_$5;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $1 ) && (long_$3 = PyInt_AS_LONG ( $1 )) $6 ) {
                        long_$3 = long_$3 $7;
                        if ( long_$3 < 0) {
                        long_$3 += PyString_GET_SIZE($10);
                        }
                        if (long_$3 < 0 || long_$3 >= PyString_GET_SIZE($10)) goto label_$18;
                        temp[$2] = PyString_FromStringAndSize((PyString_AS_STRING ( $10 ) + long_$3), 1);
                        } else {
                        if ((temp[$0] = PyNumber_$8 ( $1 , $9 )) == 0) goto label_$5;
                        if ((temp[$2] = PyObject_GetItem ( $10 , temp[$0] )) == 0) goto label_$5;
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 )) {
            long_$2 = PyInt_AS_LONG ( $0 );
            if ( long_$2 < 0) {
            long_$2 += PyString_GET_SIZE($1);
            }
            if (long_$2 < 0 || long_$2 >= PyString_GET_SIZE($1)) goto label_$3;
            temp[$4] = PyString_FromStringAndSize((PyString_AS_STRING ( $1 ) + long_$2), 1);
            } else {
            if ((temp[$4] = PyObject_GetItem ( $1 , $0 )) == 0) goto label_$5;
            }
            if (PyString_GET_SIZE( temp[$4] ) == 1) {
            long_$12 = (long)((unsigned char)*PyString_AS_STRING ( temp[$4] ));
            temp[$6] = PyInt_FromLong ( long_$12 );
            } else {
            if ((temp[$7] = PyTuple_New ( 1 )) == 0) goto label_$5;
            PyTuple_SET_ITEM ( temp[$7] , 0 , temp[$4] );
            temp[$4] = 0;
            if ((temp[$6] = PyCFunction_Call ( loaded_builtin[$8] , temp[$7] , NULL )) == 0) goto label_$5;
            CLEARTEMP($7);
            }
            CLEARTEMP($4);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 )) {
                        long_$2 = PyInt_AS_LONG ( $0 );
                        if ( long_$2 < 0) {
                        long_$2 += PyString_GET_SIZE($1);
                        }
                        if (long_$2 < 0 || long_$2 >= PyString_GET_SIZE($1)) goto label_$3;
                        temp[$6] = PyInt_FromLong ( (long)((unsigned char) PyString_AS_STRING ( $1 )[long_$2] ) );
                        } else {
                        if ((temp[$4] = PyObject_GetItem ( $1 , $0 )) == 0) goto label_$5;
                        if ((temp[$7] = PyTuple_New ( 1 )) == 0) goto label_$5;
                        PyTuple_SET_ITEM ( temp[$7] , 0 , temp[$4] );
                        temp[$4] = 0;
                        if ((temp[$6] = PyCFunction_Call ( loaded_builtin[$8] , temp[$7] , NULL )) == 0) goto label_$5;
                        CLEARTEMP($7);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $2 ) {
            long_$1 = long_$1 $3;
            if ( long_$1 < 0) {
            long_$1 += PyString_GET_SIZE($4);
            }
            if (long_$1 < 0 || long_$1 >= PyString_GET_SIZE($4)) goto label_$5;
            temp[$9] = PyString_FromStringAndSize((PyString_AS_STRING ( $4 ) + long_$1), 1);
            } else {
            if ((temp[$8] = PyNumber_Add ( $0 , $7 )) == 0) goto label_$6;
            if ((temp[$9] = PyObject_GetItem ( $4 , temp[$8] )) == 0) goto label_$6;
            CLEARTEMP($8);
            }
            if (PyString_GET_SIZE( temp[$9] ) == 1) {
            long_$12 = (long)((unsigned char)*PyString_AS_STRING ( temp[$9] ));
            temp[$8] = PyInt_FromLong ( long_$12 );
            } else {
            if ((temp[$19] = PyTuple_New ( 1 )) == 0) goto label_$6;
            PyTuple_SET_ITEM ( temp[$10] , 0 , temp[$9] );
            temp[$9] = 0;
            if ((temp[$8] = PyCFunction_Call ( loaded_builtin[$11] , temp[$10] , NULL )) == 0) goto label_$6;
            CLEARTEMP($10);
            }
            CLEARTEMP($9);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $2 ) {
                        long_$1 = long_$1 $3;
                        if ( long_$1 < 0) {
                        long_$1 += PyString_GET_SIZE($4);
                        }
                        if (long_$1 < 0 || long_$1 >= PyString_GET_SIZE($4)) goto label_$5;
                        temp[$8] = PyInt_FromLong ( (long)((unsigned char)PyString_AS_STRING ( $4 )[long_$1] ) );
                        } else {
                        if ((temp[$8] = PyNumber_Add ( $0 , $7 )) == 0) goto label_$6;
                        if ((temp[$9] = PyObject_GetItem ( $4 , temp[$8] )) == 0) goto label_$6;
                        CLEARTEMP($8);
                        if ((temp[$10] = PyTuple_New ( 1 )) == 0) goto label_$6;
                        PyTuple_SET_ITEM ( temp[$10] , 0 , temp[$9] );
                        temp[$9] = 0;
                        if ((temp[$8] = PyCFunction_Call ( loaded_builtin[$11] , temp[$10] , NULL )) == 0) goto label_$6;
                        CLEARTEMP($10);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $4 ) {
            temp[$2] = PyInt_FromLong ( long_$1 $5 );
            } else {
            if ((temp[$2] = PyNumber_Subtract ( $0 , $7 )) == 0) goto label_$6;
            }
            if ((Py_ssize_t_$8 = PyObject_Size ( $15 )) == -1) goto label_$6;
            if (PyInt_CheckExact( temp[$2] )) {
            int_$9 = PyInt_AS_LONG ( temp[$2] ) $11 Py_ssize_t_$8;
            } else {
            temp[$10] = PyInt_FromLong ( Py_ssize_t_$8 );
            if ((int_$9 = PyObject_RichCompareBool ( temp[$2] , temp[$10] , $12 )) == -1) goto label_$6;
            CLEARTEMP($10);
            }
            CLEARTEMP($2);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $4 ) {
                        if ((Py_ssize_t_$8 = PyObject_Size ( $15 )) == -1) goto label_$6;
                        int_$9 = ( long_$1 $5 ) $11 Py_ssize_t_$8;
                        } else {
                        if ((temp[$2] = PyNumber_Subtract ( $0 , $7 )) == 0) goto label_$6;
                        if ((Py_ssize_t_$8 = PyObject_Size ( $15 )) == -1) goto label_$6;
                        temp[$10] = PyInt_FromLong ( Py_ssize_t_$8 );
                        if ((int_$9 = PyObject_RichCompareBool ( temp[$2] , temp[$10] , $12 )) == -1) goto label_$6;
                        CLEARTEMP($10);
                        CLEARTEMP($2);
                        }
                        """, v2) 
                    return True 
                
        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ( $2 );
            } else {
            if ((temp[$1] = PyNumber_$3) == 0) goto label_$10;
            }
            CLEARTEMP($0);
            if ((int_$4 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$10;
            CLEARTEMP($1);            
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        int_$4 = ( $2 ) != 0;
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$3) == 0) goto label_$10;
                        CLEARTEMP($0);
                        if ((int_$4 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$10;
                        CLEARTEMP($1);            
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $19 )) {
            long_$18 = PyInt_AS_LONG ( $19 );
            if ( long_$18 < 0) {
            long_$18 += PyString_GET_SIZE($17);
            }
            if (long_$18 < 0 || long_$18 >= PyString_GET_SIZE($17)) goto label_$16;
            temp[$15] = PyString_FromStringAndSize((PyString_AS_STRING ( $17 ) + long_$18), 1);
            } else {
            if ((temp[$15] = PyObject_GetItem ( $17 , $19 )) == 0) goto label_$14;
            }
            if (PyString_GET_SIZE( temp[$15] ) == 1) {
            long_$18 = (long)((unsigned char)*PyString_AS_STRING ( temp[$15] ));
            temp[$13] = PyInt_FromLong ( long_$18 );
            } else {
            if ((temp[$12] = PyTuple_New ( 1 )) == 0) goto label_$14;
            PyTuple_SET_ITEM ( temp[$12] , 0 , temp[$15] );
            temp[$15] = 0;
            if ((temp[$13] = PyCFunction_Call ( $11 , temp[$12] , NULL )) == 0) goto label_$14;
            CLEARTEMP($12);
            }
            Py_CLEAR(temp[$15]); 
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $19 )) {
                        long_$18 = PyInt_AS_LONG ( $19 );
                        if ( long_$18 < 0) {
                        long_$18 += PyString_GET_SIZE($17);
                        }
                        if (long_$18 < 0 || long_$18 >= PyString_GET_SIZE($17)) goto label_$16;
                        temp[$13] = PyInt_FromLong ( (long)(unsigned char)(PyString_AS_STRING ( $17 )[long_$18]) );
                        } else {
                        if ((temp[$15] = PyObject_GetItem ( $17 , $19 )) == 0) goto label_$14;
                        if ((temp[$12] = PyTuple_New ( 1 )) == 0) goto label_$14;
                        PyTuple_SET_ITEM ( temp[$12] , 0 , temp[$15] );
                        temp[$15] = 0;
                        if ((temp[$13] = PyCFunction_Call ( $11 , temp[$12] , NULL )) == 0) goto label_$14;
                        CLEARTEMP($12);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) $3 ) {
            temp[$8] = PyInt_FromLong ( long_$2 $4 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$8] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) $5);
            } else {
            if ((temp[$8] = PyNumber_$7 ( $1 , consts[$6] )) == 0) goto label_$10;
            }
            if (PyInt_CheckExact( temp[$8] )) {
            temp[$9] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$8] ) $11 );
            } else {
            if ((temp[$9] = PyNumber_$12 ( temp[$8] , consts[$14] )) == 0) goto label_$10;
            }
            CLEARTEMP($8);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) $3 ) {
                        temp[$9] = PyInt_FromLong ( ( long_$2 $4 ) $11 );
                        } else {
                        if ((temp[$8] = PyNumber_$7 ( $1 , consts[$6] )) == 0) goto label_$10;
                        if ((temp[$9] = PyNumber_$12 ( temp[$8] , consts[$14] )) == 0) goto label_$10;
                        CLEARTEMP($8);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $5 ) && (long_$6 = PyInt_AS_LONG ( $5 )) $7 ) {
            temp[$1] = PyInt_FromLong ( $8 );
            } else {
            if ((temp[$0] = PyNumber_$9 ( $11 )) == 0) goto label_$4;
            if ((temp[$1] = PyNumber_$10 ( $12 )) == 0) goto label_$4;
            CLEARTEMP($0);
            }
            if (PyInt_CheckExact( temp[$1] )) {
            long_$13 = PyInt_AS_LONG ( temp[$1] );
            long_$14 = long_$13 $15;
            if ($16) goto label_$3 ;
            temp[$2] = PyInt_FromLong ( long_$14 );
            } else if (PyFloat_CheckExact( temp[$1] )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) $17);
            } else { label_$3 :;
            if ((temp[$2] = PyNumber_$18 ( $19 )) == 0) goto label_$4;
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $5 ) && (long_$6 = PyInt_AS_LONG ( $5 )) $7 ) {
                        long_$13 = $8;
                        long_$14 = long_$13 $15;
                        if ($16) goto label_$3 ;
                        temp[$2] = PyInt_FromLong ( long_$14 );
                        } else { label_$3 :;
                        if ((temp[$0] = PyNumber_$9 ( $11 )) == 0) goto label_$4;
                        if ((temp[$1] = PyNumber_$10 ( $12 )) == 0) goto label_$4;
                        CLEARTEMP($0);
                        if ((temp[$2] = PyNumber_$18 ( $19 )) == 0) goto label_$4;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True 

    if '_CheckExact' in o[i]:
        if TxMatch(o, i, """
            if (Py$1_CheckExact( $2 ) && Py$1_CheckExact( $2 )) {
            """, v2): 
                    TxRepl(o, i, """
                        if (Py$1_CheckExact( $2 )) {
                        """, v2) 
                    return True 
        if TxMatch(o, i, """
            if (Py$1_CheckExact( temp[$2] ) && Py$1_CheckExact( temp[$2] )) {
            """, v2): 
                    TxRepl(o, i, """
                        if (Py$1_CheckExact( temp[$2] )) {
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$3] )) {
            long_$7;
            long_$8;
            long_$9;
            if ($19) goto label_$6 ;
            temp[$0] = PyInt_FromLong ( long_$18 );
            } else if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$3] )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) $17 PyFloat_AS_DOUBLE(temp[$3]));
            } else { label_$6 :;
            if ((temp[$0] = PyNumber_$16 ( temp[$1] , temp[$3] )) == 0) goto label_$5;
            }
            CLEARTEMP($1);
            CLEARTEMP($3);
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble($10);
            } else {
            if ((temp[$1] = PyNumber_$11) == 0) goto label_$5;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$3] )) {
                        temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) $17 PyFloat_AS_DOUBLE(temp[$3]));
                        } else {
                        if ((temp[$0] = PyNumber_$16 ( temp[$1] , temp[$3] )) == 0) goto label_$5;
                        }
                        CLEARTEMP($1);
                        CLEARTEMP($3);
                        if (PyFloat_CheckExact( temp[$0] )) {
                        temp[$1] = PyFloat_FromDouble($10);
                        } else {
                        if ((temp[$1] = PyNumber_$11) == 0) goto label_$5;
                        }
                        CLEARTEMP($0);
                        """, v2) 
                    return True 

    if 'PyFloat_CheckExact' in o[i]:
        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
            } else if (PyInt_CheckExact( temp[$0] )) {
            long_$3 = PyInt_AS_LONG ( temp[$0] );
            if (!long_$3 || (long_$3 * long_$3) / long_$3 == long_$3) {
            temp[$1] = PyInt_FromLong ( long_$3 * long_$3 );
            } else {
            temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], temp[$0]);
            }
            } else {
            if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto label_$2;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($5);
            } else {
            if ((temp[$0] = PyNumber_$6) == 0) goto label_$2;
            }
            CLEARTEMP($1);        
            """, v2): 
                    TxRepl(o, i, """
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
            } else {
            if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto label_$2;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($5);
            } else {
            if ((temp[$0] = PyNumber_$6) == 0) goto label_$2;
            }
            CLEARTEMP($1);   
                        """, v2) 
                    return True         
        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
            } else if (PyInt_CheckExact( temp[$0] )) {
            long_$3 = PyInt_AS_LONG ( temp[$0] );
            if (!long_$3 || (long_$3 * long_$3) / long_$3 == long_$3) {
            temp[$1] = PyInt_FromLong ( long_$3 * long_$3 );
            } else {
            temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], temp[$0]);
            }
            } else {
            if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto label_$2;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($5 * PyFloat_AS_DOUBLE(temp[$1]));
            } else {
            if ((temp[$0] = PyNumber_Multiply ( $6 , temp[$1] )) == 0) goto label_$2;
            }
            CLEARTEMP($1);        
            """, v2): 
                    TxRepl(o, i, """
                    if (PyFloat_CheckExact( temp[$0] )) {
                    temp[$1] = temp[$0];
                    temp[$0] = PyFloat_FromDouble($5 * (PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0])));
                    CLEARTEMP($1);
                    } else {
                    if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto label_$2;
                    CLEARTEMP($0);
                    if ((temp[$0] = PyNumber_Multiply ( $6 , temp[$1] )) == 0) goto label_$2;
                    CLEARTEMP($1);    
                    }
                        """, v2) 
                    return True 
        
        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($5 $16 PyFloat_AS_DOUBLE(temp[$1]));
            } else {
            if ((temp[$0] = PyNumber_$17 ( $6 , temp[$1] )) == 0) goto label_$3;
            }
            CLEARTEMP($1);
            if (PyInt_CheckExact( $2 ) && PyInt_CheckExact( temp[$0] )) {
            long_$7 = $10;
            long_$8 = $11;
            long_$9 = $12;
            if ($13) goto label_$4 ;
            temp[$1] = PyInt_FromLong ( long_$9 );
            } else if (PyFloat_CheckExact( $2 ) && PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) $14 PyFloat_AS_DOUBLE(temp[$0]));
            } else { label_$4 :;
            if ((temp[$1] = PyNumber_$15 ( $2 , temp[$0] )) == 0) goto label_$3;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyFloat_CheckExact( temp[$1] )) {
                        temp[$0] = PyFloat_FromDouble($5 $16 PyFloat_AS_DOUBLE(temp[$1]));
                        } else {
                        if ((temp[$0] = PyNumber_$17 ( $6 , temp[$1] )) == 0) goto label_$3;
                        }
                        CLEARTEMP($1);
                        if (PyFloat_CheckExact( $2 ) && PyFloat_CheckExact( temp[$0] )) {
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) $14 PyFloat_AS_DOUBLE(temp[$0]));
                        } else {
                        if ((temp[$1] = PyNumber_$15 ( $2 , temp[$0] )) == 0) goto label_$3;
                        }
                        CLEARTEMP($0);
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$3] )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) $4 PyFloat_AS_DOUBLE(temp[$3]));
            } else {
            if ((temp[$0] = PyNumber_$5 ( temp[$1] , temp[$3] )) == 0) goto label_0;
            }
            CLEARTEMP($1);
            CLEARTEMP($3);
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $6 PyFloat_AS_DOUBLE(temp[$0]));
            } else {
            if ((temp[$1] = PyNumber_$7 ( temp[$0] , temp[$0] )) == 0) goto label_0;
            }
            """, v2): 
                    TxRepl(o, i, """
                        if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$3] )) {
                        temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) $4 PyFloat_AS_DOUBLE(temp[$3]));
                        CLEARTEMP($1);
                        CLEARTEMP($3);
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $6 PyFloat_AS_DOUBLE(temp[$0]));
                        } else {
                        if ((temp[$0] = PyNumber_$5 ( temp[$1] , temp[$3] )) == 0) goto label_0;
                        CLEARTEMP($1);
                        CLEARTEMP($3);
                        if ((temp[$1] = PyNumber_$7 ( temp[$0] , temp[$0] )) == 0) goto label_0;
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """
            if ($10) {
            temp[$0] = PyFloat_FromDouble($11);
            CLEARTEMP($1);
            CLEARTEMP($3);
            temp[$1] = PyFloat_FromDouble($12);
            } else {
            if ((temp[$0] = PyNumber_$13) == 0) goto label_$17;
            CLEARTEMP($1);
            CLEARTEMP($3);
            if ((temp[$1] = PyNumber_$14) == 0) goto label_$17;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($15);
            } else {
            if ((temp[$0] = PyNumber_$16) == 0) goto label_$17;
            }
            """, v2): 
                    TxRepl(o, i, """
                    if ($10) {
                    temp[$0] = PyFloat_FromDouble($11);
                    CLEARTEMP($1);
                    CLEARTEMP($3);
                    temp[$1] = PyFloat_FromDouble($12);
                    CLEARTEMP($0);
                    temp[$0] = PyFloat_FromDouble($15);
                    } else {
                    if ((temp[$0] = PyNumber_$13) == 0) goto label_$17;
                    CLEARTEMP($1);
                    CLEARTEMP($3);
                    if ((temp[$1] = PyNumber_$14) == 0) goto label_$17;
                    CLEARTEMP($0);
                    if ((temp[$0] = PyNumber_$16) == 0) goto label_$17;
                    }
                        """, v2) 
                    return True 
        if TxMatch(o, i, """
            if ($10) {
            temp[$0] = PyFloat_FromDouble($11);
            CLEARTEMP($1);
            temp[$1] = PyFloat_FromDouble($12);
            } else {
            if ((temp[$0] = PyNumber_$13) == 0) goto label_$17;
            CLEARTEMP($1);
            if ((temp[$1] = PyNumber_$14) == 0) goto label_$17;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($15);
            } else {
            if ((temp[$0] = PyNumber_$16) == 0) goto label_$17;
            }
            """, v2): 
                    TxRepl(o, i, """
                    if ($10) {
                    temp[$0] = PyFloat_FromDouble($11);
                    CLEARTEMP($1);
                    temp[$1] = PyFloat_FromDouble($12);
                    CLEARTEMP($0);
                    temp[$0] = PyFloat_FromDouble($15);
                    } else {
                    if ((temp[$0] = PyNumber_$13) == 0) goto label_$17;
                    CLEARTEMP($1);
                    if ((temp[$1] = PyNumber_$14) == 0) goto label_$17;
                    CLEARTEMP($0);
                    if ((temp[$0] = PyNumber_$16) == 0) goto label_$17;
                    }
                        """, v2) 
                    return True 
        if TxMatch(o, i, """
            if ($10) {
            temp[$0] = PyFloat_FromDouble($11);
            temp[$1] = PyFloat_FromDouble($12);
            } else {
            if ((temp[$0] = PyNumber_$13) == 0) goto label_$17;
            if ((temp[$1] = PyNumber_$14) == 0) goto label_$17;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$0] = PyFloat_FromDouble($15);
            } else {
            if ((temp[$0] = PyNumber_$16) == 0) goto label_$17;
            }
            """, v2): 
                    TxRepl(o, i, """
                    if ($10) {
                    temp[$0] = PyFloat_FromDouble($11);
                    temp[$1] = PyFloat_FromDouble($12);
                    CLEARTEMP($0);
                    temp[$0] = PyFloat_FromDouble($15);
                    } else {
                    if ((temp[$0] = PyNumber_$13) == 0) goto label_$17;
                    if ((temp[$1] = PyNumber_$14) == 0) goto label_$17;
                    CLEARTEMP($0);
                    if ((temp[$0] = PyNumber_$16) == 0) goto label_$17;
                    }
                        """, v2) 
                    return True 
        
    if 'if (PyInstance_Check(' in o[i]:    
        if TxMatch(o, i, ('if (PyInstance_Check($1) && ((PyInstanceObject *)$1)->in_class == (PyClassObject*)$2) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else',
            'if (PyInstance_Check($1) && ((PyInstanceObject *)$1)->in_class == (PyClassObject*)$3) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else'), v2):
                TxRepl(o, i, ('if (PyInstance_Check($1) && (((PyInstanceObject *)$1)->in_class == (PyClassObject*)$2 || (((PyInstanceObject *)$1)->in_class == (PyClassObject*)$3))) {',
                    'if ((temp[$7] = $5) == 0) goto $0;',
                    '} else'), v2)
                return True
            
        if TxMatch(o, i, ('if (PyInstance_Check($1) && (((PyInstanceObject *)$1)->in_class == (PyClassObject*)$2 || ($9))) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else',
            'if (PyInstance_Check($1) && ((PyInstanceObject *)$1)->in_class == (PyClassObject*)$3) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else'), v2):
                TxRepl(o, i, ('if (PyInstance_Check($1) && (((PyInstanceObject *)$1)->in_class == (PyClassObject*)$2 || ($9 || (((PyInstanceObject *)$1)->in_class == (PyClassObject*)$3)))) {',
                    'if ((temp[$7] = $5) == 0) goto $0;',
                    '} else'), v2)
                return True
        
        if TxMatch(o, i, """
            if (PyInstance_Check($3) && $4) {
            if ((temp[$10] = _Direct_$17 ( $3 $5)) == 0) goto label_$0;
            } else {
            if ((temp[$11] = PyObject_GetAttr ( $3 , $6 )) == 0) goto label_$0;
            if ((temp[$10] = FastCall($7)) == 0) goto label_$0;
            CLEARTEMP($11);
            }
            CLEARTEMP($10);        
            """, v2):
                TxRepl(o, i, """
                    if (PyInstance_Check($3) && $4) {
                    if ((temp[$10] = _Direct_$17 ( $3 $5)) == 0) goto label_$0;
                    CLEARTEMP($10);        
                    } else {
                    if ((temp[$11] = PyObject_GetAttr ( $3 , $6 )) == 0) goto label_$0;
                    if ((temp[$10] = FastCall($7)) == 0) goto label_$0;
                    CLEARTEMP($10);        
                    CLEARTEMP($11);
                    }
                    """, v2)
                return True
            
    if 'Py_TYPE' in o[i]:                                
        if TxMatch(o, i, ('if (((PyObject *)Py_TYPE($1)) == $2) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else',
            'if (((PyObject *)Py_TYPE($1)) == $3) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else'), v2):
                TxRepl(o, i, ('if (((PyObject *)Py_TYPE($1)) == $2 || (((PyObject *)Py_TYPE($1)) == $3)) {',
                    'if ((temp[$7] = $5) == 0) goto $0;',
                    '} else'), v2)
                return True    
            
        if TxMatch(o, i, ('if (((PyObject *)Py_TYPE($1)) == $2 || ($6)) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else',
            'if (((PyObject *)Py_TYPE($1)) == $3) {',
            'if ((temp[$7] = $5) == 0) goto $0;',
            '} else'), v2):
                TxRepl(o, i, ('if (((PyObject *)Py_TYPE($1)) == $2 || (($6) || ((PyObject *)Py_TYPE($1)) == $3)) {',
                    'if ((temp[$7] = $5) == 0) goto $0;',
                    '} else'), v2)
                return True    
        if TxMatch(o, i, ('if (((PyObject *)Py_TYPE($4)) == calculated_const[$5]) {',
            'if ((int_$8 = _Direct_$9($4)) == -1) goto $3;',
            'temp[$1] = PyBool_FromLong(int_$8);',
            '} else',
            '{',
            'if ((temp[$2] = PyObject_GetAttr ( $4 , $6 )) == 0) goto $3;',
            'if ((temp[$1] = FastCall0(temp[$2])) == 0) goto $3;',
            'CLEARTEMP($2);',
            '}',
            'if ((int_$7 = PyObject_IsTrue ( temp[$1] )) == -1) goto $3;',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if (((PyObject *)Py_TYPE($4)) == calculated_const[$5]) {',
                    'if ((int_$7 = _Direct_$9($4)) == -1) goto $3;',
                    '} else',
                    '{',
                    'if ((temp[$2] = PyObject_GetAttr ( $4 , $6 )) == 0) goto $3;',
                    'if ((temp[$1] = FastCall0(temp[$2])) == 0) goto $3;',
                    'CLEARTEMP($2);',
                    'if ((int_$7 = PyObject_IsTrue ( temp[$1] )) == -1) goto $3;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True
    
    
    if o[i].startswith('if (_'):                
        if TxMatch(o, i, ('if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $4)) != 0) {',
            'Py_INCREF(temp[$3]);',
            '} else {',
            'if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $4 )) == 0) goto $2;',
            '}',
            'if ( PyList_SetItem ( temp[$3] , $5 , $6 ) == -1) goto $2;',
            'CLEARTEMP($3);'), v2):
                TxRepl(o, i, ('if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $4)) != 0) {',
                    'if ( PyList_SetItem ( temp[$3] , $5 , $6 ) == -1) goto $2;',
                    'temp[$3] = 0;',
                    '} else {',
                    'if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $4 )) == 0) goto $2;',
                    'if ( PyList_SetItem ( temp[$3] , $5 , $6 ) == -1) goto $2;',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True    
                                        
        if TxMatch(o, i, ('if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {',
            'Py_INCREF(temp[$3]);',
            '} else {',
            'if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;',
            '}',
            '$4 = PyInt_AsSsize_t ( temp[$3] );',
            'CLEARTEMP($3);'), v2):
                TxRepl(o, i, ('if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {',
                    '$4 = PyInt_AsSsize_t ( temp[$3] );',
                    'temp[$3] = 0;',
                    '} else {',
                    'if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;',
                    '$4 = PyInt_AsSsize_t ( temp[$3] );',
                    'CLEARTEMP($3);',
                    '}'), v2)
                return True    
            
        if TxMatch(o, i, ('if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {',
            'Py_INCREF(temp[$3]);',
            '} else {',
            'if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;',
            '}',
            'if ((temp[$6] = PyList_GetItem ( temp[$3] , $7 )) == 0) goto $5;',
            'Py_INCREF(temp[$6]);',
            'CLEARTEMP($3);'), v2):
                TxRepl(o, i, ('if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {',
                    'if ((temp[$6] = PyList_GetItem ( temp[$3] , $7 )) == 0) goto $5;',
                    'temp[$3] = 0;',
                    '} else {',
                    'if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;',
                    'if ((temp[$6] = PyList_GetItem ( temp[$3] , $7 )) == 0) goto $5;',
                    'CLEARTEMP($3);',
                    '}',
                    'Py_INCREF(temp[$6]);'), v2)
                return True       

        if TxMatch(o, i, ('if (_$3_dict && (temp[$0] = PyDict_GetItem(_$3_dict, $4)) != 0) {',
            'Py_INCREF(temp[$0]);',
            '} else {',
            'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($3) , $4 )) == 0) goto $5;',
            '}',
            'if (PyInt_CheckExact( temp[$0] ) && ($7 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {',
            'CLEARTEMP($0);',
            '$6 = $8 $9 ($7 - 1);',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $15 )) == 0) goto $5;',
            'CLEARTEMP($0);',
            'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $5;',
            'if (($6 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , Py_$10 )) == -1) goto $5;',
            'CLEARTEMP($1);',
            'CLEARTEMP($2);',
            '}'), v2):
                TxRepl(o, i, ('if (_$3_dict && (temp[$0] = PyDict_GetItem(_$3_dict, $4)) != 0) {',
                    'if (PyInt_CheckExact( temp[$0] ) && ($7 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {',
                    '$6 = $8 $9 ($7 - 1);',
                    '} else {',
                    'Py_INCREF(temp[$0]);',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $15 )) == 0) goto $5;',
                    'CLEARTEMP($0);',
                    'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $5;',
                    'if (($6 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , Py_$10 )) == -1) goto $5;',
                    'CLEARTEMP($1);',
                    'CLEARTEMP($2);',
                    '}',                    
                    '} else {',
                    'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($3) , $4 )) == 0) goto $5;',
                    'if (PyInt_CheckExact( temp[$0] ) && ($7 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {',
                    'CLEARTEMP($0);',
                    '$6 = $8 $9 ($7 - 1);',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $15 )) == 0) goto $5;',
                    'CLEARTEMP($0);',
                    'if ((temp[$2] = PyInt_FromSsize_t($8)) == 0) goto $5;',
                    'if (($6 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , Py_$10 )) == -1) goto $5;',
                    'CLEARTEMP($1);',
                    'CLEARTEMP($2);',
                    '}',
                    '}'), v2)
                return True
            
        if TxMatch(o, i, ('if (_$2_dict && (temp[$0] = PyDict_GetItem(_$2_dict, $3)) != 0) {',
            'Py_INCREF(temp[$0]);',
            '} else {',
            'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($2) , $3 )) == 0) goto $4;',
            '}',
            'if (PyInt_CheckExact( temp[$0] ) && ($5 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {',
            'CLEARTEMP($0);',
            '$6 = $5 - 1;',
            '} else {',
            'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $4;',
            'CLEARTEMP($0);',
            '$6 = PyInt_AsSsize_t ( temp[$1] );',
            'CLEARTEMP($1);',
            '}'), v2):
                TxRepl(o, i, ('if (_$2_dict && (temp[$0] = PyDict_GetItem(_$2_dict, $3)) != 0) {',
                    'if (PyInt_CheckExact( temp[$0] ) && ($5 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {',
                    '$6 = $5 - 1;',
                    '} else {',
                    'Py_INCREF(temp[$0]);',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $4;',
                    'CLEARTEMP($0);',
                    '$6 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);',
                    '}',
                    '} else {',
                    'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($2) , $3 )) == 0) goto $4;',
                    'if (PyInt_CheckExact( temp[$0] ) && ($5 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {',
                    'CLEARTEMP($0);',
                    '$6 = $5 - 1;',
                    '} else {',
                    'if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $4;',
                    'CLEARTEMP($0);',
                    '$6 = PyInt_AsSsize_t ( temp[$1] );',
                    'CLEARTEMP($1);',
                    '}',
                    '}'), v2)
                return True 

        if TxMatch(o, i, ('if (_$3_dict && (temp[$0] = PyDict_GetItem(_$3_dict, $5)) != 0) {',
            'if ((temp[$1] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $6;',
            'temp[$0] = 0;',
            '} else {',
            'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($3) , $5 )) == 0) goto $6;',
            'if ((temp[$1] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $6;',
            'CLEARTEMP($0);',
            '}',
            'Py_INCREF(temp[$1]);',
            'if (_$3_dict && (temp[$0] = PyDict_GetItem(_$3_dict, $5)) != 0) {',
            'if ((temp[$2] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $6;',
            'temp[$0] = 0;',
            '} else {',
            'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($3) , $5 )) == 0) goto $6;',
            'if ((temp[$2] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $6;',
            'CLEARTEMP($0);',
            '}',
            'Py_INCREF(temp[$2]);'), v2):
                TxRepl(o, i, ('if (_$3_dict && (temp[$0] = PyDict_GetItem(_$3_dict, $5)) != 0) {',
                    'if ((temp[$1] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $6;',
                    'temp[$0] = 0;',
                    '} else {',
                    'if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($3) , $5 )) == 0) goto $6;',
                    'if ((temp[$1] = PyList_GetItem ( temp[$0] , $4 )) == 0) goto $6;',
                    'CLEARTEMP($0);',
                    '}',
                    'Py_INCREF(temp[$1]);',
                    'temp[$2] = temp[$1];',
                    'Py_INCREF(temp[$2]);'), v2)      
                return True 

        if TxMatch(o, i, """
            if (_$9_dict && (temp[$0] = PyDict_GetItem(_$9_dict, $8)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($9) , $8 )) == 0) goto label_$10;
            }
            if ((int_$11 = c_Py_$12_Int ($15)) == -1) goto label_$10;
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if (_$9_dict && (temp[$0] = PyDict_GetItem(_$9_dict, $8)) != 0) {
                    if ((int_$11 = c_Py_$12_Int ($15)) == -1) goto label_$10;
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($9) , $8 )) == 0) goto label_$10;
                    if ((int_$11 = c_Py_$12_Int ($15)) == -1) goto label_$10;
                    CLEARTEMP($0);
                    }
                    """, v2)      
                return True 


    if o[i].startswith('if ( int_') and o[i].endswith(') {'):
        if TxMatch(o, i, ('if ( int_$2 ) {',
            'temp[$0] = Py_True;',
            '} else {',
            'temp[$0] = Py_False;',
            '}',
            'Py_INCREF(temp[$0]);',
            'if ((int_$2 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, (), v2)
                return True     
            
        if TxMatch(o, i, ('if ( int_$2 ) {',
            'temp[$0] = Py_True;',
            '} else {',
            'temp[$0] = Py_False;',
            '}',
            'Py_INCREF(temp[$0]);',
            'int_$2 = PyObject_IsTrue ( temp[$0] );',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, (), v2)
                return True   
                                    
        if TxMatch(o, i, ('if ( int_$2 ) {',
            'temp[$0] = Py_True;',
            '} else {',
            'temp[$0] = Py_False;',
            '}',
            'Py_INCREF(temp[$0]);',
            'if ((int_$2 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;'), v2):
                TxRepl(o, i, ('if ( int_$2 ) {',
                    'temp[$0] = Py_True;',
                    '} else {',
                    'temp[$0] = Py_False;',
                    '}',
                    'Py_INCREF(temp[$0]);'), v2)
                return True                         
        if TxMatch(o, i, """
            if ( int_$3 ) {
            temp[$0] = Py_True;
            } else {
            temp[$0] = Py_False;
            }
            Py_INCREF(temp[$0]);
            if ( int_$3 ) {
            CLEARTEMP($0);
            if ((temp[$0] = PyDict_GetItem ( $4 )) == 0) goto label_$10;
            Py_INCREF(temp[$0]);
            }
            """, v2):
                TxRepl(o, i, """
                    if ( int_$3 ) {
                    if ((temp[$0] = PyDict_GetItem ( $4 )) == 0) goto label_$10;
                    Py_INCREF(temp[$0]);
                    } else {
                    Py_INCREF(Py_False);
                    temp[$0] = Py_False;
                    }
                    """, v2)
                return True                         

        if TxMatch(o, i, """
            if ( int_$2 ) {
            temp[$0] = Py_True;
            } else {
            temp[$0] = Py_False;
            }
            Py_INCREF(temp[$0]);
            if ( int_$2 ) {
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ( !(int_$2)) {
                    temp[$0] = Py_False;
                    Py_INCREF(temp[$0]);
                    } else {
                    """, v2)
                return True                         
        
    if i+1 < len(o) and o[i+1].startswith('if ((int_'):
        if TxMatch(o, i, ('if ($11) {',
            'if ((int_$3 = $14) == -1) goto $12;',
            'temp[$0] = PyBool_FromLong(int_$3);',
            '} else {',
            'if ((temp[$2] = $15) == 0) goto $12;',
            'if ((temp[$0] = $16) == 0) goto $12;',
            'CLEARTEMP($2);',
            '}',
            'CLEARTEMP($19);',
            'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;',
            'CLEARTEMP($0);'), v2) and v2[19] != v2[0] and v2[19] != v2[2]:
                TxRepl(o, i, ('if ($11) {',
                    'if ((int_$1 = $14) == -1) goto $12;',
                    '} else {',
                    'if ((temp[$2] = $15) == 0) goto $12;',
                    'if ((temp[$0] = $16) == 0) goto $12;',
                    'CLEARTEMP($2);',
                    'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;',
                    'CLEARTEMP($0);',
                    '}',
                    'CLEARTEMP($19);'), v2)
                return True 
            
        if TxMatch(o, i, ('if ($11) {',
            'if ((int_$3 = $14) == -1) goto $12;',
            'temp[$0] = PyBool_FromLong(int_$3);',
            '} else {',
            'if ((temp[$2] = $15) == 0) goto $12;',
            'if ((temp[$0] = $16) == 0) goto $12;',
            'CLEARTEMP($2);',
            '}',
            'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, i, ('if ($11) {',
                    'if ((int_$1 = $14) == -1) goto $12;',
                    '} else {',
                    'if ((temp[$2] = $15) == 0) goto $12;',
                    'if ((temp[$0] = $16) == 0) goto $12;',
                    'CLEARTEMP($2);',
                    'if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True 

    if 'PyString_GET_SIZE' in o[i]:
        if TxMatch(o, i, """
            if ($10) {
            long_$3 = (long)$16;
            } else if ($11) {
            long_$3 = (long)$17;
            } else if ($12) {
            long_$3 = (long)$18;
            } else {
            >0
            long_$3 = PyInt_AsLong ( temp[$1] );
            CLEARTEMP($1);
            }
            $15 = ( long_$3 );        
            """, v2):
                TxRepl(o, i, """
                    if ($10) {
                    $15 = (long)$16;
                    } else if ($11) {
                    $15 = (long)$17;
                    } else if ($12) {
                    $15 = (long)$18;
                    } else {
                    >0
                    $15 = PyInt_AsLong ( temp[$1] );
                    CLEARTEMP($1);
                    }
                    """, v2)
                return True 
        if TxMatch(o, i, ('if (PyString_GET_SIZE( temp[$2] ) == 1) {',
            '$1 = (long)((unsigned char)*PyString_AS_STRING(temp[$2]));',
            'temp[$0] = PyInt_FromLong ( $1 );',
            '} else {',
            'if ((temp[$4] = PyTuple_New ( 1 )) == 0) goto $3;',
            'PyTuple_SET_ITEM ( temp[$4] , 0 , temp[$2] );',
            'temp[$2] = 0;',
            'if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$5] , temp[$4] , NULL )) == 0) goto $3;',
            'CLEARTEMP($4);',
            '}',
            'CLEARTEMP($2);',
            '$6 = PyInt_AS_LONG ( temp[$0] );',
            '$9 = $6 * $10;',
            'if ($9 / $10 == $6) {',
            'temp[$7] = PyInt_FromLong ($9);',
            '} else {',
            'temp[$7] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], consts[$8]);',
            '}',
            'CLEARTEMP($0);'), v2) and abs(int(v2[10])) < 70000:
                TxRepl(o, i, ('if (PyString_GET_SIZE( temp[$2] ) == 1) {',
                    '$9 = ((long)((unsigned char)*PyString_AS_STRING(temp[$2]))) * $10;',
                    'CLEARTEMP($2);',
                    'temp[$7] = PyInt_FromLong ( $9 );',
                    '} else {',
                    'if ((temp[$4] = PyTuple_New ( 1 )) == 0) goto $3;',
                    'PyTuple_SET_ITEM ( temp[$4] , 0 , temp[$2] );',
                    'temp[$2] = 0;',
                    'if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$5] , temp[$4] , NULL )) == 0) goto $3;',
                    'CLEARTEMP($4);',
                    '$6 = PyInt_AS_LONG ( temp[$0] );',
                    '$9 = $6 * $10;',
                    'if ($9 / $10 == $6) {',
                    'temp[$7] = PyInt_FromLong ($9);',
                    '} else {',
                    'temp[$7] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], consts[$8]);',
                    '}',
                    'CLEARTEMP($0);',
                    '}'), v2)
                return True 
        if TxMatch(o, i, """
            if (PyString_GET_SIZE( $9 ) == 1) {
            long_$3 = (long)((unsigned char)*PyString_AS_STRING ( $9 ));
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else {
            if ((temp[$1] = PyTuple_Pack ( 1 , $9 )) == 0) goto label_$10;
            if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$11] , temp[$1] , NULL )) == 0) goto label_$10;
            CLEARTEMP($1);
            }
            $15 = PyInt_AsLong(temp[$0]);
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """
                    if (PyString_GET_SIZE( $9 ) == 1) {
                    $15 = (long)((unsigned char)*PyString_AS_STRING ( $9 ));
                    } else {
                    if ((temp[$1] = PyTuple_Pack ( 1 , $9 )) == 0) goto label_$10;
                    if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$11] , temp[$1] , NULL )) == 0) goto label_$10;
                    CLEARTEMP($1);
                    $15 = PyInt_AsLong(temp[$0]);
                    CLEARTEMP($0);
                    }""", v2)
                return True 
    
    if i+1 < len(o) and 'PyInt_FromLong' in o[i+1]:
        if TxMatch(o, i, """
            if ($9) {
            temp[$1] = PyInt_FromLong ($8);
            } else {
            temp[$0] = $7;
            if ((temp[$1] = PyNumber_$6 ( temp[$0] , $5 )) == 0) goto label_$12;
            CLEARTEMP($0);
            }
            if ((temp[$10] = PyObject_GetItem ( $14 , temp[$1] )) == 0) goto label_$12;
            CLEARTEMP($1);""", v2):
                v2[9] = v2[9].strip()
                v2[8] = v2[8].strip()
                TxRepl(o, i, """
                    if ( $9 ) {
                    temp[$1] = PyInt_FromLong ( $8 );
                    if ((temp[$10] = PyObject_GetItem ( $14 , temp[$1] )) == 0) goto label_$12;
                    CLEARTEMP($1);
                    } else {
                    temp[$0] = $7;
                    if ((temp[$1] = PyNumber_$6 ( temp[$0] , $5 )) == 0) goto label_$12;
                    CLEARTEMP($0);
                    if ((temp[$10] = PyObject_GetItem ( $14 , temp[$1] )) == 0) goto label_$12;
                    CLEARTEMP($1);
                    }
                    """, v2)
                return True    
                    
    
        if TxMatch(o, i, ('if (Loc_long_$2 < INT_MAX) {',
            'temp[$1] = PyInt_FromLong ( Loc_long_$2 + 1 );',
            '} else {',
            'temp[$0] = PyInt_FromLong (Loc_long_$2);',
            'if ((temp[$1] = PyNumber_Add ( temp[$0] , $5 )) == 0) goto $3;',
            'CLEARTEMP($0);',
            '}',
            'if ((temp[$0] = PyObject_GetItem ( $4 , temp[$1] )) == 0) goto $3;',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if ((temp[$0] = __c_BINARY_SUBSCR_Int ( $4 , Loc_long_$2 + 1 )) == 0) goto $3;',), v2, ('__c_BINARY_SUBSCR_Int',))
                return True  
        
        if TxMatch(o, i, ('if ($2 < INT_MAX) {',
            'temp[$1] = PyInt_FromLong ( $2 + 1 );',
            '} else {',
            'temp[$0] = PyInt_FromLong ($2);',
            'if ((temp[$1] = PyNumber_Add ( temp[$0] , $4 )) == 0) goto $3;',
            'CLEARTEMP($0);',
            '}',
            '$2 = PyInt_AsLong(temp[$1]);',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('$2 += 1;',), v2)
                return True
        
        if TxMatch(o, i, ('if ($3) {',
            'temp[$1] = PyInt_FromLong ($4);',
            '} else {',
            'temp[$0] = PyInt_FromLong ( $5 );',
            'temp[$1] = $6;',
            'CLEARTEMP($0);',
            '}',
            'if (PyInt_CheckExact( temp[$1] ) && ($7 = PyInt_AS_LONG ( temp[$1] )) > (INT_MIN+$8) ) {',
            'temp[$0] = PyInt_FromLong ( $7 - $9 );',
            '} else {',
            'if ((temp[$0] = PyNumber_Subtract ( temp[$1] , $10 )) == 0) goto $2;',
            '}',
            'CLEARTEMP($1);'), v2):
                TxRepl(o, i, ('if ($3 && (($7 = $4) > (INT_MIN+$8))) {',
                    'temp[$0] = PyInt_FromLong ( $7 - $9 );',
                    '} else {',
                    'temp[$0] = PyInt_FromLong ( $5 );',
                    'temp[$1] = $6;',
                    'CLEARTEMP($0);',
                    'if ((temp[$0] = PyNumber_Subtract ( temp[$1] , $10 )) == 0) goto $2;',
                    'CLEARTEMP($1);',
                    '}'), v2)
                return True  
        if TxMatch(o, i, """
            if ($5) {
            temp[$1] = PyInt_FromLong ($7);
            } else if ($6) {
            temp[$1] = PyFloat_FromDouble($8);
            } else {
            if ((temp[$1] = PyNumber_$9) == 0) goto $3;
            }
            if ((temp[$2] = PyNumber_Float ( temp[$1] )) == 0) goto $3;
            CLEARTEMP($1);
            $4 = PyFloat_AsDouble ( temp[$2] );
            CLEARTEMP($2);
            """, v2):
                TxRepl(o, i, """
                    if ($5) {
                    $4 = (double)($7);
                    } else if ($6) {
                    $4 = $8;
                    } else {
                    if ((temp[$1] = PyNumber_$9) == 0) goto $3;
                    if ((temp[$2] = PyNumber_Float ( temp[$1] )) == 0) goto $3;
                    CLEARTEMP($1);
                    $4 = PyFloat_AsDouble ( temp[$2] );
                    CLEARTEMP($2);
                    }
                    """, v2)   
                return True   
        if TxMatch(o, i, """
            if ($5) {
            temp[$1] = PyInt_FromLong ($6);
            } else {
            temp[$0] = $7;
            temp[$1] = $8;
            CLEARTEMP($0);
            }
            if ((temp[$3] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto label_$10;
            CLEARTEMP($1);        
            """, v2): 
                TxRepl(o, i, """
                    if ($5) {
                    temp[$1] = PyInt_FromLong ($6);
                    if ((temp[$3] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto label_$10;
                    CLEARTEMP($1);   
                    } else {
                    temp[$0] = $7;
                    temp[$1] = $8;
                    CLEARTEMP($0);
                    if ((temp[$3] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto label_$10;
                    CLEARTEMP($1);   
                    }
                    """, v2)  
                return True   
            
        if TxMatch(o, i, """
            if ($5) {
            temp[$1] = PyInt_FromLong ( $6 );
            } else {
            if ((temp[$1] = PyNumber_$7 ($8)) == 0) goto $9;
            }
            if ((temp[$2] = $10) == 0) goto $9;
            if ((Py_ssize_t_$11 = $12 ( temp[$2] )) == -1) goto $9;
            CLEARTEMP($2);
            if (PyInt_CheckExact( temp[$1] )) {
            int_$16 = PyInt_AS_LONG ( temp[$1] ) $14 Py_ssize_t_$11;
            } else {
            if ((temp[$3] = PyInt_FromSsize_t(Py_ssize_t_$11)) == 0) goto $9;
            if ((int_$16 = PyObject_RichCompareBool ( temp[$1] , temp[$3] , $13 )) == -1) goto $9;
            CLEARTEMP($3);
            }
            CLEARTEMP($1);        
            """, v2): 
                TxRepl(o, i, """
                    if ($5) {
                    if ((temp[$2] = $10) == 0) goto $9;
                    if ((Py_ssize_t_$11 = $12 ( temp[$2] )) == -1) goto $9;
                    CLEARTEMP($2);
                    int_$16 = ($6) $14 Py_ssize_t_$11;
                    } else {
                    if ((temp[$1] = PyNumber_$7 ($8)) == 0) goto $9;
                    if ((temp[$2] = $10) == 0) goto $9;
                    if ((Py_ssize_t_$11 = $12 ( temp[$2] )) == -1) goto $9;
                    CLEARTEMP($2);
                    if ((temp[$3] = PyInt_FromSsize_t(Py_ssize_t_$11)) == 0) goto $9;
                    if ((int_$16 = PyObject_RichCompareBool ( temp[$1] , temp[$3] , $13 )) == -1) goto $9;
                    CLEARTEMP($3);
                    CLEARTEMP($1);  
                    }
                    """, v2)  
                return True   
            
        if TxMatch(o, i, """
            if ($3) {
            temp[$0] = PyInt_FromLong ($4);
            } else {
            if ((temp[$0] = PyNumber_$5) == 0) goto label_$10;
            }
            if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
            CLEARTEMP($0);        
            """, v2): 
                TxRepl(o, i, """
                    if ($3) {
                    int_$1 = ($4) != 0;
                    } else {
                    if ((temp[$0] = PyNumber_$5) == 0) goto label_$10;
                    if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
                    CLEARTEMP($0);   
                    }
                    """, v2)  
                return True   

        if TxMatch(o, i, """
            if ($3) {
            temp[$1] = PyInt_FromLong ($4);
            } else {
            temp[$0] = $5;
            temp[$1] = $6;
            CLEARTEMP($0);
            }
            if (PyInt_CheckExact( temp[$1] )) {
            long_$7 = PyInt_AS_LONG ( temp[$1] );
            long_$8;
            if ($9) goto $10 ;
            temp[$2] = PyInt_FromLong ( $19 );
            } else { $10 :;
            if ((temp[$2] = PyNumber_$11) == 0) goto $12;
            }
            CLEARTEMP($1);        
            """, v2): 
                TxRepl(o, i, """
                    if ($3) {
                    long_$7 = $4;
                    long_$8;
                    if ($9) goto $10 ;
                    temp[$2] = PyInt_FromLong ( $19 );
                    } else { $10 :;
                    temp[$0] = $5;
                    temp[$1] = $6;
                    CLEARTEMP($0);
                    if ((temp[$2] = PyNumber_$11) == 0) goto $12;
                    CLEARTEMP($1);
                    }
                    """, v2)  
                return True   

        if TxMatch(o, i, """
            if ($2) {
            temp[$1] = PyInt_FromLong ( $4 );
            } else if ($3) {
            temp[$1] = PyFloat_FromDouble($5);
            } else {
            if ((temp[$1] = PyNumber_$6) == 0) goto $7;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            temp[$10] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $8 );
            } else {
            if ((temp[$10] = PyNumber_$9 ( temp[$1] , $11 )) == 0) goto $7;
            }
            CLEARTEMP($1);
            """, v2) and not ('temp[' + v2[0] + ']') in v2[4] and not ('temp[' + v2[0] + ']') in v2[8]: 
                TxRepl(o, i, """
                    if ($2) {
                    CLEARTEMP($0);
                    temp[$10] = PyInt_FromLong ( ($4) $8 );
                    } else {
                    if ((temp[$1] = PyNumber_$6) == 0) goto $7;
                    CLEARTEMP($0);
                    if ((temp[$10] = PyNumber_$9 ( temp[$1] , $11 )) == 0) goto $7;
                    CLEARTEMP($1);
                    }
                    """, v2)  
                return True   
    
        if TxMatch(o, i, """
            if ($3) {
            temp[$1] = PyInt_FromLong ($4);
            } else {
            if ((temp[$1] = PyNumber_$5) == 0) goto $6;
            }
            CLEARTEMP($0);
            if ((int_$7 = c_Py_$11_Int ( temp[$1] , $8 , $9 )) == -1) goto $6;
            CLEARTEMP($1);
            """, v2): 
                pycmp = 'Py_' + v2[11]
                if pycmp in c_2_op_op:
                    v2[12] = c_2_op_op[pycmp]
                if v2[12] != None:
                    TxRepl(o, i, """
                        if ($3) {
                        int_$7 = ($4) $12 $8;
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$5) == 0) goto $6;
                        CLEARTEMP($0);
                        if ((int_$7 = c_Py_$11_Int ( temp[$1] , $8 , $9 )) == -1) goto $6;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True   

        if TxMatch(o, i, """
            if ($5) {
            temp[$0] = PyInt_FromLong ( $6 );
            } else {
            if ((temp[$0] = PyNumber_$8) == 0) goto $7;
            }
            if ((Py_ssize_t_$9 = $10 )) == -1) goto $7;
            if (PyInt_CheckExact( temp[$0] )) {
            int_$14 = PyInt_AS_LONG ( temp[$0] ) $12 Py_ssize_t_$9;
            } else {
            if ((temp[$1] = PyInt_FromSsize_t(Py_ssize_t_$9)) == 0) goto $7;
            if ((int_$14 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , $11 )) == -1) goto $7;
            CLEARTEMP($1);
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if ($5) {
                        if ((Py_ssize_t_$9 = $10 )) == -1) goto $7;
                        int_$14 = ($6) $12 Py_ssize_t_$9;
                        } else {
                        if ((temp[$0] = PyNumber_$8) == 0) goto $7;
                        if ((Py_ssize_t_$9 = $10 )) == -1) goto $7;
                        if ((temp[$1] = PyInt_FromSsize_t(Py_ssize_t_$9)) == 0) goto $7;
                        if ((int_$14 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , $11 )) == -1) goto $7;
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True
    
        if TxMatch(o, i, """
            if (long_$4 / $10 == long_$3) {
            temp[$2] = PyInt_FromLong (long_$4);
            } else {
            temp[$0] = PyInt_FromLong ( long_$3 );
            temp[$2] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $10);
            CLEARTEMP($0);
            }
            long_$14 = PyInt_AS_LONG ( temp[$1] );
            long_$6 = PyInt_AS_LONG ( temp[$2] );
            long_$13 = long_$14 + long_$6;
            if (( long_$13 ^ long_$14 ) < 0 && ( long_$13 ^ long_$6 ) < 0) goto $12 ;
            temp[$0] = PyInt_FromLong ( long_$13 );
            if (1) {
            } else { $12 :;
            if ((temp[$0] = PyNumber_Add ( temp[$1] , temp[$2] )) == 0) goto $11;
            }
            CLEARTEMP($1);
            CLEARTEMP($2); 
            """, v2): 
                    TxRepl(o, i, """
                        long_$6 = long_$4;
                        long_$14 = PyInt_AS_LONG ( temp[$1] );
                        long_$13 = long_$14 + long_$6;
                        if (( long_$13 ^ long_$14 ) < 0 && ( long_$13 ^ long_$6 ) < 0) goto $12 ;
                        temp[$0] = PyInt_FromLong ( long_$13 );
                        if (1) {
                        } else { $12 :;
                        if ((temp[$0] = PyNumber_Add ( temp[$1] , temp[$2] )) == 0) goto $11;
                        }
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True
    
    
        if TxMatch(o, i, """
            if ($11) {
            temp[$2] = PyInt_FromLong ( $12 );
            } else {
            temp[$0] = PyInt_FromLong ( $13 );
            temp[$2] = PyInt_Type.tp_as_number->nb_multiply($14);
            CLEARTEMP($0);
            }
            long_$4 = PyInt_AS_LONG ( temp[$2] );
            long_$3 = $15;
            if ($16) goto $17 ;
            temp[$18] = PyInt_FromLong ( long_$3 );
            if (1) {
            } else { $17 :;
            if ((temp[$18] = PyNumber_$19) == 0) goto $10;
            }
            CLEARTEMP($2);
            """, v2): 
                    TxRepl(o, i, """
                        long_$4 = $12;
                        long_$3 = $15;
                        if ($16) goto $17 ;
                        temp[$18] = PyInt_FromLong ( long_$3 );
                        if (1) {
                        } else { $17 :;
                        if ((temp[$18] = PyNumber_$19) == 0) goto $10;
                        }
                        """, v2)   
                    return True
                
        if TxMatch(o, i, """
            if (long_$6 / $7 == $8) {
            temp[$0] = PyInt_FromLong ( long_$6 );
            } else {
            temp[$0] = PyInt_Type.tp_as_number->nb_multiply($9, $10);
            }
            long_$6 = PyInt_AS_LONG ( temp[$0] );
            long_$5 = long_$6 - $4;
            if (( long_$5 ^ long_$6 ) < 0 && ( long_$5 ^~ $4 ) < 0) goto label_$17 ;
            temp[$1] = PyInt_FromLong ( long_$5 );
            if (1) {
            } else { label_$17 :;
            if ((temp[1] = PyNumber_Subtract ( temp[$0] , $11 )) == 0) goto label_$12;
            }
            CLEARTEMP($0);                
                """, v2): 
                    TxRepl(o, i, """
                        long_$5 = long_$6 - $4;
                        if (( long_$5 ^ long_$6 ) < 0 && ( long_$5 ^~ $4 ) < 0) goto label_$17 ;
                        temp[$1] = PyInt_FromLong ( long_$5 );
                        if (0) { label_$17 :;
                        temp[$0] = PyInt_FromLong ( long_$6 );
                        if ((temp[1] = PyNumber_Subtract ( temp[$0] , $11 )) == 0) goto label_$12;
                        CLEARTEMP($0);  
                        }
                        """, v2)   
                    return True
    
    if 'int_' in o[i] and '=' not in o[i]:  
        if '!' in o[i]:  
            if TxMatch(o, i, ('if ( !(int_$1) ) {',), v2) and v2[1].isdigit():
                    TxRepl(o, i, ('if ( !int_$1 ) {',), v2)
                    return True    
            if TxMatch(o, i, ('if ( (!(int_$1)) ) {',), v2) and v2[1].isdigit():
                    TxRepl(o, i, ('if ( !int_$1 ) {',), v2)
                    return True    
            if TxMatch(o, i, ('if (!( int_$1 )) {',), v2) and v2[1].isdigit():
                    TxRepl(o, i, ('if ( !int_$1 ) {',), v2)
                    return True    
        else:        
            if TxMatch(o, i, ('if ( ((int_$1)) ) {',), v2) and v2[1].isdigit():
                    TxRepl(o, i, ('if ( int_$1 ) {',), v2)
                    return True    
            if TxMatch(o, i, ('if ( (int_$1) ) {',), v2) and v2[1].isdigit():
                    TxRepl(o, i, ('if ( int_$1 ) {',), v2)
                    return True    
            if TxMatch(o, i, ('if (( int_$1 )) {',), v2) and v2[1].isdigit():
                    TxRepl(o, i, ('if ( int_$1 ) {',), v2)
                    return True   
        if i+1 < len(o) and 'Loc_int_' in o[i+1] and TxMatch(o, i, """
            if ( int_$1 ) {
            int_$1 = Loc_int_$3;
            int_$1 = !(int_$1);
            }
            """, v2) and ' ' not in v2[3]: 
                    TxRepl(o, i, """
                        if ( int_$1 ) {
                        int_$1 = !Loc_int_$3;
                        }""", v2)   
                    return True

    if i+1 < len(o) and 'PyFloat_FromDouble' in o[i+1]:
        if TxMatch(o, i, """
            if ($11)) {
            temp[$2] = PyFloat_FromDouble($12);
            } else if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$0] )) {
            $4 = PyInt_AS_LONG ( temp[$1] );
            $5 = PyInt_AS_LONG ( temp[$0] );
            if ($4 && $5 && ($4 * $5) / $5 == $4) {
            temp[$2] = PyInt_FromLong ($4 * $5);
            } else {
            temp[$2] = PyInt_Type.tp_as_number->nb_multiply(temp[$1], temp[$0]);
            }
            } else {
            """, v2): 
                TxRepl(o, i, """
                    if ($11)) {
                    temp[$2] = PyFloat_FromDouble($12);
                    } else if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$0] ) && ($4 = PyInt_AS_LONG ( temp[$1] )) && ($5 = PyInt_AS_LONG ( temp[$0] )) && (($4 * $5) / $5 == $4)) {
                    temp[$2] = PyInt_FromLong ($4 * $5);
                    } else {
                    """, v2)   
                return True   
    
    
        if TxMatch(o, i, """
            if ($4) {
            temp[$2] = PyFloat_FromDouble($5);
            } else if ($6) {
            temp[$2] = PyInt_FromLong ($7);
            } else {
            if ((temp[$2] = PyNumber_Multiply ($8)) == 0) goto $9;
            }
            CLEARTEMP($1);
            CLEARTEMP($0);
            if (PyInt_CheckExact( $10 ) && PyInt_CheckExact( temp[$2] )) {
            long_$12 = PyInt_AS_LONG ( $10 );
            long_$13 = PyInt_AS_LONG ( temp[$2] );
            long_$14 = long_$12 + long_$13;
            if (( long_$14 ^ long_$12 ) < 0 && ( long_$14 ^ long_$13 ) < 0) goto $11 ;
            temp[$15] = PyInt_FromLong ( long_$14 );
            } else if (PyFloat_CheckExact( $10 ) && PyFloat_CheckExact( temp[$2] )) {
            temp[$15] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($10) + PyFloat_AS_DOUBLE(temp[$2]));
            } else { $11 :;
            if ((temp[$15] = PyNumber_Add ( $10 , temp[$2] )) == 0) goto $9;
            }
            CLEARTEMP($2);
            """, v2): 
                TxRepl(o, i, """
                    if (PyFloat_CheckExact( $10 ) && ($4)) {
                    temp[$15] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($10) + ($5));
                    } else if (PyInt_CheckExact( $10 ) && ($4)) {
                    temp[$15] = PyFloat_FromDouble(PyInt_AS_LONG($10) + ($5));
                    } else if (PyInt_CheckExact( $10 ) && $6) {
                    long_$13 = $7;
                    long_$12 = PyInt_AS_LONG ( $10 );
                    long_$14 = long_$12 + long_$13;
                    if (( long_$14 ^ long_$12 ) < 0 && ( long_$14 ^ long_$13 ) < 0) goto $11 ;
                    temp[$15] = PyInt_FromLong ( long_$14 );
                    } else { $11 :;
                    if ((temp[$2] = PyNumber_Multiply ($8)) == 0) goto $9;
                    CLEARTEMP($1);
                    CLEARTEMP($0);
                    if ((temp[$15] = PyNumber_Add ( $10 , temp[$2] )) == 0) goto $9;
                    CLEARTEMP($2);
                    }
                    """, v2)  
                return True   
            
        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$0] ) && PyFloat_CheckExact( temp[$0] )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
            } else if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( temp[$0] ) && (long_$4 = PyInt_AS_LONG ( temp[$0] )) && (long_$5 = PyInt_AS_LONG ( temp[$0] )) && ((long_$4 * long_$5) / long_$5 == long_$4)) {
            temp[$1] = PyInt_FromLong (long_$4 * long_$5);
            } else {
            if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto $9;
            }
            CLEARTEMP($0);
            """, v2): 
                TxRepl(o, i, """
                    if (PyFloat_CheckExact( temp[$0] )) {
                    temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
                    } else if (PyInt_CheckExact( temp[$0] ) && (long_$4 = PyInt_AS_LONG ( temp[$0] )) && ((long_$4 * long_$4) / long_$4 == long_$4)) {
                    temp[$1] = PyInt_FromLong (long_$4 * long_$4);
                    } else {
                    if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto $9;
                    }
                    CLEARTEMP($0);
                    """, v2)  
                return True   
            
        if TxMatch(o, i, """
            if ($11) {
            temp[$1] = PyFloat_FromDouble($12);
            } else if ($13) {
            temp[$1] = PyInt_FromLong ($14);
            } else {
            if ((temp[$1] = PyNumber_$15) == 0) goto $16;
            }
            CLEARTEMP($0);
            if (PyFloat_CheckExact( temp[$1] )) {
            temp[$3] = PyFloat_FromDouble($17PyFloat_AS_DOUBLE(temp[$1]));
            } else {
            if ((temp[$3] = PyNumber_$18 temp[$1] )) == 0) goto $16;
            }
            CLEARTEMP($1);       
            """, v2) and v2[0] != v2[3]: 
                TxRepl(o, i, """
                    if ($11) {
                    temp[$3] = PyFloat_FromDouble($17($12));
                    CLEARTEMP($0);
                    } else if ($13) {
                    temp[$3] = PyFloat_FromDouble($17(double)($14));
                    CLEARTEMP($0);
                    } else {
                    if ((temp[$1] = PyNumber_$15) == 0) goto $16;
                    CLEARTEMP($0);
                    if ((temp[$3] = PyNumber_$18 temp[$1] )) == 0) goto $16;
                    CLEARTEMP($1);
                    }
                    """, v2)  
                return True   

        if TxMatch(o, i, """
            if ($11) {
            temp[$4] = PyFloat_FromDouble($5);
            } else if ($6) {
            temp[$4] = PyInt_FromLong ($7);
            } else {
            if ((temp[$4] = PyNumber_$10) == 0) goto $8;
            }
            CLEARTEMP($1);
            CLEARTEMP($3);
            if (PyInt_CheckExact( temp[$4] )) {
            long_$12 = PyInt_AS_LONG ( temp[$4] );
            long_$13;
            if ($14) goto $9 ;
            temp[$1] = PyInt_FromLong ( $15 );
            } else if (PyFloat_CheckExact( temp[$4] )) {
            temp[$1] = PyFloat_FromDouble($16);
            } else { $9 :;
            if ((temp[$1] = PyNumber_$17) == 0) goto $8;
            }
            CLEARTEMP($4);                
            """, v2): 
                    TxRepl(o, i, """
                        if ($6) {
                        long_$12 = ($7);
                        CLEARTEMP($1);
                        CLEARTEMP($3);
                        long_$13;
                        if ($14) goto $9 ;
                        temp[$1] = PyInt_FromLong ( $15 );
                        } else { $9 :;
                        if ((temp[$4] = PyNumber_$10) == 0) goto $8;
                        CLEARTEMP($1);
                        CLEARTEMP($3);
                        if ((temp[$1] = PyNumber_$17) == 0) goto $8;
                        CLEARTEMP($4);                
                        }
                        """, v2) 
                    return True
         
    
        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$3] )) {
            temp[$4] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) * PyFloat_AS_DOUBLE(temp[$3]));
            } else if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$3] )) {
            long_$10 = PyInt_AS_LONG ( temp[$1] );
            long_$11 = PyInt_AS_LONG ( temp[$3] );
            if (long_$10 && long_$11 && (long_$10 * long_$11) / long_$11 == long_$10) {
            temp[$4] = PyInt_FromLong ( long_$10 * long_$11 );
            } else {
            temp[$4] = PyInt_Type.tp_as_number->nb_multiply(temp[$1], temp[$3]);
            }
            } else {
            if ((temp[$4] = PyNumber_Multiply ( temp[$1] , temp[$3] )) == 0) goto $5;
            }
            CLEARTEMP($1);
            CLEARTEMP($3);
            if (PyInt_CheckExact( temp[$4] )) {
            long_$12 = PyInt_AS_LONG ( temp[$4] );
            long_$13 = $14;
            if ($15) goto $7 ;
            temp[$6] = PyInt_FromLong ( long_$13 );
            } else if (PyFloat_CheckExact( temp[$4] )) {
            temp[$6] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$4]) $9);
            } else { $7 :;
            if ((temp[$6] = PyNumber_$8) == 0) goto $5;
            }
            CLEARTEMP($4);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$3] )) {
                        temp[$6] = PyFloat_FromDouble((PyFloat_AS_DOUBLE(temp[$1]) * PyFloat_AS_DOUBLE(temp[$3])) $9);
                        } else if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$3] )) {
                        long_$10 = PyInt_AS_LONG ( temp[$1] );
                        long_$11 = PyInt_AS_LONG ( temp[$3] );
                        if (!(long_$10 && long_$11 && (long_$10 * long_$11) / long_$11 == long_$10)) goto $7 ;
                        long_$12 = long_$10 * long_$11;
                        long_$13 = $14;
                        if ($15) goto $7 ;
                        temp[$6] = PyInt_FromLong ( long_$13 );
                        } else { $7 :;
                        if ((temp[$4] = PyNumber_Multiply ( temp[$1] , temp[$3] )) == 0) goto $5;
                        CLEARTEMP($1);
                        CLEARTEMP($3);
                        if ((temp[$6] = PyNumber_$8) == 0) goto $5;
                        CLEARTEMP($4);
                        }
                        """, v2)   
                    return True

        if TxMatch(o, i, """
            if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$0] )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$1]) * PyFloat_AS_DOUBLE(temp[$0]));
            } else if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$0] )) {
            long_$4 = PyInt_AS_LONG ( temp[$1] );
            long_$5 = PyInt_AS_LONG ( temp[$0] );
            if (long_$4 && long_$5 && (long_$4 * long_$5) / long_$5 == long_$4) {
            temp[$2] = PyInt_FromLong ( long_$4 * long_$5 );
            } else {
            temp[$2] = PyInt_Type.tp_as_number->nb_multiply(temp[$1], temp[$0]);
            }
            } else {
            if ((temp[$2] = PyNumber_Multiply ( temp[$1] , temp[$0] )) == 0) goto label_$9;
            }
            CLEARTEMP($1);
            CLEARTEMP($0);
            if (PyInt_CheckExact( $11 ) && PyInt_CheckExact( temp[$2] )) {
            long_$6 = PyInt_AS_LONG ( $11 );
            long_$7 = PyInt_AS_LONG ( temp[$2] );
            long_$8 = long_$6 + long_$7;
            if ($19) goto label_$10 ;
            temp[$3] = PyInt_FromLong ( long_$8 );
            } else if (PyFloat_CheckExact( $11 ) && PyFloat_CheckExact( temp[$2] )) {
            temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) + PyFloat_AS_DOUBLE(temp[$2]));
            } else { label_$10 :;
            if ((temp[$3] = PyNumber_Add ( $11 , temp[$2] )) == 0) goto label_$9;
            }
            CLEARTEMP($2);
            SETLOCAL ( $15 , temp[$3] );
            temp[0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if (PyFloat_CheckExact( temp[$1] ) && PyFloat_CheckExact( temp[$0] ) && PyFloat_CheckExact( $11 )) {
                        SETLOCAL ( $15 , PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) + (PyFloat_AS_DOUBLE(temp[$1]) * PyFloat_AS_DOUBLE(temp[$0]))) );
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        } else if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( $11 )) {
                        long_$4 = PyInt_AS_LONG ( temp[$1] );
                        long_$5 = PyInt_AS_LONG ( temp[$0] );
                        if (long_$4 && long_$5 && (long_$4 * long_$5) / long_$5 != long_$4) goto label_$10 ;
                        long_$7 = long_$4 * long_$5;
                        long_$6 = PyInt_AS_LONG ( $11 );
                        long_$8 = long_$6 + long_$7;
                        if ($19) goto label_$10 ;
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        SETLOCAL ( $15 , PyInt_FromLong ( long_$8 ) );
                        } else { label_$10 :;
                        if ((temp[$2] = PyNumber_Multiply ( temp[$1] , temp[$0] )) == 0) goto label_$9;
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        if ((temp[$3] = PyNumber_Add ( $11 , temp[$2] )) == 0) goto label_$9;
                        CLEARTEMP($2);
                        SETLOCAL ( $15 , temp[$3] );
                        temp[$3] = 0;
                        }
                        """, v2)   
                    return True
    
    
    
    if i+1 < len(o) and o[i+1].startswith('long_'):
        if TxMatch(o, i, """
            if ($3) {
            long_$4;
            long_$5;
            long_$17;
            if ($6) goto label_$7 ;
            temp[$0] = PyInt_FromLong ( $9 );
            } else { label_$7 :;
            if ((temp[$0] = PyNumber_$10) == 0) goto $8;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            int_$11 = Py_ssize_t_$12 $15 PyInt_AS_LONG ( temp[$0] );
            } else {
            if ((temp[$2] = PyInt_FromSsize_t(Py_ssize_t_$12)) == 0) goto $8;
            if ((int_$11 = PyObject_RichCompareBool ( temp[$2] , temp[$0] , $14 )) == -1) goto $8;
            CLEARTEMP($2);
            }
            CLEARTEMP($0);
            """, v2): 
                TxRepl(o, i, """
                    if ($3) {
                    long_$4;
                    long_$5;
                    long_$17;
                    if ($6) goto label_$7 ;
                    int_$11 = Py_ssize_t_$12 $15 ($9);
                    } else { label_$7 :;
                    if ((temp[$0] = PyNumber_$10) == 0) goto $8;
                    if ((temp[$2] = PyInt_FromSsize_t(Py_ssize_t_$12)) == 0) goto $8;
                    if ((int_$11 = PyObject_RichCompareBool ( temp[$2] , temp[$0] , $14 )) == -1) goto $8;
                    CLEARTEMP($2);
                    CLEARTEMP($0);
                    }
                    """, v2)  
                return True   
    
        if TxMatch(o, i, """
            if ($1) {
            long_$2;
            long_$3;
            temp[$4] = PyInt_FromLong ($5);
            } else {
            if ((temp[$6] = PyNumber_$7) == 0) goto $9;
            if ((temp[$4] = PyNumber_$8) == 0) goto $9;
            CLEARTEMP($6);
            }
            long_$10 = PyInt_AsLong ( temp[$4] );
            CLEARTEMP($4);
            """, v2): 
                TxRepl(o, i, """
                    if ($1) {
                    long_$2;
                    long_$3;
                    long_$10 = ($5);
                    } else {
                    if ((temp[$6] = PyNumber_$7) == 0) goto $9;
                    if ((temp[$4] = PyNumber_$8) == 0) goto $9;
                    CLEARTEMP($6);
                    long_$10 = PyInt_AsLong ( temp[$4] );
                    CLEARTEMP($4);
                    }
                    """, v2)  
                return True   

    if 'PyDict_GetItem' in o[i]:
        if TxMatch(o, i, """
            if ((temp[$0] = PyDict_GetItem($7, $6)) == 0) {
            if (!(temp[$1] = PyTuple_Pack(1, $6))) goto label_$11;
            PyErr_SetObject(PyExc_KeyError, temp[$1]);
            CLEARTEMP($1);
            goto label_$11;
            }
            Py_INCREF(temp[$0]);
            LETLOCAL ( $5 , temp[$0] );
            temp[$0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = PyDict_GetItem($7, $6)) == 0) {
                        if (!(temp[$1] = PyTuple_Pack(1, $6))) goto label_$11;
                        PyErr_SetObject(PyExc_KeyError, temp[$1]);
                        CLEARTEMP($1);
                        goto label_$11;
                        }
                        Py_INCREF(GETLOCAL($5));
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if ((temp[$0] = PyDict_GetItem(temp[$7], $6)) == 0) {
            if (!(temp[$1] = PyTuple_Pack(1, $6))) goto label_$11;
            PyErr_SetObject(PyExc_KeyError, temp[$1]);
            CLEARTEMP($1);
            goto label_$11;
            }
            Py_INCREF(temp[$0]);
            CLEARTEMP($7);
            LETLOCAL ( $5 , temp[$0] );
            temp[$0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = PyDict_GetItem(temp[$7], $6)) == 0) {
                        if (!(temp[$1] = PyTuple_Pack(1, $6))) goto label_$11;
                        PyErr_SetObject(PyExc_KeyError, temp[$1]);
                        CLEARTEMP($1);
                        goto label_$11;
                        }
                        Py_INCREF(GETLOCAL($5));
                        CLEARTEMP($7);
                        """, v2)   
                    return True
    if i+1 < len(o) and 'Py_True' in o[i+1]:
        if TxMatch(o, i, """
            if ($9) {
            temp[$0] = Py_True;
            } else {
            temp[$0] = Py_False;
            }
            Py_INCREF(temp[$0]);
            $2 = PyObject_IsTrue(temp[$0]);
            CLEARTEMP($0);            
            """, v2): 
                TxRepl(o, i, """
                    $2 = $9;
                    """, v2)   
                return True
          
    return False
            
def ConC(*t):
    s = ''
    for it in t:
        s += CVar(it)
    return s


def mk_t2(t):
    t2 = ['if (', t[0], '(']
    for v in t[1:]:
        t2.append(v)
        t2.append(',')
    if len(t) == 1:
        t2.append(')')    
    return t2[:-1]

def maybe_call(to):
    return to != 'f->f_lineno' and not istempref(to) and \
               not istemptyped(to) and to[0] not in ('{', '}') and\
               to[-1] not in ('{', '}') and to[0:3] != 'if ' and \
               to not in ('continue;', 'break;', 'return') and \
               to[0:4] not in ('for ', 'for(') and to != 'goto' 

def do_str(add2):
    add3 = [CVar(x) for x in add2] 
    s = ''
    if add3[0] in ('{', '}') and len(add3) == 1:
        return add3[0]
    for i, st in enumerate(add3):
        if i != len(add3)-1:
            s += st + ' '
        elif st[-1] in ('{', '}'):
            s += st    
        else:
            if st[-1] != ';':
                s += st + ';' 
            else:
                s += st  
    ## cons = [const_by_n(int(x[7:-1])) 
                 ## for x in add2 if x.startswith('consts[') and \
                                  ## x.endswith(']') ]
    ## cons = [x for x in cons if type(x) != types.CodeType]                         
    ## if len (cons) > 0 and not no_generate_comment:
        ## s += ' /* '
        ## for cco in cons:
            ## s += repr(cco).replace('/*', '/?*').replace('*/', '*?/') + ', '
        ## s += ' */'    
    return s        

def generate(cmds, co, filename_):
    global filename, func, tempgen, typed_gen, _n2c, pregenerated,\
            genfilename, current_co, is_current, Line2Addr
    assert len(cmds) == 2
    func = co.c_name
    filename = filename_
    
    genfilename, nmmodule = Pynm2Cnm(filename)
    if not co.can_be_codefunc(): ##co.co_flags & CO_GENERATOR:
        stub_generator(co)
        return
    is_current = IS_CODEFUNC
    if co.can_be_cfunc():
       is_current = IS_CFUNC
    del tempgen[:]
    del typed_gen[:]
    o = Out()
    global try_jump_context, dropped_temp
    del try_jump_context[:]
    del dropped_temp[:]
    label_exc = New('label')
    set_toerr_new(o, label_exc)
    current_co = co
    Line2Addr = line2addr(co)

    current_co.to_exception = {}
    if func in direct_args and direct_call and not is_current & IS_CFUNC:
        seq2 = co.direct_cmds
        if seq2 == cmds[1] and len(co.hidden_arg_direct) == 0 and len(co.typed_arg_direct) == 0:
            generate_from_frame_to_direct_stube(co, o, co.c_name, cmds)
            return 
    if stat_func == func:
        o.append('{')
        o.Raw('FILE * _refs = fopen(\"%s_start\", \"w+\");' % func)
        o.Raw('_Py_PrintReferences2(_refs);')   
        o.Raw('fclose(_refs);')     
        o.append('}')
    o = generate_list(cmds[1], o)
    optimize(o) 
    if is_current & IS_CFUNC:
        generate_cfunc_header(cmds[0][1], o, co, typed_gen, co.detected_type)
    else:
        generate_header(cmds[0][1], o, co, typed_gen, co.detected_type)
    generate_default_exception_handler(o, co.c_name)
    o.append('}')
    set_toerr_back(o)  
    del_unused_ret_label(o)
    optimize(o) 
    if len(tempgen) > co.co_stacksize:
        co.co_stacksize = len(tempgen)
    pregenerated.append((cmds, o, co))    

def list_direct_args(nm):
    if nm in direct_args:
        return direct_args[nm].keys()
    return []

def add_direct_arg(nm, tupl):
    a = N2C(nm)
    if a.can_be_direct_call is None:
        a.can_be_direct_call = can_be_direct_call(a.cmds[1])
    if a.can_be_direct_call != True:
        return None
    if nm not in direct_args:
        direct_args[nm] = {}
    dic = direct_args[nm]
    typ = ()
    if type(tupl) is tuple and len(tupl) == 2:
        if tupl[0] == '!BUILD_TUPLE':
            typ = tuple([TypeExpr(x) for x in tupl[1]])
        elif tupl[0] == 'CONST':    
            typ = tuple([TypeExpr(('CONST', x)) for x in tupl[1]])
    if (tupl, typ) not in dic:
        dic[(tupl, typ)] = True
        
        
def fill_direct_args(it, nm):
    if type(it) is tuple and len(it) >= 1 and type(it[0]) is str:
        if it[0] == '!CALL_CALC_CONST':
            add_direct_arg(it[1], it[2])
        elif it[0] == '!CLASS_CALC_CONST_DIRECT' and it[3][0] == '!BUILD_TUPLE':  
            slf = ('PY_TYPE', T_OLD_CL_INST, it[1], ('PSEVDO', 'self'), None)          
            add_direct_arg(CodeInit(it[1]), ('!BUILD_TUPLE', (slf,) +it[3][1]))
        elif it[0] == '!CLASS_CALC_CONST_DIRECT' and it[3][0] == 'CONST':  
            slf = ('PY_TYPE', T_OLD_CL_INST, it[1], ('PSEVDO', 'self'), None)          
            tu = tuple([('CONST', x) for x in it[3][1]])            
            add_direct_arg(CodeInit(it[1]), ('!BUILD_TUPLE', (slf,) +tu))
    return      
                            
def concretize_code_direct_call(nm, seq, co):
    calls = list_direct_args(nm)

    call = join_defined_calls(calls, co.co_argcount, nm, (co.co_flags & 0x4) != 0)

    call_changed_arg = {}
    dic = {}
    collect_store_and_delete_and_fast(seq, dic)
    for i, arg in enumerate(call):
        assert i < co.co_argcount or (co.co_flags & 0x4 and i == co.co_argcount)
        s = ('DELETE_FAST', co.co_varnames[i])
        if s in dic:
            call[i] = None
            continue
        s = ('STORE_FAST', co.co_varnames[i])
        if s in dic and call[i] != (None, None):
            call_changed_arg[i] = call[i]  

            call[i] = None
    seq2 = seq[:]            
    typed = {}
    typed_changed = {}
    for i, arg in enumerate(call):
        if type(arg) is tuple and \
          (arg[0] == 'CONST' or (len(arg) != 2 and len(arg) >= 1 and type(arg[0]) is str) or \
           (len(arg) >= 1 and type(arg[0]) is str and arg[0][0] == '!') ):
            seq2 = replace_subexpr(seq2, ('FAST', co.co_varnames[i]), arg)
            t = TypeExpr(arg)
            if t is None:
                t = (None, None)
            typed[i] = (t[0], t[1])            
        elif arg is not None and arg != (None, None):
            seq2 = replace_subexpr(seq2, ('FAST', co.co_varnames[i]), ('PY_TYPE',) + arg + (('FAST', co.co_varnames[i]),None))
            typed[i] = arg
    assert type(seq2) is list
    for i, arg in call_changed_arg.iteritems():
        old = ('FAST', co.co_varnames[i])
        stor = ('STORE_FAST', co.co_varnames[i])
        dele = ('DELETE_FAST', co.co_varnames[i])
        if type(arg) is tuple and arg[0] == 'CONST':
            new = arg
            replace_concretised_at_list_from_pos(seq2, 0, old, new, stor, dele)                
            t = TypeExpr(arg)
            typed_changed[i] = (t[0], t[1])            
        elif arg is not None and arg != (None, None):
            new = ('PY_TYPE',) + arg + (('FAST', co.co_varnames[i]), None)
            replace_concretised_at_list_from_pos(seq2, 0, old, new, stor, dele)                
            typed_changed[i] = arg

    while True:        
        seq2_ = seq2
        seq2 = tree_pass_upgrade_repl(seq2, None, nm) 
        seq2 = recursive_type_detect(seq2, nm) 
        if seq2 == seq2_:
            break
    if co.co_flags & 0x4:
        hidden = []
    else:    
        hidden = [i for i, arg in enumerate(call) if type(arg) is tuple and arg[0] == 'CONST']
    seq2 = tree_pass_upgrade_repl(seq2,  None, nm)  
    for k,v in typed.iteritems():
        Debug('def %s, arg %s -- local type %s' %(nm, co.co_varnames[k], v))
    for k,v in typed_changed.iteritems():
        Debug('def %s, arg %s changed -- local type %s' %(nm, co.co_varnames[k], v))
    co.direct_cmds = seq2
    co.hidden_arg_direct = hidden
    co.typed_arg_direct = typed
    co.typed_arg_direct_changed = typed_changed 

    ## co.changed_arg = {}
    ## co.all_arg = {}
    ## for i in range(co.co_argcount + bool(co.co_flags & 0x4)):
        ## assert i < co.co_argcount or (co.co_flags & 0x4 and i == co.co_argcount)
        ## co.all_arg[i] = True
        ## co.all_arg[co.co_varnames[i]] = True
        ## s = ('DELETE_FAST', co.co_varnames[i])
        ## if repr(s) in srepr:
            ## co.changed_arg[i] = True
            ## co.changed_arg[co.co_varnames[i]] = True
            ## continue
        ## s = ('STORE_FAST', co.co_varnames[i])
        ## if repr(s) in srepr:
            ## co.changed_arg[i] = True
            ## co.changed_arg[co.co_varnames[i]] = True
            ## continue
        ## if 'STORE_GLOBAL' in srepr or 'DELETE_' in srepr or 'STORE_NAME' in srepr:
            ## co.changed_arg[i] = True
            ## co.changed_arg[co.co_varnames[i]] = True
            ## continue


def generate_direct(cmds, co, filename_):
    global filename, func, tempgen, typed_gen, _n2c, pregenerated,\
            genfilename, current_co, is_current
    assert len(cmds) == 2
    func = co.c_name
    filename = filename_
    genfilename, nmmodule = Pynm2Cnm(filename)
    if not co.can_be_codefunc(): ##co.co_flags & CO_GENERATOR:
        stub_generator(co)
        return

    if func in direct_args and direct_call:
        is_current = IS_DIRECT
    else:
        return None
    del tempgen[:]
    del typed_gen[:]
    o = Out()
    global try_jump_context, dropped_temp
    del try_jump_context[:]
    del dropped_temp[:]
    label_exc = New('label')
    set_toerr_new(o, label_exc)
    current_co = co
    
    current_co.to_exception = {}
    if stat_func == func:
        o.append('{')
        o.Raw('FILE * _refs = fopen(\"%s_start\", \"w+\");' % func)
        o.Raw('_Py_PrintReferences2(_refs);')   
        o.Raw('fclose(_refs);')     
        o.append('}')     
    strict_varnames(co)

    o = generate_list(co.direct_cmds, o)
    optimize(o)  
    i = len(tempgen) - 1
##    repro = repr(o)
    while i >= 0:
        s1 = 'temp[%d]' % i
        s2 = 'CLEARTEMP(%d)' % i
        if not string_in_o(s1, o) and not string_in_o(s2, o):
            del tempgen[i]
            i -= 1
            continue
        else:
            break    
    l1 = len(o)   
    ## have_try = 'TRY' in repr(co.direct_cmds)
    generate_default_exception_handler(o, co.c_name)
    l2 = len(o)
    o.append('}')
    set_toerr_back(o) 
    del_unused_ret_label(o)
    optimize(o)    
    co.co_stacksize = len(tempgen)
    generate_header_direct(cmds[0][1], o, co, typed_gen, \
                           co.typed_arg_direct, co.detected_type)
    if l2 == l1 and not have_try(co.direct_cmds):
        strip_pyline_pyaddr(o)    
    o = from_fastlocals_to_single(o)
    pregenerated.append((cmds, o, co))   
    
def have_try(cmds):
    assert type(cmds) is list
    for v in cmds:
        if type(v) is list:
            if have_try(v):
                return True
        if type(v) is tuple and len(v) > 0 and v[0] in ('(TRY', '(TRY_FINALLY'):
            return True
    return False
    
def string_in_o(s, o):
    assert type(o) is Out
    for s2 in o:
        if s in s2:
            return True
    return False
    
def strip_pyline_pyaddr(o):
    i = 0
    while i < len(o):
        assert type(i) is int
        if o[i].startswith('PyLine = '):
            del o[i]
            continue
        if o[i].startswith('PyAddr = '):
            del o[i]
            continue
        if o[i].startswith('int PyLine = '):
            del o[i]
            continue
        if o[i].startswith('int PyAddr = '):
            del o[i]
            continue
        i += 1

def from_fastlocals_to_single(o):
    global no_fastlocals
    if not no_fastlocals:
        return o
    o2 = Out()
    for v in o:
        v = v.replace('GETLOCAL(', 'GETFAST(')
        v = v.replace('SETLOCAL(', 'SETFAST(')
        v = v.replace('SETLOCAL (', 'SETFAST(')
        v = v.replace('SETLOCAL2(', 'SETFAST2(')
        v = v.replace('SETLOCAL2 (', 'SETFAST2(')
        v = v.replace('LETLOCAL(', 'LETFAST(')
        v = v.replace('LETLOCAL (', 'LETFAST(')
        o2.append(v)
    return o2
    
def strict_varnames(co):
    li = []
    s2 = repr(co.direct_cmds)
    for i, v in enumerate(co.co_varnames):
        if i < co.co_argcount:
            li.append(v)    
            continue
        if repr(('FAST', v)) in s2 or repr(('STORE_FAST', v)) in s2 or repr(('DELETE_FAST', v)) in s2:
            li.append(v)    
            continue
    co.co_varnames_direct = li    
    

def generate_default_exception_handler(o, nm):  
   if IsUsedLabl(labl) or len(current_co.to_exception) > 0:
        clabl = CVar(labl)
        found = False
        for s in o:
            if clabl in s:
                found = True
                break
        if not found and len(current_co.to_exception) == 0:
            return

        o.Raw('if (0) {')
        for tu, lb in current_co.to_exception.iteritems():
            o.Raw(lb, ':;')
            o.extend(tu)
        o.Raw(labl, ':;')
        if is_current & IS_CODEFUNC:
            o.append('PyTraceBack_Here(f);')
        else:    
            cod = const_to(current_co)
            Used('Direct_AddTraceback')
            if line_number:
                o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', PyLine, PyAddr);') 
            else:
                o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', 0, 0);') 

        if is_current & IS_DIRECT:
            hid = {}
            for i in current_co.hidden_arg_direct: 
                hid[current_co.co_varnames[i]] = True               
            for i,v in enumerate(current_co.co_varnames_direct):
                if v in hid:
                    continue
                ## if v in current_co.all_arg and v not in current_co.changed_arg:            
                    ## continue
                nmvar = nmvar_to_loc(v)
                if not current_co.IsCVar(('FAST', v)):
                    o.CLEAR('GETLOCAL(' + nmvar + ')')   

        for i in range(len(tempgen)):
            o.Raw('CLEARTEMP(', str(i), ');')
        if calc_ref_total:
            o.Raw('if ((_Py_RefTotal - l_Py_RefTotal) > 0) {printf ("func ', current_co.co_name, ' delta ref = %d\\n", (int)(_Py_RefTotal - l_Py_RefTotal));}')
        if is_current & IS_CODEFUNC:
            if check_recursive_call:
                o.append('Py_LeaveRecursiveCall();')
        if is_current & IS_CODEFUNC and not is_pypy:
            o.append('tstate->frame = f->f_back;')
        if is_current & IS_DIRECT and \
            (current_co.IsRetVoid() or IsCType(current_co.ReturnType())):
            o.Raw('return -1;')        
        else:    
            if nm == 'Init_filename' and build_executable:
                o.Raw('PyErr_Print();')
            o.Stmt('return', 'NULL;')        
        o.append('}')        
      
c_head1 = """
/* Generated by 2C Python */

#include "Python.h"
#include "frameobject.h" 
#include "funcobject.h" 
#include "code.h" 
#include "dictobject.h" 
#include "listobject.h" 
#include "abstract.h" 

#include "structmember.h"
#include "object.h"

PyTypeObject Py2CCode_Type;

PyTypeObject Py2CFunction_Type;

#define Py2CCode_CheckExact(op) (Py_TYPE(op) == &Py2CCode_Type)
#define Py2CCode_Check(op) PyObject_TypeCheck(op, &Py2CCode_Type)

#define Py2CFunction_CheckExact(op) (Py_TYPE(op) == &Py2CFunction_Type)
#define Py2CFunction_Check(op) PyObject_TypeCheck(op, &Py2CFunction_Type)

typedef struct {
    PyCodeObject _body;
    void *co_function;        /* Python code compiled to C function */
} Py2CCodeObject;

/* Public interface */
static Py2CCodeObject * Py2CCode_New(
	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, void *); 

static PyObject * b = NULL;
static PyObject * bdict = NULL;

/*#define DEBUG_LOCAL_REFCNT*/

/* Local variable macros */
#ifdef DEBUG_LOCAL_REFCNT
#define GETLOCAL(i)	printf("Get local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(fastlocals[Loc_##i]->ob_refcnt)),fastlocals[Loc_##i]
#define GETFAST(i)	printf("Get local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(_Fast_##i->ob_refcnt)), _Fast_##i
#else
#define GETLOCAL(i)	(fastlocals[Loc_##i])
#define GETFAST(i)	_Fast_##i
#endif
#define GETFREEVAR(i)	(freevars[Loc2_##i])
#define GETSTATIC(i)	(fastglob[Glob_##i])
/* The SETLOCAL() macro must not DECREF the local variable in-place and
   then store the new value; it must copy the old value to a temporary
   value, then store the new value, and then DECREF the temporary value.
   This is because it is possible that during the DECREF the frame is
   accessed by other code (e.g. a __del__ method or gc.collect()) and the
   variable would be pointing to already-freed memory. */
#ifdef DEBUG_LOCAL_REFCNT
#define SETLOCAL(i, value)	do { PyObject *tmp = fastlocals[Loc_##i]; \
                                     if (tmp != NULL) \
                                     printf("Replace local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(tmp->ob_refcnt));\
                                     fastlocals[Loc_##i] = value; \
                                     printf("New local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(fastlocals[Loc_##i]->ob_refcnt));\
                                     Py_XDECREF(tmp); } while (0)
#define SETLOCAL2(i, value) SETLOCAL(i, value)
#define SETFAST(i, value)	do { PyObject *tmp = _Fast_##i; \
                                     if (tmp != NULL) \
                                     printf("Replace local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(tmp->ob_refcnt));\
                                     _Fast_##i = value; \
                                     printf("New local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(_Fast_##i->ob_refcnt));\
                                     Py_XDECREF(tmp); } while (0)
#define SETFAST2(i, value)	SETFAST(i, value)

#else
#define SETLOCAL(i, value)	do { PyObject *tmp = fastlocals[Loc_##i]; \
				     fastlocals[Loc_##i] = value; \
                                     Py_XDECREF(tmp); } while (0)

#define SETLOCAL2(i, value)	do { Py_XDECREF(fastlocals[Loc_##i]);\
				     fastlocals[Loc_##i] = value; } while (0)
                                     
#define SETFAST(i, value)	do { PyObject *tmp = _Fast_##i; \
				     _Fast_##i = value; \
                                     Py_XDECREF(tmp); } while (0)

#define SETFAST2(i, value)	do { Py_XDECREF(_Fast_##i);\
				     _Fast_##i = value; } while (0)

#endif
#define LETLOCAL(i, value)	     fastlocals[Loc_##i] = (value)
#define LETFAST(i, value)	     _Fast_##i = (value)

#define SETSTATIC(i, value)	do { PyObject *tmp = fastglob[Glob_##i]; \
				     fastglob[Glob_##i] = value; \
                                     Py_XDECREF(tmp); } while (0)

#define COPYTEMP(new, old)	do { new = old; \
				     old = NULL; } while (0)
#define CLEARTEMP(x) Py_CLEAR(temp[x])

typedef char *charref;
typedef long *longref;
"""
c_head2 = """
static PyObject * consts[]; 
static PyObject * loaded_builtin[];
static PyObject * calculated_const[];
"""
c_head3 = """
static PyObject * glob;
static PyObject * empty_tuple;
/*void static check_const_refcnt(void);*/

/* Status code for main loop (reason for stack unwind) */
enum why_code {
		WHY_NOT =	0x0001,	/* No error */
		WHY_EXCEPTION = 0x0002,	/* Exception occurred */
		WHY_RERAISE =	0x0004,	/* Exception re-raised by 'finally' */
		WHY_RETURN =	0x0008,	/* 'return' statement */
		WHY_BREAK =	0x0010,	/* 'break' statement */
		WHY_CONTINUE =	0x0020,	/* 'continue' statement */
		WHY_YIELD =	0x0040	/* 'yield' operator */
};

#define NAME_ERROR_MSG \
	"name '%.200s' is not defined"
#define GLOBAL_NAME_ERROR_MSG \
	"global name '%.200s' is not defined"
#define UNBOUNDLOCAL_ERROR_MSG \
	"local variable '%.200s' referenced before assignment"
#define UNBOUNDFREE_ERROR_MSG \
	"free variable '%.200s' referenced before assignment" \
        " in enclosing scope"

#define c_Py_GT_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) > l) : (PyObject_RichCompareBool(v, w, Py_GT)))
#define c_Py_LT_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) < l) : (PyObject_RichCompareBool(v, w, Py_LT)))
#define c_Py_GE_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) >= l) : (PyObject_RichCompareBool(v, w, Py_GE)))
#define c_Py_LE_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) <= l) : (PyObject_RichCompareBool(v, w, Py_LE)))
#define c_Py_EQ_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) == l) : (PyObject_RichCompareBool(v, w, Py_EQ)))
#define c_Py_NE_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) != l) : (PyObject_RichCompareBool(v, w, Py_NE)))

#define c_Py_EQ_String(v,l,w,w2) ((PyString_CheckExact(v))?(PyString_GET_SIZE(v) == l && memcmp(PyString_AS_STRING(v),w,l) == 0) : (PyObject_RichCompareBool(v, w2, Py_EQ)))
#define c_Py_NE_String(v,l,w,w2) ((PyString_CheckExact(v))?(PyString_GET_SIZE(v) != l || memcmp(PyString_AS_STRING(v),w,l) != 0) : (PyObject_RichCompareBool(v, w2, Py_NE)))

#ifndef PYPY_VERSION
#define FirstCFunctionCall(a,b,c)  ((PyCFunction_Check (a)) ? ( PyCFunction_Call(a,b,c) ) : ( PyObject_Call(a,b,c) ))
#else
#define FirstCFunctionCall(a,b,c)  PyObject_Call(a,b,c)
#endif

#define GET_ATTR_LOCAL(n, nm, attr, labl) if (_ ##nm##_dict && (temp[n] = PyDict_GetItem(_##nm##_dict, attr)) != 0) { Py_INCREF(temp[n]); } else if ((temp[n] = PyObject_GetAttr ( GETLOCAL(nm) , attr )) == 0) goto labl; else 

static void patch_code2c(void);

static PyObject *
PyImport_Exec2CCodeModuleEx(char *name, PyObject *co);


"""
c_tail = """

#ifndef PYPY_VERSION
#define NAME_CHARS \
	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"

/* all_name_chars(s): true iff all chars in s are valid NAME_CHARS */

static int
all_name_chars(unsigned char *s)
{
	static char ok_name_char[256];
	static unsigned char *name_chars = (unsigned char *)NAME_CHARS;

	if (ok_name_char[*name_chars] == 0) {
		unsigned char *p;
		for (p = name_chars; *p; p++)
			ok_name_char[*p] = 1;
	}
	while (*s) {
		if (ok_name_char[*s++] == 0)
			return 0;
	}
	return 1;
}

static void
intern_strings(PyObject *tuple)
{
	Py_ssize_t i;

	for (i = PyTuple_GET_SIZE(tuple); --i >= 0; ) {
		PyObject *v = PyTuple_GET_ITEM(tuple, i);
		if (v == 0 || !PyString_CheckExact(v)) {
			Py_FatalError("non-string found in code slot");
		}
		PyString_InternInPlace(&PyTuple_GET_ITEM(tuple, i));
	}
}

#endif

static Py2CCodeObject *
Py2CCode_New(int argcount, int nlocals, int stacksize, int flags,
	   PyObject *code, PyObject *consts, PyObject *names,
	   PyObject *varnames, PyObject *freevars, PyObject *cellvars,
	   PyObject *filename, PyObject *name, int firstlineno,
	   PyObject *lnotab, void * func)
{
	PyCodeObject *co;
	Py_ssize_t i;
	/* Check argument types */
	if (argcount < 0 || nlocals < 0 ||
	    code == 0 ||
	    consts == 0 || !PyTuple_Check(consts) ||
	    names == 0 || !PyTuple_Check(names) ||
	    varnames == 0 || !PyTuple_Check(varnames) ||
	    freevars == 0 || !PyTuple_Check(freevars) ||
	    cellvars == 0 || !PyTuple_Check(cellvars) ||
	    name == 0 || !PyString_Check(name) ||
	    filename == 0 || !PyString_Check(filename) ||
	    lnotab == 0 || !PyString_Check(lnotab) ||
            func == 0 ||
	    !PyObject_CheckReadBuffer(code)) {
		PyErr_BadInternalCall();
		return NULL;
	}
#ifndef PYPY_VERSION        
	intern_strings(names);
	intern_strings(varnames);
	intern_strings(freevars);
	intern_strings(cellvars);
	/* Intern selected string constants */
	for (i = PyTuple_Size(consts); --i >= 0; ) {
		PyObject *v = PyTuple_GetItem(consts, i);
		if (!PyString_Check(v))
			continue;
		if (!all_name_chars((unsigned char *)PyString_AS_STRING(v)))
			continue;
		PyString_InternInPlace(&PyTuple_GET_ITEM(consts, i));
	}
#endif        
	co = (PyCodeObject *)PyObject_NEW(Py2CCodeObject, &Py2CCode_Type);
	if (co != NULL) {
		co->co_argcount = argcount;
		co->co_nlocals = nlocals;
		co->co_stacksize = stacksize;
		co->co_flags = flags;
		Py_INCREF(code);
		co->co_code = code;
		Py_INCREF(consts);
		co->co_consts = consts;
		Py_INCREF(names);
		co->co_names = names;
		Py_INCREF(varnames);
		co->co_varnames = varnames;
		Py_INCREF(freevars);
		co->co_freevars = freevars;
		Py_INCREF(cellvars);
		co->co_cellvars = cellvars;
		Py_INCREF(filename);
		co->co_filename = filename;
		Py_INCREF(name);
		co->co_name = name;
		co->co_firstlineno = firstlineno;
		Py_INCREF(lnotab);
		co->co_lnotab = lnotab;
                co->co_zombieframe = NULL;
                ((Py2CCodeObject *)co)->co_function = func;
	}
	return ((Py2CCodeObject *)co);
}
 
static PyObject * code_repr(PyCodeObject *co)
{
	char buf[500];
	int lineno = -1;
	char *filename = "???";
	char *name = "???";
        PyObject * o_filename;
        PyObject * o_name;
        o_filename = 0;
        o_name = 0;

#ifdef PYPY_VERSION    
        {
        PyObject * o_first;
        o_first = PyObject_GetAttrString((PyObject *)co, "co_firstlineno");
        assert(o_first != 0);
        o_filename = PyObject_GetAttrString((PyObject *)co, "co_filename");
        assert(o_filename != 0);
        o_name = PyObject_GetAttrString((PyObject *)co, "co_name");
        assert(o_name != 0);
        lineno = PyInt_AsLong(o_first);
        Py_CLEAR(o_first);
        }
#else
        o_filename = co->co_filename;
        o_name = co->co_name;
	if (co->co_firstlineno != 0)
		lineno = co->co_firstlineno;
#endif               
	if (o_filename && PyString_Check(o_filename))
		filename = PyString_AS_STRING(o_filename);
	if (o_name && PyString_Check(o_name))
		name = PyString_AS_STRING(o_name);
	PyOS_snprintf(buf, sizeof(buf),
		      "<code object %.100s at %p(%p), file \\"%.300s\\", line %d>",
		      name, co, ((Py2CCodeObject *)co)->co_function, filename, lineno);
#ifdef PYPY_VERSION  
        Py_CLEAR(o_filename);
        Py_CLEAR(o_name); 
#endif                      
	return PyString_FromString(buf);
}

static int code_compare(PyObject *co, PyObject *cp)
{
	int cmp;
        cmp = PyCode_Type.tp_compare(co, cp);
	if (cmp) return cmp;
        cmp = (long)((Py2CCodeObject *)co)->co_function - (long)((Py2CCodeObject *)cp)->co_function;
	if (cmp) goto normalize;
        return cmp;
    
 normalize:
	if (cmp > 0)
		return 1;
	else if (cmp < 0)
		return -1;
	else
		return 0;
}

static PyObject * code_richcompare(PyObject *self, PyObject *other, int op)
{
	int eq;
	PyObject *res;

        if ((op == Py_EQ || op == Py_NE) && Py2CCode_CheckExact(self) && Py2CCode_CheckExact(other)) {
                eq = ((Py2CCodeObject *)self)->co_function == ((Py2CCodeObject *)other)->co_function;
	        if (!eq) goto unequal;
        	if (op == Py_EQ)
		       res = Py_True;
                else
		       res = Py_False;
	        goto done;
  unequal:
	if (eq < 0)
		return NULL;
	if (op == Py_NE)
		res = Py_True;
	else
		res = Py_False;

  done:
	Py_INCREF(res);
	return res;
        }
	if ((op != Py_EQ && op != Py_NE) ||
	    !PyCode_Check(self) || 
	    !PyCode_Check(other)) {

		/* Py3K warning if types are not equal and comparison
		isn't == or !=  */
		if (PyErr_WarnPy3k("code inequality comparisons not supported "
				   "in 3.x", 1) < 0) {
			return NULL;
		}

		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
        return PyCode_Type.tp_richcompare(self, other, op);
}


static long code_hash(PyCodeObject *co)
{
        return (long)(((Py2CCodeObject *)co)->co_function);
}

PyTypeObject Py2CCode_Type;

/* Function object implementation */

#include "eval.h"

static PyObject *
function_call(PyObject *func, PyObject *arg, PyObject *kw)
{
	PyObject *result;
	PyObject *argdefs;
	PyObject **d, **k;
	Py_ssize_t nk, nd;

	argdefs = PyFunction_GET_DEFAULTS(func);
	if (argdefs != NULL && PyTuple_Check(argdefs)) {
		d = &PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL && PyDict_Check(kw)) {
		Py_ssize_t pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == 0) {
			PyErr_NoMemory();
			return NULL;
		}
		pos = i = 0;
		while (PyDict_Next(kw, &pos, &k[i], &k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_Eval2CCodeEx(
		(PyCodeObject *)PyFunction_GET_CODE(func),
		(PyObject *)NULL,
		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd
#ifndef PYPY_VERSION
                ,
		PyFunction_GET_CLOSURE(func));
#else
                );
#endif

	if (k != NULL)
		PyMem_DEL(k);

	return result;
}

#define ISINDEX(x) ((x) == 0 || \
		    PyInt_Check(x) || PyLong_Check(x) || PyIndex_Check(x))

/* Remove name from sys.modules, if it's there. */
static void
_RemoveModule(const char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	if (PyDict_GetItemString(modules, name) == 0)
		return;
	if (PyDict_DelItemString(modules, name) < 0)
		Py_FatalError("import:  deleting existing key in"
			      "sys.modules failed");
}


static PyObject *
PyImport_Exec2CCodeModuleEx(char *name, PyObject *co)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *d, *v;

	m = PyImport_AddModule(name);
	if (m == 0)
		return NULL;
	/* If the module is being reloaded, we get the old module back
	   and re-use its dict to exec the new code. */
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == 0) {
		if (PyDict_SetItemString(d, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			goto error;
	}
 	/* Remember the filename as the __file__ attribute */ 
#ifndef PYPY_VERSION
        v = ((PyCodeObject *)co)->co_filename;
/*      v = PyString_FromString(src_name);*/
        Py_INCREF(v);
#else
        v = PyObject_GetAttrString(co, "co_filename");
#endif        
	if (PyDict_SetItemString(d, "__file__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);
        v = PyString_FromString(name);
        Py_INCREF(v);
	if (PyDict_SetItemString(d, "__name__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);
        glob = d;
	v = PyEval_Eval2CCodeEx((PyCodeObject *)co,
			  d,
			  (PyObject **)NULL, 0,
			  (PyObject **)NULL, 0,
			  (PyObject **)NULL, 0
#ifndef PYPY_VERSION
                          ,
			  NULL);
#else
                        );
#endif

	if (v == 0)
		goto error;
	Py_DECREF(v);

	if ((m = PyDict_GetItemString(modules, name)) == 0) {
		PyErr_Format(PyExc_ImportError,
			     "Loaded module %.200s not found in sys.modules",
			     name);
		return NULL;
	}

	Py_INCREF(m);

	return m;

  error:
	_RemoveModule(name);
	return NULL;
}

static void patch_code2c(void){
    Py2CCode_Type = PyCode_Type;
    Py2CCode_Type.ob_type = &PyType_Type;
    Py2CCode_Type.tp_richcompare = code_richcompare;
    Py2CCode_Type.tp_compare = (cmpfunc)code_compare;
    Py2CCode_Type.tp_repr = (reprfunc)code_repr;
    Py2CCode_Type.tp_hash = (hashfunc)code_hash;
    Py2CCode_Type.tp_new = 0;
    Py2CCode_Type.tp_name = "code2c";
    Py2CCode_Type.tp_basicsize = sizeof(Py2CCodeObject);

    Py2CFunction_Type = PyFunction_Type;
    Py2CFunction_Type.ob_type = &PyType_Type;
    Py2CFunction_Type.tp_new = 0;
    Py2CFunction_Type.tp_name = "function2c";
    Py2CFunction_Type.tp_call = function_call;
}    
"""


def UseLabl():
    current_co.used_label[labl] = True
    
## def UseThisLabel(label):    
    ## current_co.used_label[label] = True
## ##    _3(func, 'UseLabel', labl)
    
def IsUsedLabl(labl):
    return labl in current_co.used_label
    
libr_depends = {'_PyEval_PRINT_ITEM_1' : ('_PyEval_PRINT_ITEM_TO_2',),\
            'from_ceval_call_exc_trace' : ('from_ceval_call_trace',),\
            'PyEval_Eval2CCodeEx': ('kwd_as_string',)}

def Used(nm):
    ## depends = {'_PyEval_PRINT_ITEM_1' : ('_PyEval_PRINT_ITEM_TO_2',),\
               ## 'from_ceval_call_exc_trace' : ('from_ceval_call_trace',),\
               ## 'PyEval_Eval2CCodeEx': ('kwd_as_string',)}
    _3(nm, 'Used', True)
    if nm in libr_depends:
        for nm2 in libr_depends[nm]:
            Used(nm2)

_Libr = {}
def IsLibr(nm):
    return nm in _Libr

def Libr(nm, dcl, defin):
    _Libr[nm] = (dcl, defin)

def LibrDcl(nm):
    return _Libr[nm][0]

def LibrDef(nm):
    return _Libr[nm][1]

if tuple(sys.version_info)[:2] == (2,6):
    Libr('PyEval_Eval2CCodeEx', 
"""
static PyObject *
PyEval_Eval2CCodeEx(PyCodeObject *, PyObject *,
	   PyObject **, int , PyObject **, int ,
	   PyObject **, int 
#ifndef PYPY_VERSION
           , PyObject *);
#else
           );
#endif
""",
"""
/* Local variable macros */

#undef GETLOCAL
#undef SETLOCAL
#define GETLOCAL(i)	(fastlocals[i])

#define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
				     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)

static PyObject *
PyEval_Eval2CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure)
#else
            )
#endif
{
	register PyFrameObject *f;
	register PyObject *retval = NULL;
	register PyObject **fastlocals, **freevars;
	PyThreadState *tstate = PyThreadState_GET();
	PyObject *x, *u;
        PyObject *(*c_func)(PyFrameObject *);

	assert(tstate != NULL);
	f = PyFrame_New(tstate, co, glob, locals);
	if (f == 0)
		return NULL;

	fastlocals = f->f_localsplus;
	freevars = f->f_localsplus + co->co_nlocals;

	if (co->co_argcount > 0 ||
	    co->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) {
		int i;
		int n = argcount;
		PyObject *kwdict = NULL;
		if (co->co_flags & CO_VARKEYWORDS) {
			kwdict = PyDict_New();
			if (kwdict == 0)
				goto fail;
			i = co->co_argcount;
			if (co->co_flags & CO_VARARGS)
				i++;
			SETLOCAL(i, kwdict);
		}
		if (argcount > co->co_argcount) {
			if (!(co->co_flags & CO_VARARGS)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() takes %s %d "
				    "%sargument%s (%d given)",
				    PyString_AsString(co->co_name),
				    defcount ? "at most" : "exactly",
				    co->co_argcount,
				    kwcount ? "non-keyword " : "",
				    co->co_argcount == 1 ? "" : "s",
				    argcount);
				goto fail;
			}
			n = co->co_argcount;
		}
		for (i = 0; i < n; i++) {
			x = args[i];
			Py_INCREF(x);
			SETLOCAL(i, x);
		}
		if (co->co_flags & CO_VARARGS) {
			u = PyTuple_New(argcount - n);
			if (u == 0)
				goto fail;
			SETLOCAL(co->co_argcount, u);
			for (i = n; i < argcount; i++) {
				x = args[i];
				Py_INCREF(x);
				PyTuple_SET_ITEM(u, i-n, x);
			}
		}
		for (i = 0; i < kwcount; i++) {
			PyObject **co_varnames;
			PyObject *keyword = kws[2*i];
			PyObject *value = kws[2*i + 1];
			int j;
			if (keyword == 0 || !PyString_Check(keyword)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() keywords must be strings",
				    PyString_AsString(co->co_name));
				goto fail;
			}
			/* Speed hack: do raw pointer compares. As names are
			   normally interned this should almost always hit. */
			co_varnames = PySequence_Fast_ITEMS(co->co_varnames);
			for (j = 0; j < co->co_argcount; j++) {
				PyObject *nm = co_varnames[j];
				if (nm == keyword)
					goto kw_found;
			}
			/* Slow fallback, just in case */
			for (j = 0; j < co->co_argcount; j++) {
				PyObject *nm = co_varnames[j];
				int cmp = PyObject_RichCompareBool(
					keyword, nm, Py_EQ);
				if (cmp > 0)
					goto kw_found;
				else if (cmp < 0)
					goto fail;
			}
			/* Check errors from Compare */
			if (PyErr_Occurred())
				goto fail;
			if (j >= co->co_argcount) {
				if (kwdict == 0) {
					PyErr_Format(PyExc_TypeError,
					    "%.200s() got an unexpected "
					    "keyword argument '%.400s'",
					    PyString_AsString(co->co_name),
					    PyString_AsString(keyword));
					goto fail;
				}
				PyDict_SetItem(kwdict, keyword, value);
				continue;
			}
kw_found:
			if (GETLOCAL(j) != NULL) {
				PyErr_Format(PyExc_TypeError,
						"%.200s() got multiple "
						"values for keyword "
						"argument '%.400s'",
						PyString_AsString(co->co_name),
						PyString_AsString(keyword));
				goto fail;
			}
			Py_INCREF(value);
			SETLOCAL(j, value);
		}
		if (argcount < co->co_argcount) {
			int m = co->co_argcount - defcount;
			for (i = argcount; i < m; i++) {
				if (GETLOCAL(i) == 0) {
					PyErr_Format(PyExc_TypeError,
					    "%.200s() takes %s %d "
					    "%sargument%s (%d given)",
					    PyString_AsString(co->co_name),
					    ((co->co_flags & CO_VARARGS) ||
					     defcount) ? "at least"
						       : "exactly",
					    m, kwcount ? "non-keyword " : "",
					    m == 1 ? "" : "s", i);
					goto fail;
				}
			}
			if (n > m)
				i = n - m;
			else
				i = 0;
			for (; i < defcount; i++) {
				if (GETLOCAL(m+i) == 0) {
					PyObject *def = defs[i];
					Py_INCREF(def);
					SETLOCAL(m+i, def);
				}
			}
		}
	}
	else {
		if (argcount > 0 || kwcount > 0) {
			PyErr_Format(PyExc_TypeError,
				     "%.200s() takes no arguments (%d given)",
				     PyString_AsString(co->co_name),
				     argcount + kwcount);
			goto fail;
		}
	}
	/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */
	if (PyTuple_GET_SIZE(co->co_cellvars)) {
		int i, j, nargs, found;
		char *cellname, *argname;
		PyObject *c;

		nargs = co->co_argcount;
		if (co->co_flags & CO_VARARGS)
			nargs++;
		if (co->co_flags & CO_VARKEYWORDS)
			nargs++;

		/* Initialize each cell var, taking into account
		   cell vars that are initialized from arguments.

		   Should arrange for the compiler to put cellvars
		   that are arguments at the beginning of the cellvars
		   list so that we can march over it more efficiently?
		*/
		for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {
			cellname = PyString_AS_STRING(
				PyTuple_GET_ITEM(co->co_cellvars, i));
			found = 0;
			for (j = 0; j < nargs; j++) {
				argname = PyString_AS_STRING(
					PyTuple_GET_ITEM(co->co_varnames, j));
				if (strcmp(cellname, argname) == 0) {
					c = PyCell_New(GETLOCAL(j));
					if (c == 0)
						goto fail;
					GETLOCAL(co->co_nlocals + i) = c;
					found = 1;
					break;
				}
			}
			if (found == 0) {
				c = PyCell_New(NULL);
				if (c == 0)
					goto fail;
				SETLOCAL(co->co_nlocals + i, c);
			}
		}
	}
#ifndef PYPY_VERSION
	if (PyTuple_GET_SIZE(co->co_freevars)) {
		int i;
		for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {
			PyObject *o = PyTuple_GET_ITEM(closure, i);
			Py_INCREF(o);
			freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;
		}
	}
#endif
        c_func = ((Py2CCodeObject *)co)->co_function;
        retval = c_func(f);

fail: /* Jump here from prelude on failure */

	/* decref'ing the frame can cause __del__ methods to get invoked,
	   which can call back into Python.  While we're done with the
	   current Python frame (f), the associated C stack is still in use,
	   so recursion_depth must be boosted for the duration.
	*/
	assert(tstate != NULL);
#ifndef PYPY_VERSION
	++tstate->recursion_depth;
#endif
	Py_DECREF(f);
#ifndef PYPY_VERSION
	--tstate->recursion_depth;
#endif
	return retval;
}
""")
elif tuple(sys.version_info)[:2] == (2,7):
    Libr('PyEval_Eval2CCodeEx', 
"""
static PyObject *
PyEval_Eval2CCodeEx(PyCodeObject *, PyObject *,
	   PyObject **, int , PyObject **, int ,
	   PyObject **, int
#ifndef PYPY_VERSION
            , PyObject *);
#else
            );
#endif
""",
"""
/* Local variable macros */

#undef GETLOCAL
#undef SETLOCAL
#define GETLOCAL(i)	(fastlocals[i])

#define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
				     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)

static PyObject *
PyEval_Eval2CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure)
#else
           )
#endif
{
	register PyFrameObject *f;
	register PyObject *retval = NULL;
	register PyObject **fastlocals, **freevars;
	PyThreadState *tstate = PyThreadState_GET();
	PyObject *x, *u;
        PyObject *(*c_func)(PyFrameObject *);

        assert(tstate != NULL);
        f = PyFrame_New(tstate, co, glob, locals);
	if (f == 0)
		return NULL;

	fastlocals = f->f_localsplus;
	freevars = f->f_localsplus + co->co_nlocals;

	if (co->co_argcount > 0 ||
	    co->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) {
		int i;
		int n = argcount;
		PyObject *kwdict = NULL;
		if (co->co_flags & CO_VARKEYWORDS) {
			kwdict = PyDict_New();
			if (kwdict == 0)
				goto fail;
			i = co->co_argcount;
			if (co->co_flags & CO_VARARGS)
				i++;
			SETLOCAL(i, kwdict);
		}
		if (argcount > co->co_argcount) {
			if (!(co->co_flags & CO_VARARGS)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() takes %s %d "
				    "%sargument%s (%d given)",
				    PyString_AsString(co->co_name),
				    defcount ? "at most" : "exactly",
				    co->co_argcount,
				    kwcount ? "non-keyword " : "",
				    co->co_argcount == 1 ? "" : "s",
				    argcount);
				goto fail;
			}
			n = co->co_argcount;
		}
		for (i = 0; i < n; i++) {
			x = args[i];
			Py_INCREF(x);
			SETLOCAL(i, x);
		}
		if (co->co_flags & CO_VARARGS) {
			u = PyTuple_New(argcount - n);
			if (u == 0)
				goto fail;
			SETLOCAL(co->co_argcount, u);
			for (i = n; i < argcount; i++) {
				x = args[i];
				Py_INCREF(x);
				PyTuple_SET_ITEM(u, i-n, x);
			}
		}
		for (i = 0; i < kwcount; i++) {
			PyObject **co_varnames;
			PyObject *keyword = kws[2*i];
			PyObject *value = kws[2*i + 1];
			int j;
                        if (keyword == 0 || !(PyString_Check(keyword)
#ifdef Py_USING_UNICODE
                                     || PyUnicode_Check(keyword)
#endif
                            )) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() keywords must be strings",
				    PyString_AsString(co->co_name));
				goto fail;
			}
			/* Speed hack: do raw pointer compares. As names are
			   normally interned this should almost always hit. */
                        co_varnames = ((PyTupleObject *)(co->co_varnames))->ob_item;
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            if (nm == keyword)
                                goto kw_found;
                        }
                        /* Slow fallback, just in case */
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            int cmp = PyObject_RichCompareBool(
                                keyword, nm, Py_EQ);
                            if (cmp > 0)
                                goto kw_found;
                            else if (cmp < 0)
                                goto fail;
                        }
                        if (kwdict == 0) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got an unexpected "
                                            "keyword argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
                            goto fail;
                        }
                        PyDict_SetItem(kwdict, keyword, value);
                        continue;

kw_found:
			if (GETLOCAL(j) != NULL) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got multiple "
                                            "values for keyword "
                                            "argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
			}
			Py_INCREF(value);
			SETLOCAL(j, value);
		}
		if (argcount < co->co_argcount) {
			int m = co->co_argcount - defcount;
			for (i = argcount; i < m; i++) {
				if (GETLOCAL(i) == 0) {
                                    int j, given = 0;
                                    for (j = 0; j < co->co_argcount; j++)
                                        if (GETLOCAL(j))
                                            given++;
                                    PyErr_Format(PyExc_TypeError,
                                        "%.200s() takes %s %d "
                                        "argument%s (%d given)",
                                        PyString_AsString(co->co_name),
                                        ((co->co_flags & CO_VARARGS) ||
                                        defcount) ? "at least"
                                                : "exactly",
                                        m, m == 1 ? "" : "s", given);
                                    goto fail;
				}
			}
			if (n > m)
				i = n - m;
			else
				i = 0;
			for (; i < defcount; i++) {
				if (GETLOCAL(m+i) == 0) {
					PyObject *def = defs[i];
					Py_INCREF(def);
					SETLOCAL(m+i, def);
				}
			}
		}
	}
	else {
		if (argcount > 0 || kwcount > 0) {
			PyErr_Format(PyExc_TypeError,
				     "%.200s() takes no arguments (%d given)",
				     PyString_AsString(co->co_name),
				     argcount + kwcount);
			goto fail;
		}
	}
	/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */
	if (PyTuple_GET_SIZE(co->co_cellvars)) {
		int i, j, nargs, found;
		char *cellname, *argname;
		PyObject *c;

		nargs = co->co_argcount;
		if (co->co_flags & CO_VARARGS)
			nargs++;
		if (co->co_flags & CO_VARKEYWORDS)
			nargs++;

		/* Initialize each cell var, taking into account
		   cell vars that are initialized from arguments.

		   Should arrange for the compiler to put cellvars
		   that are arguments at the beginning of the cellvars
		   list so that we can march over it more efficiently?
		*/
		for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {
			cellname = PyString_AS_STRING(
				PyTuple_GET_ITEM(co->co_cellvars, i));
			found = 0;
			for (j = 0; j < nargs; j++) {
				argname = PyString_AS_STRING(
					PyTuple_GET_ITEM(co->co_varnames, j));
				if (strcmp(cellname, argname) == 0) {
					c = PyCell_New(GETLOCAL(j));
					if (c == 0)
						goto fail;
					GETLOCAL(co->co_nlocals + i) = c;
					found = 1;
					break;
				}
			}
			if (found == 0) {
				c = PyCell_New(NULL);
				if (c == 0)
					goto fail;
				SETLOCAL(co->co_nlocals + i, c);
			}
		}
	}
#ifndef PYPY_VERSION
	if (PyTuple_GET_SIZE(co->co_freevars)) {
		int i;
		for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {
			PyObject *o = PyTuple_GET_ITEM(closure, i);
			Py_INCREF(o);
			freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;
		}
	}
#endif
        assert(!(co->co_flags & CO_GENERATOR));

        c_func = ((Py2CCodeObject *)co)->co_function;
        retval = c_func(f);

fail: /* Jump here from prelude on failure */

	/* decref'ing the frame can cause __del__ methods to get invoked,
	   which can call back into Python.  While we're done with the
	   current Python frame (f), the associated C stack is still in use,
	   so recursion_depth must be boosted for the duration.
	*/
	assert(tstate != NULL);
#ifndef PYPY_VERSION
	++tstate->recursion_depth;
#endif
	Py_DECREF(f);
#ifndef PYPY_VERSION
	--tstate->recursion_depth;
#endif
	return retval;
}
""")

if tuple(sys.version_info)[:2] == (2,7):
    Libr('kwd_as_string', 
    """static PyObject * kwd_as_string(PyObject *);""",
    """
    static PyObject *
    kwd_as_string(PyObject *kwd) {
    #ifdef Py_USING_UNICODE
        if (PyString_Check(kwd)) {
    #else
            assert(PyString_Check(kwd));
    #endif
            Py_INCREF(kwd);
            return kwd;
    #ifdef Py_USING_UNICODE
        }
        return _PyUnicode_AsDefaultEncodedString(kwd, "replace");
    #endif
    }
    """)
else:
    Libr('kwd_as_string', 
    """
#define kwd_as_string(a) (a)    
    """,
    """
    """)
    
Libr('ctype', 
     """
#include <ctype.h>
""", """
""")

Libr('fastsearch', """
#define FAST_COUNT 0
#define FAST_SEARCH 1
#define FAST_RSEARCH 2

     Py_ssize_t fastsearch(const char* s, Py_ssize_t n,
           const char* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode);""", 
     """
/* Copy from stringlib CPython 2.7.3 */

/* fast search/count implementation, based on a mix between boyer-
   moore and horspool, with a few more bells and whistles on the top.
   for some more background, see: http://effbot.org/zone/stringlib.htm */

/* note: fastsearch may access s[n], which isn't a problem when using
   Python's ordinary string types, but may cause problems if you're
   using this code in other contexts.  also, the count mode returns -1
   if there cannot possible be a match in the target string, and 0 if
   it has actually checked for matches, but didn't find any.  callers
   beware! */
 
#if LONG_BIT >= 128
#define STRINGLIB_BLOOM_WIDTH 128
#elif LONG_BIT >= 64
#define STRINGLIB_BLOOM_WIDTH 64
#elif LONG_BIT >= 32
#define STRINGLIB_BLOOM_WIDTH 32
#else
#error "LONG_BIT is smaller than 32"
#endif

#define STRINGLIB_BLOOM_ADD(mask, ch) \
    ((mask |= (1UL << ((ch) & (STRINGLIB_BLOOM_WIDTH -1)))))
#define STRINGLIB_BLOOM(mask, ch)     \
    ((mask &  (1UL << ((ch) & (STRINGLIB_BLOOM_WIDTH -1)))))

Py_ssize_t
fastsearch(const char* s, Py_ssize_t n,
           const char* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == FAST_COUNT && maxcount == 0))
        return -1;

    /* look for special cases */
    if (m <= 1) {
        if (m <= 0)
            return -1;
        /* use special case for 1-character strings */
        if (mode == FAST_COUNT) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == FAST_SEARCH) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {    /* FAST_RSEARCH */
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != FAST_RSEARCH) {

        /* create compressed boyer-moore delta 1 table */

        /* process pattern[:-1] */
        for (i = 0; i < mlast; i++) {
            STRINGLIB_BLOOM_ADD(mask, p[i]);
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }
        /* process pattern[-1] outside the loop */
        STRINGLIB_BLOOM_ADD(mask, p[mlast]);

        for (i = 0; i <= w; i++) {
            /* note: using mlast in the skip path slows things down on x86 */
            if (s[i+m-1] == p[m-1]) {
                /* candidate match */
                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {
                    /* got a match! */
                    if (mode != FAST_COUNT)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }
                /* miss: check if next character is part of pattern */
                if (!STRINGLIB_BLOOM(mask, s[i+m]))
                    i = i + m;
                else
                    i = i + skip;
            } else {
                /* skip: check if next character is part of pattern */
                if (!STRINGLIB_BLOOM(mask, s[i+m]))
                    i = i + m;
            }
        }
    } else {    /* FAST_RSEARCH */

        /* create compressed boyer-moore delta 1 table */

        /* process pattern[0] outside the loop */
        STRINGLIB_BLOOM_ADD(mask, p[0]);
        /* process pattern[:0:-1] */
        for (i = mlast; i > 0; i--) {
            STRINGLIB_BLOOM_ADD(mask, p[i]);
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {
                /* candidate match */
                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)
                    /* got a match! */
                    return i;
                /* miss: check if previous character is part of pattern */
                if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))
                    i = i - m;
                else
                    i = i - skip;
            } else {
                /* skip: check if previous character is part of pattern */
                if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))
                    i = i - m;
            }
        }
    }

    if (mode != FAST_COUNT)
        return -1;
    return count;
}
     
     """)

Libr('main', 'int main(int argc, char *argv[]);',
     """
int main(int argc, char *argv[])
{
    Py_Initialize();
    PySys_SetArgv(argc, argv);
    init_main();
    Py_Finalize();
    return 0;
}
""")     

Libr('from_ceval_2_7_special_lookup',
"""
static PyObject * from_ceval_2_7_enter = NULL;
static PyObject * from_ceval_2_7_exit = NULL;
static PyObject * from_ceval_2_7_special_lookup(PyObject *, char *, PyObject **);
""",
"""
static PyObject *
from_ceval_2_7_special_lookup(PyObject *o, char *meth, PyObject **cache)
{
    PyObject *res;
    if (PyInstance_Check(o)) {
        if (!*cache)
            return PyObject_GetAttrString(o, meth);
        else
            return PyObject_GetAttr(o, *cache);
    }
    res = _PyObject_LookupSpecial(o, meth, cache);
    if (res == 0 && !PyErr_Occurred()) {
        PyErr_SetObject(PyExc_AttributeError, *cache);
        return NULL;
    }
    return res;
}
""")

Libr('Direct_AddTraceback',
"""
static void Direct_AddTraceback (PyCodeObject *, int, int);
""",
"""
static void Direct_AddTraceback (PyCodeObject * py_code, int lineno, int addr)
{
  PyFrameObject *py_frame = 0;

  py_frame = PyFrame_New (PyThreadState_GET (),	/*PyThreadState *tstate, */
			  py_code,	/*PyCodeObject *code, */
			  glob,	/*PyObject *globals, */
			  0	/*PyObject *locals */
    );
  if (!py_frame)
    goto bad;
/*  printf("--- line %d\\n", lineno);  */
  py_frame->f_lineno = lineno;
#ifndef PYPY_VERSION
  py_frame->f_lasti = addr;
#endif  
  PyTraceBack_Here (py_frame);
bad:
  Py_XDECREF (py_frame);
}
""")   
  
Libr('STR_CONCAT2',
"""
static PyObject * STR_CONCAT2( PyObject *, PyObject * );
""",
"""
static PyObject * STR_CONCAT2( PyObject *a, PyObject * b)
{
   if (PyString_CheckExact(a) && PyString_CheckExact(b)) {
      PyObject * r;
      char buf[1024];
      Py_ssize_t l_a, l_b, l_r;
      l_a = PyString_GET_SIZE(a); 
      l_b = PyString_GET_SIZE(b);
      if (l_b == 0) {
        Py_INCREF(a);
        return a;
      }
      if (l_a == 0) {
        Py_INCREF(b);
        return b;
      }
      if ((l_r = (l_a + l_b)) < 1024) {
        Py_MEMCPY(buf, PyString_AS_STRING(a), l_a);
        Py_MEMCPY(buf + l_a, PyString_AS_STRING(b), l_b);
        r = PyString_FromStringAndSize(buf, l_r);
      } else {  
        r = PyString_FromStringAndSize(PyString_AS_STRING(a), l_a);
        PyString_Concat(&r, b);
      }  
      return r;
   } else {
      return PyNumber_Add(a,b);
   }
}
""")   
  
Libr('STR_CONCAT3',
"""
static PyObject * STR_CONCAT3( PyObject *, PyObject *, PyObject *);
""",
"""
static PyObject * STR_CONCAT3( PyObject *a, PyObject * b, PyObject * c)
{
   PyObject * r, *r1;
   if (PyString_CheckExact(a) && PyString_CheckExact(b) && PyString_CheckExact(c)) {
      char buf[1024];
      Py_ssize_t l_a, l_b, l_c, l_r;
      l_a = PyString_GET_SIZE(a); 
      l_b = PyString_GET_SIZE(b);
      l_c = PyString_GET_SIZE(c);
      if ((l_r = (l_a + l_b + l_c)) < 1024) {
        Py_MEMCPY(buf, PyString_AS_STRING(a), l_a);
        Py_MEMCPY(buf + l_a, PyString_AS_STRING(b), l_b);
        Py_MEMCPY(buf + (l_a + l_b), PyString_AS_STRING(c), l_c);
        r = PyString_FromStringAndSize(buf, l_r);
      } else {  
        r = PyString_FromStringAndSize(PyString_AS_STRING(a), l_a);
        PyString_Concat(&r, b);
        PyString_Concat(&r, c);
      }  
      return r;
   } else {
      r = PyNumber_Add(a,b);
      r1 = PyNumber_Add(r,c);
      Py_DECREF(r);
      return r1;
   }
}
""")    

Libr('STR_CONCAT_N',
"""
static PyObject * STR_CONCAT_N( int, PyObject *, ...);
""",
"""
static PyObject * STR_CONCAT_N( int na, PyObject *a, ...)
{
    typedef PyObject * pyref;
    pyref args[64];
    int len[64];
    int i;
    va_list vargs;
    int strflag = 1;
    Py_ssize_t l_r;
    PyObject * r, *r1;
    char * s;
    
    assert(na>=2);
    args[0] = a; 
    va_start(vargs, a);
    for (i = 1; i < na; i++) {
        args[i] = va_arg(vargs, PyObject *);
    }    
    va_end(vargs);
    strflag = 1;
    l_r = 0;
    for (i = 0; i < na; i ++) {
        strflag = PyString_CheckExact(args[i]);
        if (!strflag) break;
        l_r += (len[i] = PyString_GET_SIZE(args[i]));
    }
    if (strflag) {   
        r = PyString_FromStringAndSize(NULL, l_r);
        s = PyString_AS_STRING(r);
        for (i = 0; i < na; i ++) {
            Py_MEMCPY(s, PyString_AS_STRING(args[i]), len[i]);
            s += len[i];
        }
        return r;
    }    
    r = PyNumber_Add(args[0], args[1]);
    for (i = 2; i < na; i ++) {
      r1 = PyNumber_Add(r, args[i]);
      Py_DECREF(r);
      r = r1;
    }
    return r;
}
""")
  
Libr('from_ceval_call_exc_trace',
"""
static void
from_ceval_call_exc_trace(Py_tracefunc, PyObject *, PyFrameObject *);
""",
"""
static void
from_ceval_call_exc_trace(Py_tracefunc func, PyObject *self, PyFrameObject *f)
{
	PyObject *type, *value, *traceback, *arg;
	int err;
	PyErr_Fetch(&type, &value, &traceback);
	if (value == 0) {
		value = Py_None;
		Py_INCREF(value);
	}
	arg = PyTuple_Pack(3, type, value, traceback);
	if (arg == 0) {
		PyErr_Restore(type, value, traceback);
		return;
	}
	err = from_ceval_call_trace(func, self, f, PyTrace_EXCEPTION, arg);
	Py_DECREF(arg);
	if (err == 0)
		PyErr_Restore(type, value, traceback);
	else {
		Py_XDECREF(type);
		Py_XDECREF(value);
		Py_XDECREF(traceback);
	}
}
""")   
  
Libr('from_ceval_call_trace',
"""
static int
from_ceval_call_trace(Py_tracefunc , PyObject *, PyFrameObject *,
	   int , PyObject *);
""",
"""
static int
from_ceval_call_trace(Py_tracefunc func, PyObject *obj, PyFrameObject *frame,
	   int what, PyObject *arg)
{
	register PyThreadState *tstate = frame->f_tstate;
	int result;
	if (tstate->tracing)
		return 0;
	tstate->tracing++;
	tstate->use_tracing = 0;
	result = func(obj, frame, what, arg);
	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
			       || (tstate->c_profilefunc != NULL));
	tstate->tracing--;
	return result;
}
""")   
  
Libr('from_ceval_BINARY_SUBSCR',
"""
static PyObject * from_ceval_BINARY_SUBSCR ( PyObject *, PyObject *);
""",
"""
static PyObject * from_ceval_BINARY_SUBSCR ( PyObject *v, PyObject *w)
{
    PyObject * x = NULL;
/*#    goto slow_get;*/
    if (PyList_CheckExact(v) && PyInt_CheckExact(w)) {
            /* INLINE: list[int] */
            Py_ssize_t i = PyInt_AS_LONG(w);
            if (i < 0)
                    i += PyList_GET_SIZE(v);
            if (i >= 0 && i < PyList_GET_SIZE(v)) {
                    x = PyList_GET_ITEM(v, i);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v) && PyInt_CheckExact(w)) {
            /* INLINE: list[int] */
            Py_ssize_t i = PyInt_AS_LONG(w);
            if (i < 0)
                    i += PyTuple_GET_SIZE(v);
            if (i >= 0 && i < PyTuple_GET_SIZE(v)) {
                    x = PyTuple_GET_ITEM(v, i);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
        slow_get:
            x = PyObject_GetItem(v, w);
    return x;
}
""")   
  
Libr('c_LOAD_NAME',
"""
static PyObject * c_LOAD_NAME (PyFrameObject *, PyObject *);
""",
"""
static PyObject * c_LOAD_NAME (PyFrameObject *f, PyObject *w)
{
        PyObject * v;
        PyObject * x;
        if ((v = f->f_locals) == 0) {
                PyErr_Format(PyExc_SystemError,
                                "no locals when loading %s",
                                PyObject_REPR(w));
                return NULL;
        }
        if (PyDict_CheckExact(v)) {
                x = PyDict_GetItem(v, w);
                Py_XINCREF(x);
        }
        else {
                x = PyObject_GetItem(v, w);
                if (x == 0 && PyErr_Occurred()) {
                        if (!PyErr_ExceptionMatches(
                                        PyExc_KeyError))
                                return NULL;
                        PyErr_Clear();
                }
        }
        if (x == 0) {
                x = PyDict_GetItem(glob, w);
                if (x == 0) {
                        x = PyDict_GetItem(bdict, w);
                        if (x == 0) {
                            char *obj_str;
                            obj_str = PyString_AsString(w);
                            if (obj_str)
                                PyErr_Format(PyExc_NameError, NAME_ERROR_MSG, obj_str);
                                return NULL;
                        }
                }
                Py_INCREF(x);
        }
        return x;
}
""")   

if not is_pypy:  
    Libr('c_LOAD_GLOBAL',
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *, long);
    """,
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *w, long hash)
    {
            PyObject * x;
                    /* Inline the PyDict_GetItem() calls.
                        WARNING: this is an extreme speed hack.
                        Do not try this at home. */
            if (hash != -1) {
                    PyDictObject *d;
                    PyDictEntry *e;
                    d = (PyDictObject *)(glob);
                    e = d->ma_lookup(d, w, hash);
                    if (e == 0) {
                            x = NULL;
                            return NULL;
                    }
                    x = e->me_value;
                    if (x != NULL) {
                            Py_INCREF(x);
                            return x;
                    }
                    d = (PyDictObject *)(bdict);
                    e = d->ma_lookup(d, w, hash);
                    if (e == 0) {
                            x = NULL;
                            return NULL;
                    }
                    x = e->me_value;
                    if (x != NULL) {
                            Py_INCREF(x);
                            return x;
                    }
                    goto load_global_error;
            }
            /* This is the un-inlined version of the code above */
            x = PyDict_GetItem(glob, w);
            if (x == 0) {
                    x = PyDict_GetItem(b, w);
                    if (x == 0) {
                        load_global_error:
                            PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, 
                                            PyString_AsString(w));
                            return NULL;
                    }
            }
            Py_INCREF(x);
            return x;
    }
    """)   
else:
    Libr('c_LOAD_GLOBAL',
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *, long);
    """,
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *w, long hash)
    {
            PyObject * x;
            /* This is the un-inlined version of the code above */
            x = PyDict_GetItem(glob, w);
            if (x == 0) {
                    x = PyDict_GetItem(b, w);
                    if (x == 0) {
                            PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, 
                                            PyString_AsString(w));
                            return NULL;
                    }
            }
            Py_INCREF(x);
            return x;
    }
    """)   

Libr('c_BINARY_SUBSCR_SUBSCR_Int_Int',
"""
static PyObject * c_BINARY_SUBSCR_SUBSCR_Int_Int(PyObject *, int, PyObject *, int, PyObject *);
""",
"""
static PyObject * c_BINARY_SUBSCR_SUBSCR_Int_Int(PyObject *v, Py_ssize_t i1, 
PyObject *const_i1, Py_ssize_t i2, PyObject * const_i2)
{
    PyObject * x = NULL;
    PyObject * x0 = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l = PyList_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    goto next;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l = PyTuple_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    goto next;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            x = PyObject_GetItem(v, const_i1);
    next:        
    x0 = x;
    v = x;        
    if (v == 0) return v;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l = PyList_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i2 < 0)
                    i2 += l;
            if (i2 >= 0 && i2 < l) {
                    x = PyList_GET_ITEM(v, i2);
                    Py_INCREF(x);
                    Py_DECREF(x0);
                    return x;
            }
            else
                    goto slow_get2;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l = PyTuple_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i2 < 0)
                    i2 += l;
            if (i2 >= 0 && i2 < l) {
                    x = PyTuple_GET_ITEM(v, i2);
                    Py_INCREF(x);
                    Py_DECREF(x0);
                    return x;
            }
            else
                    goto slow_get2;
    }
    else
        slow_get2:
            x = PyObject_GetItem(v, const_i2);
    Py_DECREF(x0);
    return x;
}
""")   
  
Libr('__c_BINARY_SUBSCR_Int',
"""
static PyObject * __c_BINARY_SUBSCR_Int(PyObject *, Py_ssize_t);
""",
"""
static PyObject * __c_BINARY_SUBSCR_Int(PyObject *v, Py_ssize_t i1)
{
    PyObject *const_i1 = NULL;
    PyObject * x = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyList_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyTuple_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            const_i1 = PyInt_FromLong (i1);
            x = PyObject_GetItem(v, const_i1);
            Py_CLEAR(const_i1);
    return x;
}
""")   

Libr('_c_BINARY_SUBSCR_Int',
"""
static PyObject * _c_BINARY_SUBSCR_Int(PyObject *, Py_ssize_t, PyObject *);
""",
"""
static PyObject * _c_BINARY_SUBSCR_Int(PyObject *v, Py_ssize_t i1, PyObject *const_i1)
{
    PyObject * x = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyList_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyTuple_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            x = PyObject_GetItem(v, const_i1);
    return x;
}
""")   


Libr('___c_BINARY_SUBSCR_Int',
"""
static PyObject * ___c_BINARY_SUBSCR_Int(PyObject *, Py_ssize_t);
""",
"""
static PyObject * ___c_BINARY_SUBSCR_Int(PyObject *v, Py_ssize_t i1)
{
    PyObject *const_i1 = NULL;
    PyObject * x = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyList_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyTuple_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            const_i1 = PyInt_FromLong (i1);
            Py_INCREF(v);
            x = PyObject_GetItem(v, const_i1);
            Py_DECREF(v);
            Py_DECREF(const_i1);
    return x;
}
""")   
  
Libr('Py2CFunction_New',
"""
static PyObject * Py2CFunction_New(PyObject *);
""",
"""
static PyObject * Py2CFunction_New(PyObject *code)
{
	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
					    &Py2CFunction_Type);
	static PyObject *__name__ = 0;
	if (op != NULL) {
		PyObject *doc;
		PyObject *consts;
		PyObject *module;
		op->func_weakreflist = NULL;
		Py_INCREF(code);
		op->func_code = code;
		Py_INCREF(glob);
		op->func_globals = glob;
		op->func_name = ((PyCodeObject *)code)->co_name;
		Py_INCREF(op->func_name);
		op->func_defaults = NULL; /* No default arguments */
		op->func_closure = NULL;
		consts = ((PyCodeObject *)code)->co_consts;
		if (PyTuple_Size(consts) >= 1) {
			doc = PyTuple_GetItem(consts, 0);
			if (!PyString_Check(doc) && !PyUnicode_Check(doc))
				doc = Py_None;
		}
		else
			doc = Py_None;
		Py_INCREF(doc);
		op->func_doc = doc;
		op->func_dict = NULL;
		op->func_module = NULL;

		/* __module__: If module name is in globals, use it.
		   Otherwise, use None.
		*/
		if (!__name__) {
			__name__ = PyString_InternFromString("__name__");
			if (!__name__) {
				Py_DECREF(op);
				return NULL;
			}
		}
		module = PyDict_GetItem(glob, __name__);
		if (module) {
		    Py_INCREF(module);
		    op->func_module = module;
		}
	}
	else
		return NULL;
	PyObject_GC_Track(op);
	return (PyObject *)op;
}
""")   
  
Libr('Py2CFunction_New_Simple',
"""
static PyObject * Py2CFunction_New_Simple(PyObject *, PyTypeObject *);
""",
"""
static PyObject * Py2CFunction_New_Simple(PyObject *code, PyTypeObject * ty)
{
	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
					    ty);
	static PyObject *__name__ = 0;
	if (op != NULL) {
		PyObject *doc;
		PyObject *consts;
		PyObject *module;
		op->func_weakreflist = NULL;
		Py_INCREF(code);
		op->func_code = code;
		Py_INCREF(glob);
		op->func_globals = glob;
		op->func_name = ((PyCodeObject *)code)->co_name;
		Py_INCREF(op->func_name);
		op->func_defaults = NULL; /* No default arguments */
		op->func_closure = NULL;
		consts = ((PyCodeObject *)code)->co_consts;
		if (PyTuple_Size(consts) >= 1) {
			doc = PyTuple_GetItem(consts, 0);
			if (!PyString_Check(doc) && !PyUnicode_Check(doc))
				doc = Py_None;
		}
		else
			doc = Py_None;
		Py_INCREF(doc);
		op->func_doc = doc;
		op->func_dict = NULL;
		op->func_module = NULL;

		/* __module__: If module name is in globals, use it.
		   Otherwise, use None.
		*/
		if (!__name__) {
			__name__ = PyString_InternFromString("__name__");
			if (!__name__) {
				Py_DECREF(op);
				return NULL;
			}
		}
		module = PyDict_GetItem(glob, __name__);
		if (module) {
		    Py_INCREF(module);
		    op->func_module = module;
		}
	}
	else
		return NULL;
	PyObject_GC_Track(op);
	return (PyObject *)op;
}
""")   
  
Libr('Py2CFunction_SetClosure',
"""
static int
Py2CFunction_SetClosure(PyObject *, PyObject *);
""",
"""
static int
Py2CFunction_SetClosure(PyObject *op, PyObject *closure)
{
	if (closure == Py_None)
		closure = NULL;
	else if (PyTuple_Check(closure)) {
		Py_INCREF(closure);
	}
	else {
		PyErr_Format(PyExc_SystemError, 
			     "expected tuple for closure, got '%.100s'",
			     closure->ob_type->tp_name);
		return -1;
	}
	Py_XDECREF(((PyFunctionObject *) op) -> func_closure);
	((PyFunctionObject *) op) -> func_closure = closure;
	return 0;
}
""")   
  
Libr('Py2CFunction_SetDefaults',
"""
static int
Py2CFunction_SetDefaults(PyObject *o, PyObject *);
""",
"""
static int
Py2CFunction_SetDefaults(PyObject *op, PyObject *defaults)
{
	if (defaults == Py_None)
		defaults = NULL;
	else if (defaults && PyTuple_Check(defaults)) {
		Py_INCREF(defaults);
	}
	else {
		PyErr_SetString(PyExc_SystemError, "non-tuple default args");
		return -1;
	}
	Py_XDECREF(((PyFunctionObject *) op) -> func_defaults);
	((PyFunctionObject *) op) -> func_defaults = defaults;
	return 0;
}
""")  
   
Libr('_PyEval_PRINT_ITEM_1',
"""
static int _PyEval_PRINT_ITEM_1 ( PyObject * );
""",
"""
static int _PyEval_PRINT_ITEM_1 ( PyObject * v)
{
    return _PyEval_PRINT_ITEM_TO_2 ( NULL, v );
}
""") 
    
Libr('_PyEval_PRINT_ITEM_TO_2',
"""
static int _PyEval_PRINT_ITEM_TO_2 ( PyObject * , PyObject *);
""",
"""
static int _PyEval_PRINT_ITEM_TO_2 ( PyObject * stream, PyObject * v)
{
        PyObject * w = stream; 
        int err = 0;
        if (stream == 0 || stream == Py_None) {
                w = PySys_GetObject("stdout");
                if (w == 0) {
                        PyErr_SetString(PyExc_RuntimeError,
                                        "lost sys.stdout");
                        err = -1;
                }
        }
        /* PyFile_SoftSpace() can exececute arbitrary code
            if sys.stdout is an instance with a __getattr__.
            If __getattr__ raises an exception, w will
            be freed, so we need to prevent that temporarily. */
        Py_XINCREF(w);
        if (w != NULL && PyFile_SoftSpace(w, 0))
                err = PyFile_WriteString(" ", w);
        if (err == 0)
                err = PyFile_WriteObject(v, w, Py_PRINT_RAW);
        if (err == 0) {
            /* XXX move into writeobject() ? */
            if (PyString_Check(v)) {
                char *s = PyString_AS_STRING(v);
                Py_ssize_t len = PyString_GET_SIZE(v);
                if (len == 0 ||
                    !isspace(Py_CHARMASK(s[len-1])) ||
                    s[len-1] == ' ')
                        PyFile_SoftSpace(w, 1);
            }
#ifdef Py_USING_UNICODE
            else if (PyUnicode_Check(v)) {
                Py_UNICODE *s = PyUnicode_AS_UNICODE(v);
                Py_ssize_t len = PyUnicode_GET_SIZE(v);
                if (len == 0 ||
                    !Py_UNICODE_ISSPACE(s[len-1]) ||
                    s[len-1] == ' ')
                    PyFile_SoftSpace(w, 1);
            }
#endif
            else
                    PyFile_SoftSpace(w, 1);
        }
        Py_XDECREF(w);
   /*     Py_DECREF(v); */
        if (w != stream) {
            Py_XDECREF(stream);
        }
        stream = NULL;
        return err;
}
""") 
    
Libr('_PyEval_PRINT_NEWLINE_TO_1',
"""
static int _PyEval_PRINT_NEWLINE_TO_1 ( PyObject * );
""",
"""
static int _PyEval_PRINT_NEWLINE_TO_1 ( PyObject * stream )
{
        PyObject * w = stream;
        int err = 0;
        if (stream == 0 || stream == Py_None) {
                w = PySys_GetObject("stdout");
                if (w == 0) {
                        PyErr_SetString(PyExc_RuntimeError,
                                        "lost sys.stdout");
                        return -1;
                }                    
        }
        if (w != NULL) {
                /* w.write() may replace sys.stdout, so we
                    * have to keep our reference to it */
                Py_INCREF(w);
                err = PyFile_WriteString("\\n", w);
                if (err == 0)
                        PyFile_SoftSpace(w, 0);                        
                Py_DECREF(w);
        }
        if (w != stream) {
            Py_XDECREF(stream);
        }
        stream = NULL;
        return err;
}
""") 
    
Libr('_PyEval_set_exc_info',
"""
static void
_PyEval_set_exc_info(PyThreadState *tstate,
	     PyObject *type, PyObject *value, PyObject *tb);
""",
"""
static void
_PyEval_set_exc_info(PyThreadState *tstate,
	     PyObject *type, PyObject *value, PyObject *tb)
{
	PyFrameObject *frame = tstate->frame;
	PyObject *tmp_type, *tmp_value, *tmp_tb;

	assert(type != NULL);
	assert(frame != NULL);
	if (frame->f_exc_type == 0) {
		assert(frame->f_exc_value == 0);
		assert(frame->f_exc_traceback == 0);
		/* This frame didn't catch an exception before. */
		/* Save previous exception of this thread in this frame. */
		if (tstate->exc_type == 0) {
			/* XXX Why is this set to Py_None? */
			Py_INCREF(Py_None);
			tstate->exc_type = Py_None;
		}
		Py_INCREF(tstate->exc_type);
		Py_XINCREF(tstate->exc_value);
		Py_XINCREF(tstate->exc_traceback);
		frame->f_exc_type = tstate->exc_type;
		frame->f_exc_value = tstate->exc_value;
		frame->f_exc_traceback = tstate->exc_traceback;
	}
	/* Set new exception for this thread. */
	tmp_type = tstate->exc_type;
	tmp_value = tstate->exc_value;
	tmp_tb = tstate->exc_traceback;
	Py_INCREF(type);
	Py_XINCREF(value);
	Py_XINCREF(tb);
	tstate->exc_type = type;
	tstate->exc_value = value;
	tstate->exc_traceback = tb;
	Py_XDECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);
	/* For b/w compatibility */
	PySys_SetObject("exc_type", type);
	PySys_SetObject("exc_value", value);
	PySys_SetObject("exc_traceback", tb);
}
""")

if not is_pypy:
    Libr('_PyEval_reset_exc_info',
"""
static void _PyEval_reset_exc_info(PyThreadState *);
""",
"""
static void
_PyEval_reset_exc_info(PyThreadState *tstate)
{
	PyFrameObject *frame;
	PyObject *tmp_type, *tmp_value, *tmp_tb;

	/* It's a precondition that the thread state's frame caught an
	 * exception -- verify in a debug build.
	 */
	assert(tstate != NULL);
	frame = tstate->frame;
	assert(frame != NULL);
	assert(frame->f_exc_type != NULL);

	/* Copy the frame's exception info back to the thread state. */
	tmp_type = tstate->exc_type;
	tmp_value = tstate->exc_value;
	tmp_tb = tstate->exc_traceback;
	Py_INCREF(frame->f_exc_type);
	Py_XINCREF(frame->f_exc_value);
	Py_XINCREF(frame->f_exc_traceback);
	tstate->exc_type = frame->f_exc_type;
	tstate->exc_value = frame->f_exc_value;
	tstate->exc_traceback = frame->f_exc_traceback;
	Py_XDECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);

	/* For b/w compatibility */
	PySys_SetObject("exc_type", frame->f_exc_type);
	PySys_SetObject("exc_value", frame->f_exc_value);
	PySys_SetObject("exc_traceback", frame->f_exc_traceback);

	/* Clear the frame's exception info. */
	tmp_type = frame->f_exc_type;
	tmp_value = frame->f_exc_value;
	tmp_tb = frame->f_exc_traceback;
	frame->f_exc_type = NULL;
	frame->f_exc_value = NULL;
	frame->f_exc_traceback = NULL;
	Py_DECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);
}
""")
else:
    Libr('_PyEval_reset_exc_info',
"""
static void _PyEval_reset_exc_info(PyThreadState *);
""",
"""
static void
_PyEval_reset_exc_info(PyThreadState *tstate)
{
	/* It's a precondition that the thread state's frame caught an
	 * exception -- verify in a debug build.
	 */
	assert(tstate != NULL);

	/* For b/w compatibility */
	PySys_SetObject("exc_type", tstate->exc_type);
	PySys_SetObject("exc_value", tstate->exc_value);
	PySys_SetObject("exc_traceback", tstate->exc_traceback);

}
""")
       
Libr('_PyEval_ApplySlice',
"""
static PyObject *
_PyEval_ApplySlice(PyObject *, PyObject *, PyObject *);
""",
"""
static PyObject *
_PyEval_ApplySlice(PyObject *u, PyObject *v, PyObject *w) /* return u[v:w] */
{
	PyTypeObject *tp = u->ob_type;
	PySequenceMethods *sq = tp->tp_as_sequence;

	if (sq && sq->sq_slice && ISINDEX(v) && ISINDEX(w)) {
		Py_ssize_t ilow = 0, ihigh = PY_SSIZE_T_MAX;
		if (!_PyEval_SliceIndex(v, &ilow))
			return NULL;
		if (!_PyEval_SliceIndex(w, &ihigh))
			return NULL;
		return PySequence_GetSlice(u, ilow, ihigh);
	}
	else {
		PyObject *slice = PySlice_New(v, w, NULL);
		if (slice != NULL) {
			PyObject *res = PyObject_GetItem(u, slice);
			Py_DECREF(slice);
			return res;
		}
		else
			return NULL;
	}
}
""")     

Libr('_PyEval_AssignSlice',
"""
static int
_PyEval_AssignSlice(PyObject *, PyObject *, PyObject *, PyObject *);
""",
"""
static int
_PyEval_AssignSlice(PyObject *u, PyObject *v, PyObject *w, PyObject *x)
	/* u[v:w] = x */
{
	PyTypeObject *tp = u->ob_type;
	PySequenceMethods *sq = tp->tp_as_sequence;

	if (sq && sq->sq_ass_slice && ISINDEX(v) && ISINDEX(w)) {
		Py_ssize_t ilow = 0, ihigh = PY_SSIZE_T_MAX;
		if (!_PyEval_SliceIndex(v, &ilow))
			return -1;
		if (!_PyEval_SliceIndex(w, &ihigh))
			return -1;
		if (x == 0)
			return PySequence_DelSlice(u, ilow, ihigh);
		else
			return PySequence_SetSlice(u, ilow, ihigh, x);
	}
	else {
		PyObject *slice = PySlice_New(v, w, NULL);
		if (slice != NULL) {
			int res;
			if (x != NULL)
				res = PyObject_SetItem(u, slice, x);
			else
				res = PyObject_DelItem(u, slice);
			Py_DECREF(slice);
			return res;
		}
		else
			return -1;
	}
}
""")

Libr('_Call_CompiledWithFrame',
"""
static PyObject * _Call_CompiledWithFrame(void *, PyObject *, int, ...);
""",
"""
static PyObject * _Call_CompiledWithFrame(void * func, PyObject *_co, int cnt_arg, ...)
{
        PyCodeObject *co = (PyCodeObject *)_co;
        PyFrameObject *f;
        PyObject *retval = NULL;
        PyThreadState *tstate = PyThreadState_GET();
        PyObject **fastlocals;
        PyObject *o;
        int i;
        PyObject *(*c_func)(PyFrameObject *);
        va_list vargs;
        va_start(vargs, cnt_arg);
		/* XXX Perhaps we should create a specialized
		   PyFrame_New() that doesn't take locals, but does
		   take builtins without sanity checking them.
		*/
        assert(tstate != NULL);
        f = PyFrame_New(tstate, co, glob, NULL);
        if (f == 0)
                return NULL;

        fastlocals = f->f_localsplus;
        
        for (i = 0; i < cnt_arg; i++) {
                o = va_arg(vargs, PyObject *);
                Py_INCREF(o);
                fastlocals[i] = o;
        }
        va_end(vargs);
        c_func = func;
        retval = c_func(f);
#ifndef PYPY_VERSION
	++tstate->recursion_depth;
#endif
        Py_DECREF(f);
#ifndef PYPY_VERSION
	--tstate->recursion_depth;
#endif
        return retval;
}
""")

Libr('FastCall',
"""
static PyObject * FastCall(int, PyObject *, ...);
""",
"""
static PyObject * FastCall(int na, PyObject *v,...)
{
    typedef PyObject * pyref;
    pyref args[18];
    pyref * r_arg;
    PyObject *func;
    int i;
    va_list vargs;
//    r_arg = args+1;
//    printf ("=fastcall\\n");
    func = v;    
    Py_INCREF(func);

    va_start(vargs, v);
    args[0] = NULL;
    for (i = 0; i < na; i++) 
        args[i+1] = va_arg(vargs, PyObject *);
    va_end(vargs);
    r_arg = args+1;
            
    if (PyCFunction_Check(func)) {
        int flags = PyCFunction_GET_FLAGS(func);
        PyObject *x;
    
//        printf ("=cfunc 1\\n");
        if (flags & (METH_NOARGS | METH_O)) {
            PyCFunction meth = PyCFunction_GET_FUNCTION(func);
            PyObject *self = PyCFunction_GET_SELF(func);
            if (flags & METH_NOARGS && na == 0) {
                x = (*meth)(self,NULL);
                Py_DECREF(func);
                return x;
            }
            else if (flags & METH_O && na == 1) {
                Py_INCREF(args[1]);                           
                x = (*meth)(self,args[1]);
                Py_DECREF(args[1]);
                Py_DECREF(func);
                return x;
            } else
            goto stand_c;
        }
        else {  stand_c: 
            { 
                PyObject *callargs = PyTuple_New(na);
                for (i = 0; i < na; i++) {
                    Py_INCREF(args[i+1]);
                    PyTuple_SET_ITEM(callargs, i, args[i+1]);
                }
                x = PyCFunction_Call(func,callargs,NULL);
                Py_XDECREF(callargs);
                Py_DECREF(func);
                return x;
            }        
        }
    } 
    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *oldfunc = func;
        args[0] = PyMethod_GET_SELF(func);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(oldfunc);
        na++;
//        printf ("=meth 1\\n");
        r_arg = args;
    } // else {
      //  Py_INCREF(func);  
    //}
    if (Py2CFunction_Check(func)) {
        Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
        PyObject *globals = PyFunction_GET_GLOBALS(func);
        PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
        PyObject **d = NULL;
        PyObject *(*c_func)(PyFrameObject *);
        int nd = 0;

//        printf ("=2Cfunc 1\\n");
        if (argdefs == 0 && co->_body.co_argcount == na && 
                co->_body.co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
            PyFrameObject *f;
            PyObject *retval = NULL;
            PyThreadState *tstate = PyThreadState_GET();
            PyObject **fastlocals;
            int i;

            assert(globals != NULL);
            assert(tstate != NULL);
            f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
            if (f == 0) {
                return NULL;
            }

            fastlocals = f->f_localsplus;
            for (i = 0; i < na; i++) {
                Py_INCREF(r_arg[i]);
                fastlocals[i] = r_arg[i];
            }
            c_func = co->co_function;
            retval = c_func(f);
#ifndef PYPY_VERSION
	    ++tstate->recursion_depth;
#endif
            Py_DECREF(f);
#ifndef PYPY_VERSION
            --tstate->recursion_depth;
#endif
            Py_DECREF(func);
            return retval;
        }
        if (argdefs != NULL) {
            d = &PyTuple_GET_ITEM(argdefs, 0);
            nd = Py_SIZE(argdefs);
        }
        Py_DECREF(func);
        return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                (PyObject *)NULL, r_arg, na,
                                NULL, 0, d, nd
#ifndef PYPY_VERSION
                                ,
                                PyFunction_GET_CLOSURE(func));
#else
                                );
#endif
    }
    else if (PyFunction_Check(func)) {
        PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
        PyObject *globals = PyFunction_GET_GLOBALS(func);
        PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
        PyObject **d = NULL;
        int nd = 0;

//        printf ("=Func 1\\n");
        if (argdefs == 0 && co->co_argcount == na && 
                co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
            PyFrameObject *f;
            PyObject *retval = NULL;
            PyThreadState *tstate = PyThreadState_GET();
            PyObject **fastlocals;
            int i;

            assert(globals != NULL);
            assert(tstate != NULL);
            f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
            if (f == 0)
                return NULL;

            fastlocals = f->f_localsplus;
            for (i = 0; i < na; i++) {
                Py_INCREF(r_arg[i]);
                fastlocals[i] = r_arg[i];
            }
            retval = PyEval_EvalFrameEx(f,0);
#ifndef PYPY_VERSION
	    ++tstate->recursion_depth;
#endif
            Py_DECREF(f);
#ifndef PYPY_VERSION
            --tstate->recursion_depth;
#endif
            Py_DECREF(func);
            return retval;
        }
        if (argdefs != NULL) {
            d = &PyTuple_GET_ITEM(argdefs, 0);
            nd = Py_SIZE(argdefs);
        }
        Py_DECREF(func);
        return PyEval_EvalCodeEx(co, globals,
                                (PyObject *)NULL, r_arg, na,
                                NULL, 0, d, nd,
                                PyFunction_GET_CLOSURE(func));
    } else {
//        printf ("=others 1\\n");
        PyObject *callargs = PyTuple_New(na);
        PyObject *x;
        for (i = 0; i < na; i++) {
            Py_INCREF(r_arg[i]);
            PyTuple_SET_ITEM(callargs, i, r_arg[i]);
        }
        x = PyObject_Call(func,callargs,NULL);
        Py_XDECREF(callargs);
        Py_DECREF(func);
        return x;
    }
}
""")

if not is_pypy:
    Libr('FastCall0',
"""
static PyObject * FastCall0(PyObject *);
""",
"""
static PyObject * FastCall0(PyObject *v)
{
    typedef PyObject * pyref;
    PyObject *func;
    PyObject *self = NULL;

    func = v;    
    Py_INCREF(func);
            
    if (PyCFunction_Check(func)) {
        int flags = PyCFunction_GET_FLAGS(func);
        PyObject *self = PyCFunction_GET_SELF(func);
        PyObject *x;
    
        if (flags & METH_NOARGS) {
            PyCFunction meth = PyCFunction_GET_FUNCTION(func);
            x = (*meth)(self,NULL);
        }
        else { 
            Py_INCREF(empty_tuple);
            x = PyCFunction_Call(func,empty_tuple,NULL);
            Py_DECREF(empty_tuple);
        }
        Py_DECREF(func);
        return x;
    } 
    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *oldfunc = func;
        self = PyMethod_GET_SELF(func);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(oldfunc);
    
        if (Py2CFunction_Check(func)) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;
    
            if (argdefs == 0 && co->_body.co_argcount == 1 && 
                    co->_body.co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState *tstate = PyThreadState_GET();
                PyObject **fastlocals;
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }
    
                fastlocals = f->f_localsplus;
                Py_INCREF(self);
                fastlocals[0] = self;
                c_func = co->co_function;
                retval = c_func(f);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                    (PyObject *)NULL, &self, 1,
                                    NULL, 0, d, nd
#ifndef PYPY_VERSION
                                    ,
                                    PyFunction_GET_CLOSURE(func));
#else
                                    );
#endif
        }
        else if (PyFunction_Check(func)) {
            PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 1 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState *tstate = PyThreadState_GET();
                PyObject **fastlocals;
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0)
                    return NULL;
    
                fastlocals = f->f_localsplus;
                Py_INCREF(self);
                fastlocals[0] = self;
    
                retval = PyEval_EvalFrameEx(f,0);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, &self, 1,
                                    NULL, 0, d, nd,
                                    PyFunction_GET_CLOSURE(func));
        } else {
            PyObject *callargs = PyTuple_Pack(1, self);
            PyObject *x;
            x = PyObject_Call(func,callargs,NULL);
            Py_XDECREF(callargs);
            Py_DECREF(func);
            return x;
        }

    } else {
        if (Py2CFunction_Check(func)) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;
    
            if (argdefs == 0 && co->_body.co_argcount == 0 && 
                    co->_body.co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState *tstate = PyThreadState_GET();
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }
                c_func = co->co_function;
                retval = c_func(f);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                    (PyObject *)NULL, NULL, 0,
                                    NULL, 0, d, nd
#ifndef PYPY_VERSION
                                    ,
                                    PyFunction_GET_CLOSURE(func));
#else
                                    );
#endif
        }
        else if (PyFunction_Check(func)) {
            PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 0 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState *tstate = PyThreadState_GET();
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0)
                    return NULL;
    
                retval = PyEval_EvalFrameEx(f,0);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, NULL, 0,
                                    NULL, 0, d, nd,
                                    PyFunction_GET_CLOSURE(func));
        } else {
            PyObject *x;
            x = PyObject_Call(func,empty_tuple,NULL);
            Py_DECREF(func);
            return x;
        }
    } 
}
""")
else:
    Libr('FastCall0',
"""
#define FastCall0(v) PyObject_Call(v,empty_tuple,NULL)
""",
"""
""")
    


Libr('_PyEval_DoRaise',
"""
static int
_PyEval_DoRaise(PyObject *, PyObject *, PyObject *);
""",
"""
static int
_PyEval_DoRaise(PyObject *type, PyObject *value, PyObject *tb)
{
	if (type == 0) {
		/* Reraise */
		PyThreadState *tstate = PyThreadState_GET();
		type = tstate->exc_type == 0 ? Py_None : tstate->exc_type;
		value = tstate->exc_value;
		tb = tstate->exc_traceback;
		Py_XINCREF(type);
		Py_XINCREF(value);
		Py_XINCREF(tb);
	}

	/* We support the following forms of raise:
	   raise <class>, <classinstance>
	   raise <class>, <argument tuple>
	   raise <class>, None
	   raise <class>, <argument>
	   raise <classinstance>, None
	   raise <string>, <object>
	   raise <string>, None

	   An omitted second argument is the same as None.

	   In addition, raise <tuple>, <anything> is the same as
	   raising the tuple's first item (and it better have one!);
	   this rule is applied recursively.

	   Finally, an optional third argument can be supplied, which
	   gives the traceback to be substituted (useful when
	   re-raising an exception after examining it).  */

	/* First, check the traceback argument, replacing None with
	   NULL. */
	if (tb == Py_None) {
		Py_DECREF(tb);
		tb = NULL;
	}
	else if (tb != NULL && !PyTraceBack_Check(tb)) {
		PyErr_SetString(PyExc_TypeError,
			   "raise: arg 3 must be a traceback or None");
		goto raise_error;
	}

	/* Next, replace a missing value with None */
	if (value == 0) {
		value = Py_None;
		Py_INCREF(value);
	}

	/* Next, repeatedly, replace a tuple exception with its first item */
	while (PyTuple_Check(type) && PyTuple_Size(type) > 0) {
		PyObject *tmp = type;
		type = PyTuple_GET_ITEM(type, 0);
		Py_INCREF(type);
		Py_DECREF(tmp);
	}

	if (PyExceptionClass_Check(type))
		PyErr_NormalizeException(&type, &value, &tb);

	else if (PyExceptionInstance_Check(type)) {
		/* Raising an instance.  The value should be a dummy. */
		if (value != Py_None) {
			PyErr_SetString(PyExc_TypeError,
			  "instance exception may not have a separate value");
			goto raise_error;
		}
		else {
			/* Normalize to raise <class>, <instance> */
			Py_DECREF(value);
			value = type;
			type = PyExceptionInstance_Class(type);
			Py_INCREF(type);
		}
	}
	else {
		/* Not something you can raise.  You get an exception
		   anyway, just not what you specified :-) */
		PyErr_Format(PyExc_TypeError,
			"exceptions must be classes or instances, not %s",
			type->ob_type->tp_name);
		goto raise_error;
	}

	assert(PyExceptionClass_Check(type));
	if (Py_Py3kWarningFlag && PyClass_Check(type)) {
		if (PyErr_WarnEx(PyExc_DeprecationWarning,
				"exceptions must derive from BaseException "
				"in 3.x", 1) < 0)
			goto raise_error;
	}

	PyErr_Restore(type, value, tb);
	if (tb == 0)
		return WHY_EXCEPTION;
	else
		return WHY_RERAISE;
 raise_error:
	Py_XDECREF(value);
	Py_XDECREF(type);
	Py_XDECREF(tb);
	return WHY_EXCEPTION;
}
""")     
Libr('_PyEval_ImportAllFrom',
"""
static int
_PyEval_ImportAllFrom(PyObject *, PyObject *);
""",
"""
static int
_PyEval_ImportAllFrom(PyObject *locals, PyObject *v)
{
	PyObject *all = PyObject_GetAttrString(v, "__all__");
	PyObject *dict, *name, *value;
	int skip_leading_underscores = 0;
	int pos, err;

	if (all == 0) {
		if (!PyErr_ExceptionMatches(PyExc_AttributeError))
			return -1; /* Unexpected error */
		PyErr_Clear();
		dict = PyObject_GetAttrString(v, "__dict__");
		if (dict == 0) {
			if (!PyErr_ExceptionMatches(PyExc_AttributeError))
				return -1;
			PyErr_SetString(PyExc_ImportError,
			"from-import-* object has no __dict__ and no __all__");
			return -1;
		}
		all = PyMapping_Keys(dict);
		Py_DECREF(dict);
		if (all == 0)
			return -1;
		skip_leading_underscores = 1;
	}

	for (pos = 0, err = 0; ; pos++) {
		name = PySequence_GetItem(all, pos);
		if (name == 0) {
			if (!PyErr_ExceptionMatches(PyExc_IndexError))
				err = -1;
			else
				PyErr_Clear();
			break;
		}
		if (skip_leading_underscores &&
		    PyString_Check(name) &&
		    PyString_AS_STRING(name)[0] == '_')
		{
			Py_DECREF(name);
			continue;
		}
		value = PyObject_GetAttr(v, name);
		if (value == 0)
			err = -1;
		else if (PyDict_CheckExact(locals))
			err = PyDict_SetItem(locals, name, value);
		else
			err = PyObject_SetItem(locals, name, value);
		Py_DECREF(name);
		Py_XDECREF(value);
		if (err != 0)
			break;
	}
	Py_DECREF(all);
	return err;
}
""")
Libr('_PyEval_BuildClass', 
"""
static PyObject *
_PyEval_BuildClass(PyObject *, PyObject *, PyObject *);
""",
"""
static PyObject *
_PyEval_BuildClass(PyObject *methods, PyObject *bases, PyObject *name)
{
	PyObject *metaclass = NULL, *result, *base;

	if (PyDict_Check(methods))
		metaclass = PyDict_GetItemString(methods, "__metaclass__");
	if (metaclass != NULL)
		Py_INCREF(metaclass);
	else if (PyTuple_Check(bases) && PyTuple_GET_SIZE(bases) > 0) {
		base = PyTuple_GET_ITEM(bases, 0);
		metaclass = PyObject_GetAttrString(base, "__class__");
		if (metaclass == 0) {
			PyErr_Clear();
			metaclass = (PyObject *)base->ob_type;
			Py_INCREF(metaclass);
		}
	}
	else {
		PyObject *g = PyEval_GetGlobals();
		if (g != NULL && PyDict_Check(g))
			metaclass = PyDict_GetItemString(g, "__metaclass__");
		if (metaclass == 0)
			metaclass = (PyObject *) &PyClass_Type;
		Py_INCREF(metaclass);
	}
	result = PyObject_CallFunctionObjArgs(metaclass, name, bases, methods,
					      NULL);
	Py_DECREF(metaclass);
	if (result == 0 && PyErr_ExceptionMatches(PyExc_TypeError)) {
		/* A type error here likely means that the user passed
		   in a base that was not a class (such the random module
		   instead of the random.random type).  Help them out with
		   by augmenting the error message with more information.*/

		PyObject *ptype, *pvalue, *ptraceback;

		PyErr_Fetch(&ptype, &pvalue, &ptraceback);
		if (PyString_Check(pvalue)) {
			PyObject *newmsg;
			newmsg = PyString_FromFormat(
				"Error when calling the metaclass bases\\n"
				"    %s",
				PyString_AS_STRING(pvalue));
			if (newmsg != NULL) {
				Py_DECREF(pvalue);
				pvalue = newmsg;
			}
		}
		PyErr_Restore(ptype, pvalue, ptraceback);
	}
	return result;
}
""")
     

Libr('_PyEval_ExecStatement',
"""static int
_PyEval_ExecStatement(PyFrameObject * , PyObject *, PyObject *, PyObject *);
""",
"""
static int
_PyEval_ExecStatement(PyFrameObject * f, PyObject *prog, PyObject *globals,
	       PyObject *locals)
{
	int n;
	PyObject *v;
	int plain = 0;

	if (PyTuple_Check(prog) && globals == Py_None && locals == Py_None &&
	    ((n = PyTuple_Size(prog)) == 2 || n == 3)) {
		/* Backward compatibility hack */
		globals = PyTuple_GetItem(prog, 1);
		if (n == 3)
			locals = PyTuple_GetItem(prog, 2);
		prog = PyTuple_GetItem(prog, 0);
	}
	if (globals == Py_None) {
		globals = PyEval_GetGlobals();
		if (locals == Py_None) {
			locals = PyEval_GetLocals();
			plain = 1;
		}
		if (!globals || !locals) {
			PyErr_SetString(PyExc_SystemError,
					"globals and locals cannot be NULL");
			return -1;
		}
	}
	else if (locals == Py_None)
		locals = globals;
	if (!PyString_Check(prog) &&
	    !PyUnicode_Check(prog) &&
	    !PyCode_Check(prog) &&
	    !PyFile_Check(prog)) {
		PyErr_SetString(PyExc_TypeError,
			"exec: arg 1 must be a string, file, or code object");
		return -1;
	}
	if (!PyDict_Check(globals)) {
		PyErr_SetString(PyExc_TypeError,
		    "exec: arg 2 must be a dictionary or None");
		return -1;
	}
	if (!PyMapping_Check(locals)) {
		PyErr_SetString(PyExc_TypeError,
		    "exec: arg 3 must be a mapping or None");
		return -1;
	}
	if (PyDict_GetItemString(globals, "__builtins__") == 0)
		PyDict_SetItemString(globals, "__builtins__", b);
	if (PyCode_Check(prog)) {
		if (PyCode_GetNumFree((PyCodeObject *)prog) > 0) {
			PyErr_SetString(PyExc_TypeError,
		"code object passed to exec may not contain free variables");
			return -1;
		}
		v = PyEval_EvalCode((PyCodeObject *) prog, globals, locals);
	}
	else if (PyFile_Check(prog)) {
		FILE *fp = PyFile_AsFile(prog);
		char *name = PyString_AsString(PyFile_Name(prog));
		PyCompilerFlags cf;
		if (name == 0)
			return -1;
		cf.cf_flags = 0;
		if (PyEval_MergeCompilerFlags(&cf))
			v = PyRun_FileFlags(fp, name, Py_file_input, globals,
					    locals, &cf);
		else
			v = PyRun_File(fp, name, Py_file_input, globals,
				       locals);
	}
	else {
		PyObject *tmp = NULL;
		char *str;
		PyCompilerFlags cf;
		cf.cf_flags = 0;
#ifdef Py_USING_UNICODE
		if (PyUnicode_Check(prog)) {
			tmp = PyUnicode_AsUTF8String(prog);
			if (tmp == 0)
				return -1;
			prog = tmp;
			cf.cf_flags |= PyCF_SOURCE_IS_UTF8;
		}
#endif
		if (PyString_AsStringAndSize(prog, &str, NULL))
			return -1;
		if (PyEval_MergeCompilerFlags(&cf))
			v = PyRun_StringFlags(str, Py_file_input, globals,
					      locals, &cf);
		else
			v = PyRun_String(str, Py_file_input, globals, locals);
		Py_XDECREF(tmp);
	}
	if (plain)
		PyFrame_LocalsToFast(f, 0);
	if (v == 0)
		return -1;
	Py_DECREF(v);
	return 0;
}
""")

Libr('__pyx_binding_PyCFunctionType_NewEx',
"""
typedef struct {
    PyCFunctionObject func;
} __pyx_binding_PyCFunctionType_object;

static PyTypeObject __pyx_binding_PyCFunctionType_type;
static PyTypeObject *__pyx_binding_PyCFunctionType = NULL;

static PyObject *__pyx_binding_PyCFunctionType_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module); /* proto */
#define __pyx_binding_PyCFunctionType_New(ml, self) __pyx_binding_PyCFunctionType_NewEx(ml, self, NULL)

static int __pyx_binding_PyCFunctionType_init(void); /* proto */

""",
"""
static PyObject *__pyx_binding_PyCFunctionType_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module) {
    __pyx_binding_PyCFunctionType_object *op = PyObject_GC_New(__pyx_binding_PyCFunctionType_object, __pyx_binding_PyCFunctionType);
    if (op == NULL)
        return NULL;
    op->func.m_ml = ml;
    Py_XINCREF(self);
    op->func.m_self = self;
    Py_XINCREF(module);
    op->func.m_module = module;
    PyObject_GC_Track(op);
    return (PyObject *)op;
}
static void __pyx_binding_PyCFunctionType_dealloc(__pyx_binding_PyCFunctionType_object *m) {
    PyObject_GC_UnTrack(m);
    Py_XDECREF(m->func.m_self);
    Py_XDECREF(m->func.m_module);
    PyObject_GC_Del(m);
}

static PyObject *__pyx_binding_PyCFunctionType_descr_get(PyObject *func, PyObject *obj, PyObject *type) {
    if (obj == Py_None)
            obj = NULL;
    return PyMethod_New(func, obj, type);
}

static int __pyx_binding_PyCFunctionType_init(void) {
    __pyx_binding_PyCFunctionType_type = PyCFunction_Type;
    __pyx_binding_PyCFunctionType_type.tp_name = "cython_binding_builtin_function_or_method";
    __pyx_binding_PyCFunctionType_type.tp_dealloc = (destructor)__pyx_binding_PyCFunctionType_dealloc;
    __pyx_binding_PyCFunctionType_type.tp_descr_get = __pyx_binding_PyCFunctionType_descr_get;
    if (PyType_Ready(&__pyx_binding_PyCFunctionType_type) < 0) {
        return -1;
    }
    __pyx_binding_PyCFunctionType = &__pyx_binding_PyCFunctionType_type;
    return 0;

}

""")

Libr('empty_number_protocol',
"""static PyNumberMethods empty_number_protocol;""",
"""static PyNumberMethods empty_number_protocol = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};
""")

Libr('empty_seq_protocol',
"""static PySequenceMethods empty_seq_protocol;""",
"""static PySequenceMethods empty_seq_protocol = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};
""")

Libr('empty_map_protocol',
"""static PyMappingMethods empty_map_protocol;""",
"""static PyMappingMethods empty_map_protocol = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};
""")

Libr('empty_buf_protocol',
"""static PyBufferProcs empty_buf_protocol;""",
"""static PyBufferProcs empty_buf_protocol = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};
""")

Libr('ping_threading',
"""
static int ping_threading (void);
""",
"""
#if PYTHON_VERSION < 300
// We share this with CPython bytecode main loop.
PyAPI_DATA(volatile int) _Py_Ticker;
#else
extern volatile int _Py_Ticker;
#define _Py_CheckInterval 20
#endif
static int ping_threading (void)
{
    if ( --_Py_Ticker < 0 )
    {
        PyThreadState *tstate = 0;
        _Py_Ticker = _Py_CheckInterval;
        if (Py_MakePendingCalls() < 0) return -1;
        tstate = PyThreadState_GET();
        assert (tstate);
        if (tstate->async_exc != NULL) {
            PyObject * x = tstate->async_exc;
            tstate->async_exc = NULL;
            PyErr_SetNone(x);
            Py_DECREF(x);
            return -1;\
        } 
    }
    return 0;
}
""")

Libr('parse_arguments',
"""
static int parse_arguments (PyObject *func, PyObject *arg, PyObject *kw, PyObject * co, PyObject * argdefs, PyObject ** fastlocals);
""",
"""

static int
PyEval_Eval3CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure, PyObject ** fastlocals);
#else
           , PyObject ** fastlocals);
#endif

static int parse_arguments (PyObject *func, PyObject *arg, PyObject *kw, PyObject * co, PyObject * argdefs, PyObject ** fastlocals)
{
	int result;
	PyObject **d, **k;
	Py_ssize_t nk, nd;

	if (argdefs != NULL && PyTuple_Check(argdefs)) {
		d = &PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL && PyDict_Check(kw)) {
		Py_ssize_t pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == 0) {
			PyErr_NoMemory();
			return -1;
		}
		pos = i = 0;
		while (PyDict_Next(kw, &pos, &k[i], &k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_Eval3CCodeEx(
		(PyCodeObject *)co,
		(PyObject *)NULL,
		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd, 0, fastlocals);


	if (k != NULL)
		PyMem_DEL(k);

	return result;
}

/* Local variable macros */

#undef GETLOCAL
#undef SETLOCAL
#define GETLOCAL(i)	(fastlocals[i])

#define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
				     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)

static int
PyEval_Eval3CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure, PyObject ** fastlocals)
#else
           , PyObject ** fastlocals)
#endif
{
	PyThreadState *tstate = PyThreadState_GET();
	PyObject *x, *u;


        assert(tstate != NULL);
	if (co->co_argcount > 0 ||
	    co->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) {
		int i;
		int n = argcount;
		PyObject *kwdict = NULL;
		if (co->co_flags & CO_VARKEYWORDS) {
			kwdict = PyDict_New();
			if (kwdict == 0)
				goto fail;
			i = co->co_argcount;
			if (co->co_flags & CO_VARARGS)
				i++;
			SETLOCAL(i, kwdict);
		}
		if (argcount > co->co_argcount) {
			if (!(co->co_flags & CO_VARARGS)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() takes %s %d "
				    "%sargument%s (%d given)",
				    PyString_AsString(co->co_name),
				    defcount ? "at most" : "exactly",
				    co->co_argcount,
				    kwcount ? "non-keyword " : "",
				    co->co_argcount == 1 ? "" : "s",
				    argcount);
				goto fail;
			}
			n = co->co_argcount;
		}
		for (i = 0; i < n; i++) {
			x = args[i];
			Py_INCREF(x);
			SETLOCAL(i, x);
		}
		if (co->co_flags & CO_VARARGS) {
			u = PyTuple_New(argcount - n);
			if (u == 0)
				goto fail;
			SETLOCAL(co->co_argcount, u);
			for (i = n; i < argcount; i++) {
				x = args[i];
				Py_INCREF(x);
				PyTuple_SET_ITEM(u, i-n, x);
			}
		}
		for (i = 0; i < kwcount; i++) {
			PyObject **co_varnames;
			PyObject *keyword = kws[2*i];
			PyObject *value = kws[2*i + 1];
			int j;
                        if (keyword == 0 || !(PyString_Check(keyword)
#ifdef Py_USING_UNICODE
                                     || PyUnicode_Check(keyword)
#endif
                            )) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() keywords must be strings",
				    PyString_AsString(co->co_name));
				goto fail;
			}
			/* Speed hack: do raw pointer compares. As names are
			   normally interned this should almost always hit. */
                        co_varnames = ((PyTupleObject *)(co->co_varnames))->ob_item;
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            if (nm == keyword)
                                goto kw_found;
                        }
                        /* Slow fallback, just in case */
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            int cmp = PyObject_RichCompareBool(
                                keyword, nm, Py_EQ);
                            if (cmp > 0)
                                goto kw_found;
                            else if (cmp < 0)
                                goto fail;
                        }
                        if (kwdict == 0) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got an unexpected "
                                            "keyword argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
                            goto fail;
                        }
                        PyDict_SetItem(kwdict, keyword, value);
                        continue;

kw_found:
			if (GETLOCAL(j) != NULL) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got multiple "
                                            "values for keyword "
                                            "argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
			}
			Py_INCREF(value);
			SETLOCAL(j, value);
		}
		if (argcount < co->co_argcount) {
			int m = co->co_argcount - defcount;
			for (i = argcount; i < m; i++) {
				if (GETLOCAL(i) == 0) {
                                    int j, given = 0;
                                    for (j = 0; j < co->co_argcount; j++)
                                        if (GETLOCAL(j))
                                            given++;
                                    PyErr_Format(PyExc_TypeError,
                                        "%.200s() takes %s %d "
                                        "argument%s (%d given)",
                                        PyString_AsString(co->co_name),
                                        ((co->co_flags & CO_VARARGS) ||
                                        defcount) ? "at least"
                                                : "exactly",
                                        m, m == 1 ? "" : "s", given);
                                    goto fail;
				}
			}
			if (n > m)
				i = n - m;
			else
				i = 0;
			for (; i < defcount; i++) {
				if (GETLOCAL(m+i) == 0) {
					PyObject *def = defs[i];
					Py_INCREF(def);
					SETLOCAL(m+i, def);
				}
			}
		}
	}
	else {
		if (argcount > 0 || kwcount > 0) {
			PyErr_Format(PyExc_TypeError,
				     "%.200s() takes no arguments (%d given)",
				     PyString_AsString(co->co_name),
				     argcount + kwcount);
			goto fail;
		}
	}
	/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */
	if (PyTuple_GET_SIZE(co->co_cellvars)) {
		int i, j, nargs, found;
		char *cellname, *argname;
		PyObject *c;

		nargs = co->co_argcount;
		if (co->co_flags & CO_VARARGS)
			nargs++;
		if (co->co_flags & CO_VARKEYWORDS)
			nargs++;

		/* Initialize each cell var, taking into account
		   cell vars that are initialized from arguments.

		   Should arrange for the compiler to put cellvars
		   that are arguments at the beginning of the cellvars
		   list so that we can march over it more efficiently?
		*/
		for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {
			cellname = PyString_AS_STRING(
				PyTuple_GET_ITEM(co->co_cellvars, i));
			found = 0;
			for (j = 0; j < nargs; j++) {
				argname = PyString_AS_STRING(
					PyTuple_GET_ITEM(co->co_varnames, j));
				if (strcmp(cellname, argname) == 0) {
					c = PyCell_New(GETLOCAL(j));
					if (c == 0)
						goto fail;
					GETLOCAL(co->co_nlocals + i) = c;
					found = 1;
					break;
				}
			}
			if (found == 0) {
				c = PyCell_New(NULL);
				if (c == 0)
					goto fail;
				SETLOCAL(co->co_nlocals + i, c);
			}
		}
	}
#ifndef PYPY_VERSION
	if (PyTuple_GET_SIZE(co->co_freevars)) {
                assert(0);
	}
#endif
        assert(!(co->co_flags & CO_GENERATOR));

fail: /* Jump here from prelude on failure */

	/* decref'ing the frame can cause __del__ methods to get invoked,
	   which can call back into Python.  While we're done with the
	   current Python frame (f), the associated C stack is still in use,
	   so recursion_depth must be boosted for the duration.
	*/
	assert(tstate != NULL);
	return 0;
}


""")


Libr('cfunc_parse_args', 
"""
static int cfunc_parse_args(PyObject *arg, PyObject *kw, PyObject *argdefs, PyCodeObject * co, PyObject ** fastlocals);
""",
"""
static int cfunc_parse_args(PyObject *arg, PyObject *kw, PyObject *argdefs, PyCodeObject * co, PyObject ** fastlocals)
{
	PyObject *result;
	PyObject **d, **k;
	Py_ssize_t nk, nd;

	if (argdefs != NULL)) {
		d = &PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL && PyDict_Check(kw)) {
		Py_ssize_t pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == 0) {
			PyErr_NoMemory();
			return -1
		}
		pos = i = 0;
		while (PyDict_Next(kw, &pos, &k[i], &k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_Eval2CCodeEx(
		co,
		(PyObject *)NULL,
		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd
#ifndef PYPY_VERSION
                ,
		PyFunction_GET_CLOSURE(func));
#else
                );
#endif

	if (k != NULL)
		PyMem_DEL(k);

	return result;
}


     """)
     
fastglob = {}

def add_fast_glob(nm):
    fastglob[nm] = True
    
def type_methfunc(co):    
    if ( ( co.co_flags & (0x4 + 0x8) ) == 0):    
        if co.method_class is None:
            if co.co_argcount == 1:
                return "METH_O", False
            elif co.co_argcount == 0:
                return "METH_NOARGS", False
            return "METH_VARARGS|METH_KEYWORDS", False
        if co.method_class is not None and co.co_argcount == 0:
            return "METH_NOARGS", True
        if co.method_class is not None and co.co_argcount == 1:
            return "METH_O", True
    return "METH_VARARGS|METH_KEYWORDS", co.method_class is not None

def write_as_c(cfile, nmmodule):
    global pregenerated
    global predeclared_chars
    first, first2, first3 = Out(), Out(), Out()
    first.print_to(c_head1)
##    first2.print_to(c_head2)
    first3.print_to(c_head3)
    if len(fastglob) > 0:
        s = 'enum{'
        n = 0
        for k in fastglob.iterkeys():
            if k in detected_global_type and IsCType(detected_global_type[k]):
                cty = Type2CType(detected_global_type[k])
                first3.print_to('static %s Glob_%s_%s;\n' % (cty, cty, k))
            else:    
                s += 'Glob_' + k + ','
                n += 1
        s = s[:-1] + '};\n'
        if n > 0:
            first3.print_to('PyObject * fastglob[' + str(n) + '];\n')
            first3.print_to(s)   
    ## for k in predeclared_chars.iterkeys():    
        ## first2.print_to('static char const_string_' + str(k) + '[];\n')   
    di = {}
    for cmds, o, co in pregenerated:
        if not hasattr(co, 'no_codefunc') or not co.no_codefunc:
            if co.c_name in di:
                continue
            di[co.c_name] = 0
            if co.can_be_cfunc():
                met, ismeth = type_methfunc(co)
                if met == "METH_O" or met == "METH_NOARGS":
                    first3.print_to('static PyObject * cfunc_' + co.c_name +'(PyObject *, PyObject *);')
                else:
                    first3.print_to('static PyObject * cfunc_' + co.c_name +'(PyObject *, PyObject *, PyObject *);')
                first3.Raw("static PyMethodDef methfunc_", co.c_name, " = {\"", co.co_name, "\", (PyCFunction)cfunc_", co.c_name, ", ", met, ", 0};")
            else:
                first3.print_to('static PyObject * codefunc_' + co.c_name +'(PyFrameObject *);')
                Used('PyEval_Eval2CCodeEx')
        if co.c_name in direct_args: # and direct_call and subroutine_can_be_direct(nm):
            arg = ""
            coarg = co.co_argcount
            hidden = co.hidden_arg_direct
            typed_arg = co.typed_arg_direct
            if co.co_flags & 0x4:
                assert len(hidden) == 0
                coarg += 1
            if coarg == 0:
                arg = '(void)'
            else:    
                arg = ''
                i = 0
                while coarg > 1:
                    if i not in hidden:
                        if i in typed_arg and IsCType(typed_arg[i]):
                            arg += ', ' + Type2CType(typed_arg[i])
                        else:    
                            arg += ', PyObject *'
                    coarg -= 1
                    i += 1
                if i not in hidden:
                    if i in typed_arg and IsCType(typed_arg[i]):
                        arg += ', ' + Type2CType(typed_arg[i])
                    else:    
                        arg += ', PyObject *'
                if arg == '':
                    arg = '  void'    
                arg = '(' + arg[2:] + ')'
            if co.IsRetVoid():    
                first3.print_to('static int _Direct_' + co.c_name + arg + ';') 
            elif IsCType(co.ReturnType()):       
                first3.print_to(('static %s _Direct_' % Type2CType(co.ReturnType())) + co.c_name + arg + ';')    
            else:
                first3.print_to('static PyObject * _Direct_' + co.c_name + arg + ';') 
    to_check = {'_c_BINARY_SUBSCR_Int':'= _c_BINARY_SUBSCR_Int', '_PyEval_AssignSlice':'( _PyEval_AssignSlice', '_PyEval_ApplySlice':' = _PyEval_ApplySlice'}
    checked = {}
    for k, v in to_check.iteritems():
        for cmds, o, co in pregenerated:
            for s in o:
                if v in s:
                    checked[k] = True
    for a,b,c in Iter3(None, 'Used', True):
        if IsLibr(a):
            if a not in to_check or (a in checked and checked[a]):
                first3.print_to(LibrDcl(a))
    for cmds, o, co in pregenerated:
        first3.extend(o)
    pregenerate_code_objects()
    generate_consts(first2, first3)    
    generate_calculated_consts(first2)    
    generate_builtin(first2, first3)
    generate_init(first3, nmmodule)    
    if build_executable:
        Used('main')
    first3.print_to(c_tail)
    for a,b,c in Iter3(None, 'Used', True):
        if IsLibr(a):
            if a not in to_check or (a in checked and checked[a]):
                first3.print_to(LibrDef(a))
    for s in first + first2 + first3:
        print_to(cfile, s)
 
def generate_init(first3, nmmodule):
    global labl
    if not build_executable:
        if c_name is None:
            first3.print_to('PyMODINIT_FUNC init' + nmmodule+'(void);')
            first3.print_to('PyMODINIT_FUNC init' + nmmodule+'(void){')
        else:
            first3.print_to('PyMODINIT_FUNC init' + c_name+'(void);')
            first3.print_to('PyMODINIT_FUNC init' + c_name+'(void){')
    else:    
        first3.print_to('static void init_main(void);')
        first3.print_to('static void init_main(void){')
    first3.print_to('    patch_code2c();')
    if Is3('__pyx_binding_PyCFunctionType_NewEx', 'Used'):
        first3.print_to('    __pyx_binding_PyCFunctionType_init();')
    first3.print_to('    b = PyImport_AddModule("__builtin__");')
    first3.print_to('    bdict = PyModule_GetDict(b);')
    if len(loaded_builtin) > 0:
        first3.print_to('    load_builtin();')
    first3.print_to('    init_consts();')
    ## o = Out()
    if c_name is None:
        first3.print_to('    PyImport_Exec2CCodeModuleEx(\"' + nmmodule +'", '  +const_to(_n2c['Init_filename']) +');')
        first3.print_to('    PyDict_SetItemString(glob, \"__compile_hash__\", PyInt_FromString(\"' + str(hash_compile) + '\", NULL, 0));')
    else:
        first3.print_to('    PyImport_Exec2CCodeModuleEx(\"' + c_name +'", '  +const_to(_n2c['Init_filename']) +');')
        first3.print_to('    PyDict_SetItemString(glob, \"__compile_hash__\", PyInt_FromString(\"' + str(hash_compile) + '\", NULL, 0));')
    first3.print_to('}')
    
def nmvar_to_loc(v):
    if '(' in v or ')' in v or '[' in v or ']' in v or '.' in v or '-' in v:
        v = v.replace('[', '_1_')    
        v = v.replace(']', '_9_')            
        v = v.replace('(', '_2_')    
        v = v.replace(')', '_7_')            
        v = v.replace('.', '_5_')    
        v = v.replace('-', '_6_')    
    return v

def generate_stand_header(l, co, typed, o, typed_local, isdirect, hidden):
    global no_fastlocals
    orepr = repr(o)
    for i,(f,t) in enumerate(typed):
        nm = t + '_' + str(i)
        if t != 'label' and t != 'longref' and nm in orepr:
            orepr = may_be_append_to_o(l, orepr, t, nm, o)
##            l.append(t + ' ' + nm + ';')
    if isdirect and no_fastlocals:
        pass
    else:    
        s = 'enum{' 
        cnt = 0
        if isdirect:
            names = co.co_varnames_direct
        else:
            names = co.co_varnames    
        for v in names:        
            if co.IsCVar(('FAST', v)) or v in hidden:
                if isdirect:
                    continue
                else:
                    v += '_missing_'
            if s != 'enum{':
                s += ', '
            v = nmvar_to_loc(v)
            s += 'Loc_' + v 
            cnt += 1
        s += '};'
        if s != 'enum{};':
            l.append(s)  
    for k, v in typed_local.iteritems():
        if IsCType(v):
            ty = Type2CType(v)
            cnm = 'Loc_%s_%s' %(ty, k)
            orepr = may_be_append_to_o(l, orepr, ty, cnm, o)
    return cnt        
   
def may_be_append_to_o(l, orepr, ty, cnm, o, debug = False):
    if cnm in orepr:
        if orepr.count(cnm) == orepr.count(cnm + ' = '):
            for i in range(len(o)):
                if (cnm + ' = ') in o[i]:
                    o[i] = o[i].replace(cnm + ' = ', '')
                    if o[i] in ('0;', '1;'):
                        o[i] = ''
                    elif o[i].startswith('( Py_ssize_t_') and o[i].endswith(' );'):
                        o[i] = ''
                    elif o[i][0].isdigit():
                        o[i] = ''
                    elif o[i].startswith('PyObject_IsTrue(temp[') and o[i].endswith(']);'):
                        o[i] = ''
                    elif o[i].startswith('PyInt_AsLong(temp[') and o[i].endswith(']);'):
                        o[i] = ''
                    elif o[i].startswith('int_') and o[i].endswith(';') and o[i][4:-1].isdigit():
                        o[i] = ''
                    else:
                        print o[i], 'o[i]', '12345678'
            o[:] = [x for x in o if x != '']
            orepr = repr(o)
        if cnm in orepr:
            l.append(ty + ' ' + cnm + ';')
    return orepr
            
def generate_parse_cfunc_args(co, cntvar, o, cntarg, ismeth):
    global labl
    assert labl is not None
    assert type(labl) is tuple
    ismeth = False
    ## for i in range(cntvar):
        ## o.Raw('fastlocals[', i, '] = 0;')
    defa = None
    if co.c_name in default_args:
        defa = default_args[co.c_name]
    if defa == ('CONST', ()):
        defa = None
    if defa is not None:
        if defa[0] == 'CONST':
            defaul = defa
            defa = tuple([('CONST', x) for x in defa[1]])
        else:
            defaul = 'GETSTATIC(__default_arg___' + co.c_name + ')'
            defa = defa[1]       # BUILD_TUPLE         
    else:
        defaul = 'NULL'
    if ( ( co.co_flags & (0x4 + 0x8) ) == 0):
        o.Raw(cntarg, ' = PyTuple_GET_SIZE(args);')
        if defa is None:
            o.Raw('if (kw == 0) {')
            if not ismeth:
                o.Raw('if ( ', cntarg, ' != ', co.co_argcount, ' ) {')
            else:
                o.Raw('if ( ', cntarg, ' != ', co.co_argcount-1, ' ) {')
            if co.co_argcount != 1:
                o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes exactly ", co.co_argcount, " arguments (%d given)\", ", cntarg, ');')
            else:
                o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes exactly ", co.co_argcount, " argument (%d given)\", ", cntarg, ');')
            o.Raw('goto ', labl, ';')
            UseLabl()
            o.Raw('}')

            if not ismeth:
                for i in range(co.co_argcount):
                    o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                    o.Raw('Py_INCREF(fastlocals[', i, ']);')
            else:
                for i in range(co.co_argcount):
                    if i == 0:
                        o.Raw('fastlocals[', i, '] = self;')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i-1, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('} else {')
            if not ismeth:
                o.Raw('static char *kwlist[] = {', ', '.join(['"' + co.co_varnames[i] + '"' for i in range(co.co_argcount)] + ['NULL']), '};')
                listargs = ' , '.join(['fastlocals+' + str(i) for i in range(co.co_argcount)])
                form = ''.join(['O' for i in range(co.co_argcount)])                
            else:
                o.Raw('static char *kwlist[] = {', ', '.join(['"' + co.co_varnames[i] + '"' for i in range(1, co.co_argcount)] + ['NULL']), '};')
                listargs = ' , '.join(['fastlocals+' + str(i) for i in range(1, co.co_argcount)])
                form = ''.join(['O' for i in range(1, co.co_argcount)])                
                o.Raw('fastlocals[', i, '] = self;')
                o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('if ( !PyArg_ParseTupleAndKeywords ( args , kw , \"', form, '\" , kwlist , ', listargs, ' ) ) goto ', labl, ';')
            o.Raw('}')
        else:
            minarg = co.co_argcount - len(defa)
            assert minarg >= 0
            o.Raw('if (kw == 0) {')
            if not ismeth:
                o.Raw('if ( ', cntarg, ' < ', minarg, ' ) {')
                if minarg != 1:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " arguments (%d given)\", ", cntarg, ');')
                else:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " argument (%d given)\", ", cntarg, ');')
            else:
                o.Raw('if ( ', cntarg, ' < ', minarg-1, ' ) {')
                if minarg != 0:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " arguments (%d given)\", ", cntarg, ');')
                else:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " argument (%d given)\", ", cntarg, ');')
            o.Raw('goto ', labl, ';')
            UseLabl()
            o.Raw('}')
            
            for i in range(co.co_argcount):
                if i < minarg:
                    if not ismeth:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    elif i == 0:
                        o.Raw('fastlocals[', i, '] = self;')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i-1, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                else:
                    if not ismeth:
                        o.Raw('if ( ', i, ' < ', cntarg, ' ) {')
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        if i == 0:
                            o.Raw('fastlocals[', i, '] = self;')
                            o.Raw('Py_INCREF(fastlocals[', i, ']);')
                        else:
                            o.Raw('if ( ', i, ' < ', cntarg, ' ) {')
                            o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i-1, ');')
                            o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    o.Raw('} else {')
                    if not ismeth:
                        assert (i-minarg) >= 0
                    edefa = defa[i-minarg]
                    if edefa[0] == 'CONST':
                        o.Raw('fastlocals[', i, '] = ', edefa, ';')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM ( GETSTATIC(__default_arg___', co.c_name, ') , ', i-minarg, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')                        
                        ## print edefa, co.c_name
                        ## edefa = Expr1(edefa, o)
                        ## o.Raw('fastlocals[', i, '] = ', edefa, ';')
                    o.Raw('} ')
            o.Raw('} else {')
            o.Raw('if ( parse_arguments (self, args, kw, ', const_to(co), ', ', defaul, ', fastlocals) == -1) goto ', labl, ';')
            UseLabl()
            Used('parse_arguments')
            ## for i in range(co.co_argcount):
                ## if i < minarg:
                    ## o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                ## else:
                    ## o.Raw('if ( ', i, ' < ', cntarg, ' ) {')
                    ## o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                    ## o.Raw('} else {')
                    ## assert (i-minarg) >= 0
                    ## edefa = defa[i-minarg]
                    ## if edefa[0] == 'CONST':
                        ## o.Raw('fastlocals[', i, '] = ', edefa, ';')
                        ## o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    ## else:
                        ## o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM ( GETSTATIC(__default_arg___', co.c_name, ') , ', i-minarg, ');')
                        ## o.Raw('Py_INCREF(fastlocals[', i, ']);')                            
                        ## ## print edefa
                        ## ## edefa = Expr1(edefa, o)
                        ## ## o.Raw('fastlocals[', i, '] = ', edefa, ';')
                    ## o.Raw('} ')
                ## o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('}')
        o.Cls(cntarg)
        return


    if ( ( co.co_flags & (0x4 + 0x8) ) == 0x4):
        defa = None
        if co.c_name in default_args:
            defa = default_args[co.c_name]
        if defa == ('CONST', ()):
            defa = None
        if defa is None:
            o.Raw(cntarg, ' = PyTuple_GET_SIZE(args);')
            o.Raw('if (kw == 0) {')
            if co.co_argcount > 0:
                o.Raw('if ( ', cntarg, ' < ', co.co_argcount, ' ) {')
                if co.co_argcount != 1:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", co.co_argcount, " arguments (%d given)\", ", cntarg, ');')
                else:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", co.co_argcount, " argument (%d given)\", ", cntarg, ');')
                o.Raw('goto ', labl, ';')
                UseLabl()
                o.Raw('}')
    
            for i in range(co.co_argcount):
                o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('fastlocals[', co.co_argcount, '] = PySequence_GetSlice ( args , ', co.co_argcount , ', PY_SSIZE_T_MAX );')
            o.Raw('} else {')
            o.Raw('if ( parse_arguments (self, args, kw, ', const_to(co), ', ', defaul, ', fastlocals) == -1) goto ', labl, ';')
            UseLabl()
            Used('parse_arguments')
            o.Raw('}')
            return
        else:
            o.Raw('if ( parse_arguments (self, args, kw, ', const_to(co), ', ', defaul, ', fastlocals) == -1) goto ', labl, ';')
            UseLabl()
            Used('parse_arguments')
            return            
    Fatal('Unhandeled cfunc', co)
    
def generate_cfunc_header(nm, o, co, typed, typed_local):
    global tempgen
    l = Out()
    l.append('') 
    to_count_arg = None
    met, ismeth = type_methfunc(co)
    have_fastlocal = False
    for s in o:
       if 'LOCAL' in s:
            have_fastlocal = True
    if met == "METH_NOARGS":
        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * UNUSED) {')
    elif met == "METH_O" or met == "METH_NOARGS":
        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * args) {')
    else:
        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * args, PyObject *kw) {')
        if have_fastlocal:
            l.append('int len_args = 0;')
            to_count_arg = 'len_args'
    cntvar = generate_stand_header(l, co, typed, o, typed_local, False, {})
    if line_number:
        l.Raw('int PyLine = ', co.co_firstlineno, ';')     
        l.append('int PyAddr = 0;')           
    if len(co.co_cellvars + co.co_freevars) > 0:
        Fatal("Can\'t make cfunc with cellvars & freevars") 
        return None
    sfree = None
    if have_fastlocal:
        l.Raw('PyObject *fastlocals[', cntvar, '];')
    is_tstate = False
    for s in o:
        if 'tstate' in s:
            is_tstate = True    
    if is_tstate:
        l.append('PyThreadState *tstate = PyThreadState_GET();')
    if not redefined_attribute:
        for k in co.dict_getattr_used.iterkeys():
            if ( len(calc_const_old_class) > 0 and not is_pypy ) or len(calc_const_new_class) > 0:
                l.append('PyObject *_%s_dict = 0;' %k)
    if calc_ref_total:
        l.append('Py_ssize_t l_Py_RefTotal;')
    l_fast = Out()
    if nm == 'Init_filename':
        if is_pypy:
            l_fast.Raw('glob = PyObject_GetAttrString((PyObject *)f, "f_locals");')
        else:
            l_fast.Raw('glob = f->f_locals;')
    l_fast = Out()
    if have_fastlocal:            
        if met == "METH_NOARGS":
            for i in range(cntvar):
                l_fast.append('fastlocals[' + str(i) + '] = 0;')
        elif met == "METH_O" or met == "METH_NOARGS":
            l_fast.append('fastlocals[0] = args;')
            l_fast.append('Py_INCREF(fastlocals[0]);')
            for i in range(1, cntvar):
                l_fast.append('fastlocals[' + str(i) + '] = 0;')
        else:
            for i in range(cntvar):
                l_fast.append('fastlocals[' + str(i) + '] = 0;')
            generate_parse_cfunc_args(co, cntvar, l_fast, to_count_arg, ismeth)
    #        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * args, PyObject *kw) {')
    if len(tempgen) != 0:
        l.Raw('PyObject * temp[', max(1, len(tempgen)), '];')
        for i in range(len(tempgen)):
            l.append('temp[' + str(i) + '] = 0;')
    l.extend(l_fast)
    l_fast = None
    if not redefined_attribute:
        for k in co.dict_getattr_used.iterkeys():
            if ( len(calc_const_old_class) > 0 and not is_pypy ) and len(calc_const_new_class) > 0:
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('} else {')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
            elif len(calc_const_old_class) > 0 and len(calc_const_new_class) == 0 and not is_pypy:
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('}')
            elif ( len(calc_const_old_class) == 0 or is_pypy ) and len(calc_const_new_class) > 0:
                l.append('{')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
    if calc_ref_total:
        l.append('l_Py_RefTotal = _Py_RefTotal;')
    l.Raw('')        
    l.extend(o)
    o[:] = l[:]   
    cnt_temp = 0
    for s in o:
        if 'temp[' in s or 'CLEAETEMP(' in s:
            cnt_temp += 1
    if cnt_temp == 1:
        for i in range(len(o)):
            if o[i].startswith('PyObject * temp['): 
                del o[i]
                break
    return   

def generate_header(nm, o, co, typed, typed_local):
    global tempgen
    l = Out()
    l.append('')        

    l.append('static PyObject * codefunc_' + nm +'(PyFrameObject *f) {')
    cntvar = generate_stand_header(l, co, typed, o, typed_local, False, {})
    if co.co_stacksize != 0:
        if is_pypy:    
            l.Raw('PyObject * temp[', co.co_stacksize, '];')
        else:
            l.append('PyObject ** temp;')

    sfree = 'enum{' + ', '.join(['Loc2_' + nmvar_to_loc(v) for v in co.co_cellvars + co.co_freevars]) + '};'
    ## for i,v in enumerate(co.co_cellvars + co.co_freevars):    
        ## if i > 0:
            ## s += ', '
        ## v = nmvar_to_loc(v)
        ## s += 'Loc2_' + v 
    ## s += '};'
    have_fastlocal = False
    if sfree != 'enum{};':
        l.Raw(sfree)  
        l.append('register PyObject **fastlocals, **freevars;')
        have_fastlocal = True
    else:    
        sfree = None
        if cntvar != 0:
            for s in o:
                if 'LOCAL' in s:
                    have_fastlocal = True
            if have_fastlocal:
                l.append('register PyObject **fastlocals;')
    l.append('PyThreadState *tstate = PyThreadState_GET();')
    if not redefined_attribute:
        ## if co.self_dict_getattr_used:
            ## if co.method_new_class:
                ## l.append('PyObject **self_dict;')
            ## elif co.method_old_class:
                ## l.append('PyObject *self_dict;')
            ## else:
                ## Fatal('')    
        for k in co.dict_getattr_used.iterkeys():
            if ( len(calc_const_old_class) > 0 and not is_pypy ) or len(calc_const_new_class) > 0:
                l.append('PyObject *_%s_dict = 0;' %k)
    if calc_ref_total:
        l.append('Py_ssize_t l_Py_RefTotal;')
    ## if line_number and is_pypy:
        ## l.append('int PyAddr = 0;')          
    if nm == 'Init_filename':
        if is_pypy:
            l.Raw('glob = PyObject_GetAttrString((PyObject *)f, "f_locals");')
        else:
            l.Raw('glob = f->f_locals;')
    l.append('if (f == 0) return NULL;')
    if check_recursive_call:
        l.append('if (Py_EnterRecursiveCall("")) return NULL;')
    if not is_pypy:
        l.append('tstate->frame = f;')
    if sfree is not None or cntvar != 0:
        if have_fastlocal:
            l.append('fastlocals = f->f_localsplus;')
    if sfree is not None:
        l.append('freevars = fastlocals + f->f_code->co_nlocals;')
    if co.co_stacksize != 0:
        if not is_pypy:    
            l.append('temp = f->f_stacktop;')
##              l.Raw('printf(\"top=%x, val=%x\\n\", f->f_stacktop, f->f_valuestack);')
            l.append('assert(temp != NULL);')

        for i in range(min(co.co_stacksize, len(tempgen))):
            l.append('temp[' + str(i) + '] = 0;')
    if not is_pypy:
        l.append('f->f_stacktop = NULL;')
    if not redefined_attribute:
        ## if co.self_dict_getattr_used:
            ## if co.method_new_class:
                ## l.append('self_dict = _PyObject_GetDictPtr(GETLOCAL(self));')
            ## elif co.method_old_class:
                ## l.append('self_dict = ((PyInstanceObject *)GETLOCAL(self))->in_dict;')
            ## else:
                ## Fatal('')    
        for k in co.dict_getattr_used.iterkeys():
            ## if k == 'self':
                ## if co.method_new_class:
                    ## l.append('_self_dict = *_PyObject_GetDictPtr(GETLOCAL(self));')
                ## elif co.method_old_class:
                    ## l.append('_self_dict = ((PyInstanceObject *)GETLOCAL(self))->in_dict;')
                ## else:    
                    ## l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                    ## l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                    ## l.append('} else {')
                    ## l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                    ## l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                    ## l.append('}')
            ## else:
            if ( len(calc_const_old_class) > 0 and not is_pypy ) and len(calc_const_new_class) > 0:
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('} else {')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
            elif ( len(calc_const_old_class) > 0 and not is_pypy ) and len(calc_const_new_class) == 0:
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('}')
            elif ( len(calc_const_old_class) == 0 or is_pypy ) and len(calc_const_new_class) > 0:
                l.append('{')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
    if calc_ref_total:
        l.append('l_Py_RefTotal = _Py_RefTotal;')
    l.Raw('')        
    l.extend(o)
    o[:] = l[:]         
    return   

def generate_from_frame_to_direct_stube(co, o, nm, cmds):
    l = []
    l.append('')        

    l.append('static PyObject * codefunc_' + nm +'(PyFrameObject *f) {')
    cntvar = generate_stand_header(l, co, [], o, {}, False, {})
    s = 'enum{' + ', '.join(['Loc2_' + nmvar_to_loc(v) for v in co.co_cellvars + co.co_freevars]) + '};'
    ## s = 'enum{' 
    ## for i,v in enumerate(co.co_cellvars + co.co_freevars):    
        ## if i > 0:
            ## s += ', '
        ## v = nmvar_to_loc(v)
        ## s += 'Loc2_' + v 
    ## s += '};'
    if s != 'enum{};':
        l.append(s)
    if  s != 'enum{};' or cntvar != 0:
        l.append('register PyObject **fastlocals;')
    l.append('PyThreadState *tstate = PyThreadState_GET();')
    if not co.IsRetVoid() and not IsCType(co.ReturnType()):
        l.append('PyObject * ret;')
    if IsCType(co.ReturnType()):
        l.append('%s ret;' % Type2CType(co.ReturnType()))
    l.append('if (f == 0) return NULL;')
##    if check_recursive_call:
##        l.append('if (Py_EnterRecursiveCall("")) return NULL;')
    if not is_pypy:
        l.append('tstate->frame = f;')
    if s != 'enum{};' or cntvar != 0:
        l.append('fastlocals = f->f_localsplus;')

    l.append('')        

    arg = ""
    coarg = co.co_argcount
    if co.co_flags & 0x4:
        coarg += 1
    ## cnt_arg = coarg    
##    arg = ''
##    i = 0
    arg = '(' + ', '.join(['GETLOCAL(' + nmvar_to_loc(x) + ')' for i, x in enumerate(co.co_varnames) if i < coarg]) + ')'
    ## for i in range(coarg):
        ## v = nmvar_to_loc(co.co_varnames[i])
        ## if i != 0:
            ## arg += ', '
        ## arg += 'GETLOCAL(' + v + ')'
##    arg = '(' + arg + ')'
    if co.IsRetVoid():
        l.append('if (_Direct_' + nm + arg + ' == -1) {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return NULL;')
        l.append('} else {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('Py_INCREF(Py_None);')
        l.append('return Py_None;')
        l.append('}')
    elif co.IsRetBool():
        l.append('if ((ret = _Direct_' + nm + arg + ') == -1) {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return NULL;')
        l.append('} else {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('if (ret) {')
        l.append('Py_INCREF(Py_True);')
        l.append('return Py_True;')
        l.append('} else {')
        l.append('Py_INCREF(Py_False);')
        l.append('return Py_False;')
        l.append('}')
        l.append('}')
    elif co.IsRetInt():
        l.append('if ((ret = _Direct_' + nm + arg + ') == -1 && PyErr_Occurred()) {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return NULL;')
        l.append('} else {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return PyInt_FromLong (ret);')
        l.append('}')
    elif co.IsRetChar():
        l.append('if ((ret = _Direct_' + nm + arg + ') == 255 && PyErr_Occurred()) {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return NULL;')
        l.append('} else {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return PyString_FromStringAndSize (&ret, 1);')
        l.append('}')
    elif co.IsRetFloat():
        l.append('if ((ret = _Direct_' + nm + arg + ') == -1 && PyErr_Occurred()) {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return NULL;')
        l.append('} else {')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return PyFloat_FromDouble (ret);')
        l.append('}')
    else:
        l.append('ret = _Direct_' + nm + arg + ';')
        if not is_pypy:
            l.append('tstate->frame = f->f_back;')
        l.append('return ret;')
    o[:] = l[:]    
    o.append('}')     
    pregenerated.append((cmds, o, co))    
    
def declare_arg(i, typed_arg, co):
    global no_fastlocals
    if i in typed_arg:
        t = typed_arg[i] 
        if IsCType(t):
            cty = Type2CType(t)
            return True, '%s Loc_%s_%s' % (cty, cty, co.co_varnames[i])
    if no_fastlocals:
        return False, 'PyObject * _Fast_%s' % co.co_varnames[i]
    return False, 'PyObject * Arg_' + str(i) 
    
    
def generate_stand_direct_header(l, co, typed, o, typed_local, hidden, cnt_arg):
    global no_fastlocals
    orepr = repr(o)
    for i,(f,t) in enumerate(typed):
        nm = t + '_' + str(i)
        if t != 'label' and t != 'longref' and nm in orepr:
            orepr = may_be_append_to_o(l, orepr, t, nm, o)
##            l.append(t + ' ' + nm + ';')
    if no_fastlocals:
        li = [(ii, nmvar_to_loc(v)) \
               for (ii, v) in enumerate(co.co_varnames_direct) \
               if not co.IsCVar(('FAST', v)) and v not in hidden]
        li = li[cnt_arg:]
    else:
        li = [(ii, nmvar_to_loc(v)) \
               for (ii, v) in enumerate(co.co_varnames_direct) \
               if not co.IsCVar(('FAST', v)) and v not in hidden]
    cnt = len(li) 
    if cnt > 0:
        if no_fastlocals:
            l.extend(['PyObject * _Fast_' + v + ' = 0;' for ii, v in li])
        else:
            l.append('enum{' + ', '.join(['Loc_' + v for ii, v in li]) + '};')       
    for k, v in typed_local.iteritems():
        if IsCType(v):
            ty = Type2CType(v)
            cnm = 'Loc_%s_%s' %(ty, k)
            orepr = may_be_append_to_o(l, orepr, ty, cnm, o)
    return cnt        
    

def generate_header_direct(nm, o, co, typed, typed_arg, typed_local):
    global no_fastlocals
    l = Out()
    assert type(co) is code_extended
    l.Raw('')        
    arg = ""
    coarg = co.co_argcount
    if co.co_flags & 0x4:
        assert len(co.hidden_arg_direct) == 0
        coarg += 1
    cnt_arg = coarg    
    if coarg == 0:
        arg = '(void)'
        i = 0
        ii = 0
    else:    
        arg = ''
        i = 0
        ii = 0
        while coarg > 1:
            if not i in co.hidden_arg_direct:  
                cty, _arg = declare_arg(i, typed_arg, co)
                arg += ', ' + _arg
                if not cty:
                    ii += 1
            i += 1
            coarg -= 1
        if not i in co.hidden_arg_direct:
            cty, _arg = declare_arg(i, typed_arg, co)
            arg += ', ' + _arg
            if not cty:
                ii += 1
        if arg == '':
            arg = '  void'    
        arg = '(' + arg[2:] + ')'
    if co.IsRetVoid() or co.IsRetBool():     
        l.Raw('static int _Direct_', nm, arg, '{')
    elif co.IsRetInt():     
        l.Raw('static long _Direct_', nm, arg, '{')
    elif co.IsRetFloat():     
        l.Raw('static double _Direct_', nm, arg, '{')
    elif co.IsRetChar():     
        l.Raw('static char _Direct_', nm, arg, '{')
    else:    
        l.Raw('static PyObject * _Direct_', nm, arg, '{')
    hid = {}
    for i in co.hidden_arg_direct: 
        hid[co.co_varnames_direct[i]] = True   
    cntvar = generate_stand_direct_header(l, co, typed, o, typed_local, hid, ii)
    if co.co_stacksize != 0:
        l.Raw('PyObject * temp[', co.co_stacksize, '];')
    ## s = 'enum{' 
    if len(co.co_varnames) > 0 and cntvar > 0:
        if no_fastlocals:
            pass
        else:
            l.Raw('PyObject *fastlocals[', cntvar, '];')
    if calc_ref_total:
        l.append('Py_ssize_t l_Py_RefTotal;')
        l.append('l_Py_RefTotal = _Py_RefTotal;')
    if line_number:
        l.Raw('int PyLine = ', co.co_firstlineno, ';')     
        l.append('int PyAddr = 0;')     
    if not redefined_attribute:
        ## if co.self_dict_getattr_used:
            ## if co.method_new_class:
                ## l.append('PyObject **self_dict;')
            ## elif co.method_old_class:
                ## l.append('PyObject *self_dict;')
        for k in co.dict_getattr_used.iterkeys():
            if ( len(calc_const_old_class) > 0 and not is_pypy ) or len(calc_const_new_class) > 0:
                l.Raw('PyObject *_', k, '_dict = 0;')
    ii = 0        
    for i in range(cnt_arg):
        if i in co.hidden_arg_direct:
            continue
        if i in typed_arg and typed_arg[i][0] is int:
            pass
        elif i in typed_arg and typed_arg[i][0] is float:
            pass
        elif i in typed_arg and typed_arg[i][0] is bool:
            pass
        elif i in typed_arg and typed_arg[i] == (str, 1):
            pass
        elif ii < cntvar:
            if no_fastlocals:
                l.Raw('Py_INCREF(_Fast_%s);' % co.co_varnames_direct[i])
            else:
                l.Raw('fastlocals[', ii, '] = Arg_', i, ';')  
                ## if i in co.changed_arg:  
                l.Raw('Py_INCREF(Arg_', i, ');')  
            ii += 1
    for i in range(ii, cntvar):
        if no_fastlocals:
            pass
        else:
            l.Raw('fastlocals[', i, '] = NULL;')   
    if not redefined_attribute:
        ## if co.self_dict_getattr_used:
            ## if co.method_new_class:
                ## l.append('self_dict = _PyObject_GetDictPtr(GETLOCAL(self));')
            ## elif co.method_old_class:
                ## l.append('self_dict = ((PyInstanceObject *)GETLOCAL(self))->in_dict;')
        for k in co.dict_getattr_used.iterkeys():
            ## l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
            ## l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
            ## l.append('} else {')
            ## l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
            ## l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
            ## l.append('}')

            if ( len(calc_const_old_class) > 0 and not is_pypy ) and len(calc_const_new_class) > 0:
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('} else {')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
            elif ( len(calc_const_old_class) > 0 and not is_pypy ) and len(calc_const_new_class) == 0:
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('}')
            elif ( len(calc_const_old_class) == 0 or is_pypy ) and len(calc_const_new_class) > 0:
                l.append('{')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')

    for i in range(co.co_stacksize):
        l.Raw('temp[', i, '] = 0;')
    l.Raw('')        
    l.extend(o)
    o[:] = l[:]         
    return   

    
def stub_generator(co):
    pass    
    
def generate_list(lis, o = None):
    i = 0
    if o is None:
        o = []
##    have_compaund = False    
    ## len_o = 0
    ## if o is not None:
        ## len_o = len(o)
    if recalc_refcnt:
        cnt_prev = New('Py_ssize_t')
        line_prev = New('int')
        o.Raw(cnt_prev, '= _Py_RefTotal;')
        o.Raw(line_prev, '= __LINE__;')
    while i < len(lis):
        assert type(i) is int
        it = lis[i]
        head = it[0]
        assert head[0] != ')' and head[0:2] != ')(' 
        if IsBeg(head):
            i1 = get_closed_pair(lis, i)
            o.Comment(it)
            generate_compaund_statement(head[1:], lis[i:i1+1], o)
            i = i1 + 1
##            have_compaund = True
        else:
            o.Comment(it)
            generate_statement(head, it, o)
            i += 1
        if recalc_refcnt:
            o.Raw('if ((int)(_Py_RefTotal -', cnt_prev, ')) { printf("\\nfunc %s, line %5d:%5d, refcnt %d\\n", "', func, '", ',\
                   line_prev, ',__LINE__, (int)(_Py_RefTotal -', cnt_prev, '));} ',\
                   cnt_prev, '= _Py_RefTotal; ', line_prev, '= __LINE__;')
    if recalc_refcnt:
        o.Cls(cnt_prev, line_prev)
    return o

def get_closed_pair(lis,i):
    if type(lis) is list:
        for i1 in range(i+1, len(lis)):
            lis2 = lis[i1]
            if type(lis2) is tuple:
                lis3 = lis2[0]
                if type(lis3) is str:
                    if lis3[0] == ')' and lis3[0:2] != ')(':
                        return i1
    Fatal('Can\'t get closed pair', lis)
   
def generate_return_statement(it, o):   
    global try_jump_context, dropped_temp
    global traced_tempgen

    current_co.return_cnt += 1
    place = len(o)
##    current_co.returns[len(o)] = 0
    retlabl = ConC('ret_label_', current_co.return_cnt)
    o.Raw(retlabl, ':;')
    o.Raw('if (ping_threading () == -1) goto ', labl, ';')
    UseLabl()
    Used('ping_threading')
    for drop in dropped_temp:
        for t in drop[1]:
            if istempref(t):
                o.Raw('Py_CLEAR(', t, ');')
    try_jump = try_jump_context[:]
    if len(it[1]) == 1 and it[1][0] == 'f->f_locals':
        ref = New()
        if is_current & IS_CFUNC:
            o.Raw(ref, ' = glob;')
        else:    
            assert is_current & IS_CODEFUNC
            o.Raw(ref, ' = ', it[1][0], ';')
        o.INCREF(ref)
        PopClearAll(o)
        if checkmaxref != 0 and not is_pypy:
            o.Raw('if ((', ref, ')->ob_refcnt > ', checkmaxref, ') printf("line %5d, line %6d \\n", __LINE__,(', ref, ')->ob_refcnt);')
        if is_current & IS_CODEFUNC:
            if check_recursive_call:
                o.append('Py_LeaveRecursiveCall();')
            if not is_pypy:
                o.append('tstate->frame = f->f_back;')
        o.Raw('return ', ref, ';')
        Cls1(o, ref)
        return
    if is_current & IS_DIRECT:
        isvoid = current_co.IsRetVoid()
        isbool = current_co.IsRetBool()
        isint = current_co.IsRetInt()
        isfloat = current_co.IsRetFloat()
        ischar = current_co.IsRetChar()
    else:
        isvoid = False
        isbool = False
        isint = False
        isfloat = False
        ischar = False
    if isvoid:
        assert IsKlNone(TypeExpr(it[1]))
    ref = it[1]            
    if isvoid:
        ref = Expr1(ref, o)
        Cls1(o, ref)
        ref = None
    elif IsCVar(ref):
        logical = CVarName(ref)      
        if is_current & IS_CALLABLE_COMPILABLE:
            ref = Expr1(ref, o)
    elif ref[0] == 'CONST' and isbool:
        if ref[1]:
            logical = 1
        else:
            logical = 0  
    elif ref[0] == 'CONST' and (isint or isfloat or ischar):
        logical = ref[1]
    elif isbool:
        ref = Expr1(ref, o)
        logical = New('int')
        o.Raw(logical, ' = PyObject_IsTrue ( ', ref, ' );')
        Cls1(o, ref)
    elif isint: 
        ref = Expr1(ref, o)
        logical = New('long')
        o.Raw('if ((', logical, ' = PyInt_AsLong ( ', ref, ' )) == -1) goto ', labl, ';')
        UseLabl()
        Cls1(o, ref)
    elif ischar: 
        ## print it
        ## assert False
        ref = Expr1(ref, o)
        logical = New('char')
        o.Raw('if (PyString_AsString ( ', ref, ' ) == 0) goto ', labl, ';')
        o.Raw('if (PyString_Size ( ', ref, ' ) != 1) goto ', labl, ';')
        o.Raw(logical, ' = *PyString_AsString ( ', ref, ' );')
        UseLabl()
        Cls1(o, ref)
    elif isfloat: 
        ref = Expr1(ref, o)
        logical = New('double')
        o.Raw('if ((', logical, ' = PyFloat_AsDouble ( ', ref, ' )) == -1) goto ', labl, ';')
        UseLabl()
        Cls1(o, ref)
    else: 
        ref = Expr1(ref, o) 
        if not istempref(ref) and not ( is_current & (IS_DIRECT | IS_CFUNC ) and ref[0] == 'FAST'): 
            o.INCREF(ref) 

    if is_current & IS_CODEFUNC:
        while len(try_jump) > 0:
            if try_jump[-1]:
                if type(try_jump[-1]) is list:
                    o.Comment((')(FINALLY',))
                    o.append('{')
                    generate_list(try_jump[-1],o)
                    o.append('}')                    
            del try_jump[-1]

    if is_current & IS_DIRECT:
        hid = {}
        for i in current_co.hidden_arg_direct: 
            hid[current_co.co_varnames[i]] = True               
        for i,v in enumerate(current_co.co_varnames_direct):
            if v in hid:
                continue
            ## if v in current_co.all_arg and v not in current_co.changed_arg:            
                ## continue
            nmvar = nmvar_to_loc(v)
            if isvoid or isbool or isint or isfloat or \
                (len(ref) != 2 or ref[0] != 'FAST' or ref[1] != nmvar): 
                if not current_co.IsCVar(('FAST', v)) and \
                   (nmvar in current_co.used_fastlocals or current_co.list_compr_in_progress == True):
                    o.CLEAR('GETLOCAL(' + nmvar + ')')

    elif is_current & IS_CFUNC:
        for i,v in enumerate(current_co.co_varnames):
            nmvar = nmvar_to_loc(v)
            if (len(ref) != 2 or ref[0] != 'FAST' or ref[1] != nmvar): 
                if not current_co.IsCVar(('FAST', v)) and \
                   (nmvar in current_co.used_fastlocals or current_co.list_compr_in_progress == True):
                     o.CLEAR('GETLOCAL(' + nmvar + ')')


    for i,v in enumerate(current_co.co_freevars):
        nmvar = nmvar_to_loc(v)
        if isvoid or isbool or (len(ref) != 2 or ref[0] != 'LOAD_CLOSURE' or ref[1] != nmvar): 
            o.CLEAR('GETFREEVAR(' + nmvar + ')')

    PopClearAll(o)
    if calc_ref_total:
        o.Raw('if ((_Py_RefTotal - l_Py_RefTotal) > 0) {printf ("func ', current_co.co_name, ' delta ref = %d\\n", (int)(_Py_RefTotal - l_Py_RefTotal));}')
    if stat_func == func:
        o.append('{')
        o.append('FILE * _refs = fopen(\"%s_end\", \"w+\");' % func)
        o.append('_Py_PrintReferences2(_refs);')  
        o.append('fclose(_refs);')     
        o.append('}')    
    if is_current & IS_CODEFUNC:
        if not is_pypy:
            o.append('if (tstate->frame->f_exc_type != NULL) {')
            PyEval_reset_exc_info(o)      
            o.append('}')
        if check_recursive_call:
            o.append('Py_LeaveRecursiveCall();')
        if not is_pypy:
            o.append('tstate->frame = f->f_back;')
    if isvoid:
        o.append('return 0;')
    elif isbool:
        o.Raw('return ', logical, ';')
        Cls1(o, logical)
    elif isint:
        o.Raw('return ', logical, ';')
        Cls1(o, logical)
    elif ischar:
        if istemptyped(logical):
            o.Raw('return ', logical, ';')
        else:
            o.Raw('return ', Char_for_C(logical), ';')
        Cls1(o, logical)
    elif isfloat:
        o.Raw('return ', logical, ';')
        Cls1(o, logical)
    else:  
        if IsCVar(it[1]):  
            if is_current & IS_CALLABLE_COMPILABLE:
                o.Stmt('return', ref)   
            else:
                ref3 = New()
                CType2Py(o, ref3, logical, TypeExpr(it[1]))    
                o.Stmt('return', ref3)   
                o.ClsFict(ref3)
        else:    
            o.Stmt('return', ref)   
            o.ClsFict(ref)
    if is_current & IS_DIRECT:
        if tuple(o[place+1:]) in current_co.returns_direct:
            rets = current_co.returns_direct[tuple(o[place+1:])]
            o[place:] = ['goto ' + rets[1] + ';']
            current_co.used_return_labels[rets[1]] = True
            return
        current_co.returns_direct[tuple(o[place+1:])] = (place, retlabl)   
    if is_current & IS_CFUNC:
        if tuple(o[place+1:]) in current_co.returns_cfunc:
            rets = current_co.returns_cfunc[tuple(o[place+1:])]
            o[place:] = ['goto ' + rets[1] + ';']
            current_co.used_return_labels[rets[1]] = True
            return
        current_co.returns_cfunc[tuple(o[place+1:])] = (place, retlabl)   
    return
    
def del_unused_ret_label(o):
    i = 0
    while i < len(o):
        assert type(i) is int
        s = o[i]
        if s.startswith('ret_label_') and s.endswith(':;'):
            retlabl = s[:-2]
            if retlabl not in current_co.used_return_labels:
                del o[i]
                continue
        i += 1
        
def generate_statement(head, it, o):
    global current_co, Line2Addr
    if type(it) is not tuple:
        Fatal('Not tuple', it)
    if head == '.L':
        if line_number:
            if is_current & IS_DIRECT or is_current & IS_CFUNC:
                o.Raw('PyLine = ', str(it[1]), ';')
            else:    
                o.Stmt('f->f_lineno', '=', it[1])
            if it[1] in Line2Addr:
                if is_current & IS_DIRECT or is_current & IS_CFUNC:
                    o.Raw('PyAddr = ', str(Line2Addr[it[1]]), ';')
                elif not is_pypy:    
                    o.Raw('f->f_lasti = ', str(Line2Addr[it[1]]), ';')
            if print_pyline:
                o.Stmt('printf', '\"Py:' + filename +':%5d\\n\"', it[1])
        
        return

    if head == 'STORE':
        if len(it) == 3 and len(it[1]) == 1 and len(it[2]) == 1:
            if it[1][0][0] == 'STORE_FAST' and IsCVar(('FAST', it[1][0][1])):
                if CSetVariable(o, ('FAST', it[1][0][1]), it[2][0]):
                    return
            elif (it[1][0][0] == 'STORE_GLOBAL' or (it[1][0][0] == 'STORE_NAME' and func == 'Init_filename')) and IsCVar(('!LOAD_GLOBAL', it[1][0][1])):
                add_fast_glob(it[1][0][1])
                if CSetVariable(o, ('!LOAD_GLOBAL', it[1][0][1]), it[2][0]):
                    return
        if len(it[2]) == 1 and len(it[1]) == 1:
            if is_like_float(it[2][0]) and it[2][0][0] != 'CONST':
                acc = []
                isfloat = {}
                if parse_for_float_expr(it[2][0], acc, isfloat):
                    if len(acc) >= 2 or \
                       (len(acc) == 1 and acc[0][0] == 'CONST' and \
                        type(acc[0][1]) is float):
                       return generate_mixed_float_expr(it,acc,o, isfloat)
            acc = detect_repeated_subexpr(it[1][0], it[2][0]).keys()
            refs = Expr(o, acc) #[Expr1(x, o) for x in acc]
            PushAcc(acc, refs)
            ## if len(acc) > 0: 
                ## pprint(acc)  
            ref = Expr1(it[2][0], o)
            if it[2][0][0] == 'FAST':
                stor = ('STORE_FAST', it[2][0][1])
                if repr(stor) in repr(it[1][0]):
                    ref2 = New()
                    o.Raw(ref2, ' = ', ref, ';')
                    o.INCREF(ref2)
                    ref = ref2
                    ref2 = None
            generate_store(it[1][0], ref, o, it[2][0])
            PopAcc(o)      
            o.Cls(*refs)              
            Cls1(o, ref)
            if ref not in g_refs2:
                o.ZeroTemp(ref)
            return
        Fatal('MultyStore', it)

    if head == 'SEQ_ASSIGN':
        ref = Expr1(it[2], o)
        PushAcc([ref], [ref])
        for i in range(len(it[1])-1):
            o.INCREF(ref)
        for iit in it[1]:
          generate_store(iit, ref, o, it[2])
        PopAcc(o, False)
        Cls1(o, ref)
        return

    if head == 'SET_EXPRS_TO_VARS':
        if len(it[1]) == 2 and it[2][0] == 'CLONE':
            ref = Expr1(it[2][1],o)
            o.ClsFict(ref)
            generate_store(it[1][0], ref, o, it[2][1])
            generate_store(it[1][1], ref, o, it[2][1])
            if istempref(ref):
                o.CLEAR(ref)
            return
        assert len(it[2]) == len(it[1])
        stor = dict.fromkeys([x[0] for x in it[1]]).keys()
        srepr = repr(it[2])
        if len(stor) == 1 and stor[0] == 'STORE_FAST':
            gets = [('FAST', x[1]) for x in it[1]]
            gets.extend([('LOAD_FAST', x[1]) for x in it[1]])
            pure = True
            for ge in gets:
                if repr(ge) in srepr:
                    pure = False
            if pure:
                for i,iit in enumerate(it[1]):
                    ref1 = Expr1(it[2][i], o)
                    generate_store(iit,ref1,o, it[2][i])
                    Cls1(o, ref1)
                return
        expr = TupleFromArgs(it[2])
        ref = Expr1(expr, o)
        its = it[1]
        ## s_ref = CVar(ref)
        for i,iit in enumerate(its):
            ref1 = New()
            o.Stmt(ref1, '=', 'PyTuple_GET_ITEM', ref, i)
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM',))
            Cls1(o, ref1)
        Cls1(o, ref)
        return

    if head == 'RETURN_VALUE':
        generate_return_statement(it, o)
        return
    if head == 'CALL_PROC':
        Fatal('Illegal', it)
        return
    if head == 'UNPUSH':
        if like_append(it[1]):
            generate_may_be_append(it[1], o)
            return
        _v = []
        if like_append_const(it[1], _v):
            generate_may_be_append_const(it[1], o, _v)
            return
        if it[1][0] == '!COND_METH_EXPR':
            generate_cond_meth_expr_new(it[1], o, None, True)
            return
        t = TypeExpr(it[1])
        if t is not None and t != Kl_None:
            if ( IsCType(t) or IsIntUndefSize(t) ) and it[1][0] in ('!PyNumber_Subtract', '!PyNumber_Add', '!PyNumber_And','!PyNumber_Or', '!PyNumber_Divide', '!_EQ_', '!_NEQ_'):
                generate_statement('UNPUSH', it[1][1], o)
                generate_statement('UNPUSH', it[1][2], o)
                return
##            print '/3', 'UNPUSH', it[1][0], TypeExpr(it[1])
        ref = Expr1(it[1], o)
        Cls1(o, ref)
        return
    if head == 'PYAPI_CALL':
        iit = it[1]
        gen = []
        for i in range(len(iit)):
            if i > 0:
                if type(iit[i]) is tuple and len(iit[i]) > 0:
                    gen.append(Expr1(iit[i], o))
                else:
                    gen.append(iit[i])
        if iit[0] in CFuncIntCheck:        
#            Debug('iiy', iit, gen)
            args = (iit[0],) + tuple(gen)       
            o.Stmt(*args)
            o.Cls(*gen)
            return    
        elif iit[0] in CFuncVoid:        
            args = (iit[0],) + tuple(gen)       
            o.Stmt(*args)
            o.Cls(*gen)
            return    
        else:
            Fatal('', it)

    if head == 'IMPORT_FROM_AS':
        if it[3][0] == 'CONST' and len(it[3][1]) == len(it[4]):
            ref = Expr1(('!IMPORT_NAME', it[1],it[2],it[3]), o)
            for i in range(len(it[4])):
                ref1 = New()
                o.Raw('if ((', ref1, ' = PyObject_GetAttr( ', ref, ', ', ('CONST', it[3][1][i]), ')) == 0) {')
                o.Raw('if (PyErr_ExceptionMatches(PyExc_AttributeError)) {')
                o.Raw('PyErr_Format(PyExc_ImportError, ', ('"cannot import name %s"' % it[3][1][i]), ');')
                o.append('}')
                o.Raw('goto ', labl, ';')
                UseLabl()
                o.append('}')
                generate_store(it[4][i], ref1,o, it)
            Cls1(o, ref)
            return
        Fatal('', it)
        return
    if head == 'PRINT_ITEM_TO_2':
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref2)
        o.Cls(ref1, ref2)
        return
    if head == 'PRINT_ITEM_AND_NEWLINE_TO_2':
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref2)
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', ref1)
        o.Cls(ref1, ref2)
        return
    if head == 'PRINT_ITEM_AND_NEWLINE_TO_3':
        ref1, ref2, ref3 = Expr(o, it[1:])
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref2)
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref3)
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', ref1)
        o.Cls(ref1, ref2, ref3)
        return
    if head == 'PRINT_ITEM_1':
        ref1 = Expr1(it[1], o)
        o.Stmt('_PyEval_PRINT_ITEM_1', ref1)
        Cls1(o, ref1)
        return
    if head == 'PRINT_NEWLINE_TO_1':
        ref1 = Expr1(it[1], o)
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', ref1)
        Cls1(o, ref1)
        return
    if head == 'PRINT_NEWLINE':
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', 'NULL')
        return
    if head == 'DELETE_ATTR_2':
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('PyObject_SetAttr', ref1, ref2, 'NULL')
        o.Cls(ref1, ref2)
        return
    if head == 'DELETE_SUBSCR':
        t = TypeExpr(it[1])
        t_ind = TypeExpr(it[2])
        if IsList(t) and IsInt(t_ind):
            ref1 = Expr1(it[1],o)
                
            o2,ind1 = shortage(generate_ssize_t_expr(it[2]))
            o.extend(o2)
            if type(ind1) is int:
                if ind1 < 0:
                    ind2 = New('long')
                    o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')
                    _ind1 = New('long')
                    o.Stmt(_ind1, '=', ind1, '+', ind2)
                    ind1 = _ind1
                else:
                    ind2 = ind1 + 1
            elif ind1[0] == 'CONST':
                if ind1[1] < 0:
                    ind2 = New('long')
                    o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')
                    _ind1 = New('long')
                    o.Stmt(_ind1, '=', ind1[1], '+', ind2)
                    ind1 = _ind1
                else:
                    ind1, ind2 = ind1[1], ind1[1]+1
            else:   
                ind2 = New('long')
                o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')                
                if not istemptyped(ind1):
                    ind_ = New('long')
                    o.Raw(ind_, ' = ', ind1, ';')
                    ind1 = ind_
                o.Stmt('if (', ind1, '< 0) {')
                o.Stmt(ind1, '=', ind1, '+', ind2)
                o.append('}')     
            if type(ind2) is not int:
                o.Stmt(ind2, '=', ind1, '+', 1)
            o.Stmt('PyList_SetSlice', ref1, ind1, ind2, 'NULL')
            o.Cls(ref1, ind1, ind2)
            return    
            
        if t is not None and t != Kl_Dict:
            Debug('Typed ' + head, t, it)
        ref1, ref2 = Expr(o, it[1:])
        if IsDict(t):
            o.Stmt('PyDict_DelItem', ref1, ref2)
        else:    
            o.Stmt('PyObject_DelItem', ref1, ref2)
        o.Cls(ref1, ref2)
        return
    if head == 'DELETE_SLICE+0':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, 'NULL')
            return    
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1 = Expr1(it[1], o)
        o.Stmt('PySequence_DelSlice', ref1, 0, 'PY_SSIZE_T_MAX')
##        o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', 'NULL', 'NULL')
        Cls1(o, ref1)
        return    
    if head == 'DELETE_SLICE+1':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, 'NULL')
            return    
            
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1, ref2 = Expr(o, it[1:])
        if isintconst(ref2):
            o.Stmt('PySequence_DelSlice', ref1, ref2[1], 'PY_SSIZE_T_MAX')
        else:    
            o.Stmt('_PyEval_AssignSlice', ref1, ref2, 'NULL', 'NULL')
        o.Cls(ref1, ref2)
        return    
    if head == 'DELETE_SLICE+2':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1, ref2 = Expr(o, it[1:])
        if isintconst(ref2):
            o.Stmt('PySequence_DelSlice', ref1, 0, ref2[1])
        else:    
            o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', ref2, 'NULL')
        o.Cls(ref1, ref2)
        return    
    if head == 'DELETE_SLICE+3':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1, ref2, ref3 = Expr(o, it[1:])
        if isintconst(ref2) and isintconst(ref3):
            o.Stmt('PySequence_DelSlice', ref1, ref2[1], ref3[1])
        else:    
            o.Stmt('_PyEval_AssignSlice', ref1, ref2, ref3, 'NULL')
        o.Cls(ref1, ref2, ref3)
        return    
    if head == 'DELETE_GLOBAL':
        if build_executable and it[1] not in d_built and it[1][0] != '_' and \
            not redefined_all and not global_used_at_generator(it[1]):
            add_fast_glob(it[1])
            o.Stmt('SETSTATIC', it[1], 'NULL')
            return
        ref1 =  Expr1(('CONST', it[1]),o)
        o.Stmt('PyDict_DelItem', ('glob',), ref1)
        Cls1(o, ref1)
        return
    if head == 'CONTINUE':
        if try_jump_context[-1]:
            if type(try_jump_context[-1]) is list:
                o.Comment((')(FINALLY',))
                o.append('{')
                generate_list(try_jump_context[-1],o)
                o.append('}')                    
##            o.Stmt('PyFrame_BlockPop', 'f')
        o.append('continue;')
        return
    if head == 'BREAK_LOOP':
        if try_jump_context[-1]:
            if type(try_jump_context[-1]) is list:
                o.Comment((')(FINALLY',))
                o.append('{')
                generate_list(try_jump_context[-1],o)
                o.append('}')                    
##            o.Stmt('PyFrame_BlockPop', 'f')
        o.append('break;')
        return
    if head == 'EXEC_STMT_3':
        current_co.Use_all_fastlocals()
        r1, r2, r3 = Expr(o, it[1:])
        plain = False
        
        if r2 == ('CONST', None) == r3:
            if it[1][0] == '!BUILD_TUPLE' and len(it[1][1]) in (2,3):
                pass
            else:
                r2 = 'glob'
                o.append('PyFrame_FastToLocals(f);')
                r3 = 'f->f_locals'
                plain = True
        if r2 != ('CONST', None) and ('CONST', None) == r3:
            r3 = r2
        ## o.INCREF(r1)    
        ## o.INCREF(r2)    
        ## o.INCREF(r3)    
        o.Stmt('_PyEval_ExecStatement', 'f', r1,r2,r3)
        if plain:
            o.append('PyFrame_LocalsToFast(f, 0);')
        ## o.DECREF(r1)    
        ## o.DECREF(r2)    
        ## o.DECREF(r3)    
        o.Cls(r1, r2, r3)
        return
    if head == 'DELETE_NAME':
        ref1 = Expr1(('CONST', it[1]),o)
        o.Stmt('PyObject_DelItem', 'f->f_locals', ref1)
        Cls1(o, ref1)
        return
    if head == 'RAISE_VARARGS_STMT' or head == 'RAISE_VARARGS':
        assert it[1] == 0
        if len(it) < 3:
            refn = []
        else:    
            refn = Expr(o, it[2])
        while len(refn) < 3:
            refn.append('NULL')
        assert len(refn) == 3    
        if refn[0] != 'NULL':
             o.INCREF(refn[0])
        if refn[1] != 'NULL':
            o.INCREF(refn[1])
        if refn[2] != 'NULL':
            o.INCREF(refn[2])
        o.Stmt('_PyEval_DoRaise', refn[0], refn[1], refn[2])
#        if not istempref(refn[0]):
        o.Cls(*refn)
        o.Stmt('goto', labl)
        UseLabl()
        return
    if head == 'IMPORT_STAR':
        current_co.Use_all_fastlocals()
        o.Stmt('PyFrame_FastToLocals', 'f')
        ref1 = Expr1(it[1],o)
        o.Stmt('_PyEval_ImportAllFrom', 'f->f_locals', ref1);
        o.Stmt('PyFrame_LocalsToFast', 'f', 0)
        Cls1(o, ref1)
        return
    if head == 'DELETE_FAST':
        o.Stmt('SETLOCAL', it[1], 'NULL')
        return
    if head == 'PASS':
        pass
        return
    Fatal('HEAD', head, it)
    
def like_append(it):
    v = []
    return TCmp(it,v,('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'append')),\
                    ('!BUILD_TUPLE', ('?',)), ('NULL',)))
                    
def like_append_const(it, v):
    return TCmp(it,v,('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'append')),\
                    ('CONST', ('?',)), ('NULL',)))          
                        
    ## try:
        ## return it[0] == '!PyObject_Call' and it[1][0] == '!PyObject_GetAttr' and\
            ## it[1][2][0] == 'CONST' and it[1][2][1] == 'append' and \
            ## it[2][0] == '!BUILD_TUPLE' and len(it[2][1]) == 1 and \
            ## len(it[2]) == 2 and it[3][0] == 'NULL'
    ## except:
        ## pass
    ## return False

def generate_may_be_append(it, o):
    ref_list = Expr1(it[1][1], o)
    ref_value = Expr1(it[2][1][0], o)
    t = TypeExpr(it[1][1])
    islist = False
    if t is None:
        pass
    elif IsList(t):
        islist = True
    elif t[0] == T_NEW_CL_INST and Is3(t[1], 'Derived', ('!LOAD_BUILTIN', 'list')):
        islist = True
    _generate_may_be_append(ref_list, ref_value, o, islist)
    o.Cls(ref_value, ref_list)

def generate_may_be_append_const(it, o, v):
    ref_list = Expr1(v[0], o)
##    ref_value = Expr1(it[2][1][0], o)
    t = TypeExpr(v[0])
    islist = False
    if t is None:
        pass
    elif IsList(t):
        islist = True
    elif t[0] == T_NEW_CL_INST and Is3(t[1], 'Derived', ('!LOAD_BUILTIN', 'list')):
        islist = True
    _generate_may_be_append_const(ref_list, v[1], o, islist)
    Cls1(o, ref_list)

def _generate_may_be_append_const(ref_list, v1, o, islist = False):
    if not islist:
        o.Stmt('if (PyList_Check(', ref_list, ')) {')
    o.Stmt('PyList_Append', ref_list, ('CONST', v1))
    if not islist:
        o.append('} else {')
        ref_attr = New()
        o.Stmt(ref_attr, '=', 'PyObject_GetAttr', ref_list, ('CONST', 'append'))    
        ref_return = New()
        o.Stmt(ref_return, '=', 'FirstCFunctionCall', ref_attr, ('CONST', (v1,)), ('NULL',))
        o.Cls(ref_return, ref_attr)
        o.append('}')


def _generate_may_be_append(ref_list, ref_value, o, islist = False):
    if not islist:
        o.Stmt('if (PyList_Check(', ref_list, ')) {')
    o.Stmt('PyList_Append', ref_list, ref_value)
    if not islist:
        o.append('} else {')
        ref_attr = New()
        o.Stmt(ref_attr, '=', 'PyObject_GetAttr', ref_list, ('CONST', 'append'))    
        ref_tuple = New()
        o.Stmt(ref_tuple, '=', 'PyTuple_New', 1)
        o.INCREF(ref_value)
        o.Stmt('PyTuple_SET_ITEM', ref_tuple, 0, ref_value)
        ref_return = New()
        o.Stmt(ref_return, '=', 'FirstCFunctionCall', ref_attr, ref_tuple, ('NULL',))
        o.Cls(ref_return, ref_tuple, ref_attr)
        o.append('}')
 
def _detect_r_subexpr(e, acc2):
    if not (type(e) is tuple) or len(e) == 0 or \
       e[0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
        return
    if type(e) is tuple and len(e) > 0 and e[0] == 'PY_TYPE':
        return _detect_r_subexpr(e[3], acc2)
   
    if e in acc2:
        acc2[e] = acc2[e] + 1
    else:    
        acc2[e] = 1    
    if type(e) is tuple and len(e) > 0:
        if e[0] == '!BUILD_MAP':
            e = e[1]    
            for i,it in enumerate(e):
                if i == 0 or not (type(it[0]) is tuple) or len(it[0]) == 0 or \
                it[0][0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
                    pass
                else:
                    _detect_r_subexpr(it[0], acc2)     
                if i == 0 or not (type(it[1]) is tuple) or len(it[1]) == 0 or \
                it[1][0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
                    pass
                else:
                    _detect_r_subexpr(it[1], acc2)     
            return        
        if e[0] in ('!BUILD_LIST', '!BUILD_TUPLE'):
            e = e[1]    
            for i,it in enumerate(e):
                acc2[it] = -100000    
        for i,it in enumerate(e):
                if i == 0 or not (type(it) is tuple) or len(it) == 0 or \
                    it[0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
                    continue
                _detect_r_subexpr(it, acc2)     
    return
    
def cond_in_expr(e):    
    s_repr_e = repr(e)
    return 'AND' in s_repr_e or 'OR' in s_repr_e or 'COND' in s_repr_e
    
def detect_repeated_subexpr(store, expr):
    acc2 = {}
    if cond_in_expr(expr):
        return {}
    _detect_r_subexpr(expr,acc2)    
    if len(store) > 0 and store[0] in ('PyObject_SetItem', 'PyObject_SetAttr'):
        if cond_in_expr(store[1]) or cond_in_expr(store[2]):
            return {}
        _detect_r_subexpr(store[1],acc2)
        _detect_r_subexpr(store[2],acc2)
    d = {}
    for k,v in acc2.iteritems():
        if v > 1:
            d[k] = v
    todel = {}
    for k,v in d.iteritems():        
        if k[0] in ('!BUILD_LIST', '!BUILD_TUPLE', '!BUILD_MAP', 'CONST', \
                    '!CLASS_CALC_CONST', '!CLASS_CALC_CONST_NEW', \
                    '!PyObject_Call', '!FirstCFunctionCall', '!FastCall') or k[0] != '!from_ceval_BINARY_SUBSCR':
            todel[k] = True
        else:
##            pprint(k)
            try:
                t = TypeExpr(k)
            except:
                t = None
#            if not IsIntOrFloat(t):
            todel[k] = True
                    
    for k in todel.keys():
        del d[k]
    todel = {}  
    for k,v in d.iteritems():      
        s_repr_k = repr(k)  
        for k1,v1 in d.iteritems():        
            if k != k1 and repr(k1) in s_repr_k and v1 == v:
               todel[k1] = True
    for k in todel.keys():
        del d[k]  
    return d    

def find_common_subexpr_for_float(it,acc):
    d = detect_repeated_subexpr(it[1][0], it[2][0])
    subfloat = {}
    upfloat = {}
    todel = {}
    for k in d.iterkeys():
        for x in acc:
            if k == x:
                todel[k] = True
    for k in todel.keys():
        del d[k]            
    for k in d.iterkeys():
        s_repr_k = repr(k)
        for x in acc:
            s_repr_x = repr(x)
            if s_repr_k in s_repr_x:
                subfloat[k] = subfloat.get(k,0) + 1
            if s_repr_x in s_repr_k:
                upfloat[k] = upfloat.get(k,0) + 1
# k1 and k2 is uniq => todel is uniq
#--
# I don't know... And I don't                 
    for k in [k1 for k1 in upfloat.iterkeys() \
                              for k2 in subfloat.iterkeys() if k1 == k2]:
        del subfloat[k]            
        del upfloat[k]  
    return subfloat.keys()
    
def generate_mixed_float_expr(it,acc,o,isfloat):
    assert (it[1] is None or len(it[1]) == 1) and len(it[2]) == 1
    acc_subfloat = find_common_subexpr_for_float(it,acc)
    refs_subfloat = Expr(o, acc_subfloat) #[Expr1(x, o) for x in acc_subfloat]
    PushAcc(acc_subfloat, refs_subfloat)
    refs = Expr(o, acc) #[Expr1(x, o) for x in acc]
    PopAcc(o)
    seq = 'if ('
    for i,x in enumerate(refs):
        if x[0] != 'CONST' and not IsFloat(TypeExpr(acc[i])) :
            seq = seq + 'PyFloat_CheckExact(' + CVar(x) + ')'
            seq = seq + ' && '
    if seq == 'if (':
       seq = 'if (1) {'
    else:    
        seq = seq[:-4] + ') {'
    o.append(seq)
    floats = []
    for x in refs:
        if x[0] == 'CONST':
            if hasattr(math, 'isnan') and math.isnan(x[1]):
                if not '-' in str(x[1]):
                    floats.append('Py_NAN')
                else:    
                    floats.append('(-(Py_NAN))')
            elif hasattr(math, 'isinf') and math.isinf(x[1]):
                if not '-' in str(x[1]):
                    floats.append('Py_HUGE_VAL')
                else:
                    floats.append('-Py_HUGE_VAL')    
            else:    
                floats.append(x)
        else:
            floats.append(New('double'))
    text_floats = []        
    for x in floats:
        if x[0] == 'CONST':
            text_floats.append(str(x[1]))
        else:
            text_floats.append(CVar(x))
    for i, x in enumerate(floats):
        if istemptyped(x):
            o.Stmt(x, '=', 'PyFloat_AS_DOUBLE', refs[i])        
    float_seq = generate_float_expr(it[2][0], acc, text_floats)    
    ref = New()
    o.Stmt(ref, '=', 'PyFloat_FromDouble', float_seq)
    o.Cls(*floats)
    o.append('} else {')
    PushAcc(acc_subfloat+acc, refs_subfloat+refs)
    if len(floats) <= 2:
        ref = GenExpr(it[2][0], o, ref,None,True)
    else:    
        ref = GenExpr(it[2][0], o, ref)
    PopAcc(o, False)
    o.append('}')
    o.Cls(*refs)
    PushAcc(acc_subfloat, refs_subfloat)
    if it[1] is not None:
        generate_store(it[1][0], ref, o, acc)
    PopAcc(o, False)
    o.Cls(*refs_subfloat)    
    if it[1] is not None:
        Cls1(o, ref)
    else:
        return ref    
    return
    
def generate_compaund_statement(head,it,o):
    if head == 'IF':
        generate_if(it,o)
        return
    if head == 'PREEXPR':
        generate_preexpr(it,o)
        return
    if head == 'WHILE':
        prev_compr = current_co.list_compr_in_progress
        current_co.list_compr_in_progress = True
        generate_while(it,o)
        current_co.list_compr_in_progress = prev_compr
        return
    if head == 'FOR':
        prev_compr = current_co.list_compr_in_progress
        current_co.list_compr_in_progress = True
##        current_co.Use_all_fastlocals()
        generate_for_new(it,o)
        current_co.list_compr_in_progress = prev_compr
        return
    if head == 'TRY': 
        current_co.Use_all_fastlocals()
        if attempt_iteration_try(it, o):
            return 
        generate_try(it,o)
        return
    if head == 'TRY_FINALLY': 
        current_co.Use_all_fastlocals()
        generate_try_finally(it,o)
        return
    if head == 'WITH':
        current_co.Use_all_fastlocals()
        generate_with(it,o)
        return
    Fatal('', it)

def generate_with(it,o):
    global try_jump_context, dropped_temp
    global traced_tempgen
    
##    raised = None
    try_j = try_jump_context[:]
    assert len(it) == 3 and it[2] == (')ENDWITH',) and len(it[0]) == 3 and it[0][0] == '(WITH'
    r0 = Expr1(it[0][1], o)
    o.INCREF(r0)
    r1 = New()
    r2 = New()
    ref1 = New()
    if tuple(sys.version_info)[:2] < (2,7):
        o.Raw('if ((', r1, ' = PyObject_GetAttr(', r0, ', ', ('CONST', '__enter__'), ')) == 0) goto ', labl, ';')
        o.Raw('if ((', r2, ' = PyObject_GetAttr(', r0, ', ', ('CONST', '__exit__'), ')) == 0) goto ', labl, ';')
    else:    
        o.Raw('if ((', r1, ' = from_ceval_2_7_special_lookup(', r0, ', "__enter__", &from_ceval_2_7_enter)) == 0) goto ', labl, ';')
        o.Raw('if ((', r2, ' = from_ceval_2_7_special_lookup(', r0, ', "__exit__", &from_ceval_2_7_exit)) == 0) goto ', labl, ';')
        Used('from_ceval_2_7_special_lookup')
    o.Raw('if ((', ref1, ' = PyObject_Call(', r1, ', ', ('CONST', ()), ', NULL)) == 0) goto ', labl, ';')
    Cls1(o, r1)

    if it[0][2] == (): 
        pass
    elif len(it[0][2]) == 1 and it[0][2][0][0] in set_any:
        generate_store(it[0][2][0], ref1, o, 'Store clause at WITH statement')
    elif it[0][2][0] == 'SET_VARS':
        generate_store(it[0][2], ref1, o, 'Multy store clause at WITH statement')
    elif len(it[0][2]) == 2 and it[0][2][0] in set_any:
        generate_store(it[0][2], ref1, o, 'Store clause at WITH statement')
    elif len(it[0][2]) == 3 and it[0][2][0] in ('PyObject_SetAttr', 'PyObject_SetItem'):
        generate_store(it[0][2], ref1, o, 'Store clause at WITH statement')
    else:
        Fatal('WITH error', len(it[0][2]), it[0][2], it)
    Cls1(o, ref1) 
        
    ## if it[1] == [('PASS',)]:     
        ## ref2 = New()
        ## o.Raw('if ((', ref2, ' = PyObject_Call(', r2, ', ', ('CONST', (None,None,None)), ', NULL)) == 0) goto ', labl, ';')
        ## UseLabl()
        ## o.Cls(r2, ref2, r0)
        ## try_jump_context[:] = try_j
        ## return
    try_jump_context.append(True)
    o.append('{')
    label_exc = New('label')  
    global traced_tempgen
    a,b,c = New(), New(), New()
    o.Stmt('PyErr_Fetch', ('&', a), ('&', b), ('&', c)) 
    set_toerr_new(o, label_exc)
    o.XINCREF(a)
    o.XINCREF(b)
    o.XINCREF(c)
##    o.Stmt('PyFrame_BlockSetup', 'f', 'SETUP_EXCEPT',-1, -1)
    dropped_temp.append(('WITH', (ref1, r2, a,b,c)))
    traced_tempgen.append({})
    generate_list(it[1],o)
    traced_temp = traced_tempgen[-1].keys()
    del traced_tempgen[-1]
    if len(traced_tempgen) > 0:
        for k in traced_temp:
            traced_tempgen[-1][k] = True
##    o.Stmt('PyFrame_BlockPop', 'f')
    set_toerr_back(o)
    o.Stmt('PyErr_Restore', a,b,c)   
    ref2 = New()
    o.Raw('if ((', ref2, ' = PyObject_Call(', r2, ', ', ('CONST', (None,None,None)), ', NULL)) == 0) goto ', labl, ';')
    bool_ret = None
##    o.Cls(ref2, r2)
    UseLabl()
    raised = None
##        ref2 = Expr1(('!PyObject_Call', r2, ('CONST', (None,None,None)), 'NULL'),o)
    if IsUsedLabl(label_exc):   
        raised = New('int')
        o.Raw(raised, ' = 0;')
        o.Stmt('if (0) { ', label_exc, ':')
        o.Stmt(raised, '=', 1)
        o.append('PyTraceBack_Here(f);') 
        generate_clear_temp_on_exception(o, traced_temp)
        ae,be,ce = get_exc_info(o)
        o.XINCREF(ae)
        o.XINCREF(be)
        o.XINCREF(ce)
        tupl = New()
        o.Raw(tupl, ' = PyTuple_Pack(3, ', ae, ', ', be, ', ', ce, ');')
        ref2 = New()
        o.Raw('if ((', ref2, ' = PyObject_Call(', r2, ', ', tupl, ', NULL)) == 0) goto ', labl, ';')
        o.Cls(tupl, r2)
        bool_ret = New('int')
        o.Raw('if (', ref2, ' == Py_None) ', bool_ret, ' = 0;')
        o.Raw('else {')
        o.Raw('if ((', bool_ret, ' = PyObject_IsTrue(', ref2, ')) == -1) goto ', labl, ';')
        o.append('}')
        Cls1(o, ref2)
        UseLabl()

##        o.Stmt('PyFrame_BlockPop', 'f')
        o.Raw('if (', bool_ret, ') {')
        o.Stmt('PyErr_Restore', a,b,c)
        PyEval_reset_exc_info(o)       
        o.append('} else {')
        o.Stmt('PyErr_Restore', ae,be,ce)   
        o.append('}')
        o.Cls(ae, be, ce)
##            o.Stmt('PyErr_Restore', a,b,c)
        o.append('}')
    o.append('}')
    o.DECREF(r0)
    o.Cls(ref2, a, b, c, r0, r2, r1)
#        o.Cls(*refs) 
    if raised is not None:
        o.Raw('if (', raised, ' && !', bool_ret,') { goto ',labl, '; }')
    UseLabl()
    o.Cls(raised, bool_ret)
    set_toerr_final(o)
    del dropped_temp[-1]
    try_jump_context[:] = try_j
    return

def attempt_iteration_try(it, o):
    if len(it) != 5:
        return False
    body = it[1]
    exc = it[2]
    handle = it[3]
    while len(body) > 0 and body[0][0] == '.L':
        body = body[1:]
    if len(body) == 0:
        return False    
    stmt = body[0]    
    no_append = False
    iter = None
    if stmt[0] == 'STORE':
        if len(stmt[1]) != 1 or len(stmt[2]) != 1:
            return False
        action = stmt[2][0]
        iter = is_attr_next_call(action)
        if iter == False:
            return False
        no_append = True
    elif 'next' in repr(stmt):
        if stmt[0] != 'UNPUSH':
            return False
        if not like_append(stmt[1]):
            return False
        ## expr_list = stmt[1][1][1]
        expr_value = stmt[1][2][1][0]
        iter = is_attr_next_call(expr_value)
        if iter == False:
            return False
        no_append = False
    if exc[0] != ')(EXCEPT':
        return False
    if len(exc) >= 3 and exc[2] != ():
        return False
    if len(exc) < 2:
        return False
    excarg = exc[1]
    if len(excarg) == 2:
        if type(excarg[1]) is int:
            excarg = (excarg[0],)
    if len(excarg) == 1 and type(excarg) is tuple:
        excarg = excarg[0]
    if len(excarg) != 2:
        return False
    if excarg[1] != 'StopIteration':
        return False 
    if iter is None:
        return False
    ref_iter = Expr1(iter,o)
    o.Stmt('if (PyIter_Check(', ref_iter, ')) {')
    val_iter = New()
    o.Stmt(val_iter, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (', val_iter, '!= NULL ) {')
    Cls1(o, ref_iter)    
    if no_append:
        generate_store(stmt[1][0], val_iter, o, stmt)
        o.ZeroTemp(val_iter)  
    else:
        ref_list = Expr1(stmt[1][1][1], o)
        _generate_may_be_append(ref_list, val_iter, o, IsList(TypeExpr(stmt[1][1][1])))
        Cls1(o, ref_list)
    Cls1(o, val_iter)
    generate_list(body[1:], o)   
    o.append('} else {')
    generate_list(handle, o)   
    o.append('}')
    o.append('} else {')
    generate_try(it, o)   
    o.append('}')
    return True

def is_attr_next_call(action):
    if action[0] != '!PyObject_Call':
        return False
    if len(action[2]) != 2:
        return False
    if action[2][0] != 'CONST':
        return False
    if action[2][1] != ():
        return False
    if len(action[3]) != 1:
        return False
    if action[3][0] != 'NULL':
        return False
    if len(action[1]) != 3:
        return False
    if action[1][0] != '!PyObject_GetAttr':
        return False
    if len(action[1][2]) != 2:
        return False
    if action[1][2][0] != 'CONST':
        return False
    if action[1][2][1] != 'next':
        return False
    return action[1][1]         

def generate_try(it,o2):
    global try_jump_context, dropped_temp, Line2Addr, line_number
    o = Out()

    else_cod = None
    i = 2
    while i < len(it):
        assert type(i) is int
        if it[i][0] == ')(EXCEPT':
            i += 2
            continue
        elif it[i][0] == ')(ELSE':
            else_cod = it[i+1]
            del it[i]
            del it[i]
            continue
        elif it[i][0] == ')ENDTRY':
            del it[i]    
        else:
            Fatal('', it, i, it[i])
    try_jump_context.append(True)
##    o.append('{')
    to_else = New('int')
    o.Stmt(to_else, '=', 1)
    label_exc = New('label') 

    global traced_tempgen
    a = New()
    b = New()
    c = New()
    o.Stmt('PyErr_Fetch', ('&', a), ('&', b), ('&', c))
    dropped_temp.append(('TRY', (a,b,c)))
    ## o.XINCREF(a)
    ## o.XINCREF(b)
    ## o.XINCREF(c)
    set_toerr_new(o, label_exc)
##    o.Stmt('PyFrame_BlockSetup', 'f', 'SETUP_EXCEPT',-1, -1)

    traced_tempgen.append({})
    generate_list(it[1],o)
    traced_temp = traced_tempgen[-1].keys()
    del traced_tempgen[-1]
    if len(traced_tempgen) > 0:
        for k in traced_temp:
            traced_tempgen[-1][k] = True
##    o.Stmt('PyFrame_BlockPop', 'f')
    set_toerr_back(o)
    o.Stmt('PyErr_Restore', a,b,c)   

    a1,b1,c1 = None,None,None
    i = 2
    ## first_except = True
    if not IsUsedLabl(label_exc):        
        del try_jump_context[-1]     
        if else_cod is not None:
            o.Comment((')(ELSE',))
            o.Stmt('if (', to_else, ') {')
            generate_list(else_cod,o)
            o.append('}')
        o.Cls(a, b, c)
##      if else_cod is not None:
        Cls1(o, to_else)
        set_toerr_final(o)
        try_opt(o, to_else)
        o2.extend(o)
        del dropped_temp[-1]
        return None
    global tempgen
    o.Stmt('if (0) { ', label_exc, ':')
    
    if is_current & IS_CODEFUNC:
        o.append('PyTraceBack_Here(f);')
    else:    
        cod = const_to(current_co)
        Used('Direct_AddTraceback')
        if line_number:
            o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', PyLine, PyAddr);') 
        else:
            o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', 0, 0);') 
        
##    to_else = New('int')
##    o.Stmt(to_else, '=', 1)
#    finally_cod = None
    handled = False
    generate_clear_temp_on_exception(o, traced_temp)
    while i < len(it):
        assert type(i) is int
        if it[i][0] == ')(EXCEPT' and len(it[i]) == 1:
            o.Comment(it[i])
##            if else_cod is not None:
            o.Raw('if (', to_else, ') {')
            ae,be,ce = get_exc_info(o)
            o.Cls(ae, be, ce)
##            o.Stmt('PyFrame_BlockPop', 'f')
            o.Stmt('PyErr_Restore', a,b,c)
            o.Stmt(to_else, '=', 0)
            generate_list(it[i+1],o)
            PyEval_reset_exc_info(o)       
            o.append('}')
            handled = True
            i += 2
            continue
        if it[i][0] == ')(EXCEPT' and len(it[i]) > 1:
            if ((len (it[i][1]) == 2 and type(it[i][1][1]) is int) or len (it[i][1]) == 1) and \
               len(it[i][2]) == 0:
                    iti = it[i]
                    o.Comment(iti)
##                    assert not is_current & IS_DIRECT and not is_current & IS_CFUNC
                    o.Raw('if (', to_else, ') {')
                    if len (iti[1]) == 2 and type(iti[1][1]) is int:
                        if line_number:
                            if is_current & IS_CODEFUNC:
                                o.Stmt('f->f_lineno', '=', iti[1][1])
                            else:
                                o.Raw('PyLine = ', str(iti[1][1]), ';')
                            if iti[1][1] in Line2Addr:
                                if is_current & IS_CODEFUNC:
                                    if not is_pypy:
                                        o.Raw('f->f_lasti = ', str(Line2Addr[iti[1][1]]), ';')
                                else:
                                    o.Raw('PyAddr = ', str(Line2Addr[iti[1][1]]), ';')
                    ref_ = Expr1(iti[1][0],o)
                    ref1 = New('int')
                    o.Stmt(ref1, '=', 'PyErr_ExceptionMatches', ref_)
                    Cls1(o, ref_)
                    o.Stmt('if (', ref1, ') {')
                    ae,be,ce = get_exc_info(o)
                    o.Cls(ae, be, ce)

##                    o.Stmt('PyFrame_BlockPop', 'f')
                    o.Stmt('PyErr_Restore', a,b,c)
                    o.Stmt(to_else, '=', 0)
                    generate_list(it[i+1],o)
                    PyEval_reset_exc_info(o)       
                    o.append('}')
                    Cls1(o, ref1)
                    o.append('}')
                    i += 2
                    continue
            if ((len (it[i][1]) == 2 and type(it[i][1][1]) is int) or len (it[i][1]) == 1) and \
               len(it[i][2]) >= 1:
                    iti = it[i]
                    o.Comment(iti)
##                    assert not is_current & IS_DIRECT and not is_current & IS_CFUNC
                    o.Raw('if (', to_else, ') {')
                    if len (iti[1]) == 2 and type(iti[1][1]) is int:
                        
                        if is_current & IS_DIRECT or is_current & IS_CFUNC:
                            o.Raw('PyLine = ', str(iti[1][1]), ';')
                        else:    
                            o.Stmt('f->f_lineno', '=', iti[1][1])
                        if iti[1][1] in Line2Addr:
                            if is_current & IS_DIRECT or is_current & IS_CFUNC:
                                o.Raw('PyAddr = ', str(Line2Addr[iti[1][1]]), ';')
                            elif not is_pypy:    
                                o.Raw('f->f_lasti = ', str(Line2Addr[iti[1][1]]), ';')                        

                    ref_ = Expr1(iti[1][0],o)
                    ref1 = New('int')
                    o.Stmt(ref1, '=', 'PyErr_ExceptionMatches', ref_)
                    Cls1(o, ref_)
                    o.Stmt('if (', ref1, ') {')
                    ae,be,ce = get_exc_info(o)
                    if len(it[i][2]) == 1 and it[i][2][0][0] in set_any:
                        generate_store(it[i][2][0], be, o, 'Object Exception')
                    elif len(it[i][2]) >= 1 and it[i][2][0] == 'UNPACK_SEQ_AND_STORE':
                        generate_store(it[i][2], be, o, 'Object Exception')
                    else:
                        Fatal('TRY error', it[i])
                    o.Cls(ae, be, ce)

##                    o.Stmt('PyFrame_BlockPop', 'f')
                    o.Stmt('PyErr_Restore', a,b,c)
##                    if else_cod is not None:
                    o.Stmt(to_else, '=', 0)
                    generate_list(it[i+1],o)
                    PyEval_reset_exc_info(o)      
                    o.append('}')
                    Cls1(o, ref1)
                    o.append('}')
                    i += 2
                    continue
            Fatal('TRY error', it[i], it[i][0], it[i][1], it[i][1][0], it[i][2], it[i][2][0])
        else:
            Fatal('', it, i, it[i])
    del try_jump_context[-1]        
##    if not handled:
##        assert not is_current & IS_DIRECT and not is_current & IS_CFUNC
##        o.Stmt('if (', to_else, ') {')
##        o.Stmt('PyFrame_BlockPop', 'f')
####        o.Stmt('PyErr_Restore', a,b,c)
##        o.append('}')
    if not handled and else_cod is None:
##        assert not is_current & IS_DIRECT and not is_current & IS_CFUNC
        o.Stmt('if (', to_else, ') {')
        o.Stmt('goto', labl)
        UseLabl()
        o.append('}')
                
    o.append('}')
    if else_cod is not None:
        o.Comment((')(ELSE',))
        o.Stmt('if (', to_else, ') {')
        generate_list(else_cod,o)
        o.append('}')
        ## handled = True
    global tempgen
    o.Cls(a, b, c)
    o.Cls(a1, b1, c1)
##    PyEval_reset_exc_info(o)     
    del dropped_temp[-1]
    if else_cod is not None:
        Cls1(o, to_else)
    set_toerr_final(o)
    try_opt(o, to_else)
    o2.extend(o)
    
def PyEval_reset_exc_info(o):    
    if is_current & IS_DIRECT or is_current & IS_CFUNC or is_pypy:
        o.Stmt('_PyEval_reset_exc_info', 'PyThreadState_GET()')
    else:
        o.Stmt('_PyEval_reset_exc_info', 'f->f_tstate')
   
def PyEval_set_exc_info(o, ae, be, ce):
    if is_current & IS_DIRECT or is_current & IS_CFUNC or is_pypy:
        o.Stmt('_PyEval_set_exc_info', 'PyThreadState_GET()', ae, be, ce)       
    else:    
        o.Stmt('_PyEval_set_exc_info', 'f->f_tstate', ae, be, ce)    
            
def try_opt(o, to_else):
    may_be_append_to_o([], repr(o), 'int', ConC(to_else), o, False)

def generate_try_finally(it,o2):
    global try_jump_context, dropped_temp
    o = Out() 
    while 2 < len(it):
        if it[2][0] == ')ENDTRY_FINALLY':
            del it[2]    
        elif it[2][0] == ')(FINALLY':
            finally_cod = it[2+1]
            del it[2]
            del it[2]
            continue
        else:
            Fatal('', it, 2, it[2])
    try_jump_context.append(finally_cod)
##    o.append('{')
    label_exc = New('label') 

    global traced_tempgen
    a = New()
    b = New()
    c = New()
    o.Stmt('PyErr_Fetch', ('&', a), ('&', b), ('&', c))
    dropped_temp.append(('TRY', (a,b,c)))
    ## o.XINCREF(a)
    ## o.XINCREF(b)
    ## o.XINCREF(c)

    set_toerr_new(o, label_exc)
##    o.Stmt('PyFrame_BlockSetup', 'f', 'SETUP_FINALLY',-1, -1)

    traced_tempgen.append({})
    generate_list(it[1],o)
    traced_temp = traced_tempgen[-1].keys()
    del traced_tempgen[-1]
    if len(traced_tempgen) > 0:
        for k in traced_temp:
            traced_tempgen[-1][k] = True
##    o.Stmt('PyFrame_BlockPop', 'f')
    set_toerr_back(o)
    o.Stmt('PyErr_Restore', a,b,c)   

    a1,b1,c1 = None,None,None 
    ## first_except = True
    if not IsUsedLabl(label_exc):        
        del try_jump_context[-1]     
        generate_list(finally_cod,o)
        o.Cls(a, b, c)
        set_toerr_final(o)
        o2.extend(o)
        del dropped_temp[-1]
        return None
    global tempgen
    raised = New('int')
    o.Stmt(raised, '=', 0)
    o.Stmt('if (0) { ', label_exc, ':')

    if is_current & IS_CODEFUNC:
        o.append('PyTraceBack_Here(f);')
    else:    
        cod = const_to(current_co)
        Used('Direct_AddTraceback')
        if line_number:
            o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', PyLine, PyAddr);') 
        else:
            o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', 0, 0);') 
    
    o.Stmt(raised, '=', 1)
    generate_clear_temp_on_exception(o, traced_temp)
    o.append('}')
    if 2 < len(it):
        Fatal('', it)
    del try_jump_context[-1]        
    o.Comment((')(FINALLY',))
    generate_list(finally_cod,o)
    global tempgen
    o.Cls(a, b, c)
    o.Cls(a1, b1, c1)
    Cls1(o, raised)
    o.Raw('if (', raised, ') { goto ',labl, '; }')
    UseLabl()
    del dropped_temp[-1]
    set_toerr_final(o)
    o2.extend(o)
  
def generate_clear_temp_on_exception(o, traced_temp):
    for k, n in traced_temp:
        o.CLEAR('temp[' + str(n) + ']')
  
def get_exc_info(o):
    ae,be,ce = New(), New(), New()
    o.Stmt('PyErr_Fetch', ('&', ae), ('&', be), ('&', ce))
    ## o.XINCREF(ae)
    ## o.XINCREF(be)
    ## o.XINCREF(ce)
    o.Stmt('if (', be, '== 0) {')
    o.Raw(be, '= Py_None;')
    o.INCREF(be)
    o.append('}')
    o.Stmt('PyErr_NormalizeException', ('&', ae), ('&', be), ('&', ce))
    PyEval_set_exc_info(o, ae, be, ce)  
    o.Stmt('if (', ce, '== 0) {')
    o.Raw(ce, '= Py_None;')
    o.INCREF(ce)
    o.append('}')
    return ae, be, ce

def set_toerr_new(o, label_err):
    global labels, labl
    labels.append(label_err)
    labl = label_err

def set_toerr_back(o):
    global labels, labl
    del labels[-1]
    if len(labels) > 0:
        labl = labels[-1]
    else:
        labl = None  
        
def set_toerr_final(o):
    pass 

IsObject = ('!LOAD_NAME', '!LOAD_GLOBAL', 'FAST', '!PyObject_Call', '!CALL_CALC_CONST', '!CALL_CALC_CONST_INDIRECT',\
            '!PyDict_GetItem(glob,', '!BINARY_SUBSCR_Int',\
            '!PyObject_GetAttr', '!PyNumber_And', '!PyNumber_Or', \
            '!from_ceval_BINARY_SUBSCR', '!PySequence_GetSlice', '!LOAD_DEREF', 'CALC_CONST',\
            '!PyList_GetSlice', '!PyTuple_GetSlice',
            '!BUILD_MAP', '!BUILD_SET',  '!MK_FUNK', '!_PyEval_ApplySlice', \
            '!LIST_COMPR', '!BUILD_TUPLE', '!ORD_BUILTIN')

IsFloatOp = {'!PyNumber_Add':'+', '!PyNumber_InPlaceAdd':'+', \
            '!PyNumber_Divide':'/', '!PyNumber_Multiply':'*', '!PyNumber_Negative':'-', \
            '!PyNumber_Subtract':'-', '!PyNumber_InPlaceSubtract':'-', '!PyNumber_Power':None}
           
def parse_for_float_expr(it, acc, isfloat): 
    if it in acc:
        return True
    t = TypeExpr(it)
    if IsInt(t) or IsStr(t) or t == Kl_IntUndefSize or IsList(t) or IsTuple(t):
        ## print it, t
        ## assert 'sqrt' not in repr(it)
        return False
    if type(it) is float:
        acc.append(('CONST', it))
        return True
    if type(it) is tuple :
        if it[0] == 'CONST' and type(it[1]) is float:
            acc.append(it)
            return True
        if it[0] == 'CONST' and type(it[1]) is int:
            acc.append(it)
            return True
        if it[0] == '!PyNumber_Power':
            if not parse_for_float_expr(it[1], acc, isfloat):
                return False
            if it[2][0] == 'CONST' and type(it[2][1]) is int and\
            it[3] == 'Py_None' and it[2][1] >= 2 and it[2][1] <= 5:
                return True
            assert 'sqrt' not in repr(it)
            return False
    
        if it[0] in IsFloatOp:
            if it[0] in ('!PyNumber_Add', '!PyNumber_Subtract'):
                if it[1][0] == 'CONST' and type(it[1][1]) is int:
                    return parse_for_float_expr(it[2], acc, isfloat)
                if it[2][0] == 'CONST' and type(it[2][1]) is int:
                    return parse_for_float_expr(it[1], acc, isfloat)
            ret = True
            for i in it[1:]:
                ret = ret and parse_for_float_expr(i, acc, isfloat)  
            ## if not ret:
                ## pprint(it)
                ## assert 'sqrt' not in repr(it)
            return ret    
        if it[0] == '!PyObject_Call' and it[1][0] == 'CALC_CONST':
            t = it[1][1]    
            if len(t) == 2:
                t = (Val3(t[0], 'ImportedM'), t[1])
                if t in CFuncFloatOfFloat:
                    if it[2][0] == 'CONST' and len(it[2][1]) == 1:
                        return parse_for_float_expr(('CONST', it[2][1][0]), acc,isfloat)
                    return parse_for_float_expr(it[2][1][0], acc,isfloat)
            t = Val3(t, 'ImportedM')
            if t in CFuncFloatOfFloat:
                if it[2][0] == 'CONST' and len(it[2][1]) == 1:
                    return parse_for_float_expr(('CONST', it[2][1][0]), acc,isfloat)
                return parse_for_float_expr(it[2][1][0], acc,isfloat)
                
        if it[0] in IsObject:
            acc.append(it)
            isfloat[it] = True
            return True
#    pprint(it)
#    assert 'sqrt' not in repr(it)
    return False    
    
def generate_float_expr(it, acc, refs):
    if type(it) is float:
        return str(it)
    if it[0] in IsFloatOp:
        op = IsFloatOp[it[0]]
        if op is None:
            if it[2] == ('CONST', 2):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ')'
            elif it[2] == ('CONST', 3):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ') * (' + iit + ')'
            elif it[2] == ('CONST', 4):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ') * (' + iit + ') * (' + iit + ')'
            elif it[2] == ('CONST', 5):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ') * (' + iit + ') * (' + iit + ') * (' + iit + ')'
            Fatal('generate float EXPR', it)
        if len(it) == 3:     
            return '(' + generate_float_expr(it[1], acc, refs) + ') ' + op + ' (' + generate_float_expr(it[2], acc, refs) + ')'
        if len(it) == 2:     
            return op + '(' + generate_float_expr(it[1], acc, refs) + ')'
        Fatal('generate float EXPR', it)
  
    if it[0] == '!PyObject_Call' and it[1][0] == 'CALC_CONST':
        t = it[1][1] 
        if type(t) is str:
            t = Val3(t, 'ImportedM')
##            print 'ppp', t2
        elif len(t) == 2:
            t = (Val3(t[0], 'ImportedM'), t[1])
        if t in CFuncFloatOfFloat:
            return CFuncFloatOfFloat[t] + ' ( ' + generate_float_expr(it[2][1][0], acc, refs) +' )'
    if it in acc:
        i = acc.index(it)
        return refs[i]
    if it[0] == 'CONST' and type(it[1]) is int:
        return ' ' + str(it[1]) + ' '
    Fatal('generate float EXPR', it)
    
def generate_ssize_t_expr(it):
    if type(it) is int:
        return Out(), it
    if it[0] == 'PY_TYPE' and IsInt(TypeExpr(it)):
        return generate_ssize_t_expr(it[3])
    if it[0] == '!PY_SSIZE_T':
        return generate_ssize_t_expr(it[1])
    if it[0] == 'CONST' and type(it[1]) is int:
        return Out(), it[1]
    if IsCVar(it) and IsInt(TypeExpr(it)):
        return Out(), CVarName(it)    
    if it[0] in len_family:
        if it[0] != '!PyObject_Size':
            if it[1][0] == '!LIST_COMPR':
                o = Out()
                prev_compr = current_co.list_compr_in_progress
                current_co.list_compr_in_progress = True
                size_t = generate_len_list_compr(it[1][1],it[1][2],o) 
                current_co.list_compr_in_progress = prev_compr
                return o, size_t
            
            nm = it[0][1:]
        else:    
            nm = 'PyObject_Size'
            t = TypeExpr(it[1])
            if t is not None:
                if IsListAll(t):
                    if it[1][0] == '!LIST_COMPR':
                        o = Out()
                        prev_compr = current_co.list_compr_in_progress
                        current_co.list_compr_in_progress = True
                        size_t = generate_len_list_compr(it[1][1],it[1][2],o) 
                        current_co.list_compr_in_progress = prev_compr
                        return o, size_t
                    nm  = 'PyList_GET_SIZE'
                elif IsTuple(t):
                    nm  = 'PyTuple_GET_SIZE'
                elif IsStr(t):
                    nm = 'PyString_GET_SIZE'
                elif IsDict(t):
                    nm = 'PyDict_Size'
                elif t == Kl_Set:
                    nm = 'PySet_Size'
                elif t == Kl_Unicode:
                    nm = 'PyUnicode_GetSize'
                elif t == Kl_Buffer:
                    nm = 'PyObject_Size'
                elif t == Kl_XRange:
                    nm = 'PyObject_Size'
                elif t in (Kl_Generator, Kl_Int, Kl_Short):
                    nm = 'PyObject_Size'
                elif IsKlNone(t):
                    Debug("len(None) construction detected", it)
                    nm = 'PyObject_Size'
                elif t[0] in (T_OLD_CL_INST, T_NEW_CL_INST):
                    nm = 'PyObject_Size'
                elif t is not None:
                    nm = 'PyObject_Size'
                    Debug('len of new known type', t, it[1], func)
        size_t = New('Py_ssize_t')
        o = Out()
        ref1 = Expr1(it[1], o)
        if nm.endswith('_GET_SIZE'):
            o.Raw(size_t, ' = ', nm, '(', ref1, ');')
        else:    
            o.Stmt(size_t, '=', nm, ref1)
        Cls1(o, ref1)
        return o, size_t
    plusminus = {'!PyNumber_Add':0, '!PyNumber_Subtract':1}
    if it[0] in plusminus:
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if IsInt(t1) and IsInt(t2):
            o1, v1 = shortage(generate_ssize_t_expr(it[1]))
            o2, v2 = shortage(generate_ssize_t_expr(it[2]))
            size_t = New('Py_ssize_t')
            o = Out()
            o.extend(o1)
            o.extend(o2)
            op = (' + ', ' - ')[plusminus[it[0]]]
            o.Raw(size_t, ' = ', v1, op, v2, ';')
            o.Cls(v1, v2)
            return o, size_t
    if it[0] == '!PyNumber_Negative':
        t1 = TypeExpr(it[1])
        if IsInt(t1):
            o1, v1 = shortage(generate_ssize_t_expr(it[1]))
            size_t = New('Py_ssize_t')
            o = Out()
            o.extend(o1)
            o.Raw(size_t, ' = 0 - ', v1, ';')
            Cls1(o, v1)
            return o, size_t
    if it[0] == '!@PyInt_FromSsize_t':
        return Out(), ConC(it[1]) # for prevent Cls of temp 'for' count 

    o = Out()
    ref2 = Expr1(it, o)
    ind = New('Py_ssize_t')
    o.Stmt(ind, '=', 'PyInt_AsSsize_t', ref2)
    Cls1(o, ref2)
    return o, ind
            

type_to_check = {'tuple' : 'PyTuple_CheckExact', 'list' : 'PyList_CheckExact',
                 'dict' : 'PyDict_CheckExact', 'int' : 'PyInt_CheckExact',
                 'str' : 'PyString_CheckExact', 'long' : 'PyLong_CheckExact',
                 'float' : 'PyFloat_CheckExact', 'complex' : 'PyComplex_CheckExact',
                 'unicode' : 'PyUnicode_CheckExact', 'bool' : 'PyBool_Check'}  
type_to_check_t = {tuple : 'PyTuple_CheckExact', list : 'PyList_CheckExact',
                 dict : 'PyDict_CheckExact', int : 'PyInt_CheckExact',
                 str : 'PyString_CheckExact', long : 'PyLong_CheckExact',
                 float : 'PyFloat_CheckExact', complex : 'PyComplex_CheckExact',
                 unicode : 'PyUnicode_CheckExact', bool : 'PyBool_Check'}  
type_to_check_str = {tuple : 'tuple', list : 'list',
                 dict : 'dict', int : 'int',
                 str : 'str', long : 'long',
                 float : 'float', complex : 'complex',
                 unicode : 'unicode', bool : 'bool'}  
##op_to_oper = {'Py_EQ':' == ', 'Py_NE':' != ', 'Py_LT':' < ', \
##              'Py_LE':' <= ', 'Py_GT':' > ', 'Py_GE':' >= '}

def generate_rich_compare(it,logic,o):
    ## v = []
    it1 = it[1]
    it2 = it[2]
    t1 = TypeExpr(it1)
    t2 = TypeExpr(it2)
    op = it[3]
    if t1 == Kl_Type and t2 == Kl_Type and op in ('Py_EQ', 'Py_NE'):
        oper = op_to_oper[op]
        built = None
        valu = None 
        if it1[0] == '!LOAD_BUILTIN' and it2[0] == '!PyObject_Type': 
            built = it1[1]
            valu = it2[1]
        elif it2[0] == '!LOAD_BUILTIN' and it2[0] == '!PyObject_Type': 
            built = it2[1]
            valu = it1[1]
        if built in type_to_check:
            ref1 = Expr1(valu, o)
            ret = ConC(type_to_check[built], '( ', ref1, ' );')
            if op == 'Py_NE':
                ret = '!' + ret
            o.Raw(logic, ' = ', ret)
            Cls1(o, ref1)
            return o, logic
        if it1[0] == '!PyObject_Type':
            ref1 = Expr1(it1[1], o)
            op1 = ConC('(PyObject *)Py_TYPE(',ref1,')')
        else:
            op1 = ref1 = Expr1(it1, o)    
        if it2[0] == '!PyObject_Type':
            ref2 = Expr1(it2[1], o)
            op2 = ConC('(PyObject *)Py_TYPE(',ref2,')')
        else:
            op2 = ref2 = Expr1(it2, o)    
        o.Raw(logic, ' = ', op1, oper, op2, ';')
        o.Cls(ref1, ref2)
        return o, logic
 
    if IsInt(t1) and IsInt(t2):
        if op in op_to_oper:
            if IsShort(t1):
                o1,int1 = shortage(generate_ssize_t_expr(it[1]))
                o.extend(o1)
            elif current_co.IsIntVar(it[1]):
                int1 = CVarName(it[1])
            elif current_co.IsBoolVar(it[1]):
                int1 = CVarName(it[1])
            else:
                ref1 = Expr1(it[1],o)   
                if not istempref(ref1):
                    int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
                else:
                    int1 = New('long')
                    o.Raw(int1, ' = PyInt_AS_LONG ( ',ref1,' );') 
                Cls1(o, ref1)
            if IsShort(t2):
                o2,int2 = shortage(generate_ssize_t_expr(it[2]))
                o.extend(o2)
            elif current_co.IsIntVar(it[2]):
                int2 = CVarName(it[2])
            elif current_co.IsBoolVar(it[2]):
                int2 = CVarName(it[2])
            else:
                ref2 = Expr1(it[2],o)   
                if not istempref(ref2):
                    int2 = ConC('PyInt_AS_LONG ( ',ref2,' )') 
                else:
                    int2 = New('long')
                    o.Raw(int2, ' = PyInt_AS_LONG ( ',ref2,' );') 
                Cls1(o, ref2)
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.Cls(int1, int2)
            return o, logic

    if IsBool(t1) and IsBool(t2):
        if op in op_to_oper:
            if current_co.IsBoolVar(it[1]):
                int1 = CVarName(it[1])
            else:
                o1, int1 = shortage(generate_logical_expr(it[1])) 
                o.extend(o1)               
            if current_co.IsBoolVar(it[2]):
                int2 = CVarName(it[2])
            else:
                o2, int2 = shortage(generate_logical_expr(it[2])) 
                o.extend(o2)    
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.Cls(int1, int2)
            return o, logic


    if IsFloat(t1) and IsFloat(t2):
        if op in op_to_oper:
            ref1 = Expr1(it[1],o)   
            if not istempref(ref1):
                if it[1][0] == 'CONST' and type(it[1][1]) is float:
                    f1 = str(it[1][1]) 
                else:    
                    f1 = ConC('PyFloat_AsDouble(',ref1,')') 
            else:
                f1 = New('double')
                o.Raw(f1, ' = PyFloat_AsDouble(',ref1,');') 
            Cls1(o, ref1)
            ref2 = Expr1(it[2],o)   
            if not istempref(ref2):
                if it[2][0] == 'CONST' and type(it[2][1]) is float:
                    f2 = str(it[2][1]) 
                else:    
                    f2 = ConC('PyFloat_AsDouble(',ref2,')') 
            else:
                f2 = New('double')
                o.Raw(f2, ' = PyFloat_AsDouble(',ref2,');') 
            Cls1(o, ref2)
            o.Raw(logic, ' = ', f1, op_to_oper[op], f2, ';')
            o.Cls(f1, f2)
            return o, logic

    if IsTuple(t1) and IsTuple(t2):
        ref1, ref2 = Expr(o, it[1:3])
        if op in ('Py_EQ', 'Py_NE'):
            if ref2[0] == 'CONST':
                o.Raw('if (PyTuple_GET_SIZE(', ref1,') != ', len(ref2[1]), ') {')
            elif ref1[0] == 'CONST':
                o.Raw('if (', len(ref1[1]), ' != PyTuple_GET_SIZE(', ref2, ')) {')
            else:    
                o.Raw('if (PyTuple_GET_SIZE(', ref1,') != PyTuple_GET_SIZE(', ref2, ')) {')
            if op == 'Py_EQ':        
                o.Raw(logic, ' = 0;')
            else:    
                o.Raw(logic, ' = 1;')
            o.append('} else {')
            ref0 = New()
            o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
            ToTrue(o, logic, ref0, it)
            o.append('}')
        else:    
            ref0 = New()
            o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
            ToTrue(o, logic, ref0, it)
        o.Cls(ref1, ref2)
        return o, logic
    if t1 is None and IsTuple(t2):
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyTuple_CheckExact(', ref1, ')) {')
        ref0 = New()
        if op == 'Py_EQ' and ref2[0] == 'CONST':
            if len(ref2[1]) == 0:
                o.Raw(logic, ' = PyTuple_GET_SIZE(', ref1,') == 0;')
            else:
                o.Raw('if (PyTuple_GET_SIZE(', ref1,') != ', len(ref2[1]), ') {')
                o.Raw(logic, ' = 0;')
                o.append('} else {')
                o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
                ToTrue(o, logic, ref0, it)
                Cls1(o, ref0)
                o.append('}')
        elif op == 'Py_NE' and ref2[0] == 'CONST':
            if len(ref2[1]) == 0:
                o.Raw(logic, ' = PyTuple_GET_SIZE(', ref1,') != 0;')
            else:
                o.Raw('if (PyTuple_GET_SIZE(', ref1,') != ', len(ref2[1]), ') {')
                o.Raw(logic, ' = 1;')
                o.append('} else {')
                o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
                ToTrue(o, logic, ref0, it)
                Cls1(o, ref0)
                o.append('}')
        else:    
            o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
            ToTrue(o, logic, ref0, it)
            Cls1(o, ref0)
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic
    if t2 is None and IsTuple(t1):
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyTuple_CheckExact(', ref2, ')) {')
        ref0 = New()
        o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
        ToTrue(o, logic, ref0, it)
        Cls1(o, ref0)
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic
    if t1 == Kl_Char and t2 == Kl_Char:   
        ref1, ref2 = Expr(o, it[1:3])        
        if ref2[0] == 'CONST':
            o.Raw(logic, ' = *', PyString_AS_STRING(ref1), op_to_oper[op],'\'', ref2[1], '\';')
            o.Cls(ref1, ref2)
            return o, logic
        o.Raw(logic, ' = *', PyString_AS_STRING(ref1),op_to_oper[op],'*', PyString_AS_STRING(ref2), ';')
        o.Cls(ref1, ref2)
        return o, logic

    if IsStr(t1) and IsStr(t2):
        ref1, ref2 = Expr(o, it[1:3])
        if op == 'Py_EQ':
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') == PyString_GET_SIZE(', ref2, ')) && ', \
                  '(PyString_AS_STRING(',ref1,')[0] == PyString_AS_STRING(',ref2, ')[0]) && ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) == 0);')
            o.Cls(ref1, ref2)
            return o, logic
        elif op == 'Py_NE':
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') != PyString_GET_SIZE(', ref2, ')) || ', \
                  '(PyString_AS_STRING(',ref1,')[0] != PyString_AS_STRING(',ref2, ')[0]) || ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) != 0);')
            o.Cls(ref1, ref2)
            return o, logic
        else:
            ref0 = New()
            o.Raw(ref0, ' = PyString_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
            ToTrue(o, logic, ref0, it)
            Cls1(o, ref0)
            o.Cls(ref1, ref2)
            return o, logic
            
        
    if IsStr(t1) and t2 is None and op in ('Py_EQ', 'Py_NE'):
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyString_CheckExact(', ref2, ')) {')
        if op == 'Py_EQ':
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') == PyString_GET_SIZE(', ref2, ')) && ', \
                  '(PyString_AS_STRING(',ref1,')[0] == PyString_AS_STRING(',ref2, ')[0]) && ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) == 0);')
        else:
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') != PyString_GET_SIZE(', ref2, ')) || ', \
                  '(PyString_AS_STRING(',ref1,')[0] != PyString_AS_STRING(',ref2, ')[0]) || ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) != 0);')
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic

    if IsStr(t2) and t1 is None and op in ('Py_EQ', 'Py_NE'):
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyString_CheckExact(', ref1, ')) {')
        if op == 'Py_EQ':
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') == PyString_GET_SIZE(', ref2, ')) && ', \
                  '(PyString_AS_STRING(',ref1,')[0] == PyString_AS_STRING(',ref2, ')[0]) && ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) == 0);')
        else:
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') != PyString_GET_SIZE(', ref2, ')) || ', \
                  '(PyString_AS_STRING(',ref1,')[0] != PyString_AS_STRING(',ref2, ')[0]) || ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) != 0);')
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic

    if IsStr(t2) and t2 == Kl_Char and t1 is None and op in op_to_oper:
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyString_CheckExact(', ref1, ') && PyString_GET_SIZE(', ref1,') == 1) {')
        o.Raw(logic, ' = PyString_AS_STRING(',ref1,')[0] ',op_to_oper[op],' PyString_AS_STRING(',ref2, ')[0];')
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic

    if IsIntUndefSize(t1) and IsInt(t2) and it[2][0] == 'CONST' and type(it[2][1]) is int:
        if op in op_to_oper:
            ref1 = GenExpr(it[1],o, None, None, True)   
            ref2 = it[2]   
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
            int2 = ref2[1]
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic

    if t1 is None and t2 == Kl_Int:
        if op in op_to_oper and not current_co.IsIntVar(it[2]):
            ref1 = GenExpr(it[1],o, None, None, True)   
            ref2 = Expr1(it[2],o)   
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
            int2 = ConC('PyInt_AS_LONG ( ',ref2,' )') 
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic

    if t1 is None and t2 == Kl_Int:
        if op in op_to_oper and current_co.IsIntVar(it[2]):
            ref1 = GenExpr(it[1],o, None, None, True)   
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
            int2 = CVarName(it[2])
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.append('} else {')
            ref2 = Expr1(it[2], o)
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            Cls1(o, ref2)
            o.append('}')
            Cls1(o, ref1)
            return o, logic


    if t1 is None and IsFloat(t2):
        if op in op_to_oper:
            ref1 = Expr1(it[1],o)   
            ref2 = Expr1(it[2],o)   
            o.Raw('if (PyFloat_CheckExact(', ref1, ')) {')
            f1 = ConC('PyFloat_AsDouble(',ref1,')') 
            if it[2][0] == 'CONST' and type(it[2][1]) is float:
                f2 = str(it[2][1]) 
            else:    
                f2 = ConC('PyFloat_AsDouble(',ref2,')') 
            o.Raw(logic, ' = ', f1, op_to_oper[op], f2, ';')
            o.Cls(f1, f2)
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic

    if IsFloat(t1) and t2 is None:
        if op in op_to_oper:
            ref1 = Expr1(it[1],o)   
            ref2 = Expr1(it[2],o)   
            o.Raw('if (PyFloat_CheckExact(', ref2, ')) {')
            if it[1][0] == 'CONST' and type(it[1][1]) is float:
                f1 = str(it[1][1]) 
            else:    
                f1 = ConC('PyFloat_AsDouble(',ref1,')') 
            f2 = ConC('PyFloat_AsDouble(',ref2,')') 
            o.Raw(logic, ' = ', f1, op_to_oper[op], f2, ';')
            o.Cls(f1, f2)
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic
    
    if IsShort(t1) and t2 is None and op in op_to_oper:
        if it1[0] == 'PY_TYPE':
            it1 = it1[3]
        if current_co.IsIntVar(it1):
            o1, size_t_1 = [], CVarName(it1)
        else:    
            o1,size_t_1 = shortage(generate_ssize_t_expr(it1))
        o.extend(o1)
        ref2 = GenExpr(it[2],o, None, None, True)   
        o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
        o.Raw(logic, ' = ', size_t_1, op_to_oper[op], 'PyInt_AS_LONG ( ', ref2, ' );')
        o.append('} else {')
        ref1 = New()
        o.PushInt(ref1, size_t_1)
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        Cls1(o, ref1)
        o.append('}')
        o.Cls(ref2, size_t_1)
        return o, logic

    if IsInt(t1) and t2 is None and op in op_to_oper:
        ref1 = Expr1(it[1], o)
        int_1 = None
        ref1, int_1 = to_long(o, ref1, int_1)  
        
        ref2 = GenExpr(it[2],o, None, None, True)   
        o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
        o.Raw(logic, ' = ', int_1, op_to_oper[op], 'PyInt_AS_LONG ( ', ref2, ' );')
        o.append('} else {')
        newref = False
        if ref1 is None:
            newref = True
            ref1 = New()
            o.PushInt(ref1, int_1) 
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        if newref:
            Cls1(o, ref1)
        o.append('}')
        o.Cls(ref1, ref2, int_1)
        return o, logic


    if IsShort(t2) and t1 is None and op in op_to_oper:
        ref1 = GenExpr(it[1],o, None, None, True)   
        if it[2][0] == 'PY_TYPE' and it[2][3][0] == 'FAST' and not current_co.IsIntVar(it[2][3]):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            o2,size_t_2 = shortage(generate_ssize_t_expr(it[2]))
            o.extend(o2)
            o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' )', op_to_oper[op], size_t_2, ';')
            Cls1(o, size_t_2)
            o.append('} else {')
            ref2 = it[2][3]
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            Cls1(o, ref2)
            o.append('}')
            o.Cls(ref1, size_t_2)
            return o, logic
   
        o2,size_t_2 = shortage(generate_ssize_t_expr(it[2]))
        o.extend(o2)
        o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' )', op_to_oper[op], size_t_2, ';')
        o.append('} else {')
        ref2 = New()
        o.PushInt(ref2, size_t_2) 
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        Cls1(o, ref2)
        o.append('}')
        o.Cls(ref1, size_t_2)
        return o, logic

    if IsInt(t2) and t1 is None and op in op_to_oper:
        ref1 = GenExpr(it[1],o, None, None, True)   
        ref2 = Expr1(it[2], o)
        n = New('long')
        o.Raw(n, ' = PyInt_AS_LONG ( ', ref2, ' );')
        o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' )', op_to_oper[op], n, ';')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2, n)
        return o, logic
    
    if IsKlNone(t2) and t1 is None and \
       op in ('Py_EQ', 'Py_NE') and it[2] == ('CONST', None):
            ref1 = Expr1(it[1],o)   
            o.Raw(logic, ' = ', ref1, op_to_oper[op], ('CONST', None), ';')
            Cls1(o, ref1)
            return o, logic

    if IsBool(t2) and IsBool(t1) and op in ('Py_EQ', 'Py_NE') and it[2][0] == 'CONST':
        o_old, n = shortage(generate_logical_expr(it[1]))
        val = '0'
        if it[2][1]:
            val = '1'
        o.extend(o_old)
        o.Raw(logic, ' = ', n, op_to_oper[op], val, ';')
        o.Cls(n)
        return o, logic
               
    if t1 is not None and t2 is not None:   
        if t1 == Kl_String and t2 == Kl_String:
            Fatal('Cmp String unrecognized ?', it) 
        Debug('Typed comparison unrecognized %s %s %s' % (t1, op, t2), it[1], it[2])
    elif t1 is not None or t2 is not None:    
        Debug('Half-typed comparison unrecognized %s %s %s' % (t1, op, t2), it[1], it[2])
    ref1, ref2 = Expr(o, it[1:3])
    o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
    o.Cls(ref1, ref2)
    return o, logic
    
def generate_logical_expr(it, logic = None):
    assert logic is None or logic[0] == 'TYPED_TEMP'
    it0 = it[0]
    if type(it0) is str and it0[-1] == '(':
        it0 = it0[:-1]
    o = Out()    
    if IsCVar(it) and IsBool(TypeExpr(it)):
        return o, CVarName(it)    
    if logic is None:    
        logic = New('int')
    if it0 == '!PyObject_RichCompare':
        return generate_rich_compare(it,logic,o)
    if it0 == '!BOOLEAN':
        return generate_logical_expr(it[1], logic) 
    if it0 == 'CONST':
        if it[1]:
            o.Stmt(logic, '=', 1)
            return o, logic
        if not it[1]:
            o.Stmt(logic, '=', 0)
            return o, logic
        Fatal('shd', it)
    if it0 == '!1NOT':
        if it[1] == ('CONST', False):
            o.Stmt(logic, '=', 1)
            return o, logic
        if it[1] == ('CONST', True):
            o.Stmt(logic, '=', 0)
            return o, logic
        if it[1][0] in IsObject and not IsCVar(it[1]):
            ref1 = Expr1(it[1], o)
            o.Stmt(logic, '=', 'PyObject_Not', ref1)
            Cls1(o, ref1)
            return o, logic
        if IsBool(TypeExpr(it[1])) and IsCVar(it[1]):
            o.Raw(logic, ' = !', CVarName(it[1]), ';')
            return o, logic
        if IsInt(TypeExpr(it[1])) and IsCVar(it[1]):
            o.Raw(logic, ' = !', CVarName(it[1]), ';')
            return o, logic
        if it[1][0] not in IsObject:
            o, logic1 = generate_logical_expr(it[1], logic)
            o.Raw(logic, ' = !(', logic1, ');')
            return o, logic
        assert False
        
    if it0 in API_cmp_2_PyObject:
        v = []
        if TCmp(it, v, ('!PyObject_IsInstance', ('FAST', '?'), ('CALC_CONST', '?'))) and\
           v[1] in calc_const_old_class and not is_pypy:
               o.Raw(logic, ' = PyInstance_Check(',('FAST', v[0]),') && ((PyInstanceObject *)',('FAST', v[0]),')->in_class == (PyClassObject*)', ('CALC_CONST', v[1]), ';')
               return o, logic
        v = []   
        if TCmp(it, v, ('!PySequence_Contains(', ('CONST', '?'),  '?')) and \
            type(v[0]) is tuple and all([type(x) is str for x in v[0]]):
                ## v2 = []

                t2 = TypeExpr(v[1])
                d = {}
                ref2 = Expr1(v[1], o)
                for ref1 in v[0]:
                    nc = len(ref1)
                    const_to(ref1)   
                    if nc != 1:
                        text = ConC('0 == memcmp(', PyString_AS_STRING(ref2), ' , ', generate_chars_literal(ref1), ' , ',nc, ')')
                    else:    
                        text = ConC('*', PyString_AS_STRING(ref2), ' == *', generate_chars_literal(ref1))
                    if nc in d:
                        d[nc] = d[nc] + ' || (' + text + ')'
                    else:
                        d[nc] = '(' + text + ')'    
                if IsStr(t2):
                    if len(d) == 1:
                        k, v = d.items()[0]
                        o.Raw(logic, ' = PyString_GET_SIZE(', ref2, ') ==  ', k, ' && (', v, ');')
                        Cls1(o, ref2)
                        return o, logic
                    o.Raw(logic, ' = 0;')
                    o.Raw('switch (PyString_GET_SIZE(', ref2, ')) {')
                    for k, v in d.iteritems():
                        o.Raw('case ', k, ':')
                        o.Raw(logic, ' = ', v, ';')
                        o.append('break;')
                    o.append('default:')
                    o.append('break;')
                    o.append('}')    
                    Cls1(o, ref2)
                    return o, logic
                else:
                    if len(d) == 1:
                        o.Raw('if (PyString_CheckExact(', ref2, ')) {')
                        k, v = d.items()[0]
                        o.Raw(logic, ' = PyString_GET_SIZE(', ref2, ') ==  ', k, ' && (', v, ');')
                        o.append('} else {')
                        o.Stmt(logic, '=', it0[1:], it[1], ref2)
                        o.append('}')
                        Cls1(o, ref2)
                        return o, logic
                    o.Raw('if (PyString_CheckExact(', ref2, ')) {')
                    o.Raw(logic, ' = 0;')
                    o.Raw('switch (PyString_GET_SIZE(', ref2, ')) {')
                    for k, v in d.iteritems():
                        o.Raw('case ', k, ':')
                        o.Raw(logic, ' = ', v, ';')
                        o.append('break;')
                    o.append('default:')
                    o.append('break;')
                    o.append('}')    
                    o.append('} else {')
                    o.Stmt(logic, '=', it0[1:], it[1], ref2)
                    o.append('}')
                    Cls1(o, ref2)
                    return o, logic

        if TCmp(it, v, ('!PySequence_Contains(', ('CONST', '?'),  '?')) and \
            type(v[0]) is tuple and not all([type(x) is str for x in v[0]]):
            Debug('Contains:Not string tuple in %s', it)
        if TCmp(it, v, ('!PySequence_Contains(', ('!BUILD_TUPLE', '?'),  '?')) and \
            type(v[0]) is tuple and not all([type(x) is str for x in v[0]]):
            Debug('Contains:Not const tuple in %s', it)
                
        ref1, ref2 = Expr(o, it[1:3])
        o.Stmt(logic, '=', it0[1:], ref1, ref2)
        o.Cls(ref1, ref2)
        return o, logic

    if it0 in ('!_EQ_', '!_NEQ_'):
        if it[1][0] == '!PyObject_Type' and it[2][0] == '!LOAD_BUILTIN' and it[2][1] in type_to_check:
            ref1 = Expr1(it[1][1], o)
            if it0 == '!_EQ_':
                o.Raw(logic, ' = ', type_to_check[it[2][1]], '( ', ref1, ' );')
            else:
                o.Raw(logic, ' = !', type_to_check[it[2][1]], '( ', ref1, ' );')
            Cls1(o, ref1)
            return o, logic
        if it[2][0] == '!PyObject_Type' and it[1][0] == '!LOAD_BUILTIN' and it[1][1] in type_to_check:
            ref1 = Expr1(it[2][1], o)
            if it0 == '!_EQ_':
                o.Raw(logic, ' = ', type_to_check[it[1][1]], '( ', ref1, ' );')
            else:
                o.Raw(logic, ' = !', type_to_check[it[1][1]], '( ', ref1, ' );')
            Cls1(o, ref1)
            return o, logic
        if it[1][0] == '!PyObject_Type' and it[2][0] == 'CALC_CONST' and IsAnyClass(it[2][1]):
            ref1 = Expr1(it[1][1], o)
            if it0 == '!_EQ_':
                o.Raw(logic, ' = (PyObject *)Py_TYPE(',ref1,') == ', it[2], ';')
            else:
                o.Raw(logic, ' = (PyObject *)Py_TYPE(',ref1,') != ', it[2], ';')
            Cls1(o, ref1)
            return o, logic
        if it[2][0] == '!PyObject_Type' and it[1][0] == 'CALC_CONST' and IsAnyClass(it[1][1]):
            ref1 = Expr1(it[2][1], o)
            if it0 == '!_EQ_':
                o.Raw(logic, ' = (PyObject *)Py_TYPE(',ref1,') == ', it[1], ';')
            else:
                o.Raw(logic, ' = (PyObject *)Py_TYPE(',ref1,') != ', it[1], ';')
            Cls1(o, ref1)
            return o, logic
        
        ref1 = Expr1(it[1], o)
        o2 = Out()
        ref2 = Expr1(it[2], o2)
        skip1 = False
        skip2 = False
        if istempref(ref1) and o[-1] == ConC('Py_INCREF(', ref1, ');') and len(o2) == 0:
            del o[-1]
            skip1 = True
        if istempref(ref2) and o2[-1] == ConC('Py_INCREF(', ref2, ');') and len(o) == 0:
            del o2[-1]
            skip2 = True
        o.extend(o2)    
        if it0 == '!_EQ_':
            o.Stmt(logic, '=', ref1, '==', ref2)
        else:    
            o.Stmt(logic, '=', ref1, '!=', ref2)
        if skip1:    
            o.ClsFict(ref1)
        else:   
            Cls1(o, ref1)
        if skip2:    
            o.ClsFict(ref2)
        else:   
            Cls1(o, ref2)
        return o, logic
    if it0 in ('!OR_JUMP', '!OR_BOOLEAN', '!OR_JUMPED_STACKED'):
        o = generate_and_or_logical(it[1:], False, logic)
        return o, logic
    if it0 in ('!AND', '!AND_JUMP', '!AND_BOOLEAN', '!AND_JUMPED_STACKED'):
        o = generate_and_or_logical(it[1:], True, logic)
        return o, logic
    if it0 in ('!SSIZE_T==', '!SSIZE_T>', '!SSIZE_T>=', '!SSIZE_T!=', \
               '!SSIZE_T<', '!SSIZE_T<='):
        o1,size_t_1 = shortage(generate_ssize_t_expr(it[1]))
        o2,size_t_2 = shortage(generate_ssize_t_expr(it[2]))
        o1.extend(o2)
        o1.Raw(logic, ' = ', size_t_1, ' ', it0[8:], ' ', size_t_2, ';')
        o1.Cls(size_t_1, size_t_2)
        return o1, logic
    if it0 == '!PY_SSIZE_T':
        o1,size_t_1 = shortage(generate_ssize_t_expr(it[1]))
        o1.Raw(logic, ' = ', size_t_1, ' != ', 0, ';')
        o1.Cls(size_t_1)
        return o1,logic
    if it0 in ('!c_Py_EQ_Int', '!c_Py_NE_Int', '!c_Py_LT_Int', \
               '!c_Py_LE_Int', '!c_Py_GT_Int', '!c_Py_GE_Int'):
        op = it0[3:-4]           
        oper = op_to_oper[op]           
        t = TypeExpr(it[1])
        if t is not None and t[0] not in (int, float): 
            return generate_logical_expr(('!PyObject_RichCompare(', it[1], it[2], op), logic)
        ref = Expr1(it[1], o)
        if t is not None and not IsInt(t):
            Debug('typed compare', t,it)
        o2 = Out()
        if it[2][0] in ('CONST', 'LOAD_CONST') and type(it[2][1]) is int:
            int_t = it[2][1]    
            int_2 = const_to(int_t)   
        else:
            Fatal('', it, type(it[2][1]))
        o.extend(o2)     
        if IsInt(t):
            o.Raw(logic, ' = PyInt_AS_LONG ( ', ref, ' )', oper, int_t, ';')
            o.Cls(ref, int_t)
            return o,logic
        if IsFloat(t):
            o.Raw(logic, ' = PyFloat_AS_DOUBLE( ', ref, ' )', oper, int_t, ';')
            o.Cls(ref, int_t)
            return o,logic
        if t is not None:
            Debug('Typed %s (%s, %s)' % (it0, t, it[2]), it) 
        o.Stmt(logic,'=', it0[1:], ref, int_t, int_2)
        o.Cls(ref, int_t)
        return o,logic

    if it0 in ('!c_Py_EQ_String', '!c_Py_NE_String'):
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            s_t = it[2][1]    
            s_2 = const_to(s_t)   
        else:
            Fatal('', it)
        t1 = TypeExpr(it[1])  
        if t1 is not None:
            Debug('Typed %s (%s, <str>)' % ( it0, t1), it[1], it[2])  
        if TypeExpr(it[2]) == Kl_Char and it[1][0] == '!BINARY_SUBSCR_Int' and \
            it[1][2][0] == 'CONST' and type(it[1][2][1]) is int and it[1][2][1] >= 0:
                t4 = TypeExpr(it[1][1])
##                ref3 = Expr1(it[1][1], o)
                if t4 == None or t4 == (None, None):
                    ref3 = Expr1(it[1][1], o)
                    o.Raw('if ( PyString_CheckExact(', ref3,') && PyString_GET_SIZE(',ref3,') > ', it[1][2][1], ') {')
                    if it0 == '!c_Py_EQ_String' :
                        o.Raw(logic,' = ', PyString_AS_STRING(ref3), '[', it[1][2][1], '] == *', generate_chars_literal(s_t), ';')
                    else:    
                        o.Raw(logic,' = ', PyString_AS_STRING(ref3), '[', it[1][2][1], '] != *', generate_chars_literal(s_t), ';')
                    o.append('} else {')
                    ref = New()
                    o.Stmt(ref, '=', '_c_BINARY_SUBSCR_Int', ref3, it[1][2][1], it[1][2])
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    Cls1(o, ref)
                    o.append('}')
                    Cls1(o, ref3)
                    return o,logic 
                elif IsStr(t4):
                    ref3 = Expr1(it[1][1], o)
                    o.Raw('if ( PyString_GET_SIZE(',ref3,') > ', it[1][2][1], ') {')
                    if it0 == '!c_Py_EQ_String' :
                        o.Raw(logic,' = ', PyString_AS_STRING(ref3), '[', it[1][2][1], '] == *', generate_chars_literal(s_t), ';')
                    else:    
                        o.Raw(logic,' = ', PyString_AS_STRING(ref3), '[', it[1][2][1], '] != *', generate_chars_literal(s_t), ';')
                    o.append('} else {')
                    ref = New()
                    o.Stmt(ref, '=', '_c_BINARY_SUBSCR_Int', ref3, it[1][2][1], it[1][2])
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    Cls1(o, ref)
                    o.append('}')
                    Cls1(o, ref3)
                    return o,logic 
                if IsTuple(t4):
                    ref = Expr1(it[1], o)
##                    generate_rich_compare(it,logic,o)
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    Cls1(o, ref)
                    return o,logic 
        if TypeExpr(it[2]) == Kl_String and it[1][0] == '!PySequence_GetSlice' and \
            it[2][0] == 'CONST' and it[1][2] == 0 and it[1][3] == len (it[2][1]):
                ref3 = Expr1(it[1][1], o)
                o.Raw('if ( PyString_CheckExact(', ref3,') ) {')
                o.Raw('if (PyString_GET_SIZE(',ref3,') >= ', len (it[2][1]), ') {')
                if it0 == '!c_Py_EQ_String' :
                    o.Raw(logic,' = 0 == memcmp(', PyString_AS_STRING(ref3), ', ', generate_chars_literal(s_t), ' , ',len (it[2][1]), ');')
                else:    
                    o.Raw(logic,' = 0 != memcmp(', PyString_AS_STRING(ref3), ', ', generate_chars_literal(s_t), ' , ',len (it[2][1]), ');')
#                    o.Raw(logic,' = PyString_AS_STRING(', ref3, ')[', it[1][2][1], '] != *', generate_chars_literal(s_t), ';')
                o.append('} else {')
                if it0 == '!c_Py_EQ_String' :
                    o.Raw(logic,' = 0;')
                else:    
                    o.Raw(logic,' = 1;')
                o.append('}')
                o.append('} else {')
                ref = New()
                o.Stmt(ref, '=', 'PySequence_GetSlice', ref3, it[1][2], it[1][3])
                o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                Cls1(o, ref)
                o.append('}')
                Cls1(o, ref3)
                return o,logic 
                            
        ref = Expr1(it[1], o)
        o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
        Cls1(o, ref)
        return o,logic
    if it0 == '!NCMP':
        tu = list(it[1])
        to_cls = []
        logic2 = New('int')
        o.Raw(logic, ' = 0;')
        ref1 = Expr1(tu[0], o)
        ref2 = Expr1(tu[2], o)
        if tu[1] == 'is':
            o.Stmt(logic2, '=', ref1, '==', ref2)
        elif tu[1] == 'is not':    
            o.Stmt(logic2, '=', ref1, '!=', ref2)
        elif tu[1] == 'in':    
            o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
        elif tu[1] == 'not in':    
            o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
            o.Raw(logic2, ' = ! ', logic2, ';')
        else:    
            o.Stmt(logic2, '=', 'PyObject_RichCompareBool', ref1, ref2, op_2_c_op[tu[1]])
        del tu[:3]
        to_cls.append(ref1)
        ref1 = ref2 
        o.Raw('if (', logic2, ') {')
        while len(tu) > 1:
            ref2 = Expr1(tu[1], o)
            if tu[0] == 'is':
                o.Stmt(logic2, '=', ref1, '==', ref2)
            elif tu[0] == 'is not':    
                o.Stmt(logic2, '=', ref1, '!=', ref2)
            elif tu[0] == 'in':    
                o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
            elif tu[0] == 'not in':    
                o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
                o.Raw(logic2, ' = ! ', logic2, ';')
            else:    
                o.Stmt(logic2, '=', 'PyObject_RichCompareBool', ref1, ref2, op_2_c_op[tu[0]])
            del tu[:2]
            to_cls.append(ref1)
            ref1 = ref2 
            o.Raw('if (', logic2, ') {')
        o.Raw(logic, ' = 1;')
        for r in range(len(to_cls)):
            o.append('}')
        Cls1(o, logic2)
        o.Cls(*to_cls) 
        Cls1(o, ref1)            
        return o, logic
    if it0 == '!COND_METH_EXPR':
        return generate_logical_cond_meth_expr(it, logic)
    if it0 == '!PyBool_Type.tp_new' and it[2][0] == '!BUILD_TUPLE' and len(it[2][1]) == 1:
        return generate_logical_expr(it[2][1][0], logic)
    ref1 = Expr1(it, o)
    return ToTrue(o,logic,ref1, it)
 
def ToTrue(o, logic, ref1, it):
    last = o[-3:]
    del_check = False
    if len(last) > 0:
        che = ('if ( %s == 0 ) goto %s;' % (CVar(ref1), CVar(labl)))
        UseLabl()
        if last[-1] == che:
            del_check = True
            del last[-1]
    if len(last) > 0:
        beg = CVar(ref1) + ' = PyBool_FromLong ('
        if last[-1].startswith(beg) and last[-1].endswith(');'):
            if del_check:
                del o[-1]
            c_expr = o[-1][len(beg):-2]
            del o[-1]
            o.ClsFict(ref1)
            o.Raw(logic, ' = ', c_expr, ';')
            return o, logic      
        beg = CVar(ref1) + ' = PyInt_FromLong ('
        if last[-1].startswith(beg) and last[-1].endswith(');'):
            if del_check:
                del o[-1]
            c_expr = o[-1][len(beg):-2]
            del o[-1]
            o.ClsFict(ref1)
            o.Raw(logic, ' = ', c_expr, ';')
            return o, logic  #    Debug('generate_logical_expr', it, o[-3:]) 
    if IsInt(TypeExpr(it)):    
        o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' ) != 0;')
        Cls1(o, ref1)
        return o, logic
    v2 = []
    if len(o) >= 1 and TxMatch(o, len(o) - 1, ('temp[$0] = PyBool_FromLong($2);',), v2):
            v2[2] = v2[2].strip()
            v2[1] = CVar(logic)
            v2[1] = v2[1].strip()
            if v2[2] == v2[1]:
                TxRepl(o, len(o) - 1, (), v2)
            else:    
                TxRepl(o, len(o) - 1, ('$1 = $2;',), v2)
            Cls1(o, ref1)
            if istempref(ref1) and o[-1].startswith('CLEARTEMP('):
                del o[-1]
            return (o, logic)       
    o.Stmt(logic, '=', 'PyObject_IsTrue', ref1)
    Cls1(o, ref1)
    return o, logic

def generate_and_or_logical(it, is_and, logic):
    assert logic is None or logic[0] == 'TYPED_TEMP'
    o,logic1 = generate_logical_expr(it[0], logic)
    if len(it) == 1:
        if not istemptyped(logic1) and istemptyped(logic) and type(logic1) is str:
            o.Raw(logic, ' = ', logic1, ';')
            logic1 = logic    
        return o
    if type(logic1) is int:
        logic2 = New('int')
        o.Stmt(logic2, '=', logic1)
        logic1 = logic2
    if not istemptyped(logic1) and logic is None:
        logic2 = New('int')
        o.Stmt(logic2, '=', logic1)
        logic1 = logic2
    if not istemptyped(logic1) and istemptyped(logic) and type(logic1) is str:
        o.Raw(logic, ' = ', logic1, ';')
        logic1 = logic    
    if istemptyped(logic1) and istemptyped(logic):
        assert logic1 == logic    
    if is_and:    
        o.Stmt('if (', logic1, ') {')
    else:    
        o.Stmt('if (!(', logic1, ')) {')
    assert logic1 is None or logic1[0] == 'TYPED_TEMP'
    o2 = generate_and_or_logical(it[1:], is_and, logic1)
    o.extend(o2)
    o.append('}')
    return o  

def generate_preexpr(it,o):
    assert len(it) == 3
    assert it[0][0] == '(PREEXPR'
    assert it[2][0] == ')PREEXPR'
    acc = it[1]
    refs = Expr(o, acc) #[Expr1(x, o) for x in acc]
    PushAcc(acc, refs)            
    generate_list(it[1],o)
    PopAcc(o, False)     
    o.Cls(*refs)       
    ## for x in refs:
        ## Cls1(o, x)            

def shortage(l):
    o, logic = l
    if len(o) == 0:
        return o, logic
    optimize(o)
    if not istemptyped(logic):
        return o, logic
    if len(o) == 1 and o[0].startswith(ConC(logic, ' = ')) and\
       o[0].endswith(';'):
       s = o[0].split(' = ')
       if len(s) != 2:
            return o, logic
       if s[0] != ConC(logic):
            return o, logic
       o2 = Out()
       o2.Cls(logic)
       return o2, '(' + s[1][:-1] + ')'
    if len(o) > 1 and o[-1].startswith(ConC(logic, ' = ')) and\
       o[-1].endswith(';'):
       s = o[-1].split(' = ')
       if len(s) != 2:
            return o, logic
       if s[0] != ConC(logic):
            return o, logic
       o2 = Out()
       o2.extend(o[:-1])
       o2.Cls(logic)
       return o2, '(' + s[1][:-1] + ')'
    v2 = []
    if len(o) >= 3 and o[-1].startswith('CLEARTEMP(') and o[-3].startswith('temp['):
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyInt_FromLong ($1);',
            '$3 = PyInt_AsSsize_t ( temp[$0] );',
            'CLEARTEMP($0);'), v2):
                v2[1] = v2[1].strip()
                TxRepl(o, len(o) - 3, ('$3 = $1;',), v2)
                return shortage((o,logic))
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            '$3 = c_Py_EQ_String(temp[$0], 1, "$4", $5);',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, len(o) - 3, ('$3 = $2 == *"$4";',), v2)
                return shortage((o,logic))
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyString_FromStringAndSize(&$2, 1);',
            '$3 = c_Py_NE_String(temp[$0], 1, "$4", $5);',
            'CLEARTEMP($0);'), v2):
                TxRepl(o, len(o) - 3, ('$3 = $2 != *"$4";',), v2)
                return shortage((o,logic))
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyInt_FromLong ($1);',
            '$2 = PyInt_AS_LONG ( temp[$0] ) $3;',
            'CLEARTEMP($0);'), v2):
                v2[1] = v2[1].strip()
                TxRepl(o, len(o) - 3, ('$2 = ($1) $3;',), v2)
                return shortage((o,logic))
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyInt_FromLong ($2);',
            'if (($3 = PyObject_Not ( temp[$0] )) == -1) goto $11;',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                TxRepl(o, len(o) - 3, ('$3 = ! $2;',), v2)
                return shortage((o,logic))
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyBool_FromLong($2);',
            'if (($1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $5;',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                if v2[2] == v2[1]:
                    TxRepl(o, len(o) - 3, (), v2)
                else:    
                    TxRepl(o, len(o) - 3, ('$1 = $2;',), v2)
                return shortage((o,logic))        
        if TxMatch(o, len(o) - 3, ('temp[$0] = PyBool_FromLong($2);',
            'if (($1 = PyObject_Not ( temp[$0] )) == -1) goto $5;',
            'CLEARTEMP($0);'), v2):
                v2[2] = v2[2].strip()
                TxRepl(o, len(o) - 3, ('$1 = ! $2;',), v2)
                return shortage((o,logic))      
    ## if len(o) >= 1:         
        ## pprint(('Shortage----', logic, o))
    return o, logic
 
def is_no_breaked(lis):
    srepr = repr(lis)
    if 'CONTINUE' in srepr or 'BREAK' in srepr or 'RAISE' in srepr or 'TRY' in srepr:
        return False
    return True
  
def generate_simple_efficient_if(expr, stmt, o):
    e = []
    for i in range(1, len(expr)):
        if expr[i][0] == '!BOOLEAN' and expr[i][1][0] == '!AND_BOOLEAN':
            for j in range(1, len(expr[i][1])):
                e.append(expr[i][1][j])
        else: 
            e.append(expr[i])  
    skip_e = {}                      
    for e_it in e:
        o1, logic = shortage(generate_logical_expr(e_it))
##        pprint((logic, o1))
        o.extend(o1)
        if type(logic) is str and logic.startswith('(') and logic.endswith(')'):
          logic = logic[1:-1].strip()
        if logic == '1':
            skip_e[e_it] = True
        else:      
            o.Stmt('if (', logic, ') {')
            Cls1(o, logic)
    prev_used_fastloc = current_co.used_fastlocals.copy()
    generate_list(stmt, o)
    if stmt[-1][0] == 'RETURN_VALUE' and is_no_breaked(stmt):
        current_co.used_fastlocals = prev_used_fastloc
    for e_it in e:
        if e_it not in skip_e:
            o.append('}')
    return         

def generate_simple_efficient_if_not(expr, stmt, o):
    o1, logic = shortage(generate_logical_expr(expr))
    o.extend(o1)
    o.Raw('if ( !(', logic, ') ) {')
    Cls1(o, logic)
    prev_used_fastloc = current_co.used_fastlocals.copy()
    generate_list(stmt, o)
    if stmt[-1][0] == 'RETURN_VALUE' and is_no_breaked(stmt):
        current_co.used_fastlocals = prev_used_fastloc
    o.append('}')
    return   

def generate_if(it,o):
    if it[0][1][0] == '!1NOT' and len(it) > 3:
       if_ = list(it[0])
       if_[1] = if_[1][1]
       it[0] = tuple(if_)
       it[1], it[3] = it[3], it[1]
    if it[0][1] == ('CONST', True):
        generate_list(it[1], o)
        return
    if it[0][1] == ('CONST', False):
        if len(it) == 3:
            return
        generate_list(it[3], o)
        return
    if len(it) == 3 and it[0][1][0] == '!BOOLEAN' and it[0][1][1][0] == '!AND_BOOLEAN':
        generate_simple_efficient_if(it[0][1][1], it[1], o)
        return
    if len(it) == 3 and it[0][1][0] == '!AND_JUMP':
        generate_simple_efficient_if(it[0][1], it[1], o)
        return
    if len(it) == 3 and it[0][1][0] == '!1NOT':
        generate_simple_efficient_if_not(it[0][1][1], it[1], o)
        return
    o1, logic = shortage(generate_logical_expr(it[0][1]))
    o.extend(o1)
    
    ## prev_used_fastloc = current_co.used_fastlocals.copy()
    after_condition_used_fastloc = current_co.used_fastlocals.copy()
##    pprint(('(THEN ' + current_co.co_name, current_co.used_fastlocals))
    if type(logic) is str and logic.startswith('(') and logic.endswith(')'):
        logic = logic[1:-1]
    o.Stmt('if (', logic, ') {')
    Cls1(o, logic)
    generate_list(it[1], o)
##    pprint((')THEN ' + current_co.co_name, current_co.used_fastlocals))
    if it[1][-1][0] == 'RETURN_VALUE' and is_no_breaked(it[1]):
        current_co.used_fastlocals = after_condition_used_fastloc.copy()
    after_then_used_fastloc = current_co.used_fastlocals.copy()
    if len(it) == 3:
        o.append('}')
        return
    assert it[2][0] == ')(ELSE'
    o.append('} else {')
    current_co.used_fastlocals = after_condition_used_fastloc.copy()
    ## prev_used_fastloc = after_condition_used_fastloc.copy()
    generate_list(it[3], o)
    if it[3][-1][0] == 'RETURN_VALUE' and is_no_breaked(it[3]):
        current_co.used_fastlocals = after_condition_used_fastloc
    for k in after_then_used_fastloc.iterkeys():
        current_co.used_fastlocals[k] = True
    o.append('}')
    assert it[4][0] == ')ENDIF'

def generate_while(it,o):
    global try_jump_context, dropped_temp
    have_else = it[2][0] == ')(ELSE'
    if have_else:
        else_cond = New('int')
        o.Stmt(else_cond, '=', 1)
    try_jump_context.append(False)    
    dropped_temp.append(('WHILE', ()))
    o.append('for (;;) {')
    o1, logic = shortage(generate_logical_expr(it[0][1]))
    o.extend(o1)
    if logic != '1' and logic != '(1)':
        if type(logic) is str and logic.startswith('(') and logic.endswith(')'):
            logic = logic[1:-1].strip()
        o.Stmt('if (!(', logic, ')) break')
    Cls1(o, logic)
    if have_else:
        o.Stmt(else_cond, '=', 0)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    if have_else:
        o.Stmt ('if (', else_cond,') {')
        Cls1(o, else_cond)
        generate_list(it[3], o)
        o.append('}')
        assert len(it) == 5
        return
    assert len(it) == 3

def generate_for_and_else_new(it,o): 
    global try_jump_context, dropped_temp
    iter = it[0][2]
    riter = Expr1(iter, o)
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    Cls1(o, riter)
    try_jump_context.append(False)
    to_else = New('int')
    o.Raw(to_else, ' = 1;')
    dropped_temp.append(('FOR', (riter2,)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
       generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
       generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    Cls1(o, ref)
    o.Raw(to_else, ' = 0;')
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    Cls1(o, riter2) 
    o.Stmt('if (', to_else, ') {')
    generate_list(it[3], o)
    o.append('}')
    Cls1(o, to_else)

    assert len(it) in (3,5)

def replace_for_index(body, var, typed_index):
    if IsCVar(var):
        return body
    return replace_subexpr(body, var, typed_index)

def generate_for_body_range_one_arg(o, hdr, body, pos_iter):
    if len(hdr[1]) == 1 and hdr[1][0][0] == 'STORE_FAST' and not have_subexpr(body, hdr[1][0]):
        body2 = replace_for_index(body, ('FAST', hdr[1][0][1]), ('!@PyInt_FromSsize_t', pos_iter, ('FAST', hdr[1][0][1])))
        generate_list(body2, o)
    else:   
        generate_list(body, o)

def generate_for_range_one_arg(it, o, range_arg):
    global try_jump_context, dropped_temp

    try_jump_context.append(False)
    if type(range_arg) != int:
        ref_arg = Expr1(range_arg, o)
        cnt = New('Py_ssize_t')
        o.Stmt(cnt, '=', 'PyInt_AsSsize_t', ref_arg)
        Cls1(o, ref_arg)
    else:
        cnt = range_arg    
    dropped_temp.append(('FOR', ()))
    ## let = it[0][1][0]
 
    pos_iter = New('Py_ssize_t')
    o.Raw('for (', pos_iter, ' = 0; ', pos_iter, ' < ', cnt, '; ', pos_iter, ' ++) {')
    ref = New()
    o.PushInt(ref, pos_iter)
    if len(it[0][1]) == 1:        
        generate_store(it[0][1][0], ref, o, 'PyInt_FromSsize_t')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyInt_FromSsize_t')
    Cls1(o, ref)
    generate_for_body_range_one_arg(o, it[0], it[1], pos_iter)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(pos_iter, cnt) 

def generate_for_range_two_arg(it, o, range_arg0, range_arg):
    global try_jump_context, dropped_temp

    try_jump_context.append(False)
    if type(range_arg0) is tuple and range_arg0[0] == 'CONST':
        range_arg0 = range_arg0[1]
    if type(range_arg) is tuple and range_arg[0] == 'CONST':
        range_arg = range_arg[1]
    if type(range_arg0) != int:
        ref_arg0 = Expr1(range_arg0, o)
        cnt0 = New('Py_ssize_t')
        o.Stmt(cnt0, '=', 'PyInt_AsSsize_t', ref_arg0)
        Cls1(o, ref_arg0)
    else:
        cnt0 = range_arg0  
        
    if type(range_arg) != int:
        ref_arg = Expr1(range_arg, o)
        cnt = New('Py_ssize_t')
        o.Stmt(cnt, '=', 'PyInt_AsSsize_t', ref_arg)
        Cls1(o, ref_arg)
    else:
        cnt = range_arg    
    dropped_temp.append(('FOR', ()))
    pos_iter = New('Py_ssize_t')
    o.Raw('for (', pos_iter, ' = ', cnt0, ';', pos_iter, ' < ', cnt, ';', pos_iter, ' ++) {')
    ref = New()
    o.PushInt(ref, pos_iter)
    if len(it[0][1]) == 1:        
        generate_store(it[0][1][0], ref, o, 'PyInt_FromSsize_t')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyInt_FromSsize_t')
    Cls1(o, ref)
    generate_for_body_range_one_arg(o, it[0], it[1], pos_iter)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(pos_iter, cnt) 
    
def generate_for_list_new(it,o): 
    global try_jump_context, dropped_temp

    iter = it[0][2]
    t = TypeExpr(iter)
    assert IsListAll(t)
    v = []
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('CONST', ('?',)), ('NULL',))) and\
                      type(v[0]) is int:
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('!BUILD_TUPLE', ('?',)), ('NULL',))):
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('CONST', ('?', '?')), ('NULL',))) and\
                      type(v[0]) is int and type(v[1]) is int:
        generate_for_range_two_arg(it, o, v[0], v[1])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
        generate_for_range_two_arg(it, o, v[0], v[1])
        return    
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    pos_iter = New('int')
    if IsList(t):
        o.Raw('assert(PyList_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyList_GET_SIZE(', riter, ');',pos_iter, '++) {')
    ref = New()
    o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyList_GET_ITEM')
    else:  
        ty = None
        if t[1] is not None:
            ty = t[1]
        mass_store(o, ref, it[0][1], 'PyList_GET_ITEM', ty)
##        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyList_GET_ITEM')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_universal_new(it,o): 
    global try_jump_context, dropped_temp

    iter = it[0][2]
    riter = Expr1(iter, o)
    riter2 = New()
    pos_iter = New('int')
    o.Raw(pos_iter, ' = 0;')
    o.Raw(riter2, ' = NULL;')
    o.Raw('if (!PyList_CheckExact(', riter, ') && !PyTuple_CheckExact(', riter, ')) {')
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    o.append('}')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,  riter)))
    o.append('for (;;) {')
    ref = New()
    o.Raw('if (PyList_CheckExact(', riter, ')) {')
    o.Stmt('if (', pos_iter, '>= PyList_GET_SIZE(', riter, ')) break;')
    o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
    o.Raw(pos_iter, '++;')
    o.Raw('} else if (PyTuple_CheckExact(', riter, ')) {')
    o.Stmt('if (', pos_iter, '>= PyTuple_GET_SIZE(', riter, ')) break;')
    o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
    o.Raw(pos_iter, '++;')
    o.append('} else {')
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    o.append('}')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, riter2, pos_iter) 

def generate_for_file_new(it,o): 
    global try_jump_context, dropped_temp

    iter = it[0][2]
    riter = Expr1(iter, o)
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,  riter)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, riter2) 

def generate_for_fuple_of_int_new(it, o, tupl_int):
    global try_jump_context, dropped_temp
    try_jump_context.append(False)
    pos_iter = New('int')
    cnt = len(tupl_int)
    val_iter = New('long')
    refint = New('longref')
    li = ''
    for i in tupl_int:
        li += str(i) + 'l, '
    li = li[:-2]    
    dropped_temp.append(('FOR', ()))
    o.append('{')
    o.Raw('static long ', refint, '[] = {', li, '};')
    o.Raw('for (', pos_iter, ' = 0;', pos_iter, ' < ', cnt, ';', pos_iter, ' ++) {')
    ## o.Raw(val_iter, ' = ', refint, '[', pos_iter, '];')
    ref = New()
    ## o.PushInt(ref, val_iter) 
    o.Raw(ref, ' = PyInt_FromLong ( ', val_iter, ' = ', refint, '[', pos_iter, ']', ' );')

    if len(it[0][1]) == 1:        
        generate_store(it[0][1][0], ref, o, 'PyInt_FromLong')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyInt_FromLong')
    Cls1(o, ref)
    generate_for_body_tuple_of_int(o, it[0], it[1], val_iter)
    o.append('}')
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(pos_iter, val_iter, refint) 

def generate_for_body_tuple_of_int(o, hdr, body, pos_iter):
    if len(hdr[1]) == 1 and hdr[1][0][0] == 'STORE_FAST' and not have_subexpr(body, hdr[1][0]):
        body2 = replace_for_index(body, ('FAST', hdr[1][0][1]), ('!@PyInt_FromSsize_t', pos_iter, ('FAST', hdr[1][0][1])))
        generate_list(body2, o)
    else:            
        generate_list(body, o)



def generate_for_tuple_new(it,o): 
    global try_jump_context, dropped_temp

    iter = it[0][2]
    if iter[0] == 'CONST' and all([type(x) is int for x in iter[1]]):
        generate_for_fuple_of_int_new(it, o, iter[1])
        return
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    pos_iter = New('int')
    if riter[0] != 'CONST':
        o.Raw('assert(PyTuple_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyTuple_GET_SIZE(', riter, ');',pos_iter, '++) {')
    ref = New()
    o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyTuple_GET_ITEM')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyTuple_GET_ITEM')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_str_new(it,o): 
    global try_jump_context, dropped_temp

    iter = it[0][2]
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    pos_iter = New('int')
    if riter[0] != 'CONST':
        o.Raw('assert(PyString_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyString_GET_SIZE(', riter, ');',pos_iter, '++) {')
    ref = New()
    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', riter, ' ) + ', pos_iter, ' , 1 );')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyString_FromStringAndSize')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyString_FromStringAndSize')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 


def generate_for_enumerate_new(it,o, store1, store2, iter): 
    global try_jump_context, dropped_temp

    riter = Expr1(iter, o)
    riter2 = New()
    pos_iter = New('int')
    o.Raw(pos_iter, ' = 0;')
    o.Raw(riter2, ' = NULL;')
    o.Raw('if (!PyList_CheckExact(', riter, ') && !PyTuple_CheckExact(', riter, ')) {')
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    o.append('}')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,  riter)))
    o.append('for (;;) {')
    ref = New()
    o.Raw('if (PyList_CheckExact(', riter, ')) {')
    o.Stmt('if (', pos_iter, '>= PyList_GET_SIZE(', riter, ')) break;')
    o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
    o.Raw('} else if (PyTuple_CheckExact(', riter, ')) {')
    o.Stmt('if (', pos_iter, '>= PyTuple_GET_SIZE(', riter, ')) break;')
    o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
    o.append('} else {')
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    o.append('}')
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
    ref_ind = New()
    o.PushInt(ref_ind, pos_iter)
    generate_store(it[0][1][0], ref_ind, o, 'PyIter_Next')
    Cls1(o, ref_ind)
    generate_store(it[0][1][1], ref, o, 'PyIter_Next')
    Cls1(o, ref)
    o.Raw(pos_iter, '++;')
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, riter2, pos_iter) 

def generate_for_enumerate_list_new(it,o, store1, store2, iter): 
    global try_jump_context, dropped_temp

    riter = Expr1(iter, o)
    pos_iter = New('int')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    o.Raw('assert(PyList_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyList_GET_SIZE(', riter, ');',pos_iter, '++) {')
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
    ref_ind = New()
    o.PushInt(ref_ind, pos_iter)
    generate_store(it[0][1][0], ref_ind, o, 'PyList_GET_ITEM')
    Cls1(o, ref_ind)
    ref = New()
    o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
    generate_store(it[0][1][1], ref, o, 'PyList_GET_ITEM')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_enumerate_tuple_new(it,o, store1, store2, iter): 
    global try_jump_context, dropped_temp

    riter = Expr1(iter, o)
    pos_iter = New('int')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    o.Raw('assert(PyTuple_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyTuple_GET_SIZE(', riter, ');',pos_iter, '++) {')
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
    ref_ind = New()
    o.PushInt(ref_ind, pos_iter)
    generate_store(it[0][1][0], ref_ind, o, 'PyTuple_GET_ITEM')
    Cls1(o, ref_ind)
    ref = New()
    o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
    generate_store(it[0][1][1], ref, o, 'PyTuple_GET_ITEM')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_iteritems_generator_standard(it,o):
    global try_jump_context, dropped_temp

    iter = it[0][2]
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    assert len(it[0][1]) == 2

    ref1 = New()
##    o.Stmt(ref1, '=', 'PyTuple_GetItem', ref, 0)
    GetTupleItem(o, (tuple, 2), ref1, ref, 0)
    generate_store(it[0][1][0], ref1, o, 'PyIter_Next')
    Cls1(o, ref1)
    ref1 = New()
    GetTupleItem(o, (tuple, 2), ref1, ref, 1)
##    o.Stmt(ref1, '=', 'PyTuple_GetItem', ref, 1)
    generate_store(it[0][1][1], ref1, o, 'PyIter_Next')
    Cls1(o, ref1)

    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    Cls1(o, riter)

def generate_for_iteritems_generator_new(it,o, v): 
    global try_jump_context, dropped_temp

    d = Expr1(v[2], o)
    pos = New('Py_ssize_t')
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (d, pos)))
    o.Raw(pos, ' = 0;')
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', d, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    assert len(it[0][1]) == 2
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(it[0][1][0], k, o, 'PyDict_Next')
    generate_store(it[0][1][1], v, o, 'PyDict_Next')
    o.Cls(k,v)

    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(d,pos) 

def generate_for_iterkeys_generator_new(it,o, v): 
    global try_jump_context, dropped_temp

    d = Expr1(v[1], o)
    pos = New('Py_ssize_t')
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (d, pos)))
    o.Raw(pos, ' = 0;')
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', d, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    assert len(it[0][1]) == 1
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(it[0][1][0], k, o, 'PyDict_Next')
    o.Cls(k,v)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(d,pos) 

def generate_for_itervalues_generator_new(it,o, v): 
    global try_jump_context, dropped_temp

    d = Expr1(v[1], o)
    pos = New('Py_ssize_t')
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (d, pos)))
    o.Raw(pos, ' = 0;')
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', d, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    assert len(it[0][1]) == 1
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(it[0][1][0], v, o, 'PyDict_Next')
    o.Cls(k,v)

    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(d,pos) 

def generate_for_new(it,o): 
    global try_jump_context, dropped_temp
    if len(it) == 5 and it[2][0] == ')(ELSE':
        generate_for_and_else_new(it,o)
        return
    iter = it[0][2]
    type_for = TypeExpr(iter)
    if IsListAll(type_for):
        generate_for_list_new(it,o)
        return
    if IsStr(type_for):
        generate_for_str_new(it,o)
        return    
    if IsTuple(type_for):
        generate_for_tuple_new(it,o)
        return
    if type_for == Kl_File:
        generate_for_file_new(it,o)
        return
    if type_for == Kl_Generator:
        v = []
        if TCmp(it[0], v,  ('(FOR', ('?', '?'), \
                             ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), \
                                     ('!BUILD_TUPLE', ('?',)), ('NULL',)))):
            t = TypeExpr(v[2])
            if IsList(t):                             
                generate_for_enumerate_list_new(it, o, v[0], v[1], v[2])
            elif IsTuple(t):                             
                generate_for_enumerate_tuple_new(it, o, v[0], v[1], v[2])
            else:
                generate_for_enumerate_new(it, o, v[0], v[1], v[2])
            return
        elif TCmp(it[0], v,  ('(FOR', ('?', '?'), \
                             ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'iteritems')), \
                                     ('CONST', ()), ('NULL',)))):
            t = TypeExpr(v[2])
            if IsDict(t):
                if dirty_iteritems:
                    generate_for_iteritems_generator_new(it,o, v)
                    return
                else:
                    generate_for_iteritems_generator_standard(it,o)
                    return
        elif TCmp(it[0], v,  ('(FOR', ('?',), \
                             ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'iterkeys')), \
                                     ('CONST', ()), ('NULL',)))) and dirty_iteritems:
            t = TypeExpr(v[1])
            if IsDict(t):
                generate_for_iterkeys_generator_new(it,o, v)
                return
        elif TCmp(it[0], v,  ('(FOR', ('?',), \
                             ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'itervalues')), \
                                     ('CONST', ()), ('NULL',)))) and dirty_iteritems:
            t = TypeExpr(v[1])
            if IsDict(t):
                generate_for_itervalues_generator_new(it,o, v)
                return
   
    if type_for == Kl_XRange:
        generate_for_xrange_new(it,o)
        return
    return generate_for_universal_new(it,o)
 
## def generate_for_generator_new(it,o): 
    ## global try_jump_context, dropped_temp
    ## iter = it[0][2]
    ## riter = Expr1(iter, o)
    ## try_jump_context.append(False)
    ## dropped_temp.append(('FOR', (riter,)))
    ## o.append('for (;;) {')
    ## ref = New()
    ## o.Stmt(ref, '=', 'PyIter_Next', riter)
    ## o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    ## UseLabl()
    ## o.Stmt('if (!', ref, '){ break; }')
    ## if len(it[0][1]) == 1:
        ## generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    ## else:  
        ## generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    ## Cls1(o, ref)
    ## generate_list(it[1], o)
    ## o.append('}')
    ## del try_jump_context[-1]
    ## del dropped_temp[-1]
    ## Cls1(o, riter) 

def generate_for_xrange_new(it,o): 
    global try_jump_context, dropped_temp
    iter = it[0][2]

    v = []
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('CONST', ('?',)), ('NULL',))) and\
                      type(v[0]) is int:
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('!BUILD_TUPLE', ('?',)), ('NULL',))):
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('CONST', ('?', '?')), ('NULL',))) and\
                      type(v[0]) is int and type(v[1]) is int:
        generate_for_range_two_arg(it, o, v[0], v[1])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
        generate_for_range_two_arg(it, o, v[0], v[1])
        return  
    riter = Expr1(iter, o)
 
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    Cls1(o, riter)
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    Cls1(o, ref)
    generate_list(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    Cls1(o, riter2) 

    assert len(it) in (3,5)

## def expanded_range(iter):
    ## v = []
    ## if TCmp(iter, v, ('!BUILD_LIST', '?')):
        ## li = v[0]
        ## rn = []
        ## for it in li:
            ## if it[0] != 'CONST':
                ## return None
            ## rn.append(it[1])
        ## if tuple(rn) == tuple(range(len(rn))):
            ## return ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', ('?',)), ('NULL',)) 
    ## return None

def is_like_float(a):
    if detect_float and have_floatmul(a):
        return True
    return False
        
def have_floatmul(a):
    if type(a) is tuple and len(a) > 0 and a != ('NULL',) and \
           type(a[0]) is str and IsFloat(TypeExpr(a)):
        return True
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str:
            if len(a) >= 2 and a[0] == '!PyNumber_Multiply' and not (a[1][0] in ('!BUILD_LIST', '!BUILD_TUPLE')):
                return True
            if a[0] == '!PyNumber_Divide':
                return True
            if a[0] == 'CONST':
                return False
        for i in a:
            if type(i) is tuple and len(i) > 0 and type(i[0]) is str and i[0] != 'NULL':
                if have_floatmul(i):
                    return True
        return False
    if type(a) is list:
        for i in a:
            if have_floatmul(i):
                return True
        return False
    return False    
 
def have_subexpr(a,b):
    if a is b:
        return True
    if type(a) is type(b):
        if len(a) == len(b) and type(a[0]) is type(b[0]):
            if a == b:
                return True
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return False
        for i in a:
            if have_subexpr(i,b):
                return True
        return False
    if type(a) is list:
        for i in a:
            if have_subexpr(i,b):
                return True
        return False
    return False    

def find_statement_calculate_const(a, b):
    if type(a) is tuple and len(a) >= 2 and a[1] == b and \
       type(a[0]) is str and a[0][:6] == 'STORE_':
        return a
    if type(a) is tuple and len(a) >= 2 and \
       type(a[0]) is str and a[0] == 'IMPORT_FROM_AS' and b in a[3][1]:
           return a
    if type(a) is tuple:
        if len(a) > 0 and a[0] == 'CONST':
            return False
        for i in a:
            ret = find_statement_calculate_const(i,b)
            if ret == True:    
                return 
            if type(ret) is tuple:
                if ret[0] in ('STORE', 'SEQ_ASSIGN', 'SET_EXPRS_TO_VARS'):
                    return ret
                return a
        return False
    if type(a) is list:
        for i in a:
            ret = find_statement_calculate_const(i,b)
            if type(ret) is tuple:
                if ret[0] in ('STORE', 'SEQ_ASSIGN', 'SET_EXPRS_TO_VARS'):
                    return ret
                return ret
    return False    

def TCmp(e,v,p, trace = None):
    assert type(v) is list
    if trace is not None:
        pprint(( 'Parameters:', e,v,p))
    if type(p) is str:
        if p == '?':
            v.append(e)
            if trace is not None: print 'Cmp success ', e,v,p
            return True
        if type(e) is str and e == p:
            if trace is not None: print 'Cmp success ', e,v,p
            return True
        if p.startswith(':') and p.endswith(':'):
            s = p[1:-1]
            if Is3(e, s):
                v.append((e,s, Val3(e,s)))
                if trace != None: print 'Cmp success ', e,v,p
                return True  
        del v[:]
        return False
    if type(p) is type:
        if type(e) is p:
            v.append(e)
            if trace is not None: print 'Cmp success ', e,v,p
            return True
        del v[:]
        return False        
    if type(p) is tuple:
        if len(p) > 0 and type(p[0]) is str and p[0] == '|':
            if e in p[1:]:
                if trace is not None: print 'Cmp success ', e,v,p
                return True
        if type(e) is tuple:
            if len(e) != len(p):
                del v[:]
                return False
            for i,p0 in enumerate(p):
                if trace is not None: print 'Cmp', i, p0
                if p0 is None and e[i] is None:
                    continue
                if type(p0) is str:
                    if p0 == '*':
                        v.append(e[i:])
                        if trace is not None: print 'Cmp success ', e,v,p
                        return True
                    if p0 == '?':
                        v.append(e[i])
                        continue

                    if type(e[i]) is str:
                        if e[i] != p0:
                            if p0.startswith(':') and p0.endswith(':'):
                                s = p0[1:-1]
                                if Is3(e[i], s):
                                    v.append((e[i],s, Val3(e[i],s)))
                                    if trace != None: print 'Cmp success ', e[i],v,p
                                    continue  
    
                            del v[:]
                            return False
                        else:
                            continue
                    elif not TCmp(e[i], v, p0, trace):
                        del v[:]
                        return False
                elif not TCmp(e[i], v, p0, trace):
                    del v[:]
                    return False
            if trace is not None: print 'Cmp success ', e,v,p
            return True
        del v[:]
        return False        
    if type(p) is list:
        if type(e) == type(p):
            if len(e) != len(p):
                del v[:]
                return False
            for i,p0 in enumerate(p):
                if not TCmp(e[i], v, p0):
                    del v[:]
                    return False
            if trace is not None: print 'Cmp success ', e,v,p
            return True
        del v[:]
        return False        
    if type(p) is dict:
        if e in p:
            v.append(e)
            if trace is not None: print 'Cmp success ', e,v,p
            return True
        del v[:]
        return False
    if e == p:
        if trace is not None: print 'Cmp success ', e,v,p
        return True
    del v[:]
    return False
  
def update_v_0_1(v):
    try:
        if v[0]:
            v[0] = True
        else:
            v[0] = False
    except:
        pass
     
def class_create_to_dict_create(nm):
    cmd = N2C(nm).cmds[1]
    cmd = [x for x in cmd if x[0] != '.L' and x != ('RETURN_VALUE', ('f->f_locals',))]
    ## ok = True
    dic = []
    for x in cmd:
        v = []
        if TCmp(x, v, ('STORE', (('STORE_NAME', '?'),),  (('!MK_FUNK', '?', ('CONST', ())),))):
            dic.append((('CONST', v[0]), ('!MK_FUNK', v[1], ('CONST', ()))))
            continue
        v = []
        if TCmp(x, v, ('STORE', (('STORE_NAME', '?'),), (('CONST', '?'),))):
            
            dic.append((('CONST', v[0]), ('CONST', v[1])))
            continue
        return None
    return DictFromArgs(tuple(dic))
           
def repl_list(a, up):
    i = 0
    assert type(a) is list
    aa = a #[:]
    updated = False

    while i < len(aa): 
        assert type(i) is int
        if i < 0:
            i = 0
            continue
        s = aa[i]
        v = []
        v0 = []
        ## v1 = []
        v2 = []
                 
        if i < len(aa) - 2 and type(s) is tuple and len(s) > 0 and \
                         type(s[0]) is str and s[0] == '(FOR' and \
                TCmp(s, v, ('(FOR', ('?',), \
                       ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                        ('!BUILD_TUPLE', ('?',)), \
                        ('NULL',)))) and aa[i+1] == [('PASS',)] and\
                        aa[i+2] == (')ENDFOR',):
            s1 = [('(IF', ('!PyObject_RichCompare(', v[1], ('CONST', 0), 'Py_GT')), [('STORE', (v[0],), (('!PyNumber_Subtract', v[1], ('CONST', 1)),))], (')ENDIF',)]
            aa[i:i+3] = s1
            updated = True
            i -= 10
            continue
        if i < len(aa) - 2 and type(s) is tuple and len(s) > 0 and \
                         type(s[0]) is str and s[0] == '(FOR' and \
                TCmp(s, v, ('(FOR', (('STORE_FAST', '?'),), \
                       ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                        ('CONST', ('?', '?')), \
                        ('NULL',)))) and type(aa[i+1]) is list and \
                        aa[i+2] == (')ENDFOR',):
            if type(v[1]) is int and type(v[2]) is int and \
               v[2] - v[1] < 10 and v[2] - v[1] >= 0 and \
               not repr(('STORE_FAST', v[0])) in repr(aa[i+1]):
                    s1 = []
                    for i_ in range(v[1], v[2]):
                        s1.extend(replace_subexpr(aa[i+1], ('FAST', v[0]), ('CONST', i_)))
                    s1.append(('STORE', (('STORE_FAST', v[0]),), (('CONST', v[2] - 1),)))
                    aa[i:i+3] = s1
                    updated = True
                    i -= 10
                    continue

        if i < len(aa) - 2 and type(s) is tuple and len(s) > 0 and \
                         type(s[0]) is str and s[0] == '(FOR' and \
                TCmp(s, v, ('(FOR', (('?', '?'),), ('CONST', ()))) \
                         and type(aa[i+1]) is list and \
                        aa[i+2] == (')ENDFOR',):
                    aa[i:i+3] = []
                    updated = True
                    i -= 10
                    continue
       
        if type(s) is tuple and len(s) == 3 and type(s[0]) is str and \
           s[0] == 'SET_EXPRS_TO_VARS':
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', (('STORE_FAST', '?'), '?'), ('CLONE', '?'))):            
                s1 = [('STORE', (('STORE_FAST', v[0]),), (v[2],)), ('STORE', (v[1],), (('FAST', v[0]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
    
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?'), (('CONST', '?'), ('CONST', '?')))):
                s1 = [('STORE', (v[0],), (('CONST', v[2]),)), ('STORE', (v[1],), (('CONST', v[3]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?', '?'), (('CONST', '?'), ('CONST', '?'), ('CONST', '?')))):
                s1 = [('STORE', (v[0],), (('CONST', v[3]),)), ('STORE', (v[1],), (('CONST', v[4]),)), ('STORE', (v[2],), (('CONST', v[5]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?', '?', '?'), (('CONST', '?'), ('CONST', '?'), ('CONST', '?'), ('CONST', '?')))):
                s1 = [('STORE', (v[0],), (('CONST', v[4]),)), ('STORE', (v[1],), (('CONST', v[5]),)), \
                      ('STORE', (v[2],), (('CONST', v[6]),)), ('STORE', (v[3],), (('CONST', v[7]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?'), (('!BUILD_LIST', ()), ('!BUILD_LIST', ())))):
                s1 = [('STORE', (v[0],), (('!BUILD_LIST', ()),)), ('STORE', (v[1],), (('!BUILD_LIST', ()),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?', '?'), (('!BUILD_LIST', ()), ('!BUILD_LIST', ()), ('!BUILD_LIST', ())))):
                s1 = [('STORE', (v[0],), (('!BUILD_LIST', ()),)), ('STORE', (v[1],), (('!BUILD_LIST', ()),)), ('STORE', (v[2],), (('!BUILD_LIST', ()),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if TCmp(s, v, (   'SET_EXPRS_TO_VARS',
                    (('STORE_FAST', '?'), ('STORE_FAST', '?')),
                    ( '?', '?'))):    
                if repr(('FAST', v[0])) not in repr([v[2], v[3]]) and repr(('STORE_FAST', v[0])) not in repr([v[2], v[3]]) and \
                   repr(('FAST', v[1])) not in repr([v[2], v[3]]) and repr(('STORE_FAST', v[1])) not in repr([v[2], v[3]]):
                    s1 = [('STORE', (('STORE_FAST', v[0]),), (v[2],)), 
                          ('STORE', (('STORE_FAST', v[1],),), (v[3],))]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
            if TCmp(s, v, (   'SET_EXPRS_TO_VARS',
                    (('STORE_FAST', '?'), ('STORE_FAST', '?'), ('STORE_FAST', '?')),
                    (   '?', '?', '?'))):    
                if repr(('FAST', v[0])) not in repr([v[3], v[4], v[5]]) and repr(('STORE_FAST', v[0])) not in repr([v[3], v[4], v[5]]) and \
                   repr(('FAST', v[1])) not in repr([v[3], v[4], v[5]]) and repr(('STORE_FAST', v[1])) not in repr([v[3], v[4], v[5]]) and \
                   repr(('FAST', v[2])) not in repr([v[3], v[4], v[5]]) and repr(('STORE_FAST', v[2])) not in repr([v[3], v[4], v[5]]):
                    s1 = [('STORE', (('STORE_FAST', v[0]),), (v[3],)), 
                          ('STORE', (('STORE_FAST', v[1]),), (v[4],)), 
                          ('STORE', (('STORE_FAST', v[2]),), (v[5],))]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
            if TCmp(s, v, ('SET_EXPRS_TO_VARS',
                (('STORE_NAME', '?'), ('STORE_NAME', '?')),
                (('CONST', '?'), ('CONST', '?')))):        
                s1 = [('STORE', (('STORE_NAME', v[0]),), (('CONST', v[2]),)), \
                    ('STORE', (('STORE_NAME', v[1]),), (('CONST', v[2]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', '?', '?')): 
                li = [x for x in v[1] if x[0] != 'FAST']
                if len(li) == 0:       
                    li1 = [x for x in v[1]]
                    li2 = [('STORE_FAST', x[1]) for x in v[1]]
                    li0 = repr(v[0])
                    li3 = [x for x in range(len(li1)) if repr(li1[x]) in li0 or repr(li2[x]) in li0]
                    if len(li3) == 0:
                        s1 = []
                        for x in range(len(li1)):
                            s1.append(('STORE', (v[0][x],), (li1[x],)))
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
        v = []
        if type(s) is tuple and len(s) > 0 and type(s[0]) is str and s[0] == 'STORE':
            if i < len(aa) - 2 and \
            TCmp(s, v, ('STORE', (('STORE_NAME', '?'),), (('!MK_FUNK', '?', ('CONST', ())),))) and\
            i+2 < len(aa) and aa[i+1][0] == '.L' and\
            TCmp(aa[i+2], v2, ('STORE', ('?',), \
                            (('!PyObject_Call', ('!LOAD_NAME', v[0]), \
                            ('CONST', ()), ('NULL',)),))):  
                ret2 = ('!PyObject_Call', ('!LOAD_NAME', v[0]), ('CONST', ()), ('NULL',)) # unchanged
                newstor = ('STORE', (v2[0],), (call_calc_const(v[1], ('CONST', ()), ret2),))
                if aa[i+2] != newstor:
                    aa[i+2] = newstor    
                    updated = True
                    i -= 10
                    continue
            v = [] 
            if TCmp(aa[i:i+3], v, [('STORE', (('STORE_FAST', '?'),), ('?',)),
                                    ('.L', '?'),
                                    ('RETURN_VALUE', ('FAST', '?'))]):
                if v[0] == v[3]:
                    aa[i:i+2] = [('RETURN_VALUE', v[1])]
                    updated = True
                    i -= 10
                    continue
            v = [] 
            if TCmp(aa[i:i+3], v, [('STORE', (('STORE_FAST', '?'),), ('?',)),
                                    ('.L', '?'),
                                    ('RETURN_VALUE', '?')]):
                repr0 = repr(('FAST', v[0]))
                repr1 = repr(v[3])    
                repr2 = repr(v[1])
                is1 = 'CALL' in repr1 or 'Call' in repr1                  
                is2 = 'CALL' in repr2 or 'Call' in repr2  
                if repr1.count(repr0) == 1:
                    if is1 and is2:
                        pass
                    else:
                        aa[i:i+2] = [('RETURN_VALUE', replace_subexpr(v[3], ('FAST', v[0]), v[1]))]
                        updated = True
                        i -= 10
                        continue
                if repr1.count(repr0) == 0:
                    aa[i:i+2] = [('UNPUSH', v[1]),
                                    ('.L', v[2]),
                                    ('RETURN_VALUE', v[3])]
                    updated = True
                    i -= 10
                    continue            
            v = [] 
            if TCmp(s, v, ('STORE', 
                    (('STORE_CALC_CONST', ('STORE_NAME', '?')),),
                    (   (   '!_PyEval_BuildClass',
                            ('!PyObject_Call', ('!MK_FUNK', '?', ('CONST', ())), ('CONST', ()), ('NULL',)),
                            '?',
                            ('CONST', '?')),))) and v[0] == v[1] and v[1] == v[3]:
                dic = class_create_to_dict_create(v[0])
                if dic is not None:
                    aa[i] = ('STORE',
                                (('STORE_CALC_CONST', ('STORE_NAME', v[0])),),
                                (   (   '!_PyEval_BuildClass',
                                        dic,
                                        v[2],
                                        ('CONST', v[3])),))
                    updated = True
                    i -= 10
                    continue
            v = []    
            if TCmp(aa[i:i+3], v, [                        
                (   'STORE',
                    (('STORE_FAST', '?'),),
                    (   '?',)),
                ('.L', '?'),
                (   'STORE',
                    (('STORE_FAST', '?'),),
                    (('!CALL_CALC_CONST', '?', '?'),))]) and v[0] == v[3] and repr(('FAST', v[0])) not in repr(v[5]):
                        aa[i:i+3] = [                        
                            (   'UNPUSH', v[1] ),
                            ('.L', v[2]),
                            (   'STORE',
                                (('STORE_FAST', v[0]),),
                                (('!CALL_CALC_CONST', v[4], v[5]),))]
                        updated = True
                        i -= 10
                        continue
            if i < len(aa) -  2 and aa[i+1][0] == '.L' and aa[i+2][0] == 'STORE':
                v = []
                v2 = []
                if TCmp(aa[i:i+3], v, [ 
                    ('STORE', (('STORE_FAST', '?'),), (('FAST', '?'),)),
                    ('.L', '?'),
                    ('STORE', (('STORE_FAST', '?'),), (('FAST', '?'),))]) and v[0] == v[4]:
                        aa[i+2] =  ('STORE', (('STORE_FAST', v[3]),), (('FAST', v[1]),))
                        updated = True
                        i -= 10
                        continue

            if i < len(aa) -  2 and aa[i+1][0] == '.L' and aa[i+2][0] == '(IF':
                v = []
                v2 = []
                srepr = repr(aa[i+2])
                if TCmp(aa[i:i+2], v, [ 
                    ('STORE', (('STORE_FAST', '?'),), (('FAST', '?'),)),
                    ('.L', '?')]) and repr(('FAST', v[0])) in srepr and not 'STORE_FAST' in srepr:
                        aa[i+2] = replace_subexpr(aa[i+2], ('FAST', v[0]), ('FAST', v[1]))
                        updated = True
                        i -= 10
                        continue
## Commented 11 09 2011 -- illegall execution sequence
            ## if i < len(aa) - 4 and aa[i+1][0] == '.L' and aa[i+2][0] == '(IF' and aa[i+4][0] == ')ENDIF':
                ## v = []
                ## v2 = []
                ## srepr = repr(aa[i+1:i+5])
                ## if TCmp(aa[i:i+2], v, [('STORE', (('STORE_FAST', '?'),), ('?',)), ('.L', '?')]) and \
                   ## repr(('FAST', v[0])) not in srepr and repr(('STORE_FAST', v[0])) not in srepr:
                        ## aa[i:i+5] = aa[i+1:i+5] + [aa[i]]
                        ## updated = True
                        ## i -= 10
                        ## continue
 
        ## if len(aa[i]) == 0:
            ## print i
            ## pprint(aa[:])        
        if i < len(aa) - 2 and type(aa[i]) is tuple and type(aa[i+1]) is tuple and aa[i][0] == '.L' == aa[i+1][0]:
                del aa[i]
                updated = True
                i -= 10
                continue

        v = []
        v2 = []

        if type(s) is tuple and len(s) == 3 and type(s[0]) is str and s[0] == 'STORE' and len(s[1]) == 1 and len(s[2]) == 1:
            if s[2][0][0] == '!CALL_CALC_CONST':
                expr = subroutine_inlined(s[2][0][1], s[2][0][2])
                if expr is not None and expr[-1][0] == 'RETURN_VALUE' and 'RETURN_VALUE' not in repr(expr[:-1]):
                    aa[i:i+1] = expr[:-1] + [('STORE', s[1], (expr[-1][1],))]
                    print '~~ proc/store inlined', s[2][0][1], len(repr(expr))
                    updated = True
                    i -= 10
                    continue
                
            if s[2][0][0] == '!COND_METH_EXPR' and len(s[2][0]) == 4:
                cond = s[2][0]
                condhead = cond[0:3]
                condvars = cond[3]
                if condhead[1][0] == 'FAST':
                    if len(condvars) > 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('STORE', s[1], (action,))],
                                        (')(ELSE',),
                                        [('STORE', s[1], (condhead + (condvars[1:],),))],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                    if len(condvars) == 1:   
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('STORE', s[1], (action,))],
                                        (')(ELSE',),
                                        [('STORE', s[1], (condhead[2],))],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue

        if type(s) is tuple and len(s) == 2 and type(s[0]) is str and s[0] == 'RETURN_VALUE':
            if s[1][0] == '!CALL_CALC_CONST':
                expr = subroutine_inlined(s[1][1], s[1][2])
                if expr is not None:
                    assert expr[-1][0] == 'RETURN_VALUE' and 'RETURN_VALUE' not in repr(expr[:-1])
                    aa[i:i+1] = expr
                    print '~~ proc/return inlined', s[1][1], len(repr(expr))
                    updated = True
                    i -= 10
                    continue
                
            if s[1][0] == '!COND_METH_EXPR' and len(s[1]) == 4:
                cond = s[1]
                condhead = cond[0:3]
                condvars = cond[3]
                if condhead[1][0] == 'FAST':
                    if len(condvars) > 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('RETURN_VALUE', action)],
                                        (')(ELSE',),
                                        [('RETURN_VALUE', condhead + (condvars[1:],))],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                    if len(condvars) == 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('RETURN_VALUE', action)],
                                        (')(ELSE',),
                                        [('RETURN_VALUE', condhead[2])],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                        
        if type(s) is tuple and len(s) == 2 and type(s[0]) is str and s[0] == 'UNPUSH':
            t = TypeExpr(s[1])
            v = []
            if TCmp(s, v, ( 'UNPUSH', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('PY_TYPE', 'NewClassInstance', '?', '?', None)), ('CALC_CONST', '?'))))) and v[0] == v[2]:
                    del aa[i]
                    updated = True
                    i -= 10
                    continue
            if t is not None and t != Kl_None:
                if ( IsCType(t) or IsIntUndefSize(t) ) and s[1][0] in ('!PyNumber_Subtract', '!PyNumber_Add', '!PyNumber_And','!PyNumber_Or', '!PyNumber_Divide', '!PyNumber_Multiply'):
                    aa[i:i+1] = [('UNPUSH', s[1][1]), ('UNPUSH', s[1][2])]
                    updated = True
                    i -= 10
                    continue
            if s[1][0] in ('FAST', 'CONST'):    
                    del aa[i]
                    updated = True
                    i -= 10
                    continue
            if s[1][0] == 'PY_TYPE':    
                    aa[i:i+1] = [('UNPUSH', s[1][3])]
                    updated = True
                    i -= 10
                    continue
            if TCmp(s[1], v, ('CALC_CONST', '?')):
                del aa[i]
                if len(aa) == 0:
                    aa.append(('PASS',))
                updated = True
                i -= 10
                continue
            if TCmp(s[1], v, ('!COND_EXPR', '?', '?', '?')):
                if v[1] != v[2]:
                    s1 = [('(IF', v[0]), [('UNPUSH', v[1])], (')(ELSE',), [('UNPUSH', (v[2]))], (')ENDIF',)]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
            if TCmp(s[1], v, ('!PyObject_Call', 
                                    ('!LOAD_BUILTIN', 'delattr'),
                                    ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
                s1 = [('PYAPI_CALL', ('PyObject_SetAttr', v[0], v[1], 'NULL'))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            if s[1][0] == '!CALL_CALC_CONST':
                expr = subroutine_inlined(s[1][1], s[1][2])
                if expr is not None and expr[-1] == ('RETURN_VALUE', ('CONST', None)):
                    aa[i:i+1] = expr[:-1]
                    print '~~ proc inlined', s[1][1], len(repr(expr[:-1]))
                    updated = True
                    i -= 10
                    continue
                if expr is not None and expr[-1][0] == 'RETURN_VALUE':
                    aa[i:i+1] = expr[:-1] + [('UNPUSH', expr[-1][1])]
                    print '~~ proc inlined', s[1][1], len(repr(expr[:-1] + [('UNPUSH', expr[-1][1])]))
                    updated = True
                    i -= 10
                    continue
                
                
            if s[1][0] == '!COND_METH_EXPR' and len(s[1]) == 4:
                cond = s[1]
                condhead = cond[0:3]
                condvars = cond[3]
                if condhead[1][0] == 'FAST':
                    if len(condvars) > 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('UNPUSH', action)],
                                        (')(ELSE',),
                                        [('UNPUSH', condhead + (condvars[1:],))],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                    if len(condvars) == 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('UNPUSH', action)],
                                        (')(ELSE',),
                                        [('UNPUSH', condhead[2])],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                            
            s_ = []
            if s[1][0] == '!PyObject_Call' and\
                TCmp(s[1], s_, ('!PyObject_Call', \
                                ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', ('NULL',))):
                s_ = tuple(s_)                    
                if TCmp(s_, v, ('?', 'sort', ('CONST', ()))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Sort', v[0]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                if TCmp(s_, v, ('?', 'append', ('CONST', ('?',)))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Append', v[0], ('CONST', v[1])))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                if TCmp(s_, v, ('?', 'append', ('!BUILD_TUPLE', ('?',)))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Append', v[0], v[1]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                v = []    
                if TCmp(s_, v, ('?', 'clear', ('CONST', ()))):
                    if IsDict(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyDict_Clear', v[0]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                if TCmp(s_, v, ('?', 'reverse', ('CONST', ()))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Reverse', v[0]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                if TCmp(s_, v, ('?', 'insert', ('CONST', ('?', '?')))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Insert', v[0], v[1], ('CONST', v[2])))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                if TCmp(s_, v, ('?', 'insert', ('!BUILD_TUPLE', (('CONST', '?'), '?')))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Insert', v[0], v[1], v[2]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue

            if TCmp(s[1], v, ('CONST', '?')):
                aa[i:i+1] = []
                if len(aa) == 0:
                    aa.append(('PASS',))
                updated = True
                i -= 10
                continue

        if type(s) is tuple and len(s) == 3 and type(s[0]) is str and \
           s[0] == 'STORE' and len(s[1]) == 1 and len(s[2]) == 1:
            if s[1][0][0] == 'STORE_FAST':   
                if TCmp(s, v, ('STORE', (('STORE_FAST', '?'),), \
                                (('!COND_EXPR', '?', '?', '?'),))):
                    if v[2] != v[3]:
                        s1 = [('(IF', v[1]), [('STORE', (('STORE_FAST', v[0]),),  (v[2],))], \
                            (')(ELSE',), [('STORE', (('STORE_FAST', v[0]),),  (v[3],))], (')ENDIF',)]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                if TCmp(s, v, \
                    ('STORE', \
                        (('STORE_FAST', '?'),), \
                        (('!PyNumber_InPlaceAdd', \
                            ('PY_TYPE', '?', None, ('FAST', '?'), None), \
                            ('!BUILD_LIST', '?')),))):
                    if v[0] == v[2] and v[1] is list:
                        new_a = []
                        for li in v[3]:
                            new_a.append(('PYAPI_CALL', ('PyList_Append', ('FAST', v[0]), li)))
                        aa[i:i+1] = new_a
                        updated = True
                        i -= 10
                        continue
            if s[1][0][0] == 'SET_VARS' and \
                TCmp(s, v, ('STORE', (('SET_VARS', '?'),), (('!BUILD_LIST', '?'),))) and \
                   len(v[0]) == len(v[1]):
                if v[0][0][0] == 'STORE_NAME' and not v[0][0][1] in repr(v[1][1:]) and not v[0][0][1] in repr(v[0][1:]):
                    s1 = [('STORE', (('STORE_NAME', v[0][0][1]),), (v[1][0],))]
                    if len(v[0]) > 1:
                        s1.append( ('STORE', (('SET_VARS', v[0][1:]),), (('!BUILD_LIST', v[1][1:]),)) )
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
            if s[1][0][0] == 'SET_VARS' and \
                TCmp(s, v, ('STORE', (('SET_VARS', '?'),), (('CONST', '?'),))) and \
                   type(v[1]) is tuple and len(v[0]) == len(v[1]):
                if v[0][0][0] == 'STORE_NAME' and not v[0][0][1] in repr(v[1][1:]) and not v[0][0][1] in repr(v[0][1:]):
                    s1 = [('STORE', (('STORE_NAME', v[0][0][1]),), (('CONST', v[1][0]),))]
                    if len(v[0]) > 1:
                        s1.append( ('STORE', (('SET_VARS', v[0][1:]),), (('CONST', v[1][1:]),)) )
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
        if i+1 < len(aa) and len(s) > 0 and s[0] == 'RETURN_VALUE' and \
           aa[i+1][0] in ('STORE', 'UNPUSH', '.L', 'RETURN_VALUE', 'PRINT_ITEM_1', 'PRINT_NEWLINE'):
            del aa[i+1]
            updated = True
            i -= 10
            continue
        if i+1 < len(aa) and len(s) > 0 and s[0] == 'CONTINUE' and \
           aa[i+1][0] in ('STORE', 'UNPUSH', '.L', 'RETURN_VALUE', 'PRINT_ITEM_1', 'PRINT_NEWLINE', 'CONTINUE'):
            del aa[i+1]
            updated = True
            i -= 10
            continue
        if i+1 < len(aa) and len(s) > 0 and s[0] == 'BREAK' and \
           aa[i+1][0] in ('STORE', 'UNPUSH', '.L', 'RETURN_VALUE', 'PRINT_ITEM_1', 'PRINT_NEWLINE'):
            del aa[i+1]
            updated = True
            i -= 10
            continue
        if i+5 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
           len(aa[i+1]) == 1 and aa[i+1][0][0] == '.L' and\
           aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
           aa[i+4] == (')ENDTRY',):
            aa[i:i+5] = aa[i+1]
            updated = True
            i -= 10
            continue
        v = []
        if i+5 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
           len(aa[i+1]) == 2 and aa[i+1][0][0] == '.L' and\
           TCmp(aa[i+1][1], v, ('STORE', (('STORE_FAST', '?'),), (('CALC_CONST', '?'),))) and\
           aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
           aa[i+4] == (')ENDTRY',):
            aa[i:i+5] = aa[i+1]
            updated = True
            i -= 10
            continue

        v = []
        if i+5 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
           len(aa[i+1]) == 1 and aa[i+1][0] == ('PASS',) and\
           aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
           aa[i+4] == (')ENDTRY',):
            del aa[i:i+5] 
            updated = True
            i -= 10
            continue
        if i+7 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
           len(aa[i+1]) == 1 and aa[i+1][0][0] == '.L' and\
           aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
           aa[i+4] == (')(ELSE',) and type(aa[i+5]) is list and\
           aa[i+6] == (')ENDTRY',):

            aa[i:i+7] = aa[i+5]
            updated = True
            i -= 10
            continue
        if i+7 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
           len(aa[i+1]) == 1 and aa[i+1][0] == ('PASS',) and\
           aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
           aa[i+4] == (')(ELSE',) and type(aa[i+5]) is list and\
           aa[i+6] == (')ENDTRY',):
            aa[i:i+7] = aa[i+5]
            updated = True
            i -= 10
            continue

          
        if s == ('(TRY',):
            i1 = get_closed_pair(aa,i)
            stm = aa[i:i1+1]
            if stm[-3] == (')(FINALLY',):
                tr = stm[1]
                if len(stm) == 5:
                    aa[i:i1+1] = [('(TRY_FINALLY',), stm[1], (')(FINALLY',), stm[3], (')ENDTRY_FINALLY',)]
                    updated = True
                    i -= 10
                    continue
                if tr[0] == ('(TRY',) and get_closed_pair(stm[1],0)+1 == len(stm[1]):
                    old1 = aa[i+1]
                    new1 = stm[-2]
                    aa[i:i1+1] = [('(TRY_FINALLY',), old1, (')(FINALLY',), new1, (')ENDTRY_FINALLY',)]
                    updated = True
                    i -= 10
                    continue
                
                new1 = aa[i1-1]
                del aa[i1-2:i1-1]
                old1 = aa[i:i1-2]
                aa[i:i1-2] = [('(TRY_FINALLY',), old1, (')(FINALLY',), new1, (')ENDTRY_FINALLY',)]
                updated = True
                i -= 10
                continue
                

        v = []    
        if type(s) is tuple and len(s) > 1 and s[0] == '(IF' and s[1][0] == 'CONST':
            if TCmp(s, v, ('(IF', ('CONST', '?'), '?')):
                if not type(v[0]) is bool: # not in (True, False):
                    update_v_0_1(v)
                    aa[i] = ('(IF', ('CONST', v[0]), v[1])
                    updated = True
                    i -= 10
                    continue            
            v = []
            if TCmp(s, v, ('(IF', ('CONST', '?'))):
                if not type(v[0]) is bool: # not in (True, False):
                    update_v_0_1(v)
                    aa[i] = ('(IF', ('CONST', v[0]))
                    updated = True
                    i -= 10
                    continue            
            v = []        
                        
            if TCmp(s, v, ('(IF', ('CONST', False), '?')):
                if type(aa[i+1]) is list and TCmp(aa[i+2],v0, (')ENDIF',)):
                    del aa[i:i+3]
                    updated = True
                    i -= 10
                    continue
                if type(aa[i+1]) is list and \
                        TCmp(aa[i+2],v0, (')(ELSE',)) and type(aa[i+3]) is list and \
                        TCmp(aa[i+4],v0, (')ENDIF',)):
                    aa[i:i+5] = aa[i+3]
                    updated = True
                    i -= 10
                    continue 
                
            if TCmp(s, v, ('(IF', ('CONST', True), '?')):
                if type(aa[i+1]) is list and TCmp(aa[i+2],v0, (')ENDIF',)):
                    aa[i:i+3] = aa[i+1]
                    updated = True
                    i -= 10
                    continue
                    
                if type(aa[i+1]) is list and \
                        TCmp(aa[i+2],v0, (')(ELSE',)) and type(aa[i+3]) is list and \
                        TCmp(aa[i+4],v0, (')ENDIF',)):
                    aa[i:i+5] = aa[i+1]
                    updated = True
                    i -= 10
                    continue    
    
            if TCmp(s, v, ('(IF', ('CONST', False))):
                if type(aa[i+1]) is list and TCmp(aa[i+2],v0, (')ENDIF',)):
                    del aa[i:i+3]
                    updated = True
                    i -= 10
                    continue
                elif type(aa[i+1]) is list and \
                        TCmp(aa[i+2],v0, (')(ELSE',)) and type(aa[i+3]) is list and \
                        TCmp(aa[i+4],v0, (')ENDIF',)):
                    aa[i:i+5] = aa[i+3]
                    updated = True
                    i -= 10
                    continue            
            if TCmp(s, v, ('(IF', ('CONST', True))):
                if type(aa[i+1]) is list and TCmp(aa[i+2],v0, (')ENDIF',)):
                    aa[i:i+3] = aa[i+1]
                    updated = True
                    i -= 10
                    continue
                elif type(aa[i+1]) is list and \
                        TCmp(aa[i+2],v0, (')(ELSE',)) and type(aa[i+3]) is list and \
                        TCmp(aa[i+4],v0, (')ENDIF',)):
                    aa[i:i+5] = aa[i+1]
                    updated = True
                    i -= 10
                    continue 
        if i+4 < len(aa) and len(s) >= 2 and s[0] == '(IF':
            if type(aa[i+1]) is list and type(aa[i+3]) is list and \
               aa[i+2][0] == ')(ELSE' and aa[i+4][0] == ')ENDIF' and aa[i+1] == aa[i+3]:
                aa[i:i+5] = [('UNPUSH', s[1])] + aa[i+1] 
                updated = True
                i -= 10
                continue 
            v = []
            if i + 10 < len (aa) and \
                TCmp(s, v, ('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('FAST', '?')), \
                                                 ('CALC_CONST', '?'))))) and \
                aa[i+5][0] == '.L' and \
                aa[i+6] == ('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('FAST', v[0])), \
                                                 ('CALC_CONST', v[1])))) and \
                type(aa[i+1]) is list and type(aa[i+3]) is list and \
                aa[i+2][0] == ')(ELSE' and aa[i+4][0] == ')ENDIF' and \
                type(aa[i+7]) is list and type(aa[i+9]) is list and \
                aa[i+8][0] == ')(ELSE' and aa[i+10][0] == ')ENDIF':
                    l1 = aa[i+1] + [aa[i+5]] + aa[i+7]
                    l2 = aa[i+3] + [aa[i+5]] + aa[i+9]
                    if 'STORE_FAST' not in repr(l1) and 'STORE_FAST' not in repr(l2):
                        aa[i:i+11] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('FAST', v[0])), \
                                                    ('CALC_CONST', v[1])))),
                                                    l1,
                                                    (')(ELSE',),
                                                    l2,
                                                    (')ENDIF',)]
                        updated = True
                        i -= 10
                        continue 

                   
        if type(s) is tuple and len(s) > 0 and s[0] == 'RETURN_VALUE':
            if TCmp(s, v, ('RETURN_VALUE', \
                            ('!PyObject_Call', \
                                ('!LOAD_BUILTIN', 'setattr'), \
                                ('!BUILD_TUPLE', ('?', '?', '?')), \
                                ('NULL',)))):
                aa[i:i+1] = [('UNPUSH', s[1]), (s[0], ('CONST', None))]
                updated = True
                i -= 10
                continue
        if type(s) is tuple and len(s) == 3 and s[0] ==  'SEQ_ASSIGN':
            v = []
            if TCmp(s, v, ('SEQ_ASSIGN', (('STORE_FAST', '?'), '?'), '?')):
                if repr(('FAST', v[0])) not in repr(v[1]):
                    aa[i:i+1] = [('STORE', (s[1][0],), (s[2],)), ('STORE', (s[1][1],), (('FAST', v[0]),))]
                    updated = True
                    i -= 10
                    continue                    
        i += 1    
    if updated:
        if len(aa) == 0:
            return [('PASS',)]
        return aa
    return a           
       
is_inlined = False
def subroutine_inlined(nm, tupl):
    global is_inlined, inline_flag
    if is_inlined or not inline_flag:
        return None
##    return None
    co = N2C(nm)
    is_varargs = co.co_flags & 0x4 
    if co == current_co:
        return None
    if tupl[0] == '!BUILD_TUPLE':
        tupl = tupl[1]
    elif tupl[0] == 'CONST':
        tupl = [('CONST', x) for x in tupl[1]]
    else:
        return None   
    if co.cmds[1][-1][0] != 'RETURN_VALUE':
        pprint(('!! no return at last', co.cmds[1]))
        return None
    ## if not all([x[0] == 'CONST' or x[0] == 'FAST' or (x[0] == 'PY_TYPE' and x[3][0] == 'FAST' ) for x in tupl]): 
## #        pprint((nm, tupl, co.cmds[1]))
        ## return None
    if not is_varargs and nm in default_args:
        is_const_default = True
        defau = default_args[nm]
        if defau[0] != 'CONST':
            is_const_default = False
        if len(tupl) < co.co_argcount:
            if is_const_default:
                _refs2 = [('CONST', x) for x in defau[1]]
            else:
                _refs2 = [x for x in defau[1]]
            while (len(tupl) + len(_refs2) ) > co.co_argcount and len(_refs2) > 0:
                del _refs2[0]
            if (len(tupl) + len(_refs2) ) == co.co_argcount:
                tupl = list(tupl) + _refs2

    if len(tupl) == co.co_argcount and len(co.co_varnames) > co.co_argcount:
        co.strip_unused_fast()
                
    cmds = co.cmds[1]
##    pprint((co.co_name, cmds))
    if co.co_argcount == co.co_nlocals and \
       co.co_argcount == len(co.co_varnames): 
        if is_varargs:
##            print 'No inline - varargs', nm
            return None
        srepr = repr(cmds)
        if len(tupl) == co.co_argcount:
                expr = cmds

                d = {}
                for i in range(co.co_argcount):
                    ttu = tupl[i]
                    if ttu[0] == 'PY_TYPE':
                        ttu = ttu[3]
                    if ttu[0] == 'PY_TYPE':
                        ttu = ttu[3]
                    if srepr.count(repr(('FAST', co.co_varnames[i]))) > 1 and ttu[0] not in ('FAST', 'CONST'):
                        print 'No inline - have dangerous arg', ('FAST', co.co_varnames[i]), ttu, nm
                        d = None
                        break
                    elif repr(('STORE_FAST', co.co_varnames[i])) in srepr :
                        d = None
                        break
                    else:
                        d[co.co_varnames[i]] = tupl[i]
                if d is None:
                    return None
                expr = replace_fastvar(expr, d)
                if (len (repr(expr)) - len(repr(tupl))) > 1024:
                    print 'No inline - too big', nm
                    return None
                if len(expr) == 2 and expr[0][0] == '.L' and expr[1][0] == 'RETURN_VALUE':
                    return expr
                if len(expr) == 1 and expr[0][0] == 'RETURN_VALUE':
                    return expr 
                is_inlined = True
                expr1 = tree_pass_upgrade_repl(expr, None, '?') 
                expr = tree_pass_upgrade_repl(expr1,  None, '?') 
                is_inlined = False
                srepr = repr(expr)
                if 'CONTINUE' in srepr or 'BREAK' in srepr or 'RETURN_VALUE' in repr(expr[:-1]):
                    return None
                return expr
    return None    
       
def to_tuple_const(v):
    try:
        return ('CONST', tuple(v[0]))
    except:
        pass
    return None

def to_const_meth_1(obj, meth, args):
    try:
        meth = operator.methodcaller(meth, *args[1])
        v_s = meth(obj[2][1][0])
        if type(v_s) is list:
            v_s = [('CONST', x) for x in v_s]
            return ('!BUILD_LIST', tuple(v_s))
        assert type(v_s) != dict
        try:
            if len(v_s) > 5000:
                pass
            else:
                return ('CONST', v_s)
        except:
            return ('CONST', v_s)
    except:
        pass
    return None
           
def to_const_meth_2(obj, meth, args):
    try:
        meth = operator.methodcaller(meth, *args[1])
        v_s = meth(obj[1])
        if type(v_s) is list:
            v_s = [('CONST', x) for x in v_s]
            return ('!BUILD_LIST', tuple(v_s))
        assert type(v_s) != dict
        try:
            if len(v_s) > 5000:
                pass
            else:
                return ('CONST', v_s)
        except:
            return ('CONST', v_s)
    except:
        pass
    return None       

def cond_expr_module(t, ret):
    this,d2 = MyImport(t[1])
    return ret[2]

def if_expr_1(ret):
    try:
        if ret[0] == '(IF' and ret[1][0] == 'CONST' and ret[1][1]:
            ret = list(ret)
            ret[1] = ('CONST', True)
            return tuple(ret)
        if ret[0] == '(IF' and ret[1][0] == 'CONST' and not ret[1][1]:
            ret = list(ret)
            ret[1] = ('CONST', False)
            return tuple(ret)
    except:
        pass    
    return None
           
def calc_expr_1(op, v):
    try:
        if op == '!PyObject_Repr':
            return ('CONST', repr(v))
        elif op == '!PyObject_Str':
            return ('CONST', str(v))
        elif op == '!PyNumber_Negative':
            return ('CONST', - v)
        elif op == '!PyNumber_Float':
            return ('CONST', float(v))
        elif op == '!PyNumber_Int':
            return ('CONST', int(v))
        elif op == '!PyNumber_Long':
            return ('CONST', long(v))
        elif op == '!PyNumber_Positive':
            return ('CONST', + v)
        elif op == '!PyNumber_Absolute':
            return ('CONST', abs(v))
        elif op == '!PyNumber_Invert':
            return ('CONST', ~ v)
        elif op == '!PyObject_Str':
            return ('CONST', str(v))
        elif op in ('!ORD_BUILTIN', ):
            return ('CONST', ord(v))
        elif op in ('!CHR_BUILTIN', ):
            return ('CONST', chr(v))
        elif op == '!1NOT':
            return ('CONST', not v)
        elif op in len_family:
            return ('CONST', len(v))
        elif op == '!PY_SSIZE_T':
            ret = ('CONST', v)
        elif op == '!PyObject_Type':
            if v is not None:
                return ('!LOAD_BUILTIN', type_to_check_str[type(v)])
    except:
        pass    
    return None

def calc_pow_1(ret):
    try:
        return ('CONST', pow(ret[1][1],ret[2][1]))
    except:
        pass    
    return None
           
def calc_expr_2(op, v1, v2, ret):
    if type(v1) in (float, int) and type(v2) in (float, int):
        if op == '!PyNumber_Multiply':
            return ('CONST', v1 * v2)
        elif op == '!PyNumber_Divide':
            if v2 != 0:
                return ('CONST', v1 / v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_FloorDivide':
            if v2 != 0:
                return ('CONST', v1 // v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_Remainder':
            if type(v1) is int and v2 != 0:
                return ('CONST', v1 % v2)
            if type(v1) is float and v2 != 0:
                return ('CONST', v1 % v2)
            if type(v1) is int and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
            if type(v1) is float and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_Add':
            return ('CONST', v1 + v2)
        elif op == '!PyNumber_InPlaceAdd':
            return ('CONST', v1 + v2)
        elif op == '!PyNumber_Subtract':
            return ('CONST', v1 - v2)
        elif op == '!PyNumber_Lshift':
            return ('CONST', v1 << v2)
        elif op == '!PyNumber_Rshift':
            return ('CONST', v1 >> v2)
        elif op == '!PyNumber_Or':
            return ('CONST', v1 | v2)
        elif op == '!PyNumber_Xor':
            return ('CONST', v1 ^ v2)
        elif op == '!PyNumber_And':
            return ('CONST', v1 & v2)
        elif op == '!OR_JUMP':
            return ('CONST', v1 or v2)
        elif op == '!AND_JUMP':
            return ('CONST', v1 and v2)
        elif op in ('!CHR_BUILTIN', ):
            return ('CONST', chr(v1))
        elif op == '!_EQ_':
            return ('CONST', v1 == v2)
        elif op == '!_NEQ_':
            return ('CONST', v1 != v2)
        elif op == '!c_Py_GT_Int':
            return ('CONST', v1 > v2)
        elif op == '!c_Py_GE_Int':
            return ('CONST', v1 >= v2)
        elif op == '!c_Py_LT_Int':
            return ('CONST', v1 < v2)
        elif op == '!c_Py_LE_Int':
            return ('CONST', v1 <= v2)
        elif op == '!c_Py_EQ_Int':
            return ('CONST', v1 == v2)
        elif op == '!c_Py_NE_Int':
            return ('CONST', v1 != v2)
        else:
            pass #Debug('rre Constant op2 unhandled', ret)

    try:
        if op == '!PyNumber_Multiply':
            v_2 = ('CONST', v1 * v2)
            try:
                if len(v_2[1]) > 5000:
                    pass
                else:
                    return v_2
            except:
                return v_2               
        elif op == '!PyNumber_Divide':
            if v2 != 0:
                return ('CONST', v1 / v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_FloorDivide':
            if v2 != 0:
                return ('CONST', v1 // v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_Remainder':
            if type(v1) is int and v2 != 0:
                return ('CONST', v1 % v2)
            if type(v1) is float and v2 != 0:
                return ('CONST', v1 % v2)
            if type(v1) is str and len(v1 % v2) <= 255:
                return ('CONST', v1 % v2)
            if type(v1) is int and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
            if type(v1) is float and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!STR_CONCAT':
            ret = ('!STR_CONCAT', ('CONST', v1 + v2)) + ret[3:]
            if len(ret) == 2:
                return ret[1]
            else:
                return repl(ret)
        elif op == '!PyNumber_Add':
            return ('CONST', v1 + v2)
        elif op == '!PyNumber_InPlaceAdd':
            return ('CONST', v1 + v2)
        elif op == '!PyNumber_Subtract':
            return ('CONST', v1 - v2)
        elif op == '!PyNumber_Lshift':
            return ('CONST', v1 << v2)
        elif op == '!PyNumber_Rshift':
            return ('CONST', v1 >> v2)
        elif op == '!PyNumber_Or':
            return ('CONST', v1 | v2)
        elif op == '!PyNumber_Xor':
            return ('CONST', v1 ^ v2)
        elif op == '!PyNumber_And':
            return ('CONST', v1 & v2)
        elif op == '!OR_JUMP':
            return ('CONST', v1 or v2)
        elif op == '!AND_JUMP':
            return ('CONST', v1 and v2)
        elif op == '!PySequence_Repeat':
            ret2 = ('CONST', v2 * v1)
            if len(ret2[1]) > 5000:
                return ret 
            return ret2
        elif op == '!PyString_Format':
            return ('CONST', v1 % v2)
        elif op in ('!PySequence_Contains(', '!PySequence_Contains', '!_PyString_Contains'):
            return ('CONST', v2 in v1)
        elif op == '!PyObject_GetAttr' and v2 == 'join' and type(v1) is str:
            pass # _PyString_Join    
        elif op in ('!BINARY_SUBSCR_Int', '!from_ceval_BINARY_SUBSCR'):
            return ('CONST', v1[v2])
        elif op in ('!ORD_BUILTIN', ):
            return ('CONST', ord(v1))
        elif op in ('!CHR_BUILTIN', ):
            return ('CONST', chr(v1))
        elif op == '!_EQ_':
            return ('CONST', v1 == v2)
        elif op == '!_NEQ_':
            return ('CONST', v1 != v2)
        elif op == '!c_Py_GT_Int':
            return ('CONST', v1 > v2)
        elif op == '!c_Py_GE_Int':
            return ('CONST', v1 >= v2)
        elif op == '!c_Py_LT_Int':
            return ('CONST', v1 < v2)
        elif op == '!c_Py_LE_Int':
            return ('CONST', v1 <= v2)
        elif op == '!c_Py_EQ_Int':
            return ('CONST', v1 == v2)
        elif op == '!c_Py_NE_Int':
            return ('CONST', v1 != v2)
        else:
            pass #Debug('rre Constant op2 unhandled', ret)
    except:
        pass
    return None

def calc_expr_and(op, v1, ret):
    try:
        if v1:
            if len(ret) == 3:
                return ret[2]
            else:
                lret = list(ret)
                del lret[1]
                return tuple(lret)
        else:
            return ('CONST', False)
    except:
        return None
    
def calc_expr_or(op, v1, ret):
    try:
        if not v1:
            if len(ret) == 3:
                return ret[2]
            else:
                lret = list(ret)
                del lret[1]
                return tuple(lret)
        else: 
            return ('CONST', True)
    except:
        return None
    

def function_inlined(nm, tupl):
    expr = subroutine_inlined(nm, tupl)
    if expr is None:
        return None 
    
    srepr = repr(expr)            
    if len(expr) == 2 and expr[0][0] == '.L' and expr[1][0] == 'RETURN_VALUE':
        print '~~ inline call ', nm, len(srepr)
        return expr[1][1]
    if len(expr) == 1 and expr[0][0] == 'RETURN_VALUE':
        print '~~ inline call ', nm, len(srepr)
        return expr[0][1]
    if 'STORE' in srepr:
##        pprint(('?? inline func', nm, tupl))    
        print '!! STORE at inlined func', nm
        return None
    if 'DELETE' in srepr:
##        pprint(('?? inline func', nm, tupl))    
        print '!! DELETE at inlined func', nm
        return None
    if '(IF' in srepr:
##        pprint(('?? inline func', nm, tupl, expr))    
        print '!! IF at inlined func', nm
        return None
    if 'PRINT_ITEM' in srepr:
##        pprint(('?? inline func', nm, tupl))    
        print '!! PRINT_ITEM at inlined func', nm
        return None
    if expr[-1] == ('RETURN_VALUE', ('CONST', None)):
        print '!! procedure ', nm, tupl
        return None
    pprint(('!! undefined unsuccess inline func', nm, tupl, expr))
    return None

def call_calc_const(func, tupl, ret):
    co = N2C(func)
    if subroutine_can_be_direct(func, len(tupl[1])):
        add_direct_arg(func, tupl)
        inlined = function_inlined(func, tupl)
        if inlined is not None:
##            pprint(inlined)
            return inlined
        else:
            return ('!CALL_CALC_CONST', func, tupl)
    elif co.co_flags & 0x28 == 0 and co.co_flags == 0x43 and \
         len(co.co_cellvars) == 0 and len(co.co_freevars) == 0 and co.co_argcount == len(tupl[1]):
        return ('!CALL_CALC_CONST_INDIRECT', func, tupl)
    elif co.co_flags & CO_GENERATOR: # interpreted generator
        return ret
    else:
        Debug('Unfortunelly ', ret, hex(co.co_flags))
        return ret
       
def repl_if_expr(ret):
    updated = False
    li = []
    if ret[0] == '!AND_JUMP':
        for v in ret[1:]:
            if v[0] == '!BOOLEAN' and v[1][0] == '!AND_BOOLEAN':
                li.extend(v[1][1:])
                updated = True
            else:
                li.append(v)
        if updated:
            return ('!AND_JUMP',) + tuple(li)
    if ret[0] == '!OR_JUMP':
        for v in ret[1:]:
            if v[0] == '!BOOLEAN' and v[1][0] == '!OR_BOOLEAN':
                li.extend(v[1][1:])
                updated = True
            else:
                li.append(v)
        if updated:
            return ('!OR_JUMP',) + tuple(li)
    if ret[0] == '!BOOLEAN' and ret[1][0] == '!AND_BOOLEAN':
        return ('!AND_JUMP',) + tuple(ret[1][1:])
    if ret[0] == '!BOOLEAN' and ret[1][0] == '!OR_BOOLEAN':
        return ('!OR_JUMP',) + tuple(ret[1][1:])
        
    return None

def cond_meth_eq(a,b):
    if type(a) is tuple and type(b) is tuple and len(a) > 0 and len(b) > 0 \
       and a[0] == b[0] == '!COND_METH_EXPR' and \
       a[1] == b[1] and len(a[3]) == len(b[3]) and\
       all([ a[3][i][0] == b[3][i][0] for i in range(len(a[3]))]):
           return True
    return False
## ret, r0, v, methods, i, t, ret3, ret2, tupl, x, codemethnm, 
##_isnew, _arg, _ret, cl, slf, _v, tag, args, ret_tupl, v2, obj, 
##meth, t1, t2, ret_co, ret_modl, n1, n2, ret_n, pos, op, ret_ret, 
##v1, li, n, v0, v1_1, v1_2, der};
def repl(ret): ## can_be_codefunc
    if type(ret) is not tuple or len(ret) == 0:
        return ret
    assert type(ret) is tuple
    r0 = ret[0]
    if type(r0) is not str:
        return ret
    assert type(r0) is str
    v = [] 
    is_can_be_codefunc = bool(current_co.can_be_codefunc())
    if r0 in ('!AND_JUMP', '!OR_JUMP', '!AND_JUMPED_STACKED', '!OR_JUMPED_STACKED'):
        if cond_meth_eq(ret[1], ret[2]):
            methods = []
            if len(ret) == 3:
                for i in range(len(ret[1][3])):
                    methods.append((ret[2][3][i][0], (r0, ret[1][3][i][1], ret[2][3][i][1])  ))
                return ('!COND_METH_EXPR', ret[1][1], (r0, ret[1][2], ret[2][2]), tuple(methods))
            elif len(ret) == 4 and cond_meth_eq(ret[1], ret[3]):
                for i in range(len(ret[1][3])):
                    methods.append((ret[2][3][i][0], (r0, ret[1][3][i][1], ret[2][3][i][1], ret[3][3][i][1])  ))
                return ('!COND_METH_EXPR', ret[1][1], (r0, ret[1][2], ret[2][2], ret[3][2]), tuple(methods))
            elif len(ret) == 5 and cond_meth_eq(ret[1], ret[3]) and cond_meth_eq(ret[1], ret[4]):
                for i in range(len(ret[1][3])):
                    methods.append((ret[2][3][i][0], (r0, ret[1][3][i][1], ret[2][3][i][1], ret[3][3][i][1], ret[4][3][i][1])   ))
                return ('!COND_METH_EXPR', ret[1][1], (r0, ret[1][2], ret[2][2], ret[3][2], ret[4][2]), tuple(methods))
        elif len(ret) == 4 and cond_meth_eq(ret[2], ret[3]) and ret[1][0] != '!COND_METH_EXPR':
            methods = []
            for i in range(len(ret[2][3])):
                methods.append((ret[2][3][i][0], (r0, ret[1], ret[2][3][i][1], ret[3][3][i][1])  ))
            return ('!COND_METH_EXPR', ret[2][1], (r0, ret[1], ret[2][2], ret[3][2]), tuple(methods))
        elif r0 == '!AND_JUMP':
            li = []
            _updated = False
            for x in ret[1:]:
                if x[0] == '!BOOLEAN' and x[1][0] == '!AND_BOOLEAN':
                    y = x[1]
                    if len(y) == 3 and y[1][0] == '!BOOLEAN'  and y[2][0] == '!BOOLEAN':
                        li.append(y[1][1])
                        li.append(y[2][1])
                        _updated = True
                        continue
                li.append(x)
            if _updated:
                return (r0,) + tuple(li)
    if len(ret) >= 1 and type(r0) is str:
        if is_can_be_codefunc and len(ret) == 4 and \
           r0 == '!PyObject_Call' and ret[3] == ('NULL',) and \
           TCmp(ret[1:-1], v, (('CALC_CONST', '?'), ('CONST', '?'))) :
                t = None
                if type(v[0]) is tuple and len(v[0]) == 2:
                    t = (Val3(v[0][0], 'ImportedM'), v[0][1])
                else:
                    t = Val3(v[0], 'ImportedM')
                if type(t) is tuple and len(t) == 2 and t[0] == 'math':
                    return attempt_calc_constant_math(t[1], ret, v[1]) #sqrt
        if r0 == '!PyBool_Type.tp_new' and ret[1] == '&PyBool_Type' and \
           ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1 and \
           ret[2][1][0][0] == '!OR_JUMPED_STACKED':
               return ('!BOOLEAN', ('!OR_BOOLEAN',) + ret[2][1][0][1:])
        if r0 == '!PyBool_Type.tp_new' and ret[1] == '&PyBool_Type' and \
           ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1 and \
           ret[2][1][0][0] == '!AND_JUMPED_STACKED':
               return ('!BOOLEAN', ('!AND_BOOLEAN',) + ret[2][1][0][1:])
        v = []
        if r0 == '!_PyEval_ApplySlice':
            if ret[2][0] == 'CONST' and ret[3][0] == 'CONST' and \
                type(ret[2][1]) is int and type(ret[3][1]) is int:
                        return ('!PySequence_GetSlice', ret[1], ret[2][1], ret[3][1])
        elif r0 == '!PySequence_Contains(':
            if TCmp(ret, v, ('!PySequence_Contains(', '?', '?')) and IsStr(TypeExpr(v[1])) and IsStr(TypeExpr(v[0])) and not is_pypy:
                return ('!_PyString_Contains', v[0], v[1])
        elif r0 == '!PySequence_GetSlice':
            if TCmp(ret, v, ('!PySequence_GetSlice', ('CONST', '?'), \
                              int, 'PY_SSIZE_T_MAX')):
                return ('CONST', v[0][v[1]:])
            t = TypeExpr(ret[1])
            if IsList(t):
                ret3 = ret[3]
                ret2 = ret[2]
                if (type(ret2) is not int or type(ret3) is not int) and \
                    ret2 != 'PY_SSIZE_T_MAX' and ret3 != 'PY_SSIZE_T_MAX':
                    Fatal('Strange slice arg', ret)
                return ('!PyList_GetSlice', ret[1], ret2, ret3)
            if IsTuple(t):
                return ('!PyTuple_GetSlice', ret[1], ret[2], ret[3])
        elif r0 == '!AND_JUMPED_STACKED':
            isbool = True
            for tupl in ret[1:]:
                isbool = isbool and IsBool(TypeExpr(tupl))
            if isbool:
                ret1 = ('!AND_BOOLEAN',) + ret[1:]
                return ('!BOOLEAN', ret1)
            else:
                Debug('Not Is bool', ret, [TypeExpr(x) for x in ret[1:]])
            v = []
            if TCmp(ret, v, ('!AND_JUMPED_STACKED', ('!BOOLEAN', '?' ), '?' )):
                return ('!COND_EXPR', ('!BOOLEAN', v[0]), v[1], ('CONST', False))
        elif r0 == '!OR_JUMPED_STACKED':
            isbool = True
            for tupl in ret[1:]:
                isbool = isbool and IsBool(TypeExpr(tupl))
            if isbool:
                ret1 = ('!OR_BOOLEAN',) + ret[1:]
                return ('!BOOLEAN', ret1)
            else:
                Debug('Not Is bool', ret, [TypeExpr(x) for x in ret[1:]])
            v = []    
            if TCmp(ret, v, ('!OR_JUMPED_STACKED', ('!BOOLEAN', '?' ), '?' )):
                return ('!COND_EXPR', ('!BOOLEAN', v[0]), ('CONST', True), v[1])

        if r0 == '(FOR' and len(ret) == 3 and ret[2][0] == '!BUILD_LIST' and all([x[0] == 'CONST' for x in ret[2][1]]):
            return (r0, ret[1], ('CONST', tuple([x[1] for x in ret[2][1]])))
        if r0 == '!PySequence_Contains(' and len(ret) == 3:
            if ret[1][0] == '!BUILD_LIST' and all([x[0] == 'CONST' for x in ret[1][1]]):
                return (r0, ('CONST', tuple([x[1] for x in ret[1][1]])), ret[2])
            if TCmp(ret, v, ('!PySequence_Contains(', '?', '?')):
                t =  TypeExpr(ret[1])
                if IsDict(t):
                    return ('!PyDict_Contains', ret[1], ret[2])
                elif t == Kl_Set:
                    return ('!PySet_Contains', ret[1], ret[2])
                v = []
                if TCmp(ret, v, ('!PySequence_Contains(', ('!BUILD_TUPLE', '?'),  '?')) and \
                    type(v[0]) is tuple:
                        if len(v[0]) == 1:
                            return ('!PyObject_RichCompare(', v[0][0],  v[1], 'Py_EQ')
                        return ('!OR_BOOLEAN',) + \
                            tuple([('!PyObject_RichCompare(', x,  v[1], 'Py_EQ') for x in v[0]])
    
        
        if r0 == '!PySequence_Tuple':
            t = TypeExpr(ret[1])
            if IsTuple(t):
                return ret[1]
            if IsList(t):
                if ret[1][0] == '!BUILD_LIST':
                    return TupleFromArgs(ret[1][1])                    
                return ('!PyList_AsTuple', ret[1])
        if build_executable and (ret == ('!LOAD_GLOBAL', '__name__') or ret == ('!LOAD_NAME', '__name__')):
            return ('CONST', '__main__')
        if r0 == '!IMPORT_NAME':
            CheckExistListImport(dotted_name_to_first_name(ret[1]))   
        elif r0 == 'IMPORT_FROM_AS':
            CheckExistListImport(ret[1], ret[3][1], ret[2][1])   
        if r0 == '!PyObject_Str':
            if len(ret) == 2:
                t = TypeExpr(ret[1])
                if IsInt(t):
                    return ('!PyInt_Type.tp_str', ret[1])   
                if t is not None and t[0] in (T_NEW_CL_INST, T_OLD_CL_INST) and \
                   IsMethod(t[1], '__str__'):
                    codemethnm = ValMethod(t[1], '__str__')
                    tupl = ('!BUILD_TUPLE', (ret[1],))
                    return call_calc_const(codemethnm, tupl, ret)
        if r0 == '!PyInt_Type.tp_str' and ret[1][0] == '!PyNumber_Int' and \
           ret[1][1][0] == 'PY_TYPE' and ret[1][1][1] == bool:
               return ('!COND_EXPR', ret[1][1], ('CONST', '1'), ('CONST', '0'))
        if r0 == '!PyNumber_Remainder' and len(ret) == 3:
            t = TypeExpr(ret[1])
            if IsStr(t):
                return ('!PyString_Format', ret[1], ret[2])
        if r0 == '!PyObject_Repr':
            if IsInt(TypeExpr(ret[1])) and not is_pypy:
                return ('!_PyInt_Format', ret[1], 10, 0)            
        if len(ret) == 2 and r0 == 'CONST' and type(ret[1]) == type:
            if ret[1] in d_built_inv:
                return ('!LOAD_BUILTIN', d_built_inv[ret[1]])
            else:
                Fatal ('???', ret, type(ret[1]))
                return ret    
        if r0 == '!PyObject_RichCompare(' and\
           TCmp(ret,v, ('!PyObject_RichCompare(', \
                        ('!COND_EXPR', '?', '?', '?'), \
                        ('CONST', '?'), '?')):
            if v[1] != v[2]:
                return ('!COND_EXPR', v[0], ('!PyObject_RichCompare(', v[1], ('CONST', v[3]), v[4]),\
                                           ('!PyObject_RichCompare(', v[2], ('CONST', v[3]), v[4]))

        if direct_call and is_can_be_codefunc:
            v = []

            if r0 == '!PyObject_Call' and \
               TCmp(ret, v, ('!PyObject_Call', ('!MK_FUNK', '?', ('CONST', ())), \
                    ('!BUILD_TUPLE', '?'), ('NULL',))):
                return call_calc_const(v[0], ('!BUILD_TUPLE', v[1]), ret)               
            if r0 == '!COND_METH_EXPR' and ret[2][0] == '!CALL_CALC_CONST':
                return ret[2]
            if r0 == '!COND_METH_EXPR' and ret[2][0] == '!CALL_CALC_CONST_INDIRECT':
                return ret[2]
            if r0 == '!COND_METH_EXPR' and ret[1][0] == 'PY_TYPE':
                _isnew = None
                if ret[1][1] == 'OldClassInstance':
                    _isnew = False
                elif ret[1][1] == 'NewClassInstance':
                    _isnew = True
                    ## re3 = ret[3]
                else:
                    _isnew = None    
                if _isnew == None:
                    return ret[2]
##                pprint(ret[3])
                for _arg, _ret in ret[3]: ###isnew, cl, bas, _ret in ret[3]: 
                    cl = _arg[1]
                    isnew = _arg[0] == T_NEW_CL_INST
                    if isnew == _isnew and cl == ret[1][2]:
                        return _ret
                return ret[2]

            if r0 == '!COND_EXPR' and ret[2] == ret[3] and\
               ret[2][0] == '!CALL_CALC_CONST' and \
               TCmp(ret[1], v, ('!_EQ_', ('!PyObject_Type', ('PY_TYPE', '?', '?', '?', None)), \
                                ('CALC_CONST', '?'))) and\
               v[1] == v[3]:
                   return ret[2]
            elif r0 == '!COND_EXPR' and ret[2] == ret[3] and\
               ret[2][0] == '!CALL_CALC_CONST' and \
               TCmp(ret[1], v, ('!BOOLEAN', ('!PyObject_IsInstance', \
                                             ('PY_TYPE', '?', '?', '?', None), \
                                             ('CALC_CONST', '?')))) and\
               v[1] == v[3]:
                   return ret[2]                   
            elif r0 == '!CLASS_CALC_CONST' and is_can_be_codefunc:
                if TCmp(ret, v, ('!CLASS_CALC_CONST', '?', ('!BUILD_TUPLE', '?'))):
                    if IsMethod(v[0], '__init__'):
                        if subroutine_can_be_direct(CodeInit(v[0]),\
                                                len(v[1]) +1):
                            slf = ('PY_TYPE', T_OLD_CL_INST, v[0], ('PSEVDO', 'self'), None)
                            add_direct_arg(CodeInit(v[0]), ('!BUILD_TUPLE', (slf,) +v[1]))
                            return ('!CLASS_CALC_CONST_DIRECT', v[0], \
                                CodeInit(v[0]), ('!BUILD_TUPLE', v[1]))
                elif TCmp(ret, v, ('!CLASS_CALC_CONST', '?', ('CONST', '?'))):
                    if IsMethod(v[0], '__init__'):
                        if subroutine_can_be_direct(CodeInit(v[0]), len(v[1])+1):
                            slf = ('PY_TYPE', T_OLD_CL_INST, v[0], ('PSEVDO', 'self'), None)
                            add_direct_arg(CodeInit(v[0]), ('!BUILD_TUPLE', (slf,) + tuple([('CONST', x) for x in v[1]])))
                            return ('!CLASS_CALC_CONST_DIRECT', v[0], \
                                CodeInit(v[0]), ('CONST', v[1]))

        if r0 == '!PyObject_Call':
            _v = []
            if TCmp(ret, _v, ('!PyObject_Call', ('!LOAD_BUILTIN', '?'), '?', ('NULL',))):
                tag,args = _v[0], _v[1]
                v = []    
                if tag == 'apply' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))):
                    return ('!PyObject_Call', v[0] , v[1], ('NULL',))
                elif tag == 'apply' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?', '?'))):
                    return ('!PyObject_Call', v[0] , v[1], v[2])
                elif tag == 'getattr' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))):
                    return ('!PyObject_GetAttr', v[0], v[1])
                elif tag == 'getattr' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?', '?'))):
                    return ('!PyObject_GetAttr3', v[0], v[1], v[2])
                elif tag == 'dict' and args == ('CONST', ()):
                    return ('!PyDict_New', )
                elif tag == 'slice' and TCmp(args, v, ('!BUILD_TUPLE', '?')):
                    if len(v[0]) == 3:                  
                        return ('!PySlice_New', v[0][0], v[0][1], v[0][2])
                    elif len(v[0]) == 2:                  
                        return ('!PySlice_New', v[0][0], v[0][1], 'NULL')
                    elif len(v[0]) == 1:                  
                        return ('!PySlice_New', 'NULL', v[0][0], 'NULL')
                    else:
                        Fatal('Strange arg Slice', ret)
                elif tag == 'slice' and TCmp(args, v, ('CONST', '?')):
                    if len(v[0]) == 3:                  
                        return ('!PySlice_New', ('CONST', v[0][0]), ('CONST', v[0][1]), ('CONST', v[0][2]))
                    elif len(v[0]) == 2:                  
                        return ('!PySlice_New', ('CONST', v[0][0]), ('CONST', v[0][1]), 'NULL')
                    elif len(v[0]) == 1:                  
                        return ('!PySlice_New', 'NULL', ('CONST', v[0][0]), 'NULL')
                    else:
                        Fatal('Strange arg Slice', ret)
                elif tag == 'tuple' and TCmp(args, v, ('CONST', '?')):
                    ret_tupl = to_tuple_const(v)
                    if ret_tupl is not None:
                        return ret_tupl
                elif tag == 'callable':
                    if args[0] == '!BUILD_TUPLE' and TypeExpr(args[1][0]) is not None:
                        Debug('callable, ', TypeExpr(args[1][0]))
                        Debug(args)
                elif tag == 'list' and args == ('CONST', ()):  
                    return ('!BUILD_LIST', ())    
            _v = []
            if direct_call and is_can_be_codefunc:
                if  \
                   r0 == '!PyObject_Call' and ret[1][0] == '!PyObject_GetAttr':
                    if ret[2][0] == '!BUILD_TUPLE' and TCmp(ret, v, \
                        ('!PyObject_Call',  
                            ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))):
                        t = TypeExpr(v[0])
                        if t is not None and type(t[1]) is str and IsMethod(t[1], v[1]):
                            classmeth = Is3(t[1], ('ClassMethod', v[1]))
                            staticmeth = Is3(t[1], ('StaticMethod', v[1]))
                            codemethnm = ValMethod(t[1], v[1])
                            isoldclass = t[1] in calc_const_old_class
                            isnewclass = t[1] in calc_const_new_class
                            if is_old_class_inst(t) and isoldclass and not isnewclass:
                                if classmeth:
                                    Debug('No direct call of class method', ret)
                                elif staticmeth:
                                    tupl = ('!BUILD_TUPLE', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:                        
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                            elif is_old_class_typ(t) and isoldclass and not isnewclass:
                                if classmeth:
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                elif staticmeth:
                                    tupl = ('!BUILD_TUPLE', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:                        
                                    tupl = ('!BUILD_TUPLE', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                
                            elif is_new_class_inst(t) and isnewclass and not isoldclass:
                                if classmeth:
                                    Debug('No direct call of class method', ret)
                                elif staticmeth:
                                    tupl = ('!BUILD_TUPLE', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:                        
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                            elif is_new_class_typ(t) and isnewclass and not isoldclass:
                                if classmeth:
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                elif staticmeth:
                                    tupl = ('!BUILD_TUPLE', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:                        
                                    tupl = ('!BUILD_TUPLE', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
        
                    if ret[2][0] == 'CONST' and TCmp(ret, v, \
                        ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))):
                        t = TypeExpr(v[0])
                        if t is not None and type(t[1]) is str and IsMethod(t[1], v[1]):
                            classmeth = Is3(t[1], ('ClassMethod', v[1]))
                            staticmeth = Is3(t[1], ('StaticMethod', v[1]))
                            codemethnm = ValMethod(t[1], v[1])
                            isoldclass = t[1] in calc_const_old_class
                            isnewclass = t[1] in calc_const_new_class
                            if is_old_class_inst(t) and isoldclass and not isnewclass:
                                if classmeth:
                                    Debug('No direct call of class method', ret)
                                elif staticmeth:
                                    tupl = ('CONST', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:    
                                    v2 = tuple([('CONST', x) for x in v[2]])
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v2)
                                    return call_calc_const(codemethnm, tupl, ret)
            
                            elif is_old_class_typ(t) and isoldclass and not isnewclass:
                                if classmeth:
                                    Debug('No direct call of class method', ret)
                                elif staticmeth:
                                    tupl = ('CONST', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:    
                                    v2 = tuple([('CONST', x) for x in v[2]])
                                    tupl = ('CONST', v2)
                                    return call_calc_const(codemethnm, tupl, ret)
                            
                            elif is_new_class_inst(t) and isnewclass and not isoldclass:
                                if classmeth:
                                    Debug('No direct call of class method', ret)
                                elif staticmeth:
                                    tupl = ('CONST', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:    
                                    v2 = tuple([('CONST', x) for x in v[2]])
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v2)
                                    return call_calc_const(codemethnm, tupl, ret)
            
                            elif is_new_class_typ(t) and isnewclass and not isoldclass:
                                if classmeth:
                                    tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                                    return call_calc_const(codemethnm, tupl, ret) 
                                elif staticmeth:
                                    tupl = ('CONST', v[2])
                                    return call_calc_const(codemethnm, tupl, ret)
                                else:    
                                    v2 = tuple([('CONST', x) for x in v[2]])
                                    tupl = ('CONST', v2)
                                    return call_calc_const(codemethnm, tupl, ret)
            _v = []
            v = []
            if  \
               r0 == '!PyObject_Call' and ret[1][0] == '!PyObject_GetAttr' and ret[1][2][0] == 'CONST':
                if TCmp(ret, _v, ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', ('NULL',))):
                    obj, meth, args = _v
                    t = TypeExpr(obj)
                    if IsListAll(t):
                        if meth == 'pop':
                            if TCmp(args, v, ('CONST', ('?',))):
                                return ('!_PyList_Pop', obj, ('CONST', v[0]))
                            elif TCmp(args, v, ('CONST', ())):
                                return ('!_PyList_Pop', obj)
                            elif TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                                return ('!_PyList_Pop', obj, v[0])
                        elif meth == 'len' and args == ('CONST', ()) :
                            return ('!PY_SSIZE_T', ('!PyList_GET_SIZE', obj))
                        elif meth == 'extend' and not is_pypy:
                            v2 = []
                            if TCmp(args, v2, ('!BUILD_TUPLE', ('?',))):
                                return ('!_PyList_Extend', obj, v2[0])
                    elif IsStr(t):
                        if meth == 'startswith' and TCmp(args, v, ('CONST', ('?',))) and\
                            type(v[0]) is str:
                            return ('!_PyString_StartSwith', obj, ('CONST', v[0]))
                        if meth == 'endswith' and TCmp(args, v, ('CONST', ('?',))) and\
                            type(v[0]) is str:
                            return ('!_PyString_EndSwith', obj, ('CONST', v[0]))
                        if meth == 'find':
                            if TCmp(args, v, ('CONST', ('?',))) and type(v[0]) is str:
                                return ('!_PyString_Find', obj, ('CONST', v[0]))
                            if TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and IsStr(TypeExpr(v[0])):
                                return ('!_PyString_Find', obj,  v[0])
                        if meth == 'rfind':
                            if TCmp(args, v, ('CONST', ('?',))) and type(v[0]) is str:
                                return ('!_PyString_RFind', obj, ('CONST', v[0]))
                            if TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and IsStr(TypeExpr(v[0])):
                                return ('!_PyString_RFind', obj,  v[0])


                        if meth == 'index' and TCmp(args, v, ('CONST', ('?',))) and\
                            type(v[0]) is str:
                            return ('!_PyString_Index', obj, ('CONST', v[0]))
                        if meth == 'rindex' and TCmp(args, v, ('CONST', ('?',))) and\
                            type(v[0]) is str:
                            return ('!_PyString_RIndex', obj, ('CONST', v[0]))                        

                        if meth == 'index' and TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and\
                            IsStr(TypeExpr(v[0])):
                            return ('!_PyString_Index', obj, v[0])
                        if meth == 'rindex' and TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and\
                            IsStr(TypeExpr(v[0])):
                            return ('!_PyString_RIndex', obj,  v[0])   
                        if meth in ('isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper'):
                            if TCmp(args, v, ('CONST', ())):
                                return ('!_PyString_ctype', obj, meth)


                    elif IsDict(t):
                        if meth == 'copy':
                            if TCmp(args, v, ('CONST', ())):
                                return ('!PyDict_Copy', obj)
                        elif meth == 'get':
                            if TCmp(args, v, ('!BUILD_TUPLE', ('?','?'))):
                                return ('!_PyDict_Get', obj, v[0], v[1])
                            elif TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                                return ('!_PyDict_Get', obj, v[0], ('CONST', None))
                            elif TCmp(args, v, ('CONST', ('?','?'))):
                                return ('!_PyDict_Get', obj, ('CONST',v[0]), ('CONST', v[1]))
                            elif TCmp(args, v, ('CONST', ('?',))):
                                return ('!_PyDict_Get', obj, ('CONST',v[0]), ('CONST', None))
                        elif meth == 'has_key':
                            if TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                                return ('!BOOLEAN', ('!PyDict_Contains', obj, v[0]))
                            elif TCmp(args, v, ('CONST', ('?',))):
                                return ('!BOOLEAN', ('!PyDict_Contains', obj, ('CONST', v[0])))
                        elif meth == 'keys' and args == ('CONST', ()) :
                            return ('!PyDict_Keys', obj)
                        elif meth == 'values' and args == ('CONST', ()) :
                            return ('!PyDict_Values', obj)
                        elif meth == 'items' and args == ('CONST', ()) :
                            return ('!PyDict_Items', obj)
                        elif meth == 'len' and args == ('CONST', ()) :
                            return ('!PY_SSIZE_T', ('!PyDict_Size', obj))
    # TypeError: 'int' object is not iterable !!!!!!!!
                    if len(obj) == 4 and obj[-1] == 'NULL' and obj[1][0] == '&' and \
                            obj[0].endswith('.tp_new') and obj[0][0] == '!' and \
                            obj[0][1:-7] == obj[1][1:] and obj[2][0] == 'CONST' and\
                            len(obj[2][1]) == 1:
                        t1 = TypeExpr(obj)
                        t2 = TypeExpr(('CONST', obj[2][1][0]))
                        if t1 == t2 and t1 is not None:
                                if args[0] == 'CONST':
                                    ret_co = to_const_meth_1(obj, meth, args)
                                    if ret_co is not None:
                                        return ret_co
                    if obj[0] == 'CONST':
                        if args[0] == 'CONST':
                            ret_co = to_const_meth_2(obj, meth, args)
                            if ret_co is not None:
                                return ret_co
                        else:
                            Debug('Call const meth', obj, meth, args)
    
    
        if ret == ('!BOOLEAN', ('CONST', True)):
            return ('CONST', True)
        if ret == ('!BOOLEAN', ('CONST', False)):
            return ('CONST', False)
    
        v = []
        if r0 == '!COND_EXPR' and TCmp(ret,v, ('!COND_EXPR', ('CALC_CONST', '?'), '?', '?')):
            t = TypeExpr(ret[1])
            if t is not None and t[0] is types.ModuleType and t[1] is not None:
                ret_modl = cond_expr_module(t, ret)
                if ret_modl is not None:
                    return ret_modl
    
    
        if r0 == 'PY_TYPE':
            if ret[3][0] == 'CONST':
                return ret[3]
            v = []
            if TCmp(ret, v, ( 'PY_TYPE', '?', '?', ('PY_TYPE', '?', '?', '?', None), None)) and v[0] == v[2] and v[1] == v[3]:
                return ('PY_TYPE', v[0], v[1], v[4], None)
            v = []
            if TCmp(ret, v, ('PY_TYPE', '?', None, ('!PyNumber_Add', '?', '?'), '?')) and v[0] is int:
                n1 = v[1]
                n2 = v[2]
                t = v[3]
                if n1[0] not in ('PY_TYPE', 'CONST'):
                    n1 = ('PY_TYPE', int, None, n1, t)
                if n2[0] not in ('PY_TYPE', 'CONST'):
                    n2 = ('PY_TYPE', int, None, n2, t)
                return ('PY_TYPE', int, None, ('!PyNumber_Add', n1, n2), t)
            if TCmp(ret, v, ('PY_TYPE', '?', None, ('!PyNumber_Subtract', '?', '?'), '?')) and v[0] is int:
                n1 = v[1]
                n2 = v[2]
                t = v[3]
                if n1[0] not in ('PY_TYPE', 'CONST'):
                    n1 = ('PY_TYPE', int, None, n1, t)
                if n2[0] not in ('PY_TYPE', 'CONST'):
                    n2 = ('PY_TYPE', int, None, n2, t)
                return ('PY_TYPE', int, None, ('!PyNumber_Subtract', n1, n2), t)
            if TCmp(ret, v, ('PY_TYPE', '?', None, ('!PyNumber_Negative', '?'), '?')) and v[0] is int:
                n1 = v[1]
                t = v[2]
                if n1[0] not in ('PY_TYPE', 'CONST'):
                    n1 = ('PY_TYPE', int, None, n1, t)
                return ('PY_TYPE', int, None, ('!PyNumber_Negative', n1), t)
        v = []    
        if len(ret) >= 2 and r0 == '(IF':
            ret_n = repl_if_expr(ret[1])
            if ret_n is not None:
                return ('(IF', ret_n)
            ret_n = if_expr_1(ret)
            if ret_n is not None:
                return ret_n
        v = []
        if r0 == '!BINARY_SUBSCR_Int' and ret[1][0] == '!BUILD_LIST' and \
           TCmp(ret, v, \
            ('!BINARY_SUBSCR_Int', ('!BUILD_LIST', '?'), ('CONST', int))):
                pos = v[1]
                if pos < 0:
                    pos = pos + len(v[0])
                if pos < len(v[0]):    
                    return v[0][v[1]]
    
        v = []    
        if r0 == '!c_Py_EQ_String' and \
                TCmp(ret, v, ('!c_Py_EQ_String', ('CONST', '?'), ('CONST', '?'))):
            return ('CONST', v[0] == v[1])    
        if r0 == '!c_Py_NE_String' and \
                TCmp(ret, v, ('!c_Py_NE_String', ('CONST', '?'), ('CONST', '?'))):
            return ('CONST', v[0] != v[1])    
        v = []    
        if len(ret) == 2 and  \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST':
            op, v = r0, ret[1][1]
            ret_ret = calc_expr_1(op, v)
            if ret_ret is not None:
                return ret_ret
        v = []    
        if len(ret) == 4 and  \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST' and \
            type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == 'CONST' and\
            ret[3] == 'Py_None':
            if r0 == '!PyNumber_Power':
                ret_ret = calc_pow_1(ret)
                if ret_ret is not None:
                    return ret_ret
        v = []    
        if len(ret) == 3 and     \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST' and \
            type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == 'CONST':
            op, v1, v2 = r0, ret[1][1], ret[2][1]
            ret_ret = calc_expr_2(op, v1, v2, ret)
            if ret_ret is not None:
                return ret_ret
   
        if len(ret) == 3 and     r0 == '!_EQ_' and \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == '!LOAD_BUILTIN' and \
            type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                return ('CONST', ret[1][1] == ret[2][1])
        if len(ret) == 3 and     r0 == '!_NEQ_' and \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == '!LOAD_BUILTIN' and \
            type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                return ('CONST', ret[1][1] != ret[2][1])

        if len(ret) == 3 and     r0 == '!_EQ_' and \
            type(ret[1]) is tuple and len(ret[1]) >= 2 and ret[1][0] == '!PyObject_Type' and \
            len(ret[1][1]) == 5 and type(ret[1][1][0]) is str and ret[1][1][0] == 'PY_TYPE' and \
            ret[1][1][1] in type_to_check_str and \
            type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                return ('CONST', type_to_check_str[ret[1][1][1]] == ret[2][1])
            
        if len(ret) == 3 and     r0 == '!_NEQ_' and \
            type(ret[1]) is tuple and len(ret[1]) >= 2 and ret[1][0] == '!PyObject_Type' and \
            len(ret[1][1]) == 5 and type(ret[1][1][0]) is str and ret[1][1][0] == 'PY_TYPE' and \
            ret[1][1][1] in type_to_check_str and \
            type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                return ('CONST', type_to_check_str[ret[1][1][1]] != ret[2][1])

        v = []    
        if len(ret) >= 3 and  (r0 == '!AND_BOOLEAN' or r0  == '!AND_JUMP') and \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST':
            op, v1 = r0, ret[1][1]
            ret_ret = calc_expr_and(op, v1, ret)
            if ret_ret is not None:
                return ret_ret
        v = []    
        if len(ret) >= 3 and  (r0 == '!OR_BOOLEAN' or r0  == '!OR_JUMP') and \
            type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST':
            op, v1 = r0, ret[1][1]
            ret_ret = calc_expr_or(op, v1, ret)
            if ret_ret is not None:
                return ret_ret
                        
        if r0 == '!PyNumber_Divide' and \
                TCmp(ret, v, ('!PyNumber_Divide', '?', ('CONST', 0))):
            return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"), v[0])    
        v = []
        if r0 == '!PySequence_Repeat' and \
                TCmp(ret, v, ('!PySequence_Repeat', \
                              ('!BUILD_LIST', (('CONST', '?'),)), \
                              ('CONST', int))) and v[1] >= 0 and v[1] < 256:
            return ('!BUILD_LIST', (('CONST', v[0]),) * v[1]) 
        v = []
        if r0 == 'UNPUSH':
            if TCmp(ret, v, ('UNPUSH', ('!PyObject_Call', 
                                ('?', 'setattr'),
                                ('!BUILD_TUPLE', ('?', '?', '?')), ('NULL',)))):
                if v[0] == '!LOAD_BUILTIN':
                    return ('STORE', (('PyObject_SetAttr', v[1], v[2]),), (v[3],))
                elif v[0] in ('!LOAD_GLOBAL', '!LOAD_NAME', '!PyDict_GetItem(glob,'):
                    return ('STORE', (('?PyObject_SetAttr', v[1], v[2], (v[0], 'setattr')),), (v[3],))
                else:
                    return ret 
    
        v = []
        if r0 == '!PyNumber_InPlaceAdd' and \
                TCmp(ret, v, ('!PyNumber_InPlaceAdd', '?', '?')):
            t1 = TypeExpr(v[0])
            t2 = TypeExpr(v[1])        
            if IsStr(t1) and IsStr(t2):
                if v[0][0] == v[1][0] == 'CONST':
                    return ('CONST', v[0][1] + v[1][1])
                return ('!STR_CONCAT', v[0], v[1])
        v = []
        if r0 == '!STR_CONCAT':
            li = list(ret[1:])
            upd = False
            for i, v in enumerate(li):
                if v[0] == '!STR_CONCAT':
                    li[i:i+1] = list(v[1:])
                    upd = True
            i = 0
            while i+1 < len(li):
                if li[i][0] == 'CONST' and li[i+1][0] == 'CONST' and type(li[i][1]) is str and type(li[i+1][1]) is str:
                    li[i] = ('CONST', li[i][1] + li[i+1][1])
                    del li[i+1]
                    upd = True
                    continue
                i += 1
            if len(li) == 1 and li[0][0] == 'CONST':
                return li[0]    
            if upd:
                return ('!STR_CONCAT',) + tuple(li)    
            if ret[1][0] == '!STR_CONCAT':
                return ('!STR_CONCAT',) + ret[1][1:] + ret[2:]
            if len(ret) >= 3 and ret[1][0] == 'CONST' and type(ret[1][1]) is str and ret[2][0] == '!STR_CONCAT':
                return ('!STR_CONCAT', ret[1]) + ret[2][1:] + ret[3:]
            
        if r0 == '!PyNumber_Add':                
            if TCmp(ret, v, ('!PyNumber_Add', ('CONST', str), ('!STR_CONCAT', '*'))):
                return ('!STR_CONCAT', ('CONST', v[0])) + v[1]
            if TCmp(ret, v, ('!PyNumber_Add', ('CONST', str), '?')):
                return ('!STR_CONCAT', ('CONST', v[0]), v[1])
            if TCmp(ret, v, ('!PyNumber_Add', ('!STR_CONCAT', '*'), ('CONST', str))):
                return ('!STR_CONCAT',) + v[0] + (('CONST', v[1]),)
            if TCmp(ret, v, ('!PyNumber_Add', '?', ('CONST', str))):
                return ('!STR_CONCAT', v[0], ('CONST', v[1]))
            if TCmp(ret, v, ('!PyNumber_Add', ('!STR_CONCAT', '*'), ('!STR_CONCAT', '*'))):
                return ('!STR_CONCAT',) +  v[0] + v[1]
            if TCmp(ret, v, ('!PyNumber_Add', ('!STR_CONCAT', '*'), '?')):
                return ('!STR_CONCAT',) +  v[0] + (v[1],)
            if TCmp(ret, v, ('!PyNumber_Add', '?', ('!STR_CONCAT', '*'))):
                return ('!STR_CONCAT', v[0]) + v[1]
            if IsStr(TypeExpr(ret[1])):
                return ('!STR_CONCAT',) + ret[1:]
            if IsStr(TypeExpr(ret[2])):
                return ('!STR_CONCAT',) + ret[1:]
            if ret[1][0] == '!BUILD_TUPLE' and ret[2][0] == '!BUILD_TUPLE':
                return ('!BUILD_TUPLE', ret[1][1] + ret[2][1])
        if r0 == '!PyNumber_Multiply':                
            if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', str), '?')):
                return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', unicode), '?')):
                return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', list), '?')):
                return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', tuple), '?')):
                return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('!STR_CONCAT', '*'), '?')):
                return ('!PySequence_Repeat', ('!STR_CONCAT',) + v[0], v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('!UNICODE_CONCAT', '*'), '?')):
                return ('!PySequence_Repeat', ('!UNICODE_CONCAT',) + v[0], v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('!BUILD_LIST', '*'), '?')):
                return ('!PySequence_Repeat', ('!BUILD_LIST',) + v[0], v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', ('!BUILD_LIST', '*'), '?')):
                return ('!PySequence_Repeat', ('!BUILD_TUPLE',) + v[0], v[1])
            if TCmp(ret, v, ('!PyNumber_Multiply', (('CONST', int), ('!BUILD_LIST', '*')))):
                return ('!PySequence_Repeat', ('!BUILD_LIST',) + v[1], ('CONST', v[1]))
        if len(ret) == 2 and r0 == '!BUILD_TUPLE':
            if all([x[0] == 'CONST' for x in ret[1]]):
                return ('CONST', tuple([x[1] for x in ret[1]]))
        if type(r0) is str:
            if r0 == '!PyObject_RichCompare(' and\
                  TCmp(ret, v, ('!PyObject_RichCompare(', '?', '?', c_2_op_op)):
                n = _process_compare_op(c_2_op_op[v[2]], v[0],v[1])
                if n is not None:
                    return n
            elif r0 == '!PyObject_RichCompare' and \
                TCmp(ret, v, ('!PyObject_RichCompare', '?', '?', c_2_op_op)):
                n = _process_compare_op(c_2_op_op[v[2]], v[0],v[1])
                if n is not None:
                    return n
                
        v = []       
        if r0 == '!_PyEval_BuildClass':
            if TCmp(ret, v, ('!_PyEval_BuildClass', \
                    ('!PyObject_Call', \
                        ('!MK_CLOSURE', '?', '?', '?'), \
                        '?', '?'), '?', ('CONST', '?'))): 
                _3(v[0], 'IsClassCreator', v[6])   
            elif TCmp(ret, v, ('!_PyEval_BuildClass', \
                    ('!PyObject_Call', \
                        ('!MK_FUNK', '?', '?'), '?', '?'), \
                    '?', ('CONST', '?'))): 
                _3(v[0], 'IsClassCreator', v[5])   
                
                
        v0 = []       
        if r0 == 'STORE':
            if TCmp(ret, v0, ('STORE', (('STORE_CALC_CONST', ('?', '?')),), ('?',))) and \
                    v0[0] in ('STORE_NAME', 'STORE_GLOBAL') and v0[1] in all_calc_const:
                v = [(v0[1], '', all_calc_const[v0[1]]), v0[2]]
                if v[1] == ('!MK_FUNK', v[0][0], ('CONST', ())):
                    val_direct_code[v[0][0]] = v[1]
                    direct_code[v[0][0]] = v[1][1]
                elif v[0][2][0] == '!MK_FUNK' and v[0][2][2] != v[0][0] and v[0][2][2] == ('CONST', ()):
                    val_direct_code[v[0][0]] = v[0][2]
                    direct_code[v[0][0]] = v[0][2][1]
                elif v[1][0] == '!MK_FUNK' and v[1][1] == v[0][0] and \
                    v[1][2][0] == 'CONST' and len(v[1][2][1]) > 0:
                    val_direct_code[v[0][0]] = v[1]
                    direct_code[v[0][0]] = v[1][1]
                    default_args[v[0][0]] = v[1][2]
                elif v[1][0] == '!_PyEval_BuildClass':
                    v1 = v[1]
                    v1_1 = []
                    v1_2 = []
                    if TCmp(v1, v1_1, ('!_PyEval_BuildClass',\
                                        ('!PyObject_Call',\
                                            ('!MK_FUNK', v[0][0], ('CONST', ())),\
                                            ('CONST', ()), ('NULL',)),\
                                        '?', ('CONST', v[0][0]))):
                        if v1_1[0] == ('CONST', ()):     
                            if not Is3(v[0][0], 'HaveMetaClass'): 
                                calc_const_old_class[v[0][0]] = v[1]
                    elif TCmp(v1, v1_2, ('!_PyEval_BuildClass',\
                                         ('!BUILD_MAP', '?'),\
                                        '?', ('CONST', v[0][0]))):
                        if v1_2[1] == ('CONST', ()):     
                            if not Is3(v[0][0], 'HaveMetaClass'): 
                                calc_const_old_class[v[0][0]] = v[1]
                    else:
                        pprint(v1)
                        Fatal('calcConst???Class', v1)   
            v0 = []
            if len(ret[1]) == 1 and len(ret[1][0]) == 2 and \
                    ret[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                    ret[1][0][1] in all_calc_const and TCmp(ret, v0, ('STORE', (('?', '?'),), ('?',))):
                v = [(v0[1], '', all_calc_const[v0[1]]), v0[2]]
                if v[1] == ('!MK_FUNK', v[0][0], ('CONST', ())):
                    val_direct_code[v[0][0]] = v[1]
                    direct_code[v[0][0]] = v[1][1]
                elif v[0][2][0] == '!MK_FUNK' and v[0][2][2] != v[0][0] and v[0][2][2] == ('CONST', ()):
                    val_direct_code[v[0][0]] = v[0][2]
                    direct_code[v[0][0]] = v[0][2][1]
                elif v[1][0] == '!MK_FUNK' and v[1][1] == v[0][0] and \
                    v[1][2][0] == 'CONST' and len(v[1][2][1]) > 0:
                    val_direct_code[v[0][0]] = v[1]
                    direct_code[v[0][0]] = v[1][1]
                    default_args[v[0][0]] = v[1][2]
                elif v[1][0] == '!_PyEval_BuildClass':
                    v1 = v[1]
                    v1_1 = []
                    if TCmp(v1, v1_1, ('!_PyEval_BuildClass',\
                                        ('!PyObject_Call',\
                                            ('!MK_FUNK', v[0][0], ('CONST', ())),\
                                            ('CONST', ()), ('NULL',)),\
                                        '?', ('CONST', v[0][0]))):  
                        ## vv = []                    
                        if v1_1[0] == ('CONST', ()):                    
                            if not Is3(v[0][0], 'HaveMetaClass'): 
                                calc_const_old_class[v[0][0]] = v[1]
                        elif v1_1[0][0] ==  '!BUILD_TUPLE':
##                            f = v1_1[0][1]
                            for der in v1_1[0][1]:
                                if der[0] == '!LOAD_BUILTIN':
                                    calc_const_new_class[v[0][0]] = v[1]
                                    _3(v[0][0], 'Derived', der)
                                elif der[0] in ('!LOAD_NAME', '!LOAD_GLOBAL'):    
                                    if der[1] in calc_const_old_class:
                                        if not Is3(v[0][0], 'HaveMetaClass'): 
                                            calc_const_old_class[v[0][0]] = v[1]
                                        _3(v[0][0], 'Derived', ('!CALC_CONST', der[1]))
                                    if der[1] in calc_const_new_class:
                                        calc_const_new_class[v[0][0]] = v[1]
                                        _3(v[0][0], 'Derived', ('!CALC_CONST', der[1]))
                                    else:
                                        Debug('Not name CalcConst???Class', v1)
                                elif der[0] == '!PyObject_GetAttr':        
                                    pass
                                elif der[0] == '!PyObject_Type':        
                                    Debug('Not name CalcConst???Class', v1)
                                elif der[0] == '!PyObject_Call':        
                                    Debug('Not name CalcConst???Class', v1)
                                else:
                                    Debug('Not name CalcConst???Class', v1, der)
                        else:    
                            print v1_1[0], v1_1[0][0], v1_1
                            Fatal('?k', v1)
                    else:
                        Fatal('?k', v1)
    return ret

def collect_modules_attr(ret):
    v = []
    if type(ret) is tuple and len(ret) > 1 and ret[0] == '!PyObject_GetAttr' and\
      TCmp(ret, v, ('!PyObject_GetAttr', \
                     (('|', 'CALC_CONST', \
                            '!LOAD_NAME', \
                            '!LOAD_GLOBAL', \
                            '!PyDict_GetItem(glob,'), \
                        ':ImportedM:'), ('CONST', '?'))) and \
                        ModuleHaveAttr(v[0][0], v[1]):
        if v[0][2][:6] == '__buil' and v[0][2][6:] == 'tin__':
           pass
        elif v[0][2] == 'sys' and v[1] in sys_const:
            return ('CONST', getattr(sys,v[1]))
        else:
            if v[0][2] != 'sys' and v[0][2] not in variable_module_attr:
                v2 = IfConstImp(v[0][0], v[1])
                if v2 is not None:
                    return v2
            if ModuleHaveAttr(v[0][0], v[1]) and v[0][2] not in variable_module_attr:
                _3(v[0][0], 'ModuleAttr', v[1])  


variable_module_attr = ('time', 'strptime', '_strptime', 'textwrap')

sys_const = ('byteorder', 'subversion', 'builtin_module_names', 
             'copyright', 'hexversion', 'maxint', 'maxsize', 'maxunicode',
             'platform', 'version', 'api_version')

def is_right_const_value(v2):
    if type(v2) in (int,long,bool,complex,float):
        return True
    return False

def IfConstImp(imp,nm):
    assert imp is not None
    v2 = val_imp(imp, nm)
    if is_right_const_value(v2):
        return ('CONST', v2)
    return None

def ModuleHaveAttr(imp,nm):
    if imp[:6] == '__buil' and imp[6:] == 'tin__':
        return nm in d_built
    if imp == 'sys' or imp in variable_module_attr or (imp[:6] == '__buil' and imp[6:] == 'tin__'):
        return False
    if Is3(imp, 'ImportedM'):
        v = Val3(imp, 'ImportedM')
        if type(v) is tuple and len(v) == 2:
            imp = v[0] + '.' + v[1]
            if v[0] in list_import and v[1] in list_import[v[0]] and not IsModule(list_import[v[0]][v[1]]):
                return False
        elif type(v) is str and v != imp:
            imp = v
        elif v != imp:
            Fatal(imp, v, nm)
    if imp == 'sys' or imp in variable_module_attr:
        return False
    v2 = val_imp(imp, nm)
    if v2 is None:
        return False
    return True

def repl_collected_module_attr(ret):
#    global all_calculated_const
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and ret[0] == '!PyObject_GetAttr':
        v = []
        if TCmp(ret, v, ('!PyObject_GetAttr', '?', ('CONST', '?'))):
            t = TypeExpr(v[0])
            if t is not None and t[0] is types.ModuleType and t[1] == 'sys' and v[1] in sys_const:
                return ('CONST', getattr(sys,v[1]))
            elif t is not None and t[0] is types.ModuleType and t[1] != 'sys' and\
                t[1] is not None and t[1]  not in variable_module_attr:
                v2 = IfConstImp(t[1], v[1])
                if v2 is not None:
                    return v2
        v = []
        if TCmp(ret, v, ('!PyObject_GetAttr', 
                        (('|', 'CALC_CONST',
                                '!LOAD_NAME', 
                                '!LOAD_GLOBAL', 
                                '!PyDict_GetItem(glob,'),
                            ':ImportedM:'), ('CONST', '?'))):
            if v[0][2] == 'sys' and v[1] in sys_const:
                return ('CONST', getattr(sys,v[1]))
            elif v[0][2] != 'sys' and v[0][2] not in variable_module_attr:
                v2 = IfConstImp(v[0][0], v[1])
                if v2 is not None:
                    return v2
            if v[0][2] != 'sys' and ModuleHaveAttr(v[0][0], v[1]) and v[0][2] not in variable_module_attr:
                _3(v[0][0], 'ModuleAttr', v[1])                    
                ret = calc_const_to((v[0][0], v[1]))
            v = []
    
        if TCmp(ret, v, ('!PyObject_GetAttr', ('CALC_CONST', '?'), ('CONST', '?'))):
            t = TypeExpr(('CALC_CONST', v[0]))
            if not redefined_attribute and t != None and \
            t[0] in (T_NEW_CL_INST, T_OLD_CL_INST) and\
            IsAttrInstance(t[1], v[1]) and not is_pypy: 
                _3(v[0], 'ModuleAttr', '.__dict__') 
                calc_const_to((v[0], '.__dict__'))                  
        v = []

    if type(ret) is tuple and len(ret) == 2 and type(ret[0]) is str and \
       ret[0] in ('!LOAD_NAME', '!LOAD_GLOBAL', '!PyDict_GetItem(glob,') and \
       ret[1] in all_calc_const:
        ret = calc_const_to(ret[1])    
    return ret

def upgrade_op(ret, nm = None):   
    if type(ret) is tuple and len(ret) == 2 and \
       ret[0] in ('!LOAD_NAME', '!LOAD_GLOBAL', '!PyDict_GetItem(glob,') and \
       ret[1] in mnemonic_constant:
           return mnemonic_constant[ret[1]]
    collect_modules_attr(ret)    
    return repl(ret)

methods_type = {(Kl_String, 'find'): Kl_Short,
                (Kl_String, 'index'): Kl_Short,
                (Kl_String, 'split'): Kl_List,
                (Kl_String, 'splitlines'): Kl_List,
                (Kl_String, 'ljust'): Kl_String,
                (Kl_String, 'rjust'): Kl_String,
                (Kl_String, 'zfill'): Kl_String,
                (Kl_String, 'lower'): Kl_String,
                (Kl_String, 'upper'): Kl_String,
                (Kl_String, 'encode'): None,
                (Kl_String, 'replace'): Kl_String,
                (Kl_String, 'strip'): Kl_String,
                (Kl_String, 'rstrip'): Kl_String,
                (Kl_String, 'lstrip'): Kl_String,
                (Kl_String, 'center'): Kl_String,
                (Kl_String, 'join'): Kl_String,
                (Kl_String, 'startswith'): Kl_Boolean,
                (Kl_String, 'endswith'): Kl_Boolean,
                (Kl_String, 'isalnum'): Kl_Boolean,
                (Kl_String, 'isalpha'): Kl_Boolean,
                (Kl_String, 'isdigit'): Kl_Boolean,
                (Kl_String, 'islower'): Kl_Boolean,
                (Kl_String, 'isspace'): Kl_Boolean,
                (Kl_String, 'istitle'): Kl_Boolean,
                (Kl_String, 'isupper'): Kl_Boolean,
                (Kl_File, 'close'): Kl_None,
                (Kl_File, 'write'): Kl_None,
                (Kl_File, 'seek'): Kl_None,
                (Kl_File, 'fileno'): Kl_Int,
                (Kl_File, 'tell'): Kl_Long,
                (Kl_File, 'read'): Kl_String,
                (Kl_File, 'getvalue'): Kl_String,
                (Kl_File, 'readline'): Kl_String,
                (Kl_File, 'readlines'): Kl_List,
                
                (Kl_Dict, 'iteritems'): Kl_Generator,
                (Kl_Dict, 'iterkeys'): Kl_Generator,
                (Kl_Dict, 'copy'): Kl_Dict,
                (Kl_Dict, 'keys'): Kl_List,
                (Kl_Dict, 'values'): Kl_List,
                (Kl_Dict, 'items'): (list, (tuple,(None,None))),
                (Kl_Dict, 'itervalues'): Kl_Generator,
                (Kl_Dict, 'setdefault'): None,
                (Kl_Dict, 'get'): None,
                (Kl_List, 'popitem'): Kl_Tuple,
                (Kl_List, 'pop'): None,
                (Kl_List, 'append'): Kl_None,
                (Kl_List, 'insert'): Kl_None,
                (Kl_List, 'sort'): Kl_None,
                (Kl_List, 'remove'): Kl_None,
                (Kl_List, 'index'): Kl_Short,
                (Kl_List, 'count'): Kl_Short,
                (Kl_List, 'pop'): None,
                ((T_NEW_CL_INST, 'StringIO'), 'getvalue') : Kl_String,
#                (Klass(T_NEW_CL_INST, 'Popen'), 'stdin') : None,
                ((T_OLD_CL_INST, 'ZipFile'), 'getinfo') : (T_OLD_CL_INST, 'ZipInfo'),
                ((T_OLD_CL_INST, 'ZipFile'), 'infolist') : Kl_List,
                ((T_OLD_CL_INST, 'ZipFile'), 'namelist') : Kl_List,
                (Kl_MatchObject, 'group'): None,
                (Kl_MatchObject, 'groups'): Kl_Tuple,
                (Kl_MatchObject, 'span'): Kl_Tuple,
                (Kl_RegexObject, 'subn'): Kl_Tuple,
                (Kl_RegexObject, 'search'): None,
                (Kl_RegexObject, 'finditer'): Kl_Generator,
                (Kl_RegexObject, 'findall'): Kl_List,
                (Kl_RegexObject, 'split'): Kl_List,
                (Kl_RegexObject, 'match'): None,
                (Kl_RegexObject, 'sub'): Kl_String
                }

klass_attr = {(('NewClassInstance', 'Popen'), 'stdin') : None,
              (('NewClassInstance', 'Popen'), 'stdout') : None,
              (('NewClassInstance', 'Popen'), 'stderr') : None}
                
tag_type = {}

def TypeDef(kl, *words):
    for w in words:
        tag_type[w] = kl
        
TypeDef(Kl_Char, '!CHR_BUILTIN')
TypeDef(Kl_String, '!_PyString_Join')
TypeDef((list, (tuple,(None,None))), '!PyDict_Items')
TypeDef(Kl_List, '!PyDict_Keys', '!PyDict_Values', '!PyList_GetSlice')
TypeDef(Kl_List, '!BUILD_LIST', \
                  '!PySequence_List', '!LIST_COMPR', '!PyObject_Dir')
TypeDef(Kl_Tuple, '!BUILD_TUPLE', '!PyList_AsTuple', '!PySequence_Tuple', '!PyTuple_GetSlice')
TypeDef(Kl_Dict, '!BUILD_MAP', '!PyDict_New', '!_PyDict_New', '!_PyDict_NewPresized', '!PyDict_Copy')
TypeDef(Kl_String, '!PyObject_Repr', '!STR_CONCAT2', '!STR_CONCAT_N',\
                  '!STR_CONCAT3', '!PyString_Format', '!STR_CONCAT', \
                  '!PyObject_Str', '!PyNumber_ToBase', '!_PyInt_Format', '!PyInt_Type.tp_str')
TypeDef(Kl_Int, '!PyInt_FromLong', '!PyInt_Type.tp_new')
TypeDef(Kl_Short, '!PY_SSIZE_T', '!@PyInt_FromSsize_t', '!ORD_BUILTIN', \
                  '!PyInt_FromSsize_t', '!_PyString_Find', '!_PyString_RFind', '!_PyString_Index', '!_PyString_RIndex')
TypeDef(Kl_Short, *len_family)                
TypeDef(Kl_Long, '!PyLong_Type.tp_new', '!PyNumber_Long')
TypeDef(Kl_Set, '!PySet_New', '!BUILD_SET')
TypeDef(Kl_FrozenSet, '!PyFrozenSet_New')
TypeDef(Kl_Type, '!PyObject_Type')
TypeDef(Kl_Slice, '!PySlice_New')
TypeDef(Kl_Boolean, '!AND_JUMP', '!OR_JUMP', '!PyObject_IsInstance', '!PyObject_IsSubclass', \
                  '!PySequence_Contains(', '!_EQ_', '!OR_BOOLEAN', '!AND_BOOLEAN', \
                  '!1NOT', '!_PyString_StartSwith',  '!_PyString_EndSwith',\
                  '!c_Py_EQ_Int', '!c_Py_NE_Int', '!c_Py_LT_Int', \
                  '!c_Py_LE_Int', '!c_Py_GT_Int', '!c_Py_GE_Int', \
                  '!c_Py_EQ_String', '!c_Py_NE_String', '!SSIZE_T==', '!SSIZE_T!=',\
                  '!SSIZE_T>', '!SSIZE_T<', '!SSIZE_T>=', '!SSIZE_T<=', \
                  '!PyDict_Contains', '!PySequence_Contains', '!PyBool_Type.tp_new',\
                  '!_NEQ_', '!_EQ_', '!_PyString_Contains', '!_PyString_ctype')
TypeDef(Kl_Float, '!PyFloat_Type.tp_new', '!PyNumber_Float')
TypeDef(Kl_Generator, '!GET_ITER')

tag_builtin = {}

def TypeBuilt(kl, *words):
    for w in words:
        tag_builtin[w] = kl
        
TypeBuilt(Kl_Tuple, 'divmod', 'tuple')
TypeBuilt(Kl_List, 'map', 'range', 'zip', 'list', 'dir', 'sorted')
TypeBuilt(Kl_Boolean, 'all', 'any', 'callable', 'isinstance', 'issubclass')
TypeBuilt(Kl_Int, 'hash', 'int')
TypeBuilt(Kl_Short, 'cmp', 'len', 'ord')
TypeBuilt(Kl_Dict, 'dict', 'globals', 'locals', 'vars')
TypeBuilt(Kl_Float, 'float', 'round')
TypeBuilt(Kl_String, 'hex', 'oct', 'str', 'repr', 'raw_input', 'bin', 'bytes')
TypeBuilt(Kl_Char, 'chr')
TypeBuilt(Kl_Unicode, 'unicode', 'unichr')
TypeBuilt(Kl_File, 'file', 'open')
TypeBuilt(Kl_Slice, 'slice')
TypeBuilt(Kl_Buffer, 'buffer')
TypeBuilt(Kl_XRange, 'xrange')
TypeBuilt(Kl_Complex, 'complex')
TypeBuilt(Kl_Set, 'set')
TypeBuilt(Kl_FrozenSet, 'frozenset')
TypeBuilt(Kl_StaticMethod, 'staticmethod')
TypeBuilt(Kl_Module(None), '__import__')
TypeBuilt(Kl_ClassMethod, 'classmethod')
TypeBuilt(Kl_Generator, 'enumerate', 'reversed', 'iter')
TypeBuilt(None, 'min', 'max', 'property', 'reduce', 'eval', 'super', \
                          'sum', 'compile', 'ValueError', 'IOError', \
                          'SyntaxError', 'input', 'bytearray', \
                          'filter')

## def TypeExpr(ret):
    ## r = _TypeExpr(ret)
    ## print >>out, ret
    ## pprint(r, out)
    ## assert r is None or (len(r) == 2 and type(r) is tuple)
    ## return r

def TypeExpr(ret):
    if ret == 'Py_None':
        return Kl_None
    if type(ret) != tuple:
        return None
    if len(ret) < 1:
        return None
    if ret[0] == '!?Raise':
        return ('Raise', ret[1])
    if ret[0] == '!LOAD_BUILTIN':
        if ret[1] in d_built and type(d_built[ret[1]]) == type(len):
            return Kl_BuiltinFunction
        elif ret[1] in d_built and type(d_built[ret[1]]) == type(int):
            return Kl_Type
    if ret == ('!LOAD_NAME', '__name__'):
        return Kl_String
    if ret[0] == '!LOAD_GLOBAL' and ret[1] in detected_global_type:
        return detected_global_type[ret[1]]
    if ret[0] == 'FAST':
        if ret[1] in current_co.detected_type:
            return current_co.detected_type[ret[1]]
        if current_co.can_be_codefunc() and hasattr(current_co, 'no_codefunc') and current_co.no_codefunc:
            ind = -1
            if ret[1] in current_co.co_varnames:
                ind = current_co.co_varnames.index(ret[1])
            if ind != -1 and ind in current_co.typed_arg_direct:
                return current_co.typed_arg_direct[ind]
        return current_co.TypeVar(ret)
    if ret[0] == '!COND_EXPR':
        t1 = TypeExpr(ret[2])
        t2 = TypeExpr(ret[3])
        if t1 == t2:
            return t1
        return None
    if ret[0] == '!COND_METH_EXPR':
        return TypeExpr(ret[2])
 
    if ret[0] == '!PyNumber_Int':
        t1 = TypeExpr(ret[1])
        if IsBool(t1):
            return Kl_Short
        if IsInt(t1):
            return t1
        return Kl_IntUndefSize   
    if ret[0] == '!PyNumber_Negative':
        t1 = TypeExpr(ret[1])
        if IsIntOrFloat(t1):
            return t1
    if ret[0] == '!PyNumber_Remainder':
        t1 = TypeExpr(ret[1])
        t2 = TypeExpr(ret[2])
        if IsInt(t1) and IsShort(t2):
            return Kl_Short
        if IsInt(t1) and IsIntOnly(t2):
            return Kl_Int
        if ret[0] == '!PyNumber_Remainder' and IsStr(t1):
            return Kl_String       
    if ret[0] in ('!OR_BOOLEAN', '!AND_BOOLEAN'):
        d2 = dict.fromkeys([TypeExpr(x) for x in ret[1:]]).keys()
        if len(d2) == 1:
            return d2[0]
        return None
    if ret[0] in ('!OR_JUMPED_STACKED', '!AND_JUMPED_STACKED'):
        d2 = dict.fromkeys([TypeExpr(x) for x in ret[1:]]).keys()
        if len(d2) == 1:
            return d2[0]
        return None
    if ret[0] == '!MK_FUNK':
        return (types.FunctionType, ret[1])
    if ret[0] == 'PY_TYPE':
        return (ret[1], ret[2])
    if ret[0] == 'CONST':
        if type(ret[1]) is int and ret[1] >= -30000 and ret[1] <= 30000:
            return Kl_Short
        if type(ret[1]) is tuple:
            return (tuple, tuple([TypeExpr(('CONST', x)) for x in ret[1]]))
        if type(ret[1]) is str and len(ret[1]) == 1:
            return Kl_Char
        return (type(ret[1]), None)
    if ret[0] == '!BUILD_TUPLE':
        return (tuple, tuple([TypeExpr(x) for x in ret[1]]))
    if ret[0] in tag_type:
        return tag_type[ret[0]]
    if ret[0] == '!CLASS_CALC_CONST':
        return (T_OLD_CL_INST, ret[1])
    if ret[0] == '!CLASS_CALC_CONST_DIRECT':
        return (T_OLD_CL_INST, ret[1])
    if ret[0] == '!CLASS_CALC_CONST_NEW':
        return (T_NEW_CL_INST, ret[1])
    if ret[0] == '!CLASS_CALC_CONST_NEW_DIRECT':
        return (T_NEW_CL_INST, ret[1])
    if ret[0] == '!_PyEval_BuildClass' and ret[2] == ('CONST', ()) and ret[3][0] == 'CONST':
        return (T_OLD_CL_TYP, ret[3][1])
    if ret[0] == '!PyObject_GetAttr' and ret[2][0] == 'CONST':
        t1 = TypeExpr(ret[1])
        if t1 is not None and (t1, ret[2][1]) in klass_attr:
            return klass_attr[(t1, ret[2][1])]
        if t1 is not None and (t1, ret[2][1]) in methods_type:
            return (types.MethodType, None)
        if t1 == Kl_Char and (Kl_String, ret[2][1]) in methods_type:
            return (types.MethodType, None)
        if t1 is not None:
            if t1[0] == 'MayBe':
                t1 = t1[1]
            if IsAnyClass(t1[1]):
                pass
            elif t1[0] is types.ModuleType:
                tupl = (t1[1], ret[2][1], 'val')
                if tupl in t_imp:
                    return t_imp[tupl]
                tupl = (t1[1], ret[2][1], '()')
                if tupl in t_imp:
                    return (types.MethodType, None)
                if t1[1] in list_import:
                    d2 = list_import[t1[1]]
                    if ret[2][1] not in d2 and len(d2) != 0:
                        Debug('Module attrib is not valid: %s -> %s ()' % (t1, ret[2][1]), ret)
                    if ret[2][1] in d2:
                        t2 = d2[ret[2][1]]
                        if t2[0] is types.ModuleType and t2[1] is None:
                            nm2 = t1[1] + '.' + ret[2][1]
                            CheckExistListImport(nm2)
                            return (types.ModuleType, nm2)
                        return t2
                    if len(d2) == 0:
                        return None
                Debug('Undefined type attrib: %s -> %s ()' % (t1, ret[2][1]), ret)
                if IsKlNone(t1):
                    Fatal('')
            else:
                Debug('Undefined type attrib: %s -> %s ()' % (t1, ret[2][1]), ret)
                if IsKlNone(t1):
                    return None
        if ret[2][1] in detected_attr_type:
            r = detected_attr_type[ret[2][1]] 
            if r == Kl_BuiltinFunction and (not IsModule(t1) or 'self' in repr(ret)):
                if (IsList(t1) or IsTuple(t1) or IsDict(t1) or t1 == Kl_Set) and ret[2][1][:2] != '__':
                    return r
                if t1 is not None:
                    Debug('May by CFunction attribute of %s ?' % repr(t1), ret)
                return None
            return r
        return None
    if ret[0] == '!CALL_CALC_CONST':
        if ret[1] in detected_return_type:
            return detected_return_type[ret[1]] 
        return None
    if ret[0] == '!CALL_CALC_CONST_INDIRECT':
        if ret[1] in detected_return_type:
            return detected_return_type[ret[1]] 
        return None
    if ret[0] == '!1NOT':
        t1 = TypeExpr(ret[1])
        if IsInt(t1) or IsBool(t1):
            return Kl_Boolean
    if ret[0] == '!BINARY_SUBSCR_Int':
        t1 = TypeExpr(ret[1])
        if IsStr(t1) and \
            TypeExpr(ret[2]) in (Kl_Short, Kl_Int, Kl_IntUndefSize):
           return Kl_Char
        elif IsTuple(t1) and t1[1] is not None and ret[2][0] == 'CONST' and type(t1[1]) is tuple:
            ind = ret[2][1]
            if ind >= 0 and ind < len(t1[1]):
                return t1[1][ind] 
    if ret[0] == '!BINARY_SUBSCR_Int' and IsStr(TypeExpr(ret[1])) and\
       TypeExpr(ret[2]) in (Kl_Short, Kl_Int, Kl_IntUndefSize):
           return Kl_Char   
    if ret[0] == '!from_ceval_BINARY_SUBSCR':
        t1 = TypeExpr(ret[1])
        t2 = TypeExpr(ret[2])
        if IsStr(t1) and t2 in (Kl_Short, Kl_Int, Kl_IntUndefSize):
           return Kl_Char
        if IsStr(t1):
            return Kl_String
        elif IsTuple(t1) and t1[1] is not None and ret[2][0] == 'CONST':
            ind = ret[2][1]
            if ind >= 0 and ind < len(t1[1]):
                return t1[1][ind]   
                  
    if ret[0] == 'CALC_CONST':
        nm = ret[1]    
        if type(nm) is tuple and len(nm) == 2:
            tupl = (Val3(nm[0], 'ImportedM'), nm[1], 'val')
            if tupl in t_imp:
                return t_imp[tupl]
            tupl = (Val3(nm[0], 'ImportedM'), nm[1], '()')
            if tupl in t_imp:
                return ('lazycall', t_imp[tupl])
        if ret[1] in calc_const_old_class:
            return (T_OLD_CL_TYP, ret[1])
        if ret[1] in calc_const_new_class:
            return (T_NEW_CL_TYP, ret[1])
        if ret[1] not in calc_const_value:
            return None
        return TypeExpr(calc_const_value[ret[1]]) #Klass(ret)
    if ret[0] == '!PySequence_Repeat':
            t1 = TypeExpr(ret[1])
            if t1 == Kl_Char:
                    return Kl_String
            if t1 is not None and t1[0] is tuple:
                    return Kl_Tuple
            return t1		
    if ret[0] in ('!PyNumber_Lshift', '!PyNumber_Rshift'):
        t1 = TypeExpr(ret[1])
        if t1 == Kl_Long:
            return t1
        if IsInt(t1) and ret[0] == '!PyNumber_Rshift' :
            return t1
##    v = []
    if (ret[0] == '!PyNumber_Lshift' or ret[0] == '!PyNumber_InPlaceLshift'):
        if ret[2][0] == 'CONST' and type(ret[2][1]) is int and ret[2][1] >= 1 and ret[2][1] <= 31:
            t1 = TypeExpr(ret[1])
            if IsShort(t1) and  ret[2][1] < 16:
                return Kl_Int
    if ret[0] == '!PyObject_Call':
        if ret[1][0] == '!LOAD_BUILTIN':
            d2 = ret[1][1]
            if d2 in ('max', 'min') and ret[2][0] == '!BUILD_TUPLE' and len (ret[2][1]) == 2:
                t1 = TypeExpr(ret[2][1][0])
                t2 = TypeExpr(ret[2][1][1])
                if t1 == t2:
                    return t1
            if d2 == 'sorted':
                if ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1 and \
                   ret[3] == ('NULL',):
                       t2 = TypeExpr(ret[2][1][0])
                       if IsList(t2):
                           return t2
            if d2 in tag_builtin:
                return tag_builtin[d2]
            else:
                Debug('Undefined type builtin: %s' % (d2,), ret)
                return None
        if ret[1][0] == 'CALC_CONST':    
            nm = ret[1][1] 
            if type(nm) is tuple and len(nm) == 2:
                tuplcall = (Val3(nm[0], 'ImportedM'), nm[1], '()')
                if tuplcall in t_imp:
                    return t_imp[tuplcall]
            elif type(nm) is str:
                tuplcall = Val3(nm, 'ImportedM')
                if type(tuplcall) is tuple:
                    tuplcall +=  ('()',)
                    if tuplcall in t_imp:
                        return t_imp[tuplcall]
        t2 = TypeExpr(ret[1])
        if t2 is not None and t2[0] == 'lazycall':
#            Debug('Lazycall detected', t2, ret)
            return t2[1]    
        ## if ret[1][0] == 'CALC_CONST':
            ## nm = ret[1][1]    
            ## if type(nm) is tuple and len(nm) == 2:
                ## tupl = (Val3(nm[0], 'ImportedM'), nm[1], '()')
            ## elif type(tupl) is str:    
                ## tupl = (Val3(nm, 'ImportedM') + ('()',)
                ## if tupl in t_imp:
                    ## return t_imp[tupl]
        _v = [] 
        if TCmp(ret[1], _v, ('!PyObject_GetAttr', '?', ('CONST', '?'))):
            if _v[1] == 'fromkeys' and TCmp(_v[0], [], ('!LOAD_BUILTIN', 'dict')):
                return Kl_Dict
            t1 = TypeExpr(_v[0])
            if t1 is not None and (t1, _v[1]) in methods_type:
                return methods_type[(t1, _v[1])]
            elif t1 == Kl_Char and (Kl_String, _v[1]) in methods_type:
                return methods_type[(Kl_String, _v[1])]
            elif t1 is not None:
                if type(t1[1]) is str and IsAnyClass(t1[1]):
                    pass
                elif t1[0] is types.ModuleType:
                    tupl = (t1[1], _v[1], '()')
                    if tupl in t_imp:
                        return t_imp[tupl]
                    tupl = (t1[1], _v[1], 'val')
                    if tupl in t_imp:
                        t2 = t_imp[tupl]
                        if t2[0] == T_OLD_CL_TYP:
                            return (T_OLD_CL_INST, _v[1])
                        elif t2[0] == T_NEW_CL_TYP:
                            return (T_NEW_CL_INST, _v[1])
                    Debug('Undefined type method: %s -> %s ()' % (t1, _v[1]), ret)
                else:
                    Debug('Undefined type method: %s -> %s ()' % (t1, _v[1]), ret)
        return None            
    if ret[0] == '!PyNumber_Power':
        if Kl_Float == TypeExpr(ret[1]) and Kl_Float == TypeExpr(ret[2]):
           return Kl_Float
        return None
    if ret[0] in ('!PyNumber_And', '!PyNumber_Or', '!PyNumber_InPlaceAnd', '!PyNumber_InPlaceOr'):
        t1 = TypeExpr(ret[1])
        t2 = TypeExpr(ret[2])
        if (t1,t2) == (Kl_Short, Kl_Short):
            return Kl_Short
        if IsInt(t1) and IsInt(t2):
            return Kl_Int
    if ret[0] == '!PyNumber_Absolute':
        return TypeExpr(ret[1])    
    if ret[0] in ('!PyNumber_Add', '!PyNumber_InPlaceAdd'):
        t1 = TypeExpr(ret[1])
        t2 = TypeExpr(ret[2])
        if Kl_Float == t1 and Kl_Float == t2:
            return Kl_Float
        if IsTuple(t1) and ret[2][0] == '!PySequence_GetSlice':
            return t1
        ty = (t1,t2)
        if Kl_Boolean in ty and (IsInt(t1) or IsInt(t2))   :
            if Kl_Short in ty:
                return Kl_Short
            return Kl_Int
        if IsShort(t1) and IsShort(t2):
            return Kl_Int
        if t1 is not None and not IsInt(t1) and t1 == t2:
            return t1
        if IsTuple(t2) and ret[1][0] == '!PySequence_GetSlice':
            return t2        
        if IsFloat(t1) and IsFloat(t2):
            return Kl_Float
        if IsInt(t1) and IsFloat(t2):
            return Kl_Float
        if IsInt(t2) and IsFloat(t1):
            return Kl_Float
        if IsIntUndefSize(t1) and IsFloat(t2):
            return Kl_Float
        if IsIntUndefSize(t2) and IsFloat(t1):
            return Kl_Float
        if IsIntOnly(t1) and IsShort(t2) and IsSumShort(ret[1]):
            return Kl_Int
        if IsIntOnly(t2) and IsShort(t1) and IsSumShort(ret[2]):
            return Kl_Int
        if IsIntOnly(t1) and IsInt(t2):
            return Kl_IntUndefSize
        if IsIntOnly(t2) and IsInt(t1):
            return Kl_IntUndefSize
        if IsIntUndefSize(t1) and IsInt(t2):
            return Kl_IntUndefSize
        if IsIntUndefSize(t2) and IsInt(t1):
            return Kl_IntUndefSize
        if IsIntUndefSize(t1) and IsIntUndefSize(t2):
            return Kl_IntUndefSize
        if IsTuple(t1) and IsTuple(t2):
            t1_1 = t1[1]
            t2_1 = t2[1]
            if t1_1 is not None and t2_1 is not None:
                if type(t1_1) is int and type(t2_1) is int:
                    return (tuple, t1_1 + t2_1)
                if type(t1_1) is int and type(t2_1) is tuple:
                    return (tuple, t1_1 + len(t2_1))
                if type(t1_1) is tuple and type(t2_1) is int:
                    return (tuple, len(t1_1) + t2_1)
                if type(t1_1) is tuple and type(t2_1) is tuple:
                    return (tuple, t1_1 + t2_1)
            if t1_1 is None and type(t2_1) is tuple:
                return (tuple, len(t2_1))
            if t1_1 is None and type(t2_1) is int:
                return (tuple, t2_1)
            if type(t1_1) is int and t2_1 is None:
                return (tuple, t1_1)
            if type(t1_1) is tuple and t2_1 is None:
                return (tuple, len(t1_1))
            return Kl_Tuple
        if IsList(t1) and IsList(t2):
            return Kl_List
        if IsList(t1) or IsList(t2):
            return ('Not', (Kl_Int, Kl_IntUndefSize, Kl_Float, Kl_Short))
        if IsStr(t1) and IsStr(t2):
            return Kl_String
        if ret[2][0] == '!PySequence_GetSlice' or ret[1][0] == '!PySequence_GetSlice':
            return ('Not', (Kl_Int, Kl_IntUndefSize, Kl_Float, Kl_Short))
        if t1 is None and t2 is not None and t2[0] == 'Not':
            return t2
        if t2 is None and t1 is not None and t1[0] == 'Not':
            return t1
        return None
    if ret[0] in ('!PyNumber_Multiply', '!PyNumber_Divide', '!PyNumber_InPlaceDivide', \
                  '!PyNumber_Subtract', '!PyNumber_InPlaceSubtract', '!PyNumber_InPlaceMultiply'):
        t1 = TypeExpr(ret[1])
        t2 = None
        if IsFloat(t1):
            if t2 is None:
                t2 = TypeExpr(ret[2])
            if IsFloat(t2):    
                return Kl_Float
        if t2 is None:
            t2 = TypeExpr(ret[2])

        if IsShort(t1) and IsShort(t2) and ret[0] in \
        ('!PyNumber_InPlaceMultiply', '!PyNumber_InPlaceSubtract', '!PyNumber_Subtract', '!PyNumber_Multiply'):
            return Kl_Int   
        if ret[0] in ('!PyNumber_InPlaceSubtract', '!PyNumber_Subtract'):
            if IsIntOnly(t1) and IsShort(t2) and IsSumShort(ret[1]):
                return Kl_Int
            if IsIntOnly(t2) and IsShort(t1) and IsSumShort(ret[2]):
                return Kl_Int
            if IsFloat(t1) and IsFloat(t2):
                return Kl_Float
            if IsInt(t1) and IsFloat(t2):
                return Kl_Float
            if IsIntUndefSize(t1) and IsFloat(t2):
                return Kl_Float
            if IsInt(t2) and IsFloat(t1):
                return Kl_Float
            if IsIntUndefSize(t2) and IsFloat(t1):
                return Kl_Float
            if IsIntOnly(t1) and IsShort(t2):
                return Kl_IntUndefSize
            if IsIntOnly(t2) and IsShort(t1):
                return Kl_IntUndefSize
            if IsIntOnly(t2) and IsIntOnly(t1):
                return Kl_IntUndefSize
            if IsIntUndefSize(t1) and IsInt(t2):
                return Kl_IntUndefSize
            if IsIntUndefSize(t2) and IsInt(t1):
                return Kl_IntUndefSize
            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                return Kl_IntUndefSize
            return None
        
        if ret[0] == '!PyNumber_Multiply':
            if IsTuple(t1) and IsIntUndefSize(t2):
                return Kl_Tuple
            if IsTuple(t2) and IsIntUndefSize(t1):
                return Kl_Tuple
            if IsList(t1) and IsIntUndefSize(t2):
                return t1
            if IsList(t2) and IsIntUndefSize(t1):
                return t2
            if IsTuple(t1) and IsInt(t2):
                return Kl_Tuple
            if IsTuple(t2) and IsInt(t1):
                return Kl_Tuple
            if IsList(t1) and IsInt(t2):
                return t1
            if IsList(t2) and IsInt(t1):
                return t2
            if IsFloat(t1) and IsFloat(t2):
                return Kl_Float
            if IsInt(t1) and IsFloat(t2):
                return Kl_Float
            if IsInt(t2) and IsFloat(t1):
                return Kl_Float
            if IsIntUndefSize(t2) and IsFloat(t1):
                return Kl_Float
            if IsIntUndefSize(t1) and IsFloat(t2):
                return Kl_Float
            if IsIntOnly(t1) and IsShort(t2):
                return Kl_IntUndefSize
            if IsIntOnly(t2) and IsShort(t1):
                return Kl_IntUndefSize
            if IsIntOnly(t2) and IsIntOnly(t1):
                return Kl_IntUndefSize
            if IsIntUndefSize(t1) and IsInt(t2):
                return Kl_IntUndefSize
            if IsIntUndefSize(t2) and IsInt(t1):
                return Kl_IntUndefSize
            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                return Kl_IntUndefSize
            if IsIntUndefSize(t1) and IsStr(t2):
                return Kl_String
            if IsIntUndefSize(t2) and IsStr(t1):
                return Kl_String
            if IsInt(t1) and IsStr(t2):
                return Kl_String
            if IsInt(t2) and IsStr(t1):
                return Kl_String
        if ret[0] == '!PyNumber_Divide':
            if IsShort(t1) and IsShort(t2):
                return Kl_Short
            if IsShort(t1) and IsIntOnly(t2):
                return Kl_Short
            if IsIntOnly(t1) and IsIntOnly(t2):
                return Kl_Int
            if IsIntOnly(t1) and IsShort(t2):
                return Kl_Int
            if IsFloat(t1) and IsFloat(t2):
                return Kl_Float
            if IsInt(t1) and IsFloat(t2):
                return Kl_Float
            if IsInt(t2) and IsFloat(t1):
                return Kl_Float
            if IsIntUndefSize(t2) and IsFloat(t1):
                return Kl_Float
            if IsIntUndefSize(t1) and IsFloat(t2):
                return Kl_Float
            if IsIntUndefSize(t1) and IsInt(t2):
                return Kl_IntUndefSize
            if IsIntUndefSize(t2) and IsInt(t1):
                return Kl_Int
            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                return Kl_IntUndefSize
            
        if IsIntUndefSize(t1) and IsShort(t2):
            return Kl_IntUndefSize
        if IsIntUndefSize(t2) and IsShort(t1):
            return Kl_IntUndefSize
        if IsIntUndefSize(t1) and IsInt(t2):
            return Kl_IntUndefSize
        if IsIntUndefSize(t2) and IsInt(t1):
            return Kl_IntUndefSize
        if IsIntUndefSize(t1) and IsIntUndefSize(t2):
            return Kl_IntUndefSize
    if ret[0] == '!PyNumber_Negative':
        t1 = TypeExpr(ret[1])
        if IsInt(t1) or t1 == Kl_Long or IsFloat(t1):
            return t1

    if ret[0] in ('!PySequence_GetSlice', '!_PyEval_ApplySlice'):
        t2 = TypeExpr(ret[1])
        if IsList(t2) or IsTuple(t2) or IsStr(t2):
            return t2 
        return ('Not', (Kl_Int, Kl_IntUndefSize, Kl_Float, Kl_Short))
        
#        return None   
    if ret[0] == '!BOOLEAN' and IsBool(TypeExpr(ret[1])):
        return Kl_Boolean
    if ret[0] == '!IMPORT_NAME':
        return (types.ModuleType, dotted_name_to_first_name(ret[1]))
    if ret[0] == '!PyObject_RichCompare(':
        t1 = TypeExpr(ret[1])
        t2 = TypeExpr(ret[2])
        if t1 == t2 and t1 in _Kl_Simples:
            return Kl_Boolean
    return None

def IsSumShort(it):
   if it[0] not in ('!PyNumber_Subtract', '!PyNumber_InPlaceSubtract', '!PyNumber_Add', '!PyNumber_InPlaceAdd'):
       return False
   t1 = TypeExpr(it[1])
   t2 = TypeExpr(it[2])
   if IsShort(t1) and IsShort(t2):
       return True
   if IsIntOnly(t1) and IsShort(t2) and IsSumShort(it[1]):
       return True
   if IsIntOnly(t2) and IsShort(t1) and IsSumShort(it[2]):
       return True
   if IsIntOnly(t2) and IsIntOnly(t1) and IsSumShort(it[2]) and IsSumShort(it[1]):
       return True
   return False

import math

def attempt_calc_constant_math(t, ret, v1):
    try:
        return ('CONST', getattr(math, t)(*v1))
    except:
        return ret
    
def upgrade_op2(ret, nm = None):    
    v = []
    if direct_call and current_co.can_be_codefunc():
        if type(ret) is tuple and len(ret) == 4 and type(ret[0]) is str and \
           ret[0] == '!PyObject_Call' and ret[3] == ('NULL',): 
            if TCmp(ret[1:-1], v, (('!MK_FUNK', '?', ('CONST', ())), \
                    ('!BUILD_TUPLE', '?'))):
                return call_calc_const(v[0], ('!BUILD_TUPLE', v[1]), ret)                    
            elif 'MK_FUNK' in repr(ret):
                if TCmp(ret[1:-1], v, (('!MK_FUNK', '?', ('CONST', ())), \
                    ('CONST', '?'))):
                    return call_calc_const(v[0], ('CONST', v[1]), ret)  
                ## pprint(('/////', ret))
            elif TCmp(ret[1:-1], v, (('CALC_CONST', '?'),\
                        ('!BUILD_TUPLE', '?'))) and \
                        v[0] in val_direct_code: ## and \
                return call_calc_const(direct_code[v[0]], ('!BUILD_TUPLE', v[1]), ret)
            elif TCmp(ret[1:-1], v, (('CALC_CONST', '?'),\
                        ('CONST', '?'))) :
                if v[0] in val_direct_code:
                    return call_calc_const(direct_code[v[0]], ('CONST', v[1]), ret)
                t = None
                if type(v[0]) is tuple and len(v[0]) == 2:
                    t = (Val3(v[0][0], 'ImportedM'), v[0][1])
                else:
                    t = Val3(v[0], 'ImportedM')
                if type(t) is tuple and len(t) == 2 and t[0] == 'math':
                    return attempt_calc_constant_math(t[1], ret, v[1]) #sqrt
                
    v  = []            
    if type(ret) is tuple and len(ret) == 4 and type(ret[0]) is str and \
        ret[0] == '!PyObject_Call' and ret[3] == ('NULL',):
        if TCmp(ret, v, ('!PyObject_Call', ('CALC_CONST', '?'),\
                    ('!BUILD_TUPLE', '?'), ('NULL',))) and v[0] in calc_const_old_class :
                if not Is3(v[0], 'HaveMetaClass') and v[0] not in calc_const_new_class: #have_metaclass(v[0][0]):
                    ret = ('!CLASS_CALC_CONST', v[0], ('!BUILD_TUPLE', v[1]))
        elif TCmp(ret, v, ('!PyObject_Call', ('CALC_CONST', '?'),\
                    ('CONST', '?'), ('NULL',))) and v[0] in calc_const_old_class:
                if not Is3(v[0], 'HaveMetaClass') and v[0] not in calc_const_new_class:  ## and not have_metaclass(v[0][0]):
                    ret = ('!CLASS_CALC_CONST', v[0], ('CONST', v[1]))
        elif TCmp(ret, v, ('!PyObject_Call', ('CALC_CONST', '?'),\
                    ('!BUILD_TUPLE', '?'), ('NULL',))) and v[0] in calc_const_new_class:
                if v[0] not in calc_const_old_class:        
                    ret = ('!CLASS_CALC_CONST_NEW', v[0], ('!BUILD_TUPLE', v[1]))
        elif TCmp(ret, v, ('!PyObject_Call', ('CALC_CONST', '?'),\
                    ('CONST', '?'), ('NULL',)))and v[0] in calc_const_new_class:
                if v[0] not in calc_const_old_class:        
                    ret = ('!CLASS_CALC_CONST_NEW', v[0], ('CONST', v[1]))
    v = []
    if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and \
       ret[0] == 'IMPORT_FROM_AS' and \
       TCmp(ret, v, ('IMPORT_FROM_AS', '?', ('CONST', -1), ('CONST', '?'), '?')):
        sreti = []
        imp, consts_, stores = v
        for reti in stores:
            v = []
            if type(reti) is tuple and len(reti) == 2 and \
               reti[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
               reti[1] in all_calc_const:
                reti = ('STORE_CALC_CONST', reti)
            sreti.append(reti)        
        return ret[:4] + (tuple(sreti),)    
    v0 = []
    if len(ret) == 3 and ret[0] == 'SEQ_ASSIGN':
        sreti = []
        for reti in ret[1]:
            v = []
            if type(reti) is tuple and len(reti) == 2 and \
               reti[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
               reti[1] in all_calc_const:
                calc_const_value[reti[1]] = ret[2]
                reti = ('STORE_CALC_CONST', reti)
            elif reti[0] == 'SET_VARS':    
                sretii = []
                for retii in reti[1]:
                    if type(retii) is tuple and len(retii) == 2 and \
                       retii[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                       retii[1] in all_calc_const:
                        retii = ('STORE_CALC_CONST', retii)
                    sretii.append(retii)
                reti = ('SET_VARS', tuple(sretii))        
            sreti.append(reti)        
        return (ret[0], tuple(sreti), ret[2])    
    elif len(ret) == 3 and ret[0] == 'SET_EXPRS_TO_VARS':    
        sretii = []
        for retii in ret[1]:
            if type(retii) is tuple and len(retii) == 2 and \
                retii[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                retii[1] in all_calc_const:
                retii = ('STORE_CALC_CONST', retii)
            sretii.append(retii)
        return ('SET_EXPRS_TO_VARS', tuple(sretii), ret[2])        

    elif type(ret) is tuple and len(ret) == 3 and \
         ret[0] == 'STORE' and len(ret[1]) == 1 and len(ret[1][0]) == 2 and \
         ret[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and \
         ret[1][0][1] in all_calc_const and\
                TCmp(ret, v0, ('STORE', (('?', '?'),), ('?',))):
        v = [(v0[1], '', all_calc_const[v0[1]]), v0[2]]
        calc_const_value[v[0][0]] = v[1]
        return ('STORE', (('STORE_CALC_CONST', ret[1][0]),), ret[2])    
    elif type(ret) is tuple and len(ret) == 2 and \
       ret[0] in ('!LOAD_NAME', '!LOAD_GLOBAL', '!PyDict_GetItem(glob,') and \
       ret[1] in all_calc_const:
        ret = calc_const_to(ret[1])    
    v = []    
    ret = repl_collected_module_attr(ret)    
    ret = repl(ret) 
    return ret        
def class_and_body_meth_by_meth(nm_meth):
    islis = IterMethod(nm_meth, None)
    if len(islis) == 0:
        return {}
    di = dict([(a,c) for a,b,c in islis])
    while True:
        l = len(di)
        for k in di.keys():
            for a1, b1, c1 in Iter3(None, 'Derived', ('!CALC_CONST', k)):
                if a1 not in di:
                    di[a1] = di[k]
        if len(di) == l:
            break
    return di

def tree_pass__(a, upgrade_op, up, nm):
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        r = tuple([tree_pass__(i, upgrade_op,a, nm) for i in a])
        notchanged = len(r) == len(a) and all([r[i] is a[i] for i,x in enumerate(r)])
        if notchanged:
            r = a
        r = upgrade_op(r,nm)
        return r
    if type(a) is list:
        assert len(a) > 0 
        r = [tree_pass__(i, upgrade_op, a, nm) for i in a]
        notchanged = len(r) == len(a) and all([r[i] is a[i] for i,x in enumerate(r)])
        if notchanged:
            r = a
        assert len(r) > 0
        return r
    return a

to_call_1 = {'!PyObject_Hash':('__hash__',), '!PyObject_Str':('__str__',), \
             '!PyObject_Repr':('__repr__',), '!PyNumber_Negative':('__neg__',),\
             '!PyObject_GetIter':('__iter__',), '!PyObject_Length':('__len__',)}

to_call_2 = {'!PyNumber_Subtract':('__sub__',), '!PyNumber_InPlaceSubtract':('__isub__', '__sub__',),\
'!PyNumber_Add':('__add__',), '!PyNumber_InPlaceAdd':('__iadd__', '__add__',),\
'!PyNumber_Divide':('__div__',), '!PyNumber_InPlaceDivide':('__idiv__', '__div__',),\
'!PyNumber_And':('__and__',), '!PyNumber_InPlaceAnd':('__iand__', '__and__',),\
'!PyNumber_Or':('__or__',), '!PyNumber_InPlaceOr':('__ior__', '__or__',),\
'!PyNumber_Multiply':('__mul__',), '!PyNumber_InPlaceMultiply':('__imul__', '__mul__',)}

def upgrade_repl_if_type_direct_call(ret, nm = None):  
    v = []
    if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str:
        if ret[0] == '!COND_METH_EXPR':
            return ret
        if len(ret) == 3 and ret[0] in to_call_2:
            v = ret
            t1 = TypeExpr(v[1])
            t2 = TypeExpr(v[2])
            _self1 = v[1]
            if t1 is None and t2 is None : 
                nms = to_call_2[v[0]]
                for nm_meth in nms:
                    di = class_and_body_meth_by_meth(nm_meth)
                    if len(di) == 0:
                        continue
                    li = []
                    for t, codemethnm in di.iteritems():
                        classmeth = Is3(t, ('ClassMethod', nm_meth))
                        staticmeth = Is3(t, ('StaticMethod', nm_meth))
                        isoldclass = t in calc_const_old_class
                        isnewclass = t in calc_const_new_class
                        if classmeth or staticmeth:
                            continue
                        if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                            pass
                        else:
                            continue
                        assert v[1][0] != 'PY_TYPE'
                        if isoldclass:
                            _self2 = ('PY_TYPE', T_OLD_CL_INST, t, v[1], None)
                            if is_pypy:
                                continue
                        else:    
                            _self2 = ('PY_TYPE', T_NEW_CL_INST, t, v[1], None)
                        tupl = ('!BUILD_TUPLE', (_self2, replace_subexpr(v[2], v[1], _self2)))
                        ret2 = call_calc_const(codemethnm, tupl, ret)
                        if ret2 == ret:
                            continue    
                        li.append((_self2[1:3], ret2))
                    if len(li) > 0:         
                        return ('!COND_METH_EXPR', _self1, ret, tuple(li))

        elif len(ret) == 2 and ret[0] in to_call_1:
            v = ret
            t1 = TypeExpr(v[1])
            if t1 is None : 
                nms = to_call_1[v[0]]
                for nm_meth in nms:
                    di = class_and_body_meth_by_meth(nm_meth)
                    if len(di) == 0:
                        continue
                    li = []
                    for t, codemethnm in di.iteritems():
                        classmeth = Is3(t, ('ClassMethod', nm_meth))
                        staticmeth = Is3(t, ('StaticMethod', nm_meth))
                        isoldclass = t in calc_const_old_class
                        isnewclass = t in calc_const_new_class
                        _self1 = v[1]
                        if classmeth or staticmeth:
                            continue
                        if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                            pass
                        else:
                            continue
                        assert v[1][0] != 'PY_TYPE'
                        if isoldclass:
                            _self2 = ('PY_TYPE', T_OLD_CL_INST, t, v[1], None)
                            if is_pypy:
                                continue
                        else:    
                            _self2 = ('PY_TYPE', T_NEW_CL_INST, t, v[1], None)
                        tupl = ('!BUILD_TUPLE', (_self2, ))
                        ret2 = call_calc_const(codemethnm, tupl, ret)
                        if ret2 == ret:
                            continue    
                        li.append((_self2[1:3], ret2))
                    if len(li) > 0:         
                        return ('!COND_METH_EXPR', _self1, ret, tuple(li))
 
        elif ret[0] == '!PyObject_Call' and ret[1][0] == '!PyObject_GetAttr':
            if TCmp(ret, v, \
                ('!PyObject_Call',  
                    ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',)))\
                    and TypeExpr(v[0]) is None:
                di = class_and_body_meth_by_meth(v[1])
                li = []
                for t, codemethnm in di.iteritems():
                    classmeth = Is3(t, ('ClassMethod', v[1]))
                    staticmeth = Is3(t, ('StaticMethod', v[1]))
                    isoldclass = t in calc_const_old_class
                    isnewclass = t in calc_const_new_class
                    _self1 = v[0]
                    if classmeth or staticmeth:
                        continue
                    if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                        pass
                    else:
                        continue
                    assert _self1[0] != 'PY_TYPE'
                    if isoldclass:
                        _self2 = ('PY_TYPE', T_OLD_CL_INST, t, _self1, None)
                        if is_pypy:
                            continue
                    else:    
                        _self2 = ('PY_TYPE', T_NEW_CL_INST, t, _self1, None)
                    tupl = ('!BUILD_TUPLE', (_self2,) + replace_subexpr(v[2], _self1, _self2))
                    ret2 = call_calc_const(codemethnm, tupl, ret)
                    if ret2 == ret:
                        continue
        
                    li.append((_self2[1:3], ret2))
                if len(li) == 0 and v[1] == 'startswith' and len(v[2]) == 1 and IsStr(TypeExpr(v[2][0])):
                    li.append(((str, None), ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), v[2][0])))
                if len(li) == 0 and v[1] == 'startswith' and len(v[2]) == 1 and TypeExpr(v[2][0]) is None:
                    li.append(((str, None), ('!COND_EXPR', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', v[2][0]), ('!LOAD_BUILTIN', 'str'))), 
                               ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), v[2][0]), ret)))
                ## if len(li) == 0 and v[1] == 'startswith':
                    ## print '///', ret
                if len(li) > 0:         
                    ret = ('!COND_METH_EXPR', v[0], ret, tuple(li))
            elif TCmp(ret, v, \
                ('!PyObject_Call',  
                    ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',)))\
                    and TypeExpr(v[0]) is None: 
                di = class_and_body_meth_by_meth(v[1])
                li = []
                for t, codemethnm in di.iteritems():
                    classmeth = Is3(t, ('ClassMethod', v[1]))
                    staticmeth = Is3(t, ('StaticMethod', v[1]))
                    isoldclass = t in calc_const_old_class
                    isnewclass = t in calc_const_new_class
                    _self1 = v[0]
                    if classmeth or staticmeth:
                        continue
                    if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                        pass
                    else:
                        continue            
        
                    v2 = tuple([('CONST', x) for x in v[2]])
                    assert _self1[0] != 'PY_TYPE'
                    if isoldclass:
                        _self2 = ('PY_TYPE', T_OLD_CL_INST, t, _self1, None)
                        if is_pypy:
                           continue
                    else:    
                        _self2 = ('PY_TYPE', T_NEW_CL_INST, t, _self1, None)
                    tupl = ('!BUILD_TUPLE', (_self2,) + replace_subexpr(v2, _self1, _self2))
                    ret2 = call_calc_const(codemethnm, tupl, ret)
                    if ret2 == ret:
                        continue
        
                    li.append((_self2[1:3], ret2))
                if len(li) == 0 and v[1] == 'startswith' and type(v[2]) is tuple and len(v[2]) == 1 and type(v[2][0]) is str:
                    li.append(((str, None), ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), ('CONST', v[2][0]))))
                if len(li) == 0 and v[1] == 'endswith' and type(v[2]) is tuple and len(v[2]) == 1 and type(v[2][0]) is str:
                    li.append(((str, None), ('!_PyString_EndSwith', ('PY_TYPE', str, None, v[0], None), ('CONST', v[2][0]))))


                if len(li) > 0:         
                    ret = ('!COND_METH_EXPR', v[0], ret, tuple(li))
    return ret            
           
def generate_logical_cond_meth_expr(it, logic):
    o = Out()            
    ref_self = Expr1(it[1], o)
    PushAcc([it[1]], [ref_self])
    v = []
    if TCmp(it[2], v, ('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))): 
        exprs = [x for x in v[2]]
        refs = [Expr1(x, o) for x in exprs]
        PushAcc(exprs, refs)
        for i in range(len(it[3])):
            _self2, it2 = it[3][i]
            t2, nmclass = _self2
            if type(t2) is str:
                isnewclass = t2 == T_NEW_CL_INST
                isoldclass = t2 == T_OLD_CL_INST
                if isnewclass:
                    o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                elif isoldclass:    
                    o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                else:
                   Fatal('Not instance', _self2)
            elif t2 in type_to_check_t: #is str:
                o.Raw('if (',type_to_check_t[t2],'(', ref_self,')) {')
            else:    
                Fatal('Strange COND_METH', _self2)
            o2, logic2 = generate_logical_expr(it2, logic)
            o.extend(o2)
            assert logic2 == logic
            o.Raw('} else')  
        o.append('{')
        it_ = ('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), ('!BUILD_TUPLE', tuple(refs)), ('NULL',))
        ref1 = Expr1(it_, o)
        o, logic2 = ToTrue(o,logic,ref1, it_)
        assert logic2 == logic
        o.append('}')
        PopAcc(o)
        PopAcc(o)
        return o, logic

    if TCmp(it[2], v, ('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))): 
        exprs = [('CONST', x) for x in v[2]]
        refs = [Expr1(x, o) for x in exprs]
        PushAcc(exprs, refs)
        for i in range(len(it[3])):
            _self2, it2 = it[3][i]
            t2, nmclass = _self2
            if type(t2) is str:
                isnewclass = t2 == T_NEW_CL_INST
                isoldclass = t2 == T_OLD_CL_INST
                if isnewclass:
                    o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                elif isoldclass:    
                    o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                else:
                   Fatal('Not instance', _self2)
            elif t2 in type_to_check_t: #is str:
                o.Raw('if (',type_to_check_t[t2],'(', ref_self,')) {')
            else:    
                Fatal('Strange COND_METH', t2, it[2])
            o2, logic2 = generate_logical_expr(it2, logic)
            o.extend(o2)
            assert logic2 == logic
            o.Raw('} else')  
        o.append('{')
        it_ = ('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                ('CONST', v[2]), ('NULL',))
        ref1 = Expr1(it_, o)
        o, logic2 = ToTrue(o,logic,ref1, it_)
        assert logic2 == logic
        o.append('}')
        PopAcc(o)
        PopAcc(o)
        return o, logic                

    if it[2][0] in to_call_2 and TCmp(it[2], v, ('?', '?', '?')): # and v[0] in to_call_2:
        exprs = [x for x in v[2:]]
        refs = [Expr1(x, o) if x[0] != 'FAST' and not current_co.IsCVar(x) else x for x in exprs]
        PushAcc(exprs, refs)
        for i in range(len(it[3])):
            _self2, it2 = it[3][i]
            t2, nmclass = _self2
            if type(t2) is str:
                isnewclass = t2 == T_NEW_CL_INST
                isoldclass = t2 == T_OLD_CL_INST
                if isnewclass:
                    o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                elif isoldclass:    
                    o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                else:
                   Fatal('Not instance', _self2)
            elif t2 in type_to_check_t: #is str:
                o.Raw('if (',type_to_check_t[t2],'(', ref_self,')) {')
            else:    
                Fatal('Strange COND_METH', _self2)
            o2, logic2 = generate_logical_expr(it2, logic)
            o.extend(o2)
            assert logic2 == logic                
            o.Raw('} else')  
        o.append('{')
        it_ = (v[0], ref_self, refs[0])
        ref1 = Expr1(it_, o)
        o, logic2 = ToTrue(o,logic,ref1, it_)
        assert logic2 == logic        
        o.append('}')
        PopAcc(o)
        PopAcc(o)
        return o, logic

    if TCmp(it[2], v, ('?', '?')) and v[0] in to_call_1:
        for i in range(len(it[3])):
            _self2, it2 = it[3][i]
            t2, nmclass = _self2
            if type(t2) is str:
                isnewclass = t2 == T_NEW_CL_INST
                isoldclass = t2 == T_OLD_CL_INST
                if isnewclass:
                    o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                elif isoldclass:    
                    o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                else:
                   Fatal('Not instance', _self2)
            elif t2 in type_to_check_t: #is str:
                o.Raw('if (',type_to_check_t[t2],'(', ref_self,')) {')
            else:    
                Fatal('Strange COND_METH', _self2)
            o2, logic2 = generate_logical_expr(it2, logic)
            o.extend(o2)
            assert logic2 == logic                 
            o.Raw('} else')  
        o.append('{')
        it_ = (v[0], ref_self)
        ref1 = Expr1(it_, o)
        o, logic2 = ToTrue(o,logic,ref1, it_)
        assert logic2 == logic   
        o.append('}')
        PopAcc(o)
        return o, logic

    if it[2][0] in ('!OR_JUMP', '!AND_JUMP', '!OR_JUMPED_STACKED', '!AND_JUMPED_STACKED'):
        for i in range(len(it[3])):
            _self2, it2 = it[3][i]
            t2, nmclass = _self2
            if type(t2) is str:
                isnewclass = t2 == T_NEW_CL_INST
                isoldclass = t2 == T_OLD_CL_INST
                if isnewclass:
                    o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                elif isoldclass:    
                    o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                else:
                   Fatal('Not instance', _self2)
            elif t2 in type_to_check_t: #is str:
                o.Raw('if (',type_to_check_t[t2],'(', ref_self,')) {')
            else:    
                Fatal('Strange COND_METH', _self2)
            o2, logic2 = generate_logical_expr(it2, logic)
            o.extend(o2)
            assert logic2 == logic                 
            o.Raw('} else')  
        o.append('{')
##        it_ = (v[0], ref_self)
        ref1 = Expr1(it[2], o)
        o, logic2 = ToTrue(o,logic,ref1, it[2])
        assert logic2 == logic   
        o.append('}')
        PopAcc(o)
        return o, logic


    print it
    assert False 

def generate_cond_meth_expr_new(it, o, forcenewg, no_return): 
    ret = New(None, forcenewg)
    ref_self = Expr1(it[1], o)
    PushAcc([it[1]], [ref_self])
    v = []
    if TCmp(it[2], v, ('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))): 
        ## pprint(it)
        exprs = [x for x in v[2]]
        refs = v[2] 
        li = gen_for_all_known(it, ret, ref_self)  
        old_o = o
        o = Out()
        ret2 = GenExpr(('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                        ('!BUILD_TUPLE', tuple(refs)), ('NULL',)), o, ret)
        assert ret2 == ret
        ## pprint(o)
        ## pprint(old_o)
        join_cond_meth_call(o, li, old_o, no_return, ret)
        PopAcc(old_o)
        return ret

    if TCmp(it[2], v, ('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))): 
        exprs = [('CONST', x) for x in v[2]]
        refs = exprs 
        li = gen_for_all_known(it, ret, ref_self)  
        old_o = o
        o = Out()
        ret2 = GenExpr(('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                ('CONST', v[2]), ('NULL',)), o, ret)
        assert ret2 == ret or ret2 == ('CONST', None) ## or ret2[0] == 'CONST'
        join_cond_meth_call(o, li, old_o, no_return, ret)
        PopAcc(old_o)
        return ret                

    if it[2][0] in to_call_2 and TCmp(it[2], v, ('?', '?', '?')):
        exprs = [x for x in v[2:]]
        refs = [Expr1(x, o) if x[0] != 'FAST' and not current_co.IsCVar(x) else x for x in exprs]
        PushAcc(exprs, refs)
        li = gen_for_all_known(it, ret, ref_self)  
        old_o = o
        o = Out()
        ret2 = GenExpr((v[0], ref_self, refs[0]), o, ret)
        assert ret2 == ret or ret2 == ('CONST', None)
        join_cond_meth_call(o, li, old_o, no_return, ret)
        PopAcc(old_o)
        PopAcc(old_o)
        return ret

    if TCmp(it[2], v, ('?', '?')) and v[0] in to_call_1:
        li = gen_for_all_known(it, ret, ref_self)  
        old_o = o
        o = Out()
        ret2 = GenExpr((v[0], ref_self), o, ret)
        assert ret2 == ret or ret2 == ('CONST', None)
        join_cond_meth_call(o, li, old_o, no_return, ret)
        PopAcc(old_o)
        return ret
    
    print it
    assert False  

def join_cond_meth_call(o, li, old_o, no_return, ret):
    if no_return:
        oo = Out()
        oo.Cls(ret)
    else:
        oo = []
    for k,v in li:
        v.extend(oo)
##        optimize(v)
    o.extend(oo)
##    optimize(o)
    ## l = 0
    ## ## pprint(li)
    ## while len([1 for k,v in li if v[:l] != o[:l]]) == 0 and l < len(o):
        ## l += 1
    ## l -= 1
    ## if l > 0:
        ## old_o.extend(o[:l])
        ## o[:] = o[l:]
        ## for k,v in li:
            ## v[:] = v[l:]
        ## ## assert False
    i = 0
    for k, v in li:
        if i == 0:
            old_o.append(k)
        else:
            old_o.append('} else ' + k)
        old_o.extend(v)
        i += 1
    old_o.append('} else {')
    old_o.extend(o)
    old_o.append('}')
    
def gen_for_all_known(it, ret, ref_self):
    li = []
    for i in range(len(it[3])):
        o = Out()
        _self2, it2 = it[3][i]
        t2, nmclass = _self2
        if type(t2) is str:
            isnewclass = t2 == T_NEW_CL_INST
            isoldclass = t2 == T_OLD_CL_INST
            if isnewclass:
                o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
            elif isoldclass:    
                o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                    ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
            else:
                Fatal('Not instance', _self2)
        elif t2 in type_to_check:
            o.Raw('if (', type_to_check[t2],  '(', ref_self,')) {')
        elif t2 in type_to_check_t:
            o.Raw('if (', type_to_check_t[t2],  '(', ref_self,')) {')
        else:    
            Fatal('Strange COND_METH', _self2, t2)
        if_ = o[0]
        assert len(o) == 1
        del o[0]
        assert len(o) == 0
        ret2 = GenExpr(it2, o, ret)
        if ret2[0] == 'CONST':
            o.INCREF(ret2)
            o.Raw(ret, ' = ', ret2, ';') 
        assert ret2 == ret or ret2[0] == 'CONST' 
        li.append((if_, o))
    return li

## def generate_cond_meth_expr_new_old(it, o, forcenewg, no_return): 
    ## if no_return:
        ## ret = ('CONST', None)
    ## else:
        ## ret = New(None, forcenewg)
    ## ref_self = Expr1(it[1], o)
    ## PushAcc([it[1]], [ref_self])
    ## v = []
    ## if TCmp(it[2], v, ('!PyObject_Call', \
            ## ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))): 
        ## exprs = [x for x in v[2]]
        ## refs = v[2] #[Expr1(x, o) for x in exprs]
## #        PushAcc(exprs, refs)
        ## for i in range(len(it[3])):
            ## _self2, it2 = it[3][i]
            ## t2, nmclass = _self2
            ## if type(t2) is str:
                ## isnewclass = t2 == T_NEW_CL_INST
                ## isoldclass = t2 == T_OLD_CL_INST
                ## if isnewclass:
                    ## o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                ## elif isoldclass:    
                    ## o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ## ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                ## else:
                   ## Fatal('Not instance', _self2)
            ## elif t2 in type_to_check:
                ## o.Raw('if (', type_to_check[t2],  '(', ref_self,')) {')
            ## elif t2 in type_to_check_t:
                ## o.Raw('if (', type_to_check_t[t2],  '(', ref_self,')) {')
            ## else:    
                ## Fatal('Strange COND_METH', _self2)
            ## ret2 = GenExpr(it2, o, ret)
            ## ## pprint(('ooo', it2, o[leno-1:]))
            ## ## assert ret2 == ret or ret2 == ('CONST', None)
            ## if ret2[0] == 'CONST':
                ## o.INCREF(ret2)
                ## o.Raw(ret, ' = ', ret2, ';')            

            ## o.Raw('} else')  
        ## o.append('{')
        ## ret2 = GenExpr(('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), ('!BUILD_TUPLE', tuple(refs)), ('NULL',)), o, ret)
        ## assert ret2 == ret
        ## o.append('}')
## #        PopAcc(o)
        ## PopAcc(o)
        ## return ret

    ## if TCmp(it[2], v, ('!PyObject_Call', \
            ## ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))): 
        ## exprs = [('CONST', x) for x in v[2]]
        ## refs = exprs #v[2] #[Expr1(x, o) for x in exprs]
## #        PushAcc(exprs, refs)
        ## for i in range(len(it[3])):
            ## _self2, it2 = it[3][i]
            ## t2, nmclass = _self2
            ## if type(t2) is str:
                ## isnewclass = t2 == T_NEW_CL_INST
                ## isoldclass = t2 == T_OLD_CL_INST
                ## if isnewclass:
                    ## o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                ## elif isoldclass:    
                    ## o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ## ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                ## else:
                   ## Fatal('Not instance', _self2)
            ## elif t2 in type_to_check:
                ## o.Raw('if (', type_to_check[t2],  '(', ref_self,')) {')
            ## elif t2 in type_to_check_t:
                ## o.Raw('if (', type_to_check_t[t2],  '(', ref_self,')) {')
            ## else:    
                ## pprint(it)
                ## Fatal('Strange COND_METH', _self2)
            ## ## leno = len(o)
            ## ret2 = GenExpr(it2, o, ret)
            ## if ret2[0] == 'CONST':
                ## o.INCREF(ret2)
                ## o.Raw(ret, ' = ', ret2, ';')
            ## ## pprint(('ooo', it2, o[leno-1:], it))
            ## ## print ret2, ret
            ## assert ret2 == ret or ret2[0] == 'CONST'
            ## o.Raw('} else')  
        ## o.append('{')
        ## ret2 = GenExpr(('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                ## ('CONST', v[2]), ('NULL',)), o, ret)
        ## assert ret2 == ret or ret2 == ('CONST', None) ## or ret2[0] == 'CONST'
        ## o.append('}')
## #        PopAcc(o)
        ## PopAcc(o)
        ## return ret                

    ## if it[2][0] in to_call_2 and TCmp(it[2], v, ('?', '?', '?')): # and v[0] in to_call_2:
        ## exprs = [x for x in v[2:]]
        ## refs = [Expr1(x, o) if x[0] != 'FAST' and not current_co.IsCVar(x) else x for x in exprs]
        ## PushAcc(exprs, refs)
        ## for i in range(len(it[3])):
            ## _self2, it2 = it[3][i]
            ## t2, nmclass = _self2
            ## if type(t2) is str:
                ## isnewclass = t2 == T_NEW_CL_INST
                ## isoldclass = t2 == T_OLD_CL_INST
                ## if isnewclass:
                    ## o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                ## elif isoldclass:    
                    ## o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ## ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                ## else:
                   ## Fatal('Not instance', _self2)
            ## elif t2 in type_to_check:
                ## o.Raw('if (', type_to_check[t2],  '(', ref_self,')) {')
            ## elif t2 in type_to_check_t:
                ## o.Raw('if (', type_to_check_t[t2],  '(', ref_self,')) {')
            ## else:    
                ## Fatal('Strange COND_METH', _self2)
            ## ret2 = GenExpr(it2, o, ret)
            ## assert ret2 == ret or ret2 == ('CONST', None) 
            
            ## o.Raw('} else')  
        ## o.append('{')
        ## ret2 = GenExpr((v[0], ref_self, refs[0]), o, ret)
        ## assert ret2 == ret or ret2 == ('CONST', None)
        ## o.append('}')
        ## PopAcc(o)
        ## PopAcc(o)
        ## return ret

    ## if TCmp(it[2], v, ('?', '?')) and v[0] in to_call_1:
        ## for i in range(len(it[3])):
            ## _self2, it2 = it[3][i]
            ## t2, nmclass = _self2
            ## if type(t2) is str:
                ## isnewclass = t2 == T_NEW_CL_INST
                ## isoldclass = t2 == T_OLD_CL_INST
                ## if isnewclass:
                    ## o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
                ## elif isoldclass:    
                    ## o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                        ## ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
                ## else:
                   ## Fatal('Not instance', _self2)
            ## elif t2 in type_to_check:
                ## o.Raw('if (', type_to_check[t2],  '(', ref_self,')) {')
            ## elif t2 in type_to_check_t:
                ## o.Raw('if (', type_to_check_t[t2],  '(', ref_self,')) {')
            ## else:    
                ## Fatal('Strange COND_METH', _self2)
            ## ret2 = GenExpr(it2, o, ret)
            ## assert ret2 == ret or ret2 == ('CONST', None) 

            ## o.Raw('} else')  
        ## o.append('{')
        ## ret2 = GenExpr((v[0], ref_self), o, ret)
        ## assert ret2 == ret or ret2 == ('CONST', None)
        ## o.append('}')
        ## PopAcc(o)
        ## return ret

    ## print it
    ## assert False
    
def upgrade_repl(ret, nm = None):    
    ## v = []    
    ret = repl_collected_module_attr(ret)    
    ret = repl(ret) 
    return ret        

def collect_type_return(ret, nm):    
    global type_def
    ## v = []    
    if type(ret) is tuple and len(ret) == 2 and type(ret[0]) is str and ret[0] == 'RETURN_VALUE':
        if nm not in type_def:
            type_def[nm] = {}
        type_def[nm][TypeExpr(ret[1])] = True
    return ret      

def attempt_module_import_1(nm):
    try:
        if nm == filename[:-3]:
            return None
        this = __import__(nm)
        d = this.__dict__
        return this, d
    except:
        Debug('Module %s import unsuccessful1' % nm)     
        return None

def old_class_1(v):
    try:
        return (T_OLD_CL_INST, v.__class__.__name__)
    except:
        pass
    return None

def collect_module_type_attr(nm, acc = []):
    d = None
    if type(nm) is types.ModuleType:
        this = nm
        d = this.__dict__
    elif nm in sys.modules:    
        this = sys.modules[nm]
        d = this.__dict__
    else:
        ret_ret = attempt_module_import_1(nm)
        if ret_ret is None:
            return
        this, d = ret_ret
    if type(this) is types.ModuleType and this in acc:
        return   
    acc.append(this)
    for k in d.keys():
        v = getattr(this, k)
        if type(v) is types.ModuleType and v == this:
            continue
        t = type(v)
        if t is types.ModuleType:
            collect_module_type_attr(v, acc) 
        if t is types.InstanceType:
            t2 = old_class_1(v)
            if t2 is not None:
                t = t2
        else:
            if type(t) != type:
                t = (T_NEW_CL_INST, v.__class__.__name__)
            else:    
                t = (t, None)    
        if k not in self_attr_type:
            pass
        else:
            self_attr_type[k][t] = True  

def collect_set_attr(ret, nm):    
    global self_attr_type

    v = []  

    if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'STORE':
        if nm != 'Init_filename':
            if TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
                if v[0] not in self_attr_type:
                    self_attr_type[v[0]] = {}
                self_attr_type[v[0]][TypeExpr(v[1])] = True  

        if TCmp(ret, v, ('STORE', (('PyObject_SetAttr', '?', ('CONST', '?')),), ('?',))):
            if v[1] not in self_attr_type:
                self_attr_type[v[1]] = {}
            self_attr_type[v[1]][TypeExpr(v[2])] = True  
        elif TCmp(ret, v, ('STORE', (('SET_VARS', '?'),), ( '?',))):
            if len(v[1]) > 0 and (v[1][0] in tags_one_step_expr or v[1][0][0] == '!'):
                for set2 in v[0]:
                    v2 = []
                    if TCmp(set2, v2, ('PyObject_SetAttr', '?', ('CONST', '?'))):
                        if v2[1] not in self_attr_type:
                            self_attr_type[v2[1]] = {}
                        self_attr_type[v2[1]][None] = True  
            else:
                Fatal('Unhandled SetAttr in SET_VARS', ret)
        elif TCmp(ret, v, ('STORE', '?', '?')):
            [ collect_module_type_attr (expr[1]) for expr in v[1] if expr[0] == '!IMPORT_NAME']
            if len(v[0]) == 1 and (type(v[0][0][0]) is int or v[0][0][0][0:6] == 'STORE_'):
                pass
            elif len(v[0]) == 1 and v[0][0][0] == 'PyObject_SetItem':
                pass
            elif len(v[0]) == 1 and v[0][0][0] == '?PyObject_SetAttr':
                pass ##Debug('Variable arg PyObject_SetAttr', ret)
            elif len(v[0]) == 1 and v[0][0][0] == 'PyObject_SetAttr':
                pass ##Debug('Variable arg PyObject_SetAttr', ret)
            elif len(v[0]) == 1 and v[0][0][0] == 'UNPACK_SEQ_AND_STORE' and v[0][0][1] == 0:  
                for set2 in v[0][0][2]:              
                    v2 = []
                    if TCmp(set2, v2, ('PyObject_SetAttr', '?', ('CONST', '?'))):
                        if v2[1] not in self_attr_type:
                            self_attr_type[v2[1]] = {}
                        self_attr_type[v2[1]][None] = True  
            else:
                Fatal('Unhandled STORE', ret)
    return ret    

def collect_default_args(ret, nm):    
    global default_args
    if type(ret) is tuple and len(ret) >= 3:
        if ret[0] == '!MK_FUNK':
            default_args[ret[1]] = ret[2]            
    return ret    

global_type = {}
detected_global_type = {}

def collect_set_global(ret, nm):    
    global global_type
    v = []  
    if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'STORE':
        if nm == 'Init_filename' and TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
            if v[0] not in global_type:
                global_type[v[0]] = {}
            global_type[v[0]][TypeExpr(v[1])] = v[1] 
            if TypeExpr(v[1]) is None:
                Debug('Not detected type %s for %s' % (v[0], v[1]))
            return ret
        v = []  
        if nm != 'Init_filename' and TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
            return ret
        v = []
        if TCmp(ret, v, ('STORE', (('STORE_GLOBAL', '?'),), ('?',))):
            if v[0] not in global_type:
                global_type[v[0]] = {}
            global_type[v[0]][TypeExpr(v[1])] = v[1]  
            if TypeExpr(v[1]) is None:
                Debug('Not detected type %s for %s' % (v[0], v[1]))
            return ret
        if TCmp(ret, v, ('STORE', (('STORE_FAST', '?'),), ('?',))):
            return ret
        v = []
        if TCmp(ret, v, ('STORE', (('SET_VARS', '?'),), ('?',))):
            t = TypeExpr(v[1])
            for i, s in enumerate(v[0]):
                if s[0] == 'STORE_GLOBAL':
                    if s[1] not in global_type:
                        global_type[s[1]] = {}
                    if IsTuple(t) and t[1] is not None and i < len(t[1]):
                        global_type[s[1]][t[1][i]] = True                  
                        if t[1][i] is None:
                            Debug('Not detected type %s for %s' % (s[0], ret))
                    else:
                        global_type[s[1]][None] = True                  
            return ret
        v = []
        if len(ret[1]) == 1 and ret[1][0][0] == 'STORE_CALC_CONST': ##TCmp(ret, v, ('STORE', (('STORE_CALC_CONST', '?'),), '?')):
            return ret
    v = []
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and \
        (ret[0][0] == '!' or \
         ret[0] in ('(IF', ')IF', '(WHILE', ')WHILE', \
                    ')(ELSE', 'RETURN', 'SET_VARS', 'UNPUSH')):
        return ret
    v = []
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is tuple:
        return ret
    v = []
    if TCmp(ret, v, ('CALC_CONST', '?')):
        return ret
    v = []
    if TCmp(ret, v, ('CONST', '?')):
        return ret
    v = []
    if TCmp(ret, v, (('CONST', '?'),)):
        return ret    
    v = []
    if TCmp(ret, v, ('STORE_GLOBAL', '?')):
        return ret
    v = []
    if TCmp(ret, v, ('STORE_NAME', '?')):
        return ret
    v = []
    if TCmp(ret, v, ('STORE_CALC_CONST', '?')):
        return ret
    v = []
    if TCmp(ret, v, (('STORE_GLOBAL', '?'),)):
        return ret
    v = []
    if TCmp(ret, v, (('STORE_CALC_CONST', '?'),)):
        return ret
    v = []
    if type(ret) is tuple and len(ret) == 3 and type(ret[0]) is str and \
        ret[0] == 'SET_EXPRS_TO_VARS' and \
        TCmp(ret, v, ('SET_EXPRS_TO_VARS', '?', '?')):
        for i, _v1 in enumerate(v[0]):
            _v2 = v[1][i]
            if _v1[0] == 'STORE_GLOBAL':
                if _v1[1] not in global_type:
                    global_type[_v1[1]] = {}
                global_type[_v1[1]][None] = None 
            collect_set_global(_v2, nm)
        return ret
    v = []
    if len(ret) > 0 and type(ret[0]) is str and ret[0] == '(FOR':
        sets = ret[1]
        for sets in ret[1]:
            if sets[0] == 'STORE_GLOBAL':
                if sets[1] not in global_type:
                    global_type[sets[1]] = {}
                global_type[sets[1]][None] = True  
                Debug('Not detected FOR type %s for %s' % (sets[1], ret))
        return ret                
        ## if TCmp(ret, v, ('(FOR', (('STORE_GLOBAL', '?'),), '?')):
            ## if v[0] not in global_type:
                ## global_type[v[0]] = {}
            ## global_type[v[0]][None] = True  
            ## Debug('Not detected FOR type %s for %s' % (v[0], v[1]))
            ## return ret
    v = []
    if type(ret) is tuple and 'STORE_GLOBAL' in repr(ret):
        print '<', ret, '>'
        Fatal('Can\'t collect type global variables', ret) 

    return ret    

local_type = {}

def not_loc_detec(nm, expr):
    Debug('def %s, var %s -- local type not detected (%s)' % (current_co.co_name, nm, expr))

def loc_detec(nm, typ, expr):
    Debug('def %s, var %s -- local type %s detected (%s)' % (current_co.co_name, nm, typ, expr))
 
def loc_type_set(nm, typ, expr):
    global local_type
    if nm not in local_type:
        local_type[nm] = {}
    local_type[nm][typ] = expr  
    if typ is None:
        not_loc_detec(nm, expr)    
    else:
        loc_detec(nm, typ, expr)    
def collect_set_local(a, nm):
    global local_type
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return
        if len(a) >= 1 and type(a[0]) is tuple:
            for i in a:
                collect_set_local(i, nm)
#            [collect_set_local(i, nm) for i in a]
            return
        if len(a) >= 1 and type(a[0]) is str and a[0] in ('!AND_BOOLEAN', '!OR_BOOLEAN'):
            for i in a:
                collect_set_local(i, nm)
            return
#            [collect_set_local(i, nm) for i in a]
        if len(a) >= 1 and type(a[0]) is str and a[0] == '!PyObject_Call':
            collect_set_local(a[1], nm)
            if a[2][0] == '!BUILD_TUPLE':
                for i in a[2][1]:
                    collect_set_local(i, nm)
            if a[3] != ('NULL',):
                collect_set_local(a[3], nm)
#            [collect_set_local(i, nm) for i in a]
            return
        v = []  
        ret = a
        if len(ret) == 2 and type(ret[0]) is str and ret[0] in ('RETURN_VALUE', '(IF', '(WHILE', 'UNPUSH', 'PRINT_ITEM_1', '!BOOLEAN'):
            collect_set_local(ret[1], nm)
            return
        if len(ret) == 3 and type(ret[0]) is str and ret[0] in ('PRINT_ITEM_TO_2',):
            collect_set_local(ret[1], nm)
            collect_set_local(ret[2], nm)
            return
        if len(ret) == 3 and type(ret[0]) is str and ret[0] in ('(IF', '(WHILE'):
            collect_set_local(ret[1], nm)
            return
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'PYAPI_CALL':
            temp = ret[1]
            for x in temp[1:]:
                if type(x) is tuple:
                    collect_set_local(x, nm)
#            [collect_set_local(x, nm)  for x in temp[1:] if type(x) is tuple]
            return
        if len(ret) > 2 and type(ret[0]) is str and ret[0] == 'RAISE_VARARGS_STMT' and ret[1] == 0:
            for x in ret[2:]:
                if type(x) is tuple:
                    collect_set_local(x, nm)
#            [collect_set_local(x, nm)  for x in ret[2:] if type(x) is tuple]
            return
        if len(ret) > 2 and type(ret[0]) is str and ret[0] == 'RAISE_VARARGS' and ret[1] == 0:
            for x in ret[2:]:
                if type(x) is tuple:
                    collect_set_local(x, nm)
#            [collect_set_local(x, nm)  for x in ret[2:] if type(x) is tuple]
            return
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'DELETE_FAST':
            loc_type_set(ret[1], None, ret)
            return
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'STORE':
            if TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_GLOBAL', '?'),), ('?',))):
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_DEREF', '?'),), ('?',))):
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('PyObject_SetItem', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('PyObject_SetAttr', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+3', '?', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                collect_set_local(v[3], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+2', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+1', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+0', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_FAST', '?'),), ('?',))):
                loc_type_set(v[0], TypeExpr(v[1]), v[1])
                collect_set_local(v[1], nm)
                return
 
            if TCmp(ret, v, ('STORE', (('SET_VARS', '?'),), ('?',))):
                t = TypeExpr(v[1])
                for i, s in enumerate(v[0]):
                    if s[0] == 'STORE_FAST':
                        if IsTuple(t) and t[1] is not None and i < len(t[1]):
                            loc_type_set(s[1], t[1][i], ret)
                        else:
                            loc_type_set(s[1], None, ret)
                collect_set_local(v[1], nm)
                return

            v = []
            if TCmp(ret, v, ('STORE', (('STORE_CALC_CONST', '?'),), '?')):
                collect_set_local(v[1], nm)
                return
            v = []
            if TCmp(ret, v, ('STORE', (('UNPACK_SEQ_AND_STORE', '?', '?'),), ('?',))):    
                t = TypeExpr(v[2])
                for i, s in enumerate(v[1]):
                    if s[0] == 'STORE_FAST':
                        if IsTuple(t) and t[1] is not None and i < len(t[1]):
                            loc_type_set(s[1], t[1][i], ret)
                        else:
                            loc_type_set(s[1], None, ret)
                collect_set_local(v[2], nm)
                return

        if type(ret) is tuple and len(ret) == 3 and type(ret[0]) is str and \
           ret[0] == 'SET_EXPRS_TO_VARS' and \
           TCmp(ret, v, ('SET_EXPRS_TO_VARS', '?', '?')):
            for i, _v1 in enumerate(v[0]):
                ## _v2 = v[1][i]
                if _v1[0] == 'STORE_FAST':
                    loc_type_set(_v1[1], TypeExpr(v[1][i]), v[1][i])
            collect_set_local(v[1], nm)
            return
        if type(ret) is tuple and len(ret) == 3 and type(ret[0]) is str and \
           ret[0] == 'SEQ_ASSIGN' and \
           TCmp(ret, v, ('SEQ_ASSIGN', '?', '?')):
            t = TypeExpr(v[1])
            for i, _v1 in enumerate(v[0]):
                if _v1[0] == 'STORE_FAST':
                    loc_type_set(_v1[1], t, v[1])
            collect_set_local(v[1], nm)
            return
    
        v = []
        if type(ret) is tuple and len(ret) >1 and type(ret[0]) is str and \
           ret[0] == ')(EXCEPT':
            if TCmp(ret, v, (')(EXCEPT', ('?', '?'), (('STORE_FAST', '?'),))) and type(v[1]) is int:
                collect_set_local(v[0], nm)
                loc_type_set(v[2], None, ret)
                return
            v = []
            if TCmp(ret, v, (')(EXCEPT', ('?',), (('STORE_FAST', '?'),))) :
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
        v = []
        if type(ret) is tuple and len(ret) >1 and type(ret[0]) is str and \
           ret[0] == '(WITH':
            if TCmp(ret, v, ('(WITH', '?', ('STORE_FAST', '?'))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            v = []
            if TCmp(ret, v, ('(WITH', '?', (('STORE_FAST', '?'),))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            v = []
            if TCmp(ret, v, ('(WITH', '?', ('STORE_DEREF', '?'))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            v = []
            if TCmp(ret, v, ('(WITH', '?', (('STORE_DEREF', '?'),))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            v = []            
            if TCmp(ret, v, ('(WITH', '?', (('SET_VARS', '?'),))):    
                collect_set_local(v[0], nm)
                for k in v[1]:
                    if type(k) is tuple and len(k) == 2 and k[0] == 'STORE_FAST':
                        loc_type_set(k[1], None, ret)
                return            
            v = []
            if TCmp(ret, v, ('(WITH', '?', ('SET_VARS', '?'))):    
                collect_set_local(v[0], nm)
                for k in v[1]:
                    if type(k) is tuple and len(k) == 2 and k[0] == 'STORE_FAST':
                        loc_type_set(k[1], None, ret)
                return
            if TCmp(ret, v, ('(WITH', '?', ())):    
                collect_set_local(v[0], nm)
                return
            Fatal('Can\'t collect type local variables WITH', ret) 
        v = []
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '(FOR':
            if len(ret[1]) == 2 and len(ret[1][0]) == 2 and ret[1][0][0] == 'STORE_FAST':
                if TCmp(ret, v, ('(FOR', (('STORE_FAST', '?'), '?'), 
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), \
                                    '?', ('NULL',)))):
                    loc_type_set(v[0], Kl_Int, ret)
                    if v[1][0] == 'STORE_FAST':
                        loc_type_set(v[1][1], None, v[2])
                    elif v[1][0] == 'UNPACK_SEQ_AND_STORE' and v[1][1] == 0:
                        t = TypeExpr(v[2])
                        for i, v5 in enumerate(v[1][2]):   
                            if v5[0] == 'STORE_FAST':
                                if IsTuple(t) and t[1] is not None and i < len(t[1]):
                                    loc_type_set(v5[1], t[1][i], ret)
                                else:
                                    loc_type_set(v5[1], None, ret)
                            else:    
                                if type(v5) is tuple: # and 'STORE_FAST' in repr(v5):
                                    print '<', v5, ':', ret, '>'
                                    Fatal('Can\'t collect FOR unpack type local variables', v5, ret)  
                    return
            if len(ret[1]) == 1 and len(ret[1][0]) == 2 and ret[1][0][0] == 'STORE_FAST':
                v = [ret[1][0][1], ret[2]] ##if TCmp(ret, v, ('(FOR', (('STORE_FAST', '?'),), '?')):
                v2 = []
                if  v[1][0] == '!PyObject_Call' and 'range' in repr(v[1]):
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int, int)), \
                                    ('NULL',))) or \
                        TCmp(v[1], v2, \
                                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int, int)), \
                                        ('NULL',))) or \
                        TCmp(v[1], v2, \
                                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int,)), \
                                        ('NULL',))) or \
                        TCmp(v[1], v2, \
                                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int,)), \
                                        ('NULL',))):
                        loc_type_set(v[0], Kl_Int, True)
                        collect_set_local(v[1], nm)
                        return
                    v2 = []                             
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                                    ('CONST', ('?',)), ('NULL',))):
                        if v2[0] is int:
                            loc_type_set(v[0], Kl_Int, True)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                                    ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        loc_type_set(v[0], Kl_Int, True)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                                    ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
                        t = TypeExpr(v2[0])
                        t2 = TypeExpr(v2[1])
                        if t is None and t2 is None:
                            loc_type_set(v[0], Kl_IntUndefSize, True)
                        else:    
                            if t2 is None:
                                loc_type_set(v[0], Kl_IntUndefSize, True)
                            else:    
                                loc_type_set(v[0], t, ret)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), \
                                    ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        t = TypeExpr(v2[0])
                        if t is None:
                            loc_type_set(v[0], Kl_IntUndefSize, True)
                        else:    
                            loc_type_set(v[0], t, ret)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), \
                                    ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
                        t = TypeExpr(v2[0])
                        t2 = TypeExpr(v2[1])
                        if t is None and t2 is None:
                            loc_type_set(v[0], Kl_IntUndefSize, True)
                        else:    
                            if t2 is None:
                                loc_type_set(v[0], Kl_IntUndefSize, True)
                            else:    
                                loc_type_set(v[0], t, ret)
                        collect_set_local(v[1], nm)
                        return
                loc_type_set(v[0], None, ret)
                collect_set_local(v[1], nm)
                return
            v = []
            if TCmp(ret, v, ('(FOR', '?', '?')):
                for _v in v[0]:
                    if type(_v) is tuple and _v[0] == 'STORE_FAST':
                        loc_type_set(_v[1], None, ret)
                    elif type(_v) is tuple and _v[0] == 'STORE_GLOBAL':
                        pass
                    elif type(_v) is tuple and _v[0] == 'STORE_NAME':
                        pass
                    elif type(_v) is tuple and _v[0] == 'STORE_DEREF':
                        loc_type_set(_v[1], None, ret)            
                    elif type(_v) is tuple and _v[0] == 'PyObject_SetAttr':
                        pass
                    elif type(_v) is tuple and _v[0] == 'UNPACK_SEQ_AND_STORE' and _v[1] == 0:
                        for v5 in _v[2]:   
                            if v5[0] == 'STORE_FAST':
                                loc_type_set(v5[1], None, ret)
                            else:    
                                if type(v5) is tuple: # and 'STORE_FAST' in repr(v5):
                                    print '<', v5, ':', ret, '>'
                                    Fatal('Can\'t collect FOR unpack type local variables', v5, ret) 
                    else:    
                        if type(_v) is tuple: # and 'STORE_FAST' in repr(_v):
                            print '<', _v, ':', ret, '>'
                            Fatal('Can\'t collect FOR type local variables', _v, ret) 
                collect_set_local(v[1], nm)
                return
    
        v = []
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!LIST_COMPR':
#            print ret
            if TCmp(ret, v, ('!LIST_COMPR', '?', '?')):
                varset = False
                if len(v[1][0]) == 1 and len(v[1][1]) == 1:
                    stor, expr = v[1][0][0], v[1][1][0]
                    if stor[0] == 'STORE_FAST':
                        v2 = []
                        if TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                            loc_type_set(stor[1], Kl_Int, True)
                            varset = True
                        elif TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', '?'), ('NULL',))):
                            loc_type_set(stor[1], Kl_Int, True)
                            varset = True
                temp = v[1]
                v = [v[0],None,None, None]
                collect_set_local(v[0], nm)
                while len(temp) > 0:
                    v[1:] = temp[:3]
                    temp = temp[3:]
                    
                    for _v in v[1]:
                        if type(_v) is tuple and _v[0] == 'STORE_FAST' and not varset:
                            loc_type_set(_v[1], None, ret)
                    collect_set_local(v[2], nm)
                    collect_set_local(v[3], nm)
                return
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!SET_COMPR':
            if TCmp(ret, v, ('!SET_COMPR', '?', '?')):
                temp = v[1]
                v = [v[0],None,None, None]
                collect_set_local(v[0], nm)
                while len(temp) > 0:
                    v[1:] = temp[:3]
                    temp = temp[3:]
                    
                    for _v in v[1]:
                        if type(_v) is tuple and _v[0] == 'STORE_FAST':
                            loc_type_set(_v[1], None, ret)
                    collect_set_local(v[2], nm)
                    collect_set_local(v[3], nm)
                return  
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!MAP_COMPR':
            if TCmp(ret, v, ('!MAP_COMPR', '?', '?')):
                temp = v[1]
                v = [v[0],None,None, None]
                collect_set_local(v[0], nm)
                while len(temp) > 0:
                    v[1:] = temp[:3]
                    temp = temp[3:]
                    
                    for _v in v[1]:
                        if type(_v) is tuple and _v[0] == 'STORE_FAST':
                            loc_type_set(_v[1], None, ret)
                    collect_set_local(v[2], nm)
                    collect_set_local(v[3], nm)
                return                        
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!COND_METH_EXPR':
            if TCmp(ret, v, ('!COND_METH_EXPR', '?', '?', '?')):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                return          
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'IMPORT_FROM_AS':
            collect_set_local(ret[2], nm)
            collect_set_local(ret[3], nm)
            for _v in ret[4]:
                if _v[0] == 'STORE_FAST':
                    loc_type_set(_v[1], None, ret)
                elif _v[0] == 'STORE_CALC_CONST':
                    return     
                elif _v[0] == 'STORE_NAME':
                    return                                    
                else:    
                    if type(_v) is tuple: # and 'STORE_FAST' in repr(_v):
                        print '<', _v, ':', ret, '>'
                        Fatal('Can\'t collect FOR type local variables', _v, ret)    
            return
#        repr_ret = repr(ret)
        if type(ret) is tuple and len(ret) > 0: # and 'STORE_FAST' in repr_ret:
            if ret[0] == 'PY_TYPE':
                collect_set_local(ret[3], nm)
                return
            if ret[0] in ('DELETE_SUBSCR',):
                collect_set_local(ret[1], nm)
                collect_set_local(ret[2], nm)
                return
            if type(ret[0]) is str:
                return
            if ret[0] in ('(TRY', ')ENDTRY', '.L', 'CALC_CONST', 'NULL', 'FAST'):
                return
            if type(ret[0]) is not str or ret[0][0] != '!':
                pprint(ret)
                print '<', ret, '>'
                pprint(ret)
                Fatal('Can\'t collect type local variables', ret) 
                return   

        for i in a:
            collect_set_local(i, nm)
#        [collect_set_local(i, nm) for i in a]
        return 
    if type(a) is list:
        assert len(a) > 0
##        pprint(a) 
        for i in a:
            collect_set_local(i, nm)
#        [collect_set_local(i, nm) for i in a]
    return 

  
def tree_pass(a, upgrade_op, up, nm): 
    global print_tree_node
    if print_tree_node:
        print '>> tree_pass', nm, sys.getrefcount(a)
        pprint(a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        while True:   
            r = tuple([tree_pass(v, upgrade_op,a, nm) for v in a])
            notchanged = len(r) == len(a) and all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                if print_tree_node:
                    print '/1', sys.getrefcount(a), sys.getrefcount(r)
                r = a
            r2 = upgrade_op(r,nm)
            notchanged = notchanged and r2 == r 
            if notchanged:
                break
            a = r2
        return r
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            r = [tree_pass(v, upgrade_op, a, nm) for v in a]
            notchanged = len(r) == len(a) and all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                if print_tree_node:
                    print '/2', sys.getrefcount(a), sys.getrefcount(r)
                r = a
            assert len(r) > 0
            r2 = upgrade_op(r,nm)
            notchanged = notchanged and r2 == r 
            if notchanged:
                break
            a = r2
        return r
    return a

def tree_pass_upgrade_repl(a, up, nm): 
    global print_tree_node
    if print_tree_node:
        print '>> tree_pass_upgrade_repl', nm, sys.getrefcount(a)
        pprint(a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        while True:   
            r = tuple([tree_pass_upgrade_repl(v,a, nm) for v in a])
            notchanged = len(r) == len(a) and all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                if print_tree_node:
                    print '/1', sys.getrefcount(a), sys.getrefcount(r)
                r = a
            r2 = upgrade_repl(r,nm)
            notchanged = notchanged and r2 == r 
            if notchanged:
                break
            a = r2
        return r
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            r = [tree_pass_upgrade_repl(v, a, nm) for v in a]
            notchanged = len(r) == len(a) and all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                if print_tree_node:
                    print '/2', sys.getrefcount(a), sys.getrefcount(r)
                r = a
            assert len(r) > 0
            r2 = upgrade_repl(r,nm)
            notchanged = notchanged and r2 == r 
            if notchanged:
                break
            a = r2
        return r
    return a

def tree_pass_upgrade_op2(a, up, nm): 
    global print_tree_node
    if print_tree_node:
        print '>> tree_pass_upgrade_op2', nm, sys.getrefcount(a)
        pprint(a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        while True:   
            r = tuple([tree_pass_upgrade_op2(v,a, nm) for v in a])
            notchanged = len(r) == len(a) and all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                if print_tree_node:
                    print '/1', sys.getrefcount(a), sys.getrefcount(r)
                r = a
            r2 = upgrade_op2(r,nm)
            notchanged = notchanged and r2 == r 
            if notchanged:
                break
            a = r2
        return r
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            r = [tree_pass_upgrade_op2(v, a, nm) for v in a]
            notchanged = len(r) == len(a) and all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                if print_tree_node:
                    print '/2', sys.getrefcount(a), sys.getrefcount(r)
                r = a
            assert len(r) > 0
            r2 = upgrade_op2(r,nm)
            notchanged = notchanged and r2 == r 
            if notchanged:
                break
            a = r2
        return r
    return a

## def tree_pass_old(a, upgrade_op, up, nm): 
    ## global print_tree_node
    ## if print_tree_node:
        ## print '>> tree_pass', nm
        ## pprint(a)
    ## if type(a) is tuple:
        ## if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            ## return a
        ## while True:   
            ## r = tuple([tree_pass(i, upgrade_op,a, nm) for i in a])
            ## notchanged = len(r) == len(a) and all([r[i] is a[i] for i,x in enumerate(r)])
            ## if notchanged:
                ## r = a
            ## r2 = upgrade_op(r,nm)
            ## notchanged = notchanged and r2 == r 
            ## if notchanged:
                ## break
            ## a = r2
        ## return r
    ## if type(a) is list:
        ## assert len(a) > 0 
        ## while True:   
            ## a = repl_list(a,up) 
            ## r = [tree_pass(i, upgrade_op, a, nm) for i in a]
            ## notchanged = len(r) == len(a) and all([r[i] is a[i] for i,x in enumerate(r)])
            ## if notchanged:
                ## r = a
            ## assert len(r) > 0
            ## r2 = upgrade_op(r,nm)
            ## notchanged = notchanged and r2 == r 
            ## if notchanged:
                ## break
            ## a = r2
        ## return r
    ## return a
def tree_pass_readonly(a, up, nm):
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return
        fill_direct_args(a,nm)
        [tree_pass_readonly(i, a, nm) for i in a]
        return
    elif type(a) is list:
        if len(a) <= 0:
            pprint((up, nm))
        assert len(a) > 0  
        [tree_pass_readonly(i, a, nm) for i in a]
    return

def ortogonal(a, upgrade,up=None):
    if type(a) is tuple:
        if len(a) > 0 and a[0] == 'CONST':
            return a
        r = tuple([ortogonal(i, upgrade,a) for i in a])
        if all([r[i] is a[i] for i,x in enumerate(r)]):
            r = a
        while True:   
            r2 = upgrade(r)
            if r2 == r:
                break
            r = r2
        return r
    if type(a) is list:
        a = repl_list(a,up)
        r = [ortogonal(i, upgrade, a) for i in a]
        if all([r[i] is a[i] for i,x in enumerate(r)]):
            r = a
        while True:   
            r2 = upgrade(r)
            if r2 == r:
                break
            r = r2
        return r
    return a
  
def eqexpr(a,b):
    if type(a) is list:
        if type(b) is list and len(a) == len(b):
            for i, v in enumerate(a):
                if not eqexpr(v, b[i]):
                    return False
            return True
        return False
    elif type(a) is tuple:
        if type(b) is tuple and len(a) == len(b):
            for i, v in enumerate(a):
                v2 = b[i]
                if type(v) == str and type(v2) == str and v != v2:
                    return False
                if type(v) == int and type(v2) == int and v != v2:
                    return False
                if type(v) == bool and type(v2) == bool and v != v2:
                    return False
                if type(v) == tuple and type(v2) == tuple and len(v) != len(v2):
                    return False
                if type(v) != type(v2):
                    return False
                if not eqexpr(v, v2):
                    return False
            return True
        return False
    elif type(a) == str and type(b) == str:
        return a == b
    elif type(a) == int and type(b) == int:
        return a == b
    elif type(a) == bool and type(b) == bool:
        return a is b
    elif type(a) == type(b) and a == b:
        return True
    return False
  
def replace_subexpr(a,b,c):
    ## print '/1', a
    ## print '/2', b
    ## print '/3', c
    if type(b) is not tuple or type(c) is not tuple:
        Fatal('At replace subexe is not tuple', b, c, a)
        return a
    if type(a) is tuple and type(b) is tuple and type(c) is tuple:
        if c[0] == 'PY_TYPE' and c[3][0] == 'PY_TYPE':
            Fatal('Nested PY_TYPE', b, c)
        if c[0] == 'PY_TYPE' and b[0] == 'PY_TYPE':
            Fatal('replaced PY_TYPE', b, c)
        if len(a) > 3 and type(a[0]) is str and a[0] == 'PY_TYPE' and a[3] == b and \
           len(c) == 2 and c[0] == 'CONST':
            return c    
        if len(a) == len(b) and type(a[0]) == type(b[0]) and a[0] == b[0] and eqexpr(a,b):
            return c
        if a is c:
            return a
        if len(c) >= 4 and type(c[0]) is str and \
            c[0] == 'PY_TYPE' and len(a) >= 4 and \
            len(a) >= 4 and type(a[0]) is str and a[0] == 'PY_TYPE' and a[3] == b:
            return c
        
        if len(a) == len(c) and type(a[0]) == type(c[0]) and a[0] == c[0] and eqexpr(a,c):
            return a
        return tuple([replace_subexpr(i,b,c) for i in a])
    if type(a) is list:
        return [replace_subexpr(i,b,c) for i in a]
    return a    

def replace_fastvar(a, d):
    ## print '/1', a
    ## print '/2', b
    ## print '/3', c
    if type(a) is tuple and len(a) > 3 and a[0] == 'PY_TYPE' and a[3] in d:
        new = d[a[3]]
        if new[0] == 'PY_TYPE':
            t1 = list(a)
            t2 = list(new)
            t1[3] = None
            t2[3] = None
            if t1 == t2:
                return new
            if t1 != t2:
                Fatal('Illegal replace typed arg', a, new)
    if type(a) is tuple and len(a) == 2 and a[0] == 'FAST':
        return d[a[1]]
    if type(a) is tuple:
        return tuple([replace_fastvar(i,d) for i in a])
    if type(a) is list:
        return [replace_fastvar(i,d) for i in a]
    return a    

    
def is_expandable_enumerate(iter):
    if not enumerate2for:
        return False
    v = []
    return TCmp(iter, v, ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), \
                                            ('!BUILD_TUPLE', ('?',)), \
                                            ('NULL',)))
    
def generate_list_compr_enumerate(acc, val, store_ind, store_val, enumerated, cond, o): 
    assert cond is None or len(cond) == 1 
    ref_expr = Expr1(enumerated, o)
    t = TypeExpr(enumerated)
    if t is not None:
        Debug('Known type enumerate list complete', t, enumerated)
    ref_iter = New()
    n_iter = New('long')
    o.Stmt(ref_iter, '=', 'PyObject_GetIter', ref_expr)
    Cls1(o, ref_expr)
    o.Stmt(n_iter, '=', 0)
    o.append('for (;;) {')
    ref_temp = New()
    o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref_temp, '){ break; }')
    generate_store(store_val, ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  
    ref_int = New()
    o.PushInt(ref_int, n_iter)   
    generate_store(store_ind, ref_int, o, ('PyInt_FromSsize_t', n_iter))
    Cls1(o, ref_int)
    o.Stmt(n_iter, '++')
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    o.Stmt('PyList_Append', acc, ref_val)
    Cls1(o, ref_val)
    if cond is not None:
        o.append('}')
        Cls1(o, cond_var)
    o.append('}')
    o.Cls(ref_iter, n_iter, ref_expr)

def generate_list_compr_iteritems(acc, val, store_1, store_2, dic, cond, o): 
    assert cond is None or len(cond) == 1 
    ref_expr = Expr1(dic, o)
    
    pos = New('Py_ssize_t')
    o.Stmt(pos, '=', 0)
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', ref_expr, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(store_1, k, o, 'PyDict_Next')
    generate_store(store_2, v, o, 'PyDict_Next')
    o.Cls(k,v)
 
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    o.Stmt('PyList_Append', acc, ref_val)
    Cls1(o, ref_val)
    if cond is not None:
        o.append('}')
        Cls1(o, cond_var)
    o.append('}')
    o.Cls(pos, ref_expr)

def generate_list_compr_iterkeys(acc, val, store, dic, cond, o): 
    assert cond is None or len(cond) == 1 
    ref_expr = Expr1(dic, o)
    
    pos = New('Py_ssize_t')
    o.Stmt(pos, '=', 0)
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', ref_expr, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(store, k, o, 'PyDict_Next')
    o.Cls(k,v)
 
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    o.Stmt('PyList_Append', acc, ref_val)
    Cls1(o, ref_val)
    if cond is not None:
        o.append('}')
        Cls1(o, cond_var)
    o.append('}')
    o.Cls(pos, ref_expr)

def generate_list_compr_itervalues(acc, val, store, dic, cond, o): 
    assert cond is None or len(cond) == 1 
    ref_expr = Expr1(dic, o)
    
    pos = New('Py_ssize_t')
    o.Stmt(pos, '=', 0)
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', ref_expr, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(store, v, o, 'PyDict_Next')
    o.Cls(k,v)
 
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    o.Stmt('PyList_Append', acc, ref_val)
    Cls1(o, ref_val)
    if cond is not None:
        o.append('}')
        Cls1(o, cond_var)
    o.append('}')
    o.Cls(pos, ref_expr)

def generate_list_compr(val, descr_compr, o, forcenewg):
    global current_co
    prev_compr = current_co.list_compr_in_progress
    current_co.list_compr_in_progress = True
    acc0 = GenExpr(('!BUILD_LIST', ()),o, forcenewg)
    store,expr,cond = descr_compr[0:3]

    v = []
    if len(descr_compr) == 3 and len(store) == 2 and len(expr) == 1 and \
        TCmp(descr_compr, v, (('?', '?'), (('!PyObject_Call', \
        ('!PyObject_GetAttr', '?', ('CONST', 'iteritems')), \
        ('CONST', ()), \
        ('NULL',)),), \
        '?')) and IsDict(TypeExpr(v[2])):    
        generate_list_compr_iteritems(acc0, val, store[0], store[1], v[2], cond, o)
        return acc0                             
    if len(descr_compr) == 3 and len(store) == 1 and len(expr) == 1 and \
        TCmp(descr_compr, v, (('?',), (('!PyObject_Call', \
        ('!PyObject_GetAttr', '?', ('CONST', 'iterkeys')), \
        ('CONST', ()), \
        ('NULL',)),), \
        '?')) and IsDict(TypeExpr(v[1])):    
        generate_list_compr_iterkeys(acc0, val, store[0], v[1], cond, o)
        return acc0    
    if len(descr_compr) == 3 and len(store) == 1 and len(expr) == 1 and \
        TCmp(descr_compr, v, (('?',), (('!PyObject_Call', \
        ('!PyObject_GetAttr', '?', ('CONST', 'itervalues')), \
        ('CONST', ()), \
        ('NULL',)),), \
        '?')) and IsDict(TypeExpr(v[1])):    
        generate_list_compr_itervalues(acc0, val, store[0], v[1], cond, o)
        return acc0    
    if len(descr_compr) == 3 and len(store) == 2 and len(expr) == 1 and \
                is_expandable_enumerate(expr[0]):
        generate_list_compr_enumerate(acc0, val, store[0], store[1], \
                                      expr[0][2][1][0], cond, o)
        return acc0                             
    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, '')
    current_co.list_compr_in_progress = prev_compr
    return acc0

def generate_set_compr(val, descr_compr, o, forcenewg):
    acc0 = GenExpr(('!BUILD_SET', ()),o, forcenewg)
    store,expr,cond = descr_compr[0:3]
    recursive_gen_set_compr(acc0, val, store,expr, cond, descr_compr[3:], o)
    return acc0

def recursive_gen_set_compr(acc, val, store,expr, cond,tail, o):
    assert len(expr) == 1
    assert cond is None or len(cond) == 1
    ref_iter = Expr1(expr[0], o)
    o.append('for (;;) {')
    ref_temp = New()
    o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref_temp, '){ break; }')
    if len(store) == 1:
        generate_store(store[0], ref_temp, o, 'PyIter_Next')
    else:  
        if store is not None:  
            generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  

    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
        Cls1(o, cond_var)
    if len(tail) == 0:
        ref_val = Expr1(val[0], o)
        o.Stmt('PySet_Add', acc, ref_val)
        Cls1(o, ref_val)
    else:
        store1,expr1, cond1 = tail[0:3]
        recursive_gen_set_compr(acc, val, store1,expr1, cond1, tail[3:], o)
    if cond is not None:
        o.append('}')
    o.append('}')
    o.Cls(ref_iter)

def generate_map_compr(val, descr_compr, o, forcenewg):
    acc0 = GenExpr(('!BUILD_MAP', ()),o, forcenewg)
    store,expr,cond = descr_compr[0:3]

    ## v = []
    recursive_gen_map_compr(acc0, val, store,expr, cond, descr_compr[3:], o)
    return acc0

def recursive_gen_map_compr(acc, val, store,expr, cond,tail, o):
    assert len(expr) == 1
    assert cond is None or len(cond) == 1
    ref_iter = Expr1(expr[0], o)
    o.append('for (;;) {')
    ref_temp = New()
    o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref_temp, '){ break; }')
    if len(store) == 1:
        generate_store(store[0], ref_temp, o, 'PyIter_Next')
    else:  
        if store is not None:  
            generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  

    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
        Cls1(o, cond_var)
    if len(tail) == 0:
        ref_k = Expr1(val[0], o)
        ref_v = Expr1(val[1], o)
        o.Stmt('PyDict_SetItem', acc, ref_k, ref_v)
        o.Cls(ref_k, ref_v)
    else:
        store1,expr1, cond1 = tail[0:3]
        recursive_gen_map_compr(acc, val, store1,expr1, cond1, tail[3:], o)
    if cond is not None:
        o.append('}')
    o.append('}')
    Cls1(o, ref_iter)

def generate_func_list_compr(val, descr_compr, o, func):
    acc0 = New('int')
    if func == 'all':
        o.Raw(acc0, ' = 1;')
    elif func == 'any':
        o.Raw(acc0, ' = 0;')
    else:
        Fatal('456')
    store,expr,cond = descr_compr[0:3]

    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, func)
    return acc0

def recursive_gen_func_list_compr(acc, val, store,expr, cond,tail, o, func):
    assert len(expr) == 1
    assert cond is None or len(cond) == 1
    t0 = TypeExpr(expr[0])
    islist = IsList(t0)
    istuple = IsTuple(t0)
    ref_iter = New()
    pos = None
    cnt = None
    if islist:
        pos = New('int')
        v = []
        if TCmp(expr[0], v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('!BUILD_TUPLE', ('?',)), ('NULL',))):
            ref_arg = Expr1(v[0], o)
            cnt = New('Py_ssize_t')
            o.Stmt(cnt, '=', 'PyInt_AsSsize_t', ref_arg)
            Cls1(o, ref_arg)
            o.Raw('for (', pos, ' = 0;', pos, ' < ', cnt, ';', pos, ' ++) {')
            ref_temp = New()
            o.Raw(ref_temp, ' = PyInt_FromLong(', pos, ');')
        else:
            ref_expr = Expr1(expr[0], o)
            o.Raw('for (', pos, ' = 0;', pos, ' < PyList_GET_SIZE(', ref_expr, ');', pos, ' ++) {')
            ref_temp = New()
            o.Raw(ref_temp, ' = PyList_GET_ITEM(', ref_expr, ', ', pos, ');')
            o.INCREF(ref_temp)
        if len(store) == 1:
            generate_store(store[0], ref_temp, o, 'PyList_GET_ITEM')
        else:  
            if store is not None:  
                generate_store(('SET_VARS', store), ref_temp, o, 'PyList_GET_ITEM')
    elif istuple:
        ref_expr = Expr1(expr[0], o)
        pos = New('int')
        o.Raw('for (', pos, ' = 0;', pos, ' < PyTuple_GET_SIZE(', ref_expr, ');', pos, ' ++) {')
        ref_temp = New()
        o.Raw(ref_temp, ' = PyTuple_GET_ITEM(', ref_expr, ', ', pos, ');')
        o.INCREF(ref_temp)
        if len(store) == 1:
            generate_store(store[0], ref_temp, o, 'PyTuple_GET_ITEM')
        else:  
            if store is not None:  
                generate_store(('SET_VARS', store), ref_temp, o, 'PyTuple_GET_ITEM')
    else:    
        ref_expr = Expr1(expr[0], o)
        o.Stmt(ref_iter, '=', 'PyObject_GetIter', ref_expr)
        Cls1(o, ref_expr)
        o.append('for (;;) {')
        ref_temp = New()
        o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
        o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
        UseLabl()
        o.Stmt('if (!', ref_temp, '){ break; }')
        if len(store) == 1:
            generate_store(store[0], ref_temp, o, 'PyIter_Next')
        else:  
            if store is not None:  
                generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  
    
    if cond is not None:
        cond0 = type_in_if(cond[0], {})
        o1, cond_var = shortage(generate_logical_expr(cond0))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
        Cls1(o, cond_var)
    if len(tail) == 0:
        if func in ('all', 'any'):
            o1, cond_var = shortage(generate_logical_expr(val[0]))
    ##        ref_val = Expr1(val[0], o)
            o.extend(o1)
            if func == 'all':
                o.Raw('if (!(', cond_var,')) {')
                o.Raw(acc, ' = 0;')
                o.Raw('}') 
            else:
                o.Raw('if (', cond_var,') {')
                o.Raw(acc, ' = 1;')
                o.Raw('}') 
        elif func == 'len':
            ref_val = Expr1(val[0], o)
            Cls1(o, ref_val)
            o.Raw(acc, ' += 1;')
        elif func == '':
            ref_val = Expr1(val[0], o)
            o.Stmt('PyList_Append', acc, ref_val)
            Cls1(o, ref_val)
        else:
            Fatal('321')
        Cls1(o, cond)
    else:
        store1,expr1, cond1 = tail[0:3]
        recursive_gen_func_list_compr(acc, val, store1,expr1, cond1, tail[3:], o, func)
    if cond is not None:
        o.append('}')
    o.append('}')
    o.Cls(ref_iter, pos, cnt)
    
def generate_len_list_compr(val, descr_compr, o):
    acc0 = New('Py_ssize_t')
    o.Raw(acc0, ' = 0;')
    store,expr,cond = descr_compr[0:3]

    ## v = []
    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, 'len')
    return acc0

def AssignCalcConst(nm, ref, o, expr):
    if nm in mnemonic_constant:
##        Fatal('??? Assign mnemoconst', nm, ref, expr, o)
        return
    o.Stmt(calc_const_to(nm), '=', ref);
    for a,b,c in Iter3(nm, 'ModuleAttr', None):
        if c != '.__dict__' or is_pypy:
            r = New()
            o.Stmt(r, '=', 'PyObject_GetAttr', ref, ('CONST', c))
            o.INCREF(r)
            o.Stmt(calc_const_to((nm, c)), '=', r)
            Cls1(o, r)
        else:
            t = TypeExpr(expr)
            if t is None:
                Fatal('Can\'t detect old/new class of calculated const %s' % nm, expr)
            if t[0] == T_NEW_CL_INST:
                o.Raw(calc_const_to((nm, c)), ' = *_PyObject_GetDictPtr(', calc_const_to(nm), ');')
            elif t[0] == T_OLD_CL_INST:
                o.Raw(calc_const_to((nm, c)), ' = ((PyInstanceObject *)', calc_const_to(nm), ')->in_dict;')
            else:
                Fatal('Can\'t detect any class of calculated const %s' % nm, expr)

def IsCTypedGlobal(k):
    return bool(k in detected_global_type and IsCType(detected_global_type[k]))

## def CTypeGlobal(k):
    ## return Type2CType(detected_global_type[k])

def TypeGlobal(k):
    if k in detected_global_type:
        return detected_global_type[k]
    return None

def IsCVar(it):
    if type(it) is tuple and len(it) >= 2:
        if it[0] == 'PY_TYPE':
            return IsCVar(it[3])
        if it[0] == '!@PyInt_FromSsize_t':
            return IsCVar(it[2])
        head = it[0]
        if head == 'FAST':
            pos = current_co.co_varnames.index(it[1])
            typed_arg = current_co.typed_arg_direct
            if pos in typed_arg and is_current & IS_DIRECT:
                if IsCType(typed_arg[pos]):
                    return True
            if it[1] in current_co.detected_type:
                if IsCType(current_co.detected_type[it[1]]):
                    return True
        if head == '!LOAD_GLOBAL' and it[1] not in d_built and it[1][0] != '_' and not redefined_all:
            if build_executable and not global_used_at_generator(it[1]):
                if IsCTypedGlobal(it[1]): 
                    return True
                
    return False        

def CVarName(it):
    assert type(it) is tuple and len(it) >= 2
    head = it[0]
    if head == 'PY_TYPE':
        return CVarName(it[3])
    if it[0] == '!@PyInt_FromSsize_t':
        return CVarName(it[2])
    if head == 'FAST':
        pos = current_co.co_varnames.index(it[1])
        typed_arg = current_co.typed_arg_direct
        if pos in typed_arg and is_current & IS_DIRECT:
            t = typed_arg[pos]
            if IsCType(t):
                return 'Loc_' + Type2CType(t) + '_' + it[1]
        if it[1] in current_co.detected_type:
            t = current_co.detected_type[it[1]]
            if IsCType(t):
                return 'Loc_' + Type2CType(t) + '_' + it[1]
    if head == '!LOAD_GLOBAL' and it[1] not in d_built and it[1][0] != '_' and not redefined_all:
        if build_executable and not global_used_at_generator(it[1]):
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                return 'Glob_' + Type2CType(t) + '_' + it[1]
    if head == 'CALC_CONST' and it[1] not in d_built and it[1][0] != '_' and not redefined_all:
        if build_executable and not global_used_at_generator(it[1]):
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                return 'Glob_' + Type2CType(t) + '_' + it[1]
    print head, it   

## def is_typed_global(k):
    ## return bool(k in detected_global_type and IsInt(detected_global_type[k]))

## def is_typed_global_char(k):
    ## return bool(k in detected_global_type and detected_global_type[k] == Kl_Char)

def CSetVariable(o, var, val):
    nm = CVarName(var)
    t1 = TypeExpr(var)
    t2 = TypeExpr(val)
    if IsCType(t2) and Type2CType(t1) == Type2CType(t2):
        if val[0] == 'CONST':
            generate_store_to_ctype(o, nm, t1, val, val)
            return True
        if val[0] == '!CALL_CALC_CONST':
            generate_call_calc_const(val, o, None, None, nm)
            return True
        if val[0] == 'PY_TYPE' and IsCVar(val[3]):
            o.Raw(nm, ' = ', CVarName(val[3]), ';')
            return True
        if IsCVar(val):
            o.Raw(nm, ' = ', CVarName(val), ';')
            return True
    return False    

def generate_store_to_ctype(o, cnm_, t, ref, expr):
    global g_refs2
    cnm = cnm_ + ' = '
    ## if IsCType(TypeExpr(expr)) and expr[0] != 'CONST':
        ## pprint((cnm_, expr))
    if IsInt(t):        
        if ref[0] == 'CONST':
            o.Raw(cnm, ref[1], ';')
        else:    
            o.Raw(cnm, 'PyInt_AsLong(', ref, ');')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    elif IsFloat(t):        
        if ref[0] == 'CONST':
            o.Raw(cnm, ref[1], ';')
        else:    
            o.Raw(cnm, 'PyFloat_AsDouble(', ref, ');')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    elif t == Kl_Char:        
        if ref[0] == 'CONST':
            o.Raw(cnm,  charhex(ref[1]), ';')
        else:    
            o.Raw(cnm, '*', PyString_AS_STRING(ref), ';')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    elif t == Kl_Boolean:        
        if ref[0] == 'CONST':
            if ref[1]:
                o.Raw(cnm, '1;')
            else:    
                o.Raw(cnm, '0;')
        else:    
            o.Raw(cnm, 'PyObject_IsTrue(', ref, ');')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    else:
        assert False            

def generate_store(it, ref, o, expr):
    global func
    assert type(it) is tuple
    if it[0] == 'STORE_CALC_CONST':
        it = it[1]
        AssignCalcConst(it[1], ref, o, expr)
        if it[0] == 'STORE_GLOBAL' or (it[0] == 'STORE_NAME' and func == 'Init_filename'):
            o.Stmt('PyDict_SetItem', 'glob', ('CONST', it[1]), ref)
            if istempref(ref):
                Cls1(o, ref)
        elif it[0] == 'STORE_NAME':
            o.Stmt('PyObject_SetItem', 'f->f_locals', ('CONST', it[1]), ref)
        else:
            Fatal('generate_store', it)
        o.ClsFict(ref)
        return
    if it[0] == 'STORE_GLOBAL' or (it[0] == 'STORE_NAME' and func == 'Init_filename'):
        if build_executable and it[1] not in d_built and it[1][0] != '_' \
           and not redefined_all  and not global_used_at_generator(it[1]):
            if not istempref(ref) and not IsCTypedGlobal(it[1]) :
                o.INCREF(ref)
            add_fast_glob(it[1])
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                cnm = CVarName(('!LOAD_GLOBAL', it[1]))
                generate_store_to_ctype(o, cnm, t, ref, expr)
            else:        
                o.Stmt('SETSTATIC', it[1], ref)
            o.ClsFict(ref)
            if istempref(ref) and ref not in g_refs2:
                o.Raw(ref, ' = 0;')            
        else:    
            o.Stmt('PyDict_SetItem', 'glob', ('CONST', it[1]), ref)
            if istempref(ref):
                Cls1(o, ref)
            o.ClsFict(ref)
        return
    if it[0] == 'STORE_NAME':
        o.Stmt('PyObject_SetItem', 'f->f_locals', ('CONST', it[1]), ref)
        Cls1(o, ref)
        return
    if it[0] == 'STORE_FAST':
        ## if not istempref(ref):
            ## o.INCREF(ref)
            
        if it[1] in current_co.detected_type:
            t = current_co.detected_type[it[1]]
            if IsCType(t):
                cnm = CVarName(('FAST', it[1]))
                generate_store_to_ctype(o, cnm, t, ref, expr) 
            else:        
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('SETLOCAL', it[1], ref)
        else:
            i = current_co.co_varnames.index(it[1])
            typed_arg = current_co.typed_arg_direct
            if i in typed_arg and is_current & IS_DIRECT:
                t = typed_arg[i]
                if IsCType(t):
                    cnm = CVarName(('FAST', it[1])) + ' = '
                    generate_store_to_ctype(o, cnm, t, ref, expr)
                else:        
                    if not istempref(ref):
                        o.INCREF(ref)
                    o.Stmt('SETLOCAL', it[1], ref)
            else:
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('SETLOCAL', it[1], ref)
        o.ClsFict(ref)
        if istempref(ref) and ref not in g_refs2:
            o.Raw(ref, ' = 0;')
        return
    if it[0] == 'STORE_DEREF':
        o.Stmt('PyCell_Set', ('LOAD_CLOSURE',it[1]), ref)
        Cls1(o, ref)
        return
    if it[0] == 'PyObject_SetAttr':
        generate_SetAttr(it, ref, o, expr)
        return
    if it[0] == '?PyObject_SetAttr':
        ref1, ref2 = Expr(o, it[1:3])
        o.Stmt('PyObject_SetAttr', ref1, ref2, ref)
        proc = Expr1(it[3], o)   
        o.Stmt('if (', proc, '==', load_builtin(it[3][1]), ') {')
        o.Stmt('PyObject_SetAttr', ref1, ref2, ref)
        o.Cls(ref, ref1, ref2)
        o.append('} else {')
        ref4 = New()
        tupl = Expr1(('!BUILD_TUPLE', (ref1, ref2, ref)), o)
        o.Stmt(ref4, '=', 'PyObject_Call', proc, tupl, ('NULL',))
        o.Cls(tupl, ref4)
        o.append('}')
        Cls1(o, proc)
        return
# Code crash unknown -- no crash currently   
    if it[0] == 'PyObject_SetItem':
        it2 = it[2]
        if it2[0] == 'PY_TYPE' and it2[1] is int:
            it2 = it2[3]
        if it2[0] == '!@PyInt_FromSsize_t':
            islist = IsList(TypeExpr(it[1]))
            if islist:
                ref1 = Expr1(it[1], o)
                if not istempref(ref):
                    o.INCREF(ref)
                else:    
                    o.ClsFict(ref)
                o.Stmt('PyList_SetItem', ref1, it2[1], ref)
                Cls1(o, ref1)
                return
            if not islist:
                ref1 = Expr1(it[1], o)
                o.Stmt('if (PyList_CheckExact(', ref1, ')) {')
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('PyList_SetItem', ref1, it2[1], ref)
                o.append('} else {')
                ref2 = Expr1(it2[2],o)
                o.Stmt('PyObject_SetItem', ref1, ref2, ref)
                o.Cls(ref2, ref)
                o.append('}')
                Cls1(o, ref1)
                return
            
    if it[0] == 'PyObject_SetItem' and it[2][0] == 'CONST' and type(it[2][1]) is int:
        ref1 = Expr1(it[1], o)
        o.ClsFict(ref)
        ty = TypeExpr(it[1])
        islist = IsList(ty)
        if islist:
            if not istempref(ref):
                o.INCREF(ref)
            if it[2][1] >= 0:    
                o.Stmt('PyList_SetItem', ref1, it[2][1], ref)
            else:    
                n = New('long')
                o.Raw(n, ' = PyList_GET_SIZE(', ref1, ') + ', it[2][1], ';')
                o.Stmt('PyList_SetItem', ref1, n, ref)
                Cls1(o, n)
        elif IsDict(ty):        
            o.Stmt('PyDict_SetItem', ref1, it[2], ref)
        else:
            if it[2][1] >= 0:    
                o.Stmt('if (PyList_CheckExact(', ref1, ')) {')
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('PyList_SetItem', ref1, it[2][1], ref)
                o.append('} else {')
                o.Stmt('PyObject_SetItem', ref1, it[2], ref)
                if istempref(ref):
                    o.CLEAR(ref)
                o.append('}')
            else:    
                o.Stmt('PyObject_SetItem', ref1, it[2], ref)
        Cls1(o, ref1)
        return
    if it[0] == 'PyObject_SetItem':
        ty = TypeExpr(it[1])
        ty_ind = TypeExpr(it[2])
        if IsDict(ty):        
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyDict_SetItem', ref1, ref2, ref)
            o.Cls(ref, ref1, ref2)
        elif IsListAll(ty) and IsInt(ty_ind):        
            ref1 = Expr1(it[1],o)
            if not istempref(ref):
                o.INCREF(ref)
            o2,ind = shortage(generate_ssize_t_expr(it[2]))
            o.extend(o2)
            if type(ind) is int:
                if ind < 0:
                    ind2 = New('long')
                    o.Raw(ind2, ' = ', ind, ' + PyList_GET_SIZE(', ref1, ');')
                    ind = ind2
                else:
                    pass    
            else:    
                if not istemptyped(ind):
                    ind_ = New('long')
                    o.Raw(ind_, ' = ', ind, ';')
                    ind = ind_
                o.Stmt('if (', ind, '< 0) {')
                o.Raw(ind, ' += PyList_GET_SIZE(', ref1, ');')
                o.append('}')
            o.Stmt('PyList_SetItem', ref1, ind, ref)
            o.ClsFict(ref)
            o.Cls(ind, ref, ref1)
        elif IsListAll(ty) and ty_ind == Kl_Slice:
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyObject_SetItem', ref1, ref2, ref)
            o.Cls(ref, ref1, ref2)
        elif IsListAll(ty):        
            ref1 = Expr1(it[1],o)
            if not istempref(ref):
                o.INCREF(ref)
            refind = Expr1(it[2], o)
            o.Raw('if (PyInt_CheckExact( ', refind,' )) {')
            ind = New('long')
            o.Raw(ind, ' = PyInt_AS_LONG ( ', refind,' );')
            o.Stmt('if (', ind, '< 0) {')
            o.Raw(ind, ' += PyList_GET_SIZE(', ref1, ');')
            o.append('}')
            o.Stmt('PyList_SetItem', ref1, ind, ref)
            Cls1(o, ind)
            o.append('} else {')
            o.Stmt('PyObject_SetItem', ref1, refind, ref)
            o.DECREF(ref)
            o.append('}')    
            o.ClsFict(ref)
            o.Cls(ind, ref, ref1, refind)
        else:    
            if ty is not None:
                Debug( 'typed SetItem', ty, it)
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyObject_SetItem', ref1, ref2, ref)
            o.Cls(ref, ref1, ref2)
        return
    
    if it[0] == 'STORE_SLICE_LV+0':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, ref)
            return    
        if t is not None:
            Debug('typed Store slice', t,it)
        ref1 = Expr1(it[1],o)
        o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', 'NULL', ref)
        o.Cls(ref, ref1)
        return    
    if it[0] == 'STORE_SLICE_LV+3':
        t = TypeExpr(it[1])
        if IsList(t) and it[2][0] == 'CONST' and it[3][0] == 'CONST' and \
                         type(it[2][1]) is int and type(it[3][1]) is int and \
                         it[3][1] >= it[2][1] and it[2][1] >= 0:
            ref1 = Expr1(it[1],o)
            o.Stmt('PyList_SetSlice', ref1, it[2][1], it[3][1], ref)
            o.Cls(ref, ref1)
            return    
        if t is not None:
            Debug('typed Store slice', t, it)
        ref1, ref2, ref3 = Expr(o, it[1:])
        o.Stmt('_PyEval_AssignSlice', ref1, ref2, ref3, ref)
        o.Cls(ref, ref1, ref2, ref3)
        return    
    if it[0] == 'STORE_SLICE_LV+1':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, ref)
            return    
        elif t is not None:
            Debug('typed Store slice', TypeExpr(it[1]),it)

        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_AssignSlice', ref1, ref2, 'NULL', ref)
        o.Cls(ref, ref1, ref2)
        return    
    if it[0] == 'STORE_SLICE_LV+2':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('typed Store slice', t, it)
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', ref2, ref)
        o.Cls(ref, ref1, ref2)
        return    
    if it[0] == 'SET_VARS':  
        mass_store(o,ref,it[1],expr)
        return       
    if it[0] == 'UNPACK_SEQ_AND_STORE' and it[1] == 0:  
        mass_store(o,ref,it[2],expr)
        return       
    Fatal('', it)
    
def charhex(ch):
    if 'A' <= ch <= 'Z':
        return '\'' + ch + '\''
    if 'a' <= ch <= 'z':
        return '\'' + ch + '\''
    if '0' <= ch <= '9':
        return '\'' + ch + '\''
    if ch in '~!@#$%^&*()_+-=[]{};:|/?.>,<':
        return '\'' + ch + '\''
    v = ord(ch)
    if v == 0:
        return '\'\\0\''
    s = hex(v)[2:]
    if len(s) < 2:
        s = '0' + s
    assert len(s) == 2
    return '\'\\x' + s + '\''
    
def assign_list_slice(it, o, ref, plus_1 = False):
    ref1 = Expr1(it[1],o)
    if it[0] == 'DELETE_SLICE+0':
        ind2 = New('long')
        o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')
        o.Stmt('PyList_SetSlice', ref1, 0, ind2, 'NULL')
        o.Cls(ref1, ind2)
        return    
    if it[0] == 'STORE_SLICE_LV+0': 
        o.Raw('if ( PyList_SetSlice ( ', ref1, ' , 0 , PyList_GET_SIZE(', ref1, ') , ', ref, ' ) == -1) goto ', labl, ';')
        UseLabl()
        o.Cls(ref1, ref)
        return    
        
    o2,ind1 = shortage(generate_ssize_t_expr(it[2]))
    o.extend(o2)
    ind2 = New('long')
    o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')
    if type(ind1) is int:
        if ind1 < 0:
            _ind1 = New('long')
            o.Stmt(_ind1, '=', ind1, '+', ind2)
            ind1 = _ind1
    elif ind1[0] == 'CONST':
        if ind1[1] < 0:
            _ind1 = New('long')
            o.Stmt(_ind1, '=', ind1[1], '+', ind2)
            ind1 = _ind1
    else:        
        if not istemptyped(ind1):
            ind_ = New('long')
            o.Raw(ind_, ' = ', ind1, ';')
            ind1 = ind_
        o.Stmt('if (', ind1, '< 0) {')
        o.Stmt(ind1, '=', ind1, '+', ind2)
        o.append('}')                        
    if plus_1:    
        o.Stmt(ind2, '=', ind1, '+', 1)
    o.Stmt('PyList_SetSlice', ref1, ind1, ind2, ref)
    o.Cls(ref, ref1, ind1, ind2)
    return    
 
def handle_unpack_except(o, src_len, trg_len):
    if type(src_len) is int and type(trg_len) is int:
        if src_len >  trg_len:
            o.Raw('PyErr_Format(PyExc_ValueError, "too many values to unpack");')
            o.Raw('goto ', labl, ';')
            UseLabl()
        if src_len < trg_len:
            add_s = '%s, %s == 1 ? "" : "s"' % (src_len, src_len)
            o.Raw('PyErr_Format(PyExc_ValueError, "need more than %d value%s to unpack", ', add_s, ');')
            o.Raw('goto ', labl, ';')
            UseLabl()
        return

    o_2 = Out() 
    o_2.Raw('PyErr_Format(PyExc_ValueError, "too many values to unpack");')
    o_2.Raw('goto ', labl, ';')
    tolabl = append_to_exception(o_2)          
    
    o.Raw('if (', src_len, ' > ', trg_len, ') goto ', tolabl, ';')
    UseLabl()

    o_2 = Out() 
    add_s = '%s, %s == 1 ? "" : "s"' % (CVar(src_len), CVar(src_len))
    o_2.Raw('PyErr_Format(PyExc_ValueError, "need more than %d value%s to unpack", ', add_s, ');')
    o_2.Raw('goto ', labl, ';')
    tolabl = append_to_exception(o_2)          
    
    o.Raw('if (', src_len, ' < ', trg_len, ') goto ', tolabl, ';')
    UseLabl()

def mass_store(o,ref,its,expr, t = None):
    ## islist = False
    if t is None:
        t = TypeExpr(expr)
    PushAcc([expr], [ref])
    src_len = New('int')
    trg_len = len([x for x in its if x is not None]) 
    if IsList(t):
        o.Raw(src_len, ' = PyList_GET_SIZE(', ref, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            ref1 = New()
            o.Stmt(ref1, '=', 'PyList_GET_ITEM', ref, i)
            generate_store(iit,ref1,o, ('!PyList_GET_ITEM', expr, i))
            Cls1(o, ref1)
    elif IsTuple(t) or (t is not None and t[0] == 'MayBe' and IsTuple(t[1])):
        if (t[0] == 'MayBe' and IsTuple(t[1])):
            t = t[1]
        if t[1] is None:        
            o.Stmt(src_len, '=', 'PyTuple_GET_SIZE', ref)
        else:
            Cls1(o, src_len)
            src_len = len(t[1])    
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            ref1 = New()
            o.Stmt(ref1, '=', 'PyTuple_GET_ITEM', ref, i)
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM', expr, i))
            Cls1(o, ref1)
    else:        
        if t is not None:
            ## print 'too', t    
            Debug('UNused type expr in mass store', t, expr)
        o.Stmt('if (PyList_CheckExact(', ref, ') ) {')
        o.Raw(src_len, ' = PyList_GET_SIZE(', ref, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            ref1 = New()
            o.Stmt(ref1, '=', 'PyList_GET_ITEM', ref, i)
            generate_store(iit,ref1,o, ('!PyList_GET_ITEM', expr, i))
            Cls1(o, ref1)
        o.Stmt('} else if (PyTuple_CheckExact(', ref, ') ) {')
        o.Raw(src_len, ' = PyTuple_GET_SIZE(', ref, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            ref1 = New()
            o.Stmt(ref1, '=', 'PyTuple_GET_ITEM', ref, i)
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM', expr, i))
            Cls1(o, ref1)
        o.append('} else {')
        ref2 = New()
        o.Stmt(ref2, '=', 'PySequence_Tuple', ref)
        o.Raw(src_len, ' = PyTuple_GET_SIZE(', ref2, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            ref1 = New()
            o.Stmt(ref1, '=', 'PyTuple_GET_ITEM', ref2, i)
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM', expr, i))
            Cls1(o, ref1)
        Cls1(o, ref2)
        o.append('}')
    if istempref(ref):    
        o.Raw('Py_CLEAR(',  ref,');')    
    PopAcc(o)
    o.Cls(ref, src_len)
    return       
    
g_acc2 = []
g_refs2 = []
g_len_acc = []

def PopAcc(o, clear = True):
    global g_acc2, g_refs2
    to_clear = []
    if clear:
        to_clear = g_refs2[g_len_acc[-1]:]
    del g_acc2[g_len_acc[-1]:]
    del g_refs2[g_len_acc[-1]:]
    del g_len_acc[-1]
    for g in to_clear:
        if istempref(g):
            Cls1(o, g)    

def PushAcc(acc,refs):
    global g_acc2, g_refs2
    g_len_acc.append(len(g_acc2))
    g_acc2.extend(acc)
    g_refs2.extend(refs)
    
def PopClearAll(o):
    global g_acc2, g_refs2, g_len_acc
    grefs = g_refs2[:]
    while len(grefs) > 0:
        r = grefs[-1]
        if istempref(r):
            o.CLEAR(r)
        del grefs[-1]

predeclared_chars = {}
def add_predeclaration_char_const(ind_const):
    global predeclared_chars
    predeclared_chars[ind_const] = True

def PyString_AS_STRING(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is str
        ind_const = index_const_to(ref0[1])
        add_predeclaration_char_const(ind_const)
        return ConC('const_string_', ind_const)
    return ConC('PyString_AS_STRING ( ', ref0, ' )')    

def is_mkfunc_const(proc, expr):
    if expr[0] in ('!MK_FUNK', '!_PyEval_BuildClass'):
        return True
    if len(proc) != 2:
        return False
    if not (type(proc[0]) is str):
        return False
    if proc[0] != 'CALC_CONST':
        return False
    if proc[1] in calc_const_value and \
       calc_const_value[proc[1]][0] in ('!MK_FUNK', '!_PyEval_BuildClass'):
            return True
    return False

## def standart_BINARY_SUBSCR(it, o, forcenewg):
    ## ref0 = Expr1(it[1], o)
    ## ref1 = GenExpr(it[2], o, None, None, True)
    ## ref = New(None, forcenewg)
    ## if ref1[0] == 'CONST' and type(ref1[1]) is int:
        ## o.Raw('if ((', ref, ' = _c_BINARY_SUBSCR_Int ( ', ref0, ' , ', ref1[1], ' , ', ref1, ' )) == 0) goto ', labl, ';')
        ## UseLabl()
        ## Used('_c_BINARY_SUBSCR_Int')
    ## else:
        ## o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
    ## o.Cls(ref1, ref0)
    ## return ref

def Expr1(it, o):
    return GenExpr(it, o)

def Expr(o, it):
    return [GenExpr(x, o) for x in it]
    
def Str_for_C(s):
    r = ''
    for c in s:
            h = hex(ord(c))
            assert h.startswith('0x')
            h = h[2:]
            if len(h) < 2:
                h = '0' + h
            r += '\\x' + h    
    return '"' + r + '"'            

def Char_for_C(s):
    r = ''
    assert len(s) == 1
    c = s[0]
    h = hex(ord(c))
    assert h.startswith('0x')
    h = h[2:]
    if len(h) < 2:
        h = '0' + h
    r += '\\x' + h    
    return "'" + r + "'"   

def generate_SetAttr(it, ref, o, expr):
    t = TypeExpr(it[1])

    if not redefined_attribute and it[2][0] == 'CONST' and it[2][1][0:2] != '__' and (it[1][0] == 'FAST' or (it[1][0] == 'PY_TYPE' and it[1][3][0] == 'FAST')) and not is_pypy:
        isattrs = IsAnyAttrInstance(it[2][1])
        ismeth = len (IterMethod(it[2][1], None)) > 0
        var = it[1]
        isinst = False
        if var[0] == 'PY_TYPE':
            isinst = var[1] == 'NewClassInstance' or var[1] == 'OldClassInstance'
            var = var[3]
        if not ismeth and isattrs and var[1] in current_co.co_varnames and \
            current_co.co_varnames.index(var[1]) < current_co.co_argcount:
            s1 = ('STORE_FAST', var[1])
            s2 = ('DELETE_FAST', var[1])
            srepr = repr(current_co.cmds[1])
            if not repr(s1) in srepr and not repr(s2) in srepr:
                if isinst:
                    o.Raw('if (PyDict_SetItem(_', var[1], '_dict, ', it[2], ', ', ref, ') == -1) goto ', labl, ';')
                    UseLabl()
                    current_co.dict_getattr_used[var[1]] = True
                    Cls1(o, ref)
                    return
                o.Raw('if (_' + var[1] + '_dict) {')
                o.Raw('if (PyDict_SetItem(_', var[1], '_dict, ', it[2], ', ', ref, ') == -1) goto ', labl, ';')
                UseLabl()
                current_co.dict_getattr_used[var[1]] = True
                o.append('} else {')
                o.Stmt('PyObject_SetAttr', var, it[2], ref)
                o.append('}')
                Cls1(o, ref)
                return
    if t is not None and t[0] == T_OLD_CL_INST and not is_pypy:
        ismeth = len (IterMethod(it[2][1], None)) > 0
        if  not ismeth and it[2][0] == 'CONST' and IsAttrInstance(t[1], it[2][1]):
            ref1 = Expr1(it[1], o)
            o.Stmt('PyDict_SetItem', '((PyInstanceObject *)' + CVar(ref1) + ')->in_dict', it[2], ref)
            o.Cls(ref1, ref)
            return

    elif t is not None and t[0] == T_OLD_CL_INST and it[1][0] == 'CALC_CONST':
        if it[2][0] == 'CONST' and IsAttrInstance(t[1], it[2][1]):
            if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                o.Stmt('PyDict_SetItem', calc_const_to((it[1][1], '.__dict__')), it[2], ref)
                Cls1(o, ref)
                return
    elif t is not None and t[0] == T_NEW_CL_INST and it[1][0] == 'CALC_CONST':
        if it[2][0] == 'CONST' and IsAttrInstance(t[1], it[2][1]):
            if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                o.Stmt('PyDict_SetItem', calc_const_to((it[1][1], '.__dict__')), it[2], ref)
                Cls1(o, ref)
                return
            r = Expr1(it[1], o)
            dic = New()
            o.Raw(dic, ' = *_PyObject_GetDictPtr(',r,');')
            o.INCREF(dic)
            Cls1(o, r)
            o.Stmt('PyDict_SetItem', dic, it[2], ref)
            Cls1(o, dic)
            Cls1(o, ref)
            return
    ref1, ref2 = Expr(o, it[1:])
    o.Stmt('PyObject_SetAttr', ref1, ref2, ref)
    o.Cls(ref, ref1, ref2)
    return

def IsMethod(nmcl, nmslot):
    assert type(nmcl) is str and type(nmslot) is str
    if Is3(nmcl, ('Method', nmslot)):
        return True
    elif nmslot[0] == '_' and Is3(nmcl, ('Method', '_' + nmcl + nmslot), nmslot):
        return True
    else:
        return False

def IterMethod(nmslot, nmcode):
    li = []
    for a,b,c in Iter3(None, None, nmcode):
        if b == ('Method', nmslot):
            li.append((a,b,c))
        elif nmslot[0] == '_' and type(b) is tuple and b[0] == 'Method' and b[1] == '_' + a + c:
            li.append((a,b,c))
    return li

def IsAnyMethod(nmslot, nmcode):
    if Is3(None, ('Method', nmslot), nmcode):
        return True
    elif nmslot[0] == '_':
        li = list(Iter3(None, None, nmcode))
        for a,b,c in li:
            if b == ('Method', '_' + a + c):
                return True
    return False

def ValMethod(nmcl, nmslot):
    if Is3(nmcl, ('Method', nmslot)):
        return Val3(nmcl, ('Method', nmslot))
    elif nmslot[0] == '_':
        li = list(Iter3(nmcl, None, nmslot))
        for a,b,c in li:
            if b == ('Method', '_' + a + c):
                return nmslot
    print nmcl, nmslot
    assert False
    return None 

def CodeInit(nmcl):
    return ValMethod(nmcl, '__init__')
    
attr_instance = {}

def SetAttrInstance(nmcl, nmattr):
    attr_instance[(nmcl, nmattr)] = True    
    
def IsFatherAttrInstance(nmcl, nmslot):
    for a,b,c in Iter3(nmcl, 'Derived', None):
        if c[0] == '!CALC_CONST':
            if IsAttrInstance(c[1], nmslot):
                return True
    return False

def IsAttrInstance(nmcl, nmslot):
    if (nmcl, nmslot) in attr_instance and nmslot[0:2] != '__':
        return True
    elif nmcl is not None and nmslot[0] == '_' and (nmcl, '_' + nmcl + nmslot) in attr_instance:
        return True
    if IsFatherAttrInstance(nmcl, nmslot):
        return True
    return False

def IsAnyAttrInstance(nmslot):
    for a,c in attr_instance.iterkeys():
        if c == nmslot and nmslot[0:2] != '__':
            return True
        elif nmslot[0] == '_' and c == '_' + a + nmslot:
            return True
    return False
    
def generate_GetAttr(it,o, forcenewg, typed):
    t = TypeExpr(it[1])
##    pprint(('ooo1', it, t, typed))
    if not redefined_attribute and it[2][0] == 'CONST' and it[2][1][0:2] != '__' and not is_pypy:
        ismeth = len (IterMethod(it[2][1], None)) > 0
        if it[1][0] == 'FAST' or (it[1][0] == 'PY_TYPE' and it[1][3][0] == 'FAST'):
            right_obj = False
            if it[1][0] == 'FAST':
                nmvar = it[1][1]
            else:    
                if it[1][1] == 'NewClassInstance' or it[1][1] == 'OldClassInstance':
                    right_obj = True
                nmvar = it[1][3][1]
            isattrs = IsAnyAttrInstance(it[2][1])
            if not ismeth and isattrs and nmvar in current_co.co_varnames and \
               len([True for i, nm in enumerate(current_co.co_varnames) \
                  if i < current_co.co_argcount and nm == nmvar]) > 0:
                s1 = ('STORE_FAST', nmvar)
                s2 = ('DELETE_FAST', nmvar)
                srepr = repr(current_co.cmds[1])
                if not repr(s1) in srepr and not repr(s2) in srepr:
                    if right_obj:
                        ref = New(None, forcenewg)
    ##                    o.Raw('GET_ATTR_LOCAL(', ref[1], ', ',it[1][1], ', ', it[2], ', ', labl, ');')
                        o.Raw(ref, ' = PyDict_GetItem(_', nmvar, '_dict, ', it[2], ');')
                        o.INCREF(ref)
                        current_co.dict_getattr_used[nmvar] = True
                        return ref

                    ref = New(None, forcenewg)
##                    o.Raw('GET_ATTR_LOCAL(', ref[1], ', ',it[1][1], ', ', it[2], ', ', labl, ');')
                    o.Raw('if (_' + nmvar + '_dict && (',ref, ' = PyDict_GetItem(_', nmvar, '_dict, ', it[2], ')) != 0) {')
                    o.INCREF(ref)
                    current_co.dict_getattr_used[nmvar] = True
                    o.append('} else {')
                    o.Stmt(ref, '=', 'PyObject_GetAttr', it[1], it[2])
                    o.append('}')
                    return ref
        if not ismeth and t is not None and t[0] != 'MayBe' and IsAttrInstance(t[1], it[2][1]) and not is_pypy:
            if t[0] == T_OLD_CL_INST:
                if it[1][0] == 'CALC_CONST':
                    if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                        ref = New(None, forcenewg)
                        o.Stmt(ref, '=', 'PyDict_GetItem', calc_const_to((it[1][1], '.__dict__')), it[2])
                        return ref
                r = Expr1(it[1], o)
                ref = New(None, forcenewg)
                o.Stmt(ref, '=', 'PyDict_GetItem', '((PyInstanceObject *)' + CVar(r) + ')->in_dict', it[2])
                Cls1(o, r)
                return ref
            elif t[0] == T_NEW_CL_INST:
                if it[1][0] == 'CALC_CONST':
                    if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                        ref = New(None, forcenewg)
                        o.Stmt(ref, '=', 'PyDict_GetItem', calc_const_to((it[1][1], '.__dict__')), it[2])
                        return ref

                r = Expr1(it[1], o)
                dic = New()
                o.Raw(dic, ' = *_PyObject_GetDictPtr(',r,');')
                o.INCREF(dic)
                Cls1(o, r)
                ref = New(None, forcenewg)
                o.Stmt(ref, '=', 'PyDict_GetItem', dic, it[2])
                Cls1(o, dic)
                return ref
        elif t is not None and t[0] is types.ModuleType:
            if t[1] is not None and ModuleHaveAttr(t[1], it[2][1]):
                r = Expr1(it[1], o)
                ref = New(None, forcenewg)
                o.Raw('if ((', ref, ' = PyDict_GetItem(PyModule_GetDict(' + CVar(r) + '), ', it[2], ')) == 0) goto ', labl, ';')
                o.INCREF(ref)
                Cls1(o, r)
##                o.Raw('if (', ref, ' == 0) goto ', labl, ';')
                UseLabl()
                return ref
    if t is not None:
        Debug('Non-Generic GetAttr type', t, it[2], it[1], current_co.co_name)
##        Fatal('')
    if it[2][1] == '?':
        Fatal('', it)    
    Debug('Standard Getattr', it)
    ref,attr = [Expr1(x, o) if type(x) is tuple and len(x) > 0 else x \
              for i,x in enumerate(it) if i > 0]
    newg = New(None, forcenewg)  
    o.Stmt(newg, '=', 'PyObject_GetAttr', ref, attr)
    o.Cls(ref,attr)
    return newg   
    
def IsAnyClass(nm):
    return nm in calc_const_old_class or nm in calc_const_new_class

def verif(it, o):
        if it[0] in ('!MK_FUNK', '!CALL_CALC_CONST', '!STR_CONCAT', '!STR_CONCAT3', '!STR_CONCAT2', '!STR_CONCAT_N', \
                     '!CLASS_CALC_CONST_NEW', '!IMPORT_NAME', '!PyObject_Call', '!PyDict_GetItem',\
                     '!PyInt_Type.tp_str', '!PyCFunction_Call', '!_PyEval_BuildClass',\
                     '!PyDict_Items', '!PyDict_Keys', '!PyList_AsTuple', '!PyString_Format',\
                     '!_PyList_Extend', '!PyDict_Copy', '!PyDict_Values'):
            return    
        typs = tuple([TypeExpr(x) if type(x) is tuple and len(x) > 0 else None for i,x in enumerate(it) if i > 0])
        typs2 = [x for x in typs if x is not None]
        if it[0] == '!c_LOAD_NAME' and typs == (None, Kl_String):
            return
        if len(typs2) > 0:
            Debug('Concret type operation %s %s -- %s' % (it[0], tuple(typs), it))  

## def find_singles_goto(o):
    ## li = {}
    ## for i, s in enumerate(o):
        ## if s.startswith("goto ") and s.endswith(";") and ' ' not in s[5:-1]:
            ## li[i] = s[5:-1]
    ## lii = {}
    ## for label in li.itervalues():
        ## if label in lii:
            ## lii[label] += 1
        ## else:
            ## lii[label] = 1
    ## lis = [label for label in li.itervalues() if lii[label] > 1]
    ## return li, lis
    
### UNUSED ??? 01.01.2012
## def join_before_goto(o):
    ## while True:
        ## li, lis = find_singles_goto(o)
        ## toupdate = []
        ## toappend = []
        ## for label in lis:
            ## lines = [line for line in li.iterkeys() if li[line] == label]
            ## lines,leng = find_like_tail(lines, o)
            ## if leng > 0 and newlabel is not None:
                ## newlabel = New('label')
                ## toappend.append(o[line-leng:line], newlabel)
                ## for line in lines:
                    ## toupdate.append((line, leng, newlabel))
        ## if len(toupdate) == 0:
            ## break
        ## toupdate.sort()
        ## update_tailed_gotos(o, toupdate)
        ## append_extracted(o, toappend)

## def find_like_tail(lines, o):
    ## if len(lines) <= 1:
        ## return [], 0
    ## leng = 2
    ## while True:
        ## pass

def check_GenExpr_warn(it, forcenewg):
    _v = []
    if forcenewg is not None and it[0] in tags_one_step_expr:
        Debug('Copy unhandled', forcenewg, '=', it)
    if TCmp(it, _v, ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', '?')):
        t = TypeExpr(_v[0])
        if t is not None and _v[3] == ('NULL',):
            if t not in _Kl_Simples and type(t[1]) is str:
                if IsAnyClass(t[1]) and not Is3(t[1], ('Attribute', _v[1])):
                    if IsAttrInstance(t[1], _v[1]):       
                        pass
                    elif not IsMethod(t[1], _v[1]):       
                        Debug( 'Call UNKNOWN method known classes: %s -> %s' % (t, _v[1]),it)
                        ## if _v[1] == 'append':
                            ## Fatal('')
                    else:
                        HideDebug( 'Call method known classes: %s -> %s' % (t, _v[1]),it)
    if type(it) is tuple and len(it) == 3 and type(it[0]) is str and \
        type(it[1]) is tuple and len(it[1]) >= 1 and it[1][0] == 'CONST' and \
        type(it[2]) is tuple and len(it[2]) >= 1 and it[2][0] == 'CONST':
        if it[2] != ('CONST', 'join'):    
            Debug('Constant binary operation unhandled', it)
    if type(it) is tuple and len(it) == 2 and type(it[0]) is str and \
        type(it[1]) is tuple and len(it[1]) >= 1 and it[1][0] == 'CONST':            
        Debug('Constant unary operation unhandled', it)
    if type(it) is tuple:    
        if len(it) > 1 and IsCVar(it[1]):    
            Debug('Operation of typed var', it)
        if len(it) > 2 and IsCVar(it[2]):    
            Debug('Operation of typed var', it)
    
def GenExpr(it,o, forcenewg=None,typed=None, skip_float = None):
    global _n2c, g_acc2, g_refs2
    if not hide_debug:
        check_GenExpr_warn(it, forcenewg)
    for ind,x in enumerate(g_acc2):        
        if it == x:
            if it[0] == 'CONST' and type(x[1]) != type(it[1]):
                continue
            ind = g_acc2.index(it)
            assert forcenewg is None or forcenewg == g_refs2[ind]
            if forcenewg is None or forcenewg == g_refs2[ind]:
                return g_refs2[ind]    
    if type(it) is int:
        return it
    head = it[0]
 
    if head == 'PY_TYPE':
        if it[3][0] == 'PY_TYPE':
            if it[0:3] == it[3][0:3]:
                it = it[3]
        if it[3][0] == 'PY_TYPE':
            pprint(current_co)
            pprint(it)
        assert it[3][0] != 'PY_TYPE'
      
        if typed is not None:
            Debug(typed, it[4], it)
            assert typed == it[4]
        if typed is None and it[4] is not None:
            Debug('Unhandled C-type', it)   
        if it[1] is float:    
            return GenExpr(it[3],o,forcenewg, typed, False)
        else:
            return GenExpr(it[3],o,forcenewg, typed, True)

    if not isinstance(head, types.StringTypes) and type(head) != int:
        pprint(head)
        pprint(it)
    assert isinstance(head, types.StringTypes) or type(head) is int
#    o.append('/*---*/')
    tempor = False    

    if head == 'FAST':
        pos = current_co.co_varnames.index(it[1])
        typed_arg = current_co.typed_arg_direct
        if pos in typed_arg and is_current & IS_DIRECT:
            t = typed_arg[pos]
            if IsCType(t):
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2    
        if it[1] in current_co.detected_type:
            t = current_co.detected_type[it[1]]
            if IsCType(t):
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2    
    if head[0] == '!':
        tempor = True
        head = head[1:]
    elif head[0] == '=':
        head = 'INPLACE_' + head[1:]
        tempor = True    
    if not tempor:
        if len(it) > 1:
            if not head in tags_one_step_expr:
                Fatal('', it, len(it))
            assert head in tags_one_step_expr
        return it  
     
    if tempor and head == 'LOAD_NAME' and func == 'Init_filename':
        return GenExpr(('!LOAD_GLOBAL', it[1]),o, forcenewg)
    if tempor and head == 'LOAD_NAME':
        return GenExpr(('!c_LOAD_NAME', 'f', ('CONST', it[1])),o, forcenewg)
    if tempor and head == 'LOAD_GLOBAL' and it[1] not in d_built and it[1][0] != '_' and not redefined_all:
        if build_executable and not global_used_at_generator(it[1]):
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2    
            ## else:                    
            ## if is_typed_global(it[1]):
                ## ref2 = New(None,forcenewg)
                ## o.PushInt(ref2, 'Glob_long_' + it[1])
                ## return ref2
            ## if is_typed_global_char(it[1]):
                ## ref2 = New(None,forcenewg)
                ## o.Raw(ref2, ' = PyString_FromStringAndSize(&Glob_char_', it[1], ', 1);')
                ## return ref2    
            return it
        ref = New(None, forcenewg)
        
        o_2 = Out() 
        o_2.Raw('PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, ', '"%s"' % it[1], ');')
        o_2.Raw('goto ', labl, ';')
        tolabl = append_to_exception(o_2)            
        
        o.Raw('if ((', ref, ' = PyDict_GetItem( glob, ', ('CONST', it[1]), ')) == 0) goto ', tolabl, ';')
        UseLabl()
        o.INCREF(ref)
        return ref

    if head == 'CALC_CONST' and it[1] not in d_built and it[1][0] != '_' and not redefined_all:
        if build_executable and not global_used_at_generator(it[1]):
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2 
    
    if tempor and head == 'LOAD_GLOBAL':
        return GenExpr(('!c_LOAD_GLOBAL', ('CONST', it[1]), hash(it[1])),o, forcenewg)
    if head == 'LOAD_BUILTIN':
        return ('BUILTIN', it[1])
    if head in ('OR_JUMPED_STACKED', 'AND_JUMPED_STACKED'):
        ref = forcenewg
        if ref is None:
            ref = New()
        return generate_and_or_jumped_stacked(it[1:], o, ref, head == 'AND_JUMPED_STACKED', 0)
    if head in ('AND_BOOLEAN', 'OR_BOOLEAN'):
        o1, logic = generate_logical_expr(it) 
        o.extend(o1)
        return logic

    if head in ('AND_JUMP', 'OR_JUMP'):
        o1,logic = shortage(generate_logical_expr(it))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', logic)
        Cls1(o, logic)
        return ref
    
    if head == 'PyList_GetSlice':
        ref1 = Expr1(it[1], o)
        if it[2] < 0:
            it1 = New('long')
            o.Raw(it1, ' = PyList_GET_SIZE( ', ref1, ' ) - ', abs (it[2]), ';')
            o.Raw('if (', it1, ' < 0) { ', it1, ' = 0; }')
        else:
            it1 = it[2]
        if it[3] < 0:
            it2 = New('long')
            o.Raw(it2, ' = PyList_GET_SIZE( ', ref1, ' ) - ', abs (it[3]), ';')
            o.Raw('if (', it2, ' < 0) { ', it2, ' = 0; }')
        else:
            it2 = it[3]
        ref = New(None, forcenewg)
        o.Raw('if ((', ref, ' = PyList_GetSlice( ', ref1, ' , ', it1, ' , ', it2, ' )) == 0) goto ', labl, ';')
        UseLabl()
        o.Cls(ref1, it1, it2)
        return ref
    
    if head == 'PyTuple_GetSlice':
        ref1 = Expr1(it[1], o)
        if it[2] < 0:
            it1 = New('long')
            o.Raw(it1, ' = PyTuple_GET_SIZE( ', ref1, ' ) - ', abs (it[2]), ';')
            o.Raw('if (', it1, ' < 0) { ', it1, ' = 0; }')
        else:
            it1 = it[2]
        if it[3] < 0:
            it2 = New('long')
            o.Raw(it2, ' = PyTuple_GET_SIZE( ', ref1, ' ) - ', abs (it[3]), ';')
            o.Raw('if (', it2, ' < 0) { ', it2, ' = 0; }')
        else:
            it2 = it[3]
        ref = New(None, forcenewg)
        o.Raw('if ((', ref, ' = PyTuple_GetSlice( ', ref1, ' , ', it1, ' , ', it2, ' )) == 0) goto ', labl, ';')
        UseLabl()
        o.Cls(ref1, it1, it2)
        return ref
    
    if head == 'COND_METH_EXPR':
        return generate_cond_meth_expr_new(it, o, forcenewg, False)
    if head == 'BUILD_TUPLE':
      li = []
      repeat_expr = {}
      for x in it[1]:  
         g = Expr1(x, o)
         if not istempref(g):
             o.INCREF(g) 
             li.append(g)
         elif g in g_refs2:
             if g in repeat_expr:
                Fatal('Repeated expr', it, repeat_expr, g)
             gg = New()
             o.Raw(gg, ' = ', g, ';')   
             o.INCREF(gg) 
             li.append(gg)    
             repeat_expr[gg] = True   
         else:    
             li.append(g)
      newg = New(None,forcenewg)  
      o.Stmt(newg,'=', 'PyTuple_New', len(it[1]))
      for i,g in enumerate(li):
         o.Stmt('PyTuple_SET_ITEM', newg, i, g)
         if g not in g_refs2:
            o.ZeroTemp(g)  
         o.ClsFict(g)
      return newg
    if head == 'GET_ITER':
        ref = Expr1(it[1], o)
        ref2 = New(None,forcenewg)
        o.Stmt(ref2, '=', 'PyObject_GetIter', ref)
        return ref2
 
    if head == 'PySequence_Repeat':
    #### Trouble at count < 0 
        if IsList(TypeExpr(it[1])) and it[1][0] == '!BUILD_LIST':
            Debug('Repeat list n', it[1], it[2])
               
        if it[1][0] == 'CONST' and type(it[1][1]) is str and len(it[1][1]) == 1 and IsInt(TypeExpr(it[2])):
            if it[2][0] == 'CONST' and it[2][1] <= 0:
                ref2 = New(None,forcenewg)
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', 0)
                return ref2
            elif it[2][0] == 'CONST' and it[2][1] > 0:
                n2 = it[2][1]   
                ref2 = New(None,forcenewg)
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', n2)
                cref = New('charref')
                o.Raw(cref, ' = ', PyString_AS_STRING(ref2), ';')
                n1 = New('Py_ssize_t')
                o.Raw('for(', n1, ' = 0; ', n1, ' < ', n2, '; ', n1, '++){')
                o.Raw(cref, '[', n1, '] = ', str(ord(it[1][1])), ';')
                o.append('}')
                o.Cls(n1, cref)
                return ref2
            else:
                if it[2][0] == 'CONST':
                    n2 = it[2][1]
                else:   
                    n2 = New('Py_ssize_t')
                    n = Expr1(it[2], o)
                    o.Stmt(n2, '=', 'PyInt_AsSsize_t', n)
                    Cls1(o, n)
                ref2 = New(None,forcenewg)
                o.Raw('if (', n2, ' <= 0) {')
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', 0)
                o.append('} else {')    
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', n2)
                cref = New('charref')
                o.Raw(cref, ' = ', PyString_AS_STRING(ref2), ';')
                n1 = New('Py_ssize_t')
                o.Raw('for(', n1, ' = 0; ', n1, ' < ', n2, '; ', n1, '++){')
                o.Raw(cref, '[', n1, '] = ', str(ord(it[1][1])), ';')
                o.append('}')
                o.Cls(n1, n2, cref)
                o.append('}')    
                return ref2
        if IsInt(TypeExpr(it[2])):       
            ref = Expr1(it[1], o)
            if it[2][0] == 'CONST':
                n2 = it[2][1]
            else:   
                n = Expr1(it[2], o)
                n2 = New('Py_ssize_t')
                o.Stmt(n2, '=', 'PyInt_AsSsize_t', n)
                Cls1(o, n)
            ref2 = New(None,forcenewg)
            o.Stmt(ref2, '=', 'PySequence_Repeat', ref, n2)
            Cls1(o, ref)
            Cls1(o, n2)
            return ref2
        verif(it, o)
        ref1 = Expr1(it[1], o)
        ref2 = Expr1(it[2], o)

        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.Stmt(new, '=', 'PyNumber_Multiply', ref1, ref2)
        o.Cls(ref1, ref2)
        return new
        
    if head == 'PySequence_GetSlice' and TypeExpr(it[1]) == Kl_String:
        if type(it[2]) is int and it[3] == 'PY_SSIZE_T_MAX' and it[2] >= 0:
            ref1 = Expr1(it[1], o)
            ref = New()
            o.Raw('if (PyString_GET_SIZE(', ref1,') > ', it[2], ') {')
            o.Raw(ref, ' = PyString_FromStringAndSize( ', PyString_AS_STRING(ref1), ' + ', it[2], ' , PyString_GET_SIZE(', ref1,') - ', it[2], ');')
            o.append('} else {')
            o.Raw(ref, ' = PyString_FromStringAndSize( \"\" , 0);')
            o.append('}')
            Cls1(o, ref1)
            return ref
        Debug('Typed GetSlice of string', it)        
        
    if head == 'BUILD_LIST':
      li = []
      repeat_expr = {}
      for x in it[1]:  
         g = Expr1(x, o)
         if not istempref(g):
             o.INCREF(g) 
             li.append(g)
         elif g in g_refs2:
             if g in repeat_expr:
                Fatal('Repeated expr', it, repeat_expr, g)
             gg = New()
             o.Raw(gg, ' = ', g, ';')   
             o.INCREF(gg) 
             li.append(gg)    
             repeat_expr[gg] = True   
         else:    
             li.append(g) 
      newg = New(None,forcenewg)  
      o.Stmt(newg,'=', 'PyList_New', len(it[1]))
      for i,g in enumerate(li):
         o.Stmt('PyList_SET_ITEM', newg, i, g)
         if g not in g_refs2:
            o.ZeroTemp(g)  
         o.ClsFict(g)
      return newg

    if head == 'IMPORT_NAME':
        return generate_import_name(it, o)
    
    if head == 'BUILD_SET':
      ret = New(None, forcenewg)  
      o.Stmt(ret , '=', 'PySet_New', 'NULL') 
      for v in it[1]:
          v = Expr1(v, o)
          o.Stmt('PySet_Add', ret, v)
          Cls1(o, v)
      return ret    
        
    if head == 'BUILD_MAP':
      ret = New(None, forcenewg)  
      if len(it[1]) > 5 and not is_pypy:
        o.Stmt(ret,'=', '_PyDict_NewPresized', len(it[1])) 
      else:
        o.Stmt(ret,'=', 'PyDict_New') 
      for k, v in it[1]:
          k = Expr1(k, o)
          v = Expr1(v, o)
          o.Stmt('PyDict_SetItem', ret, k, v)
          o.Cls(k, v)
      return ret
    if head == 'MK_CLOSURE':
        assert len(it) == 4
        co = _n2c[it[1]]
        if not co.can_be_codefunc(): ## co.co_flags & CO_GENERATOR:
            ref1 = New()
            o.Stmt(ref1, '=', 'PyFunction_New', const_to(co), 'glob')
            ref2 = Expr1(it[2], o)
            o.Stmt('PyFunction_SetClosure', ref1, ref2)
            Cls1(o, ref2)
            if it[3][0] == 'CONST' and type(it[3][1]) is tuple:
                if len(it[3][1]) > 0:
                    o.Stmt('PyFunction_SetDefaults', ref1, it[3])
                return ref1
            if it[3][0] == '!BUILD_TUPLE' and type(it[3][1]) is tuple:
                ref2 = Expr1(it[3], o)
                o.Stmt('PyFunction_SetDefaults', ref1, ref2)
                Cls1(o, ref2)
                return ref1
            Fatal('GenExpr', it)

        ref1 = New()
        o.Stmt(ref1, '=', 'Py2CFunction_New', const_to( _n2c[it[1]]))
        ref2 = Expr1(it[2], o)
        o.Stmt('Py2CFunction_SetClosure', ref1, ref2)
        Cls1(o, ref2)
        if it[3][0] == 'CONST' and type(it[3][1]) is tuple:
            if len(it[3][1]) > 0:
                o.Stmt('Py2CFunction_SetDefaults', ref1, it[3])
            return ref1
        if it[3][0] == '!BUILD_TUPLE' and type(it[3][1]) is tuple:
            ref2 = Expr1(it[3], o)
            o.Stmt('Py2CFunction_SetDefaults', ref1, ref2)
            Cls1(o, ref2)
            return ref1
        Fatal('GenExpr', it)
    if head == 'LOAD_CLOSURE':
        return ('LOAD_CLOSURE', it[1])    
    if head == 'LOAD_DEREF':
        return GenExpr(('!PyCell_Get',('LOAD_CLOSURE', it[1])), o, forcenewg, typed)
    if head == 'MK_FUNK':
        co = _n2c[it[1]]
        if not co.can_C():
            if len(it) == 3 and it[2][0] == 'CONST' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                if len(it[2][1]) > 0: # or len(co.co_cellvars + co.co_freevars) != 0:
                    o.Stmt(ref1, '=', 'PyFunction_New', const_to(co), 'glob')
                    o.Stmt('PyFunction_SetDefaults', ref1, it[2])
                else:
                    o.Stmt(ref1, '=', 'PyFunction_New', const_to( co), 'glob')
                        
                return ref1
            if len(it) == 3 and it[2][0] == '!BUILD_TUPLE' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                o.Stmt(ref1, '=', 'PyFunction_New', const_to(co), 'glob')
                ref2 = Expr1(it[2], o)
                o.Stmt('PyFunction_SetDefaults', ref1, ref2)
                Cls1(o, ref2)
                return ref1
            Fatal('GenExpr', it)
            return None
        if co.can_be_cfunc():
            if len(it) == 3 and it[2][0] == '!BUILD_TUPLE' and type(it[2][1]) is tuple and len(it[2][1]) > 0:
                ref = Expr1(it[2], o)
                if not istempref(ref):
                    o.INCREF(ref)
                nmdefault = '__default_arg___' + co.cmds[0][1] 
                add_fast_glob(nmdefault)
                o.Stmt('SETSTATIC', nmdefault, ref)
                o.ClsFict(ref)
                if istempref(ref) and ref not in g_refs2:
                    o.Raw(ref, ' = 0;')   
                ref = None
            
            ref1 = New(None, forcenewg)
            met, ismeth = type_methfunc(co)
            if not ismeth:
                o.Raw(ref1, ' = PyCFunction_New ( &methfunc_', co.cmds[0][1], ', NULL);')
            else:
                o.Raw(ref1, ' = __pyx_binding_PyCFunctionType_NewEx ( &methfunc_', co.cmds[0][1], ', NULL, NULL);')
                Used('__pyx_binding_PyCFunctionType_NewEx')
            return ref1

        if co.can_be_codefunc():
            if len(it) == 3 and it[2][0] == 'CONST' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                if len(it[2][1]) > 0: # or len(co.co_cellvars + co.co_freevars) != 0:
                    o.Stmt(ref1, '=', 'Py2CFunction_New', const_to( co))
                    o.Stmt('Py2CFunction_SetDefaults', ref1, it[2])
                else:
                    o.Stmt(ref1, '=', 'Py2CFunction_New', const_to( co))
                        
                return ref1
            if len(it) == 3 and it[2][0] == '!BUILD_TUPLE' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                o.Stmt(ref1, '=', 'Py2CFunction_New', const_to(co))
                ref2 = Expr1(it[2], o)
                o.Stmt('Py2CFunction_SetDefaults', ref1, ref2)
                Cls1(o, ref2)
                return ref1
        Fatal('GenExpr', it)

    if head == 'BINARY_SUBSCR_Int':
        ref = Expr1(it[1], o)
        ref1 = New(None, forcenewg)
        t = TypeExpr(it[1])
        islist = IsListAll(t)
        if IsDict(t):        
            ref2 = GenExpr(it[2], o, None, None, True)
            
            o_2 = Out() 
            tupl = New()
            o_2.Raw('if ((', tupl, ' = PyTuple_Pack(1, ', ref2, ')) == 0) goto ', labl, ';') 
            o_2.Raw('PyErr_SetObject(PyExc_KeyError, ', tupl, ');')
            Cls1(o_2, tupl)            
            o_2.Raw('goto ', labl, ';')
            tolabl = append_to_exception(o_2)                   
            
            o.Raw('if ((', ref1, ' = PyDict_GetItem(', ref, ', ', ref2, ')) == 0) goto ', tolabl, ';')
            UseLabl()
            o.INCREF(ref1)
            o.Cls(ref, ref2)
            return ref1
        elif IsTuple(t):        
            if it[2][1] >= 0:
##                o.Stmt(ref1, '=', 'PyTuple_GetItem', ref, it[2][1])
                GetTupleItem(o, t, ref1, ref, it[2][1])
            else:
                o.Stmt(ref1, '=', 'PyTuple_GetItem', ref, 'PyTuple_GET_SIZE(' + CVar(ref) + ') ' + str(it[2][1]))
        elif IsStr(t): # after. Too many low-lewel code.
            if it[2][0] == 'CONST' and type(it[2][1]) is int and it[2][1] >= 0:
                o.Raw('if (PyString_GET_SIZE( ', ref, ' ) > ', it[2][1], ') {')
                o.Raw(ref1, ' = PyString_FromStringAndSize(PyString_AS_STRING(', ref, ')+', it[2][1], ', 1);')
                o.append('} else {')
                o.Raw('if ((', ref1, ' = PyObject_GetItem (', ref, ' , ', it[2], ' )) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                return ref1
            if it[2][0] == 'CONST' and type(it[2][1]) is int and it[2][1] == -1:
                o.Raw('if (PyString_GET_SIZE( ', ref, ' ) > 0) {')
                o.Raw(ref1, ' = PyString_FromStringAndSize(PyString_AS_STRING(', ref, ')+(PyString_GET_SIZE( ', ref, ' )-1), 1);')
                o.append('} else {')
                o.Raw('if ((', ref1, ' = PyObject_GetItem (', ref, ' , ', it[2], ' )) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                return ref1
            o.Stmt(ref1, '=', 'PyObject_GetItem', ref, it[2])
        elif expand_BINARY_SUBSCR or islist:
            if not islist:
                o.Stmt('if (PyList_CheckExact(', ref, ')) {')
            if it[2][1] >= 0:
                o.Stmt(ref1, '=', 'PyList_GetItem', ref, it[2][1])
            else:
                o.Stmt(ref1, '=', 'PyList_GetItem', ref, 'PyList_GET_SIZE(' + CVar(ref) + ') ' + str(it[2][1]))
            if not islist:
                o.append('} else {')
                o.Stmt(ref1, '=', 'PyObject_GetItem', ref, it[2])
                o.append('}')
        else:
            verif(it, o)
            if t is not None and t != Kl_Buffer:
                Debug('not None', it, t)
                o.Stmt(ref1, '=', 'PyObject_GetItem', ref, it[2])
            else:    
                o.Stmt(ref1, '=', '_c_BINARY_SUBSCR_Int', ref, it[2][1], it[2])
        Cls1(o, ref)
        return ref1
    if head == 'from_ceval_BINARY_SUBSCR':
        return generate_from_ceval_binary_subscr(it, o, forcenewg)
    if head == '_PyString_StartSwith':
        assert IsStr(TypeExpr(it[1])) #, TypeExpr(it[1]), it[1]
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            ref0 = Expr1(it[1], o)
            s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
            o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
            cond = CVar(s_l) + ' >= ' + str(len(it[2][1]))
            cond += ' && 0 == memcmp(' + Str_for_C(it[2][1]) + ', ' + CVar(s_ref) + ', ' + str(len(it[2][1])) + ')'
            o.Stmt(ref, '=', 'PyBool_FromLong', cond) 
            o.Cls(s_l, s_ref, ref0)
            return ref
        ref0 = Expr1(it[1], o)
        ref1 = Expr1(it[2], o)
        s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
        o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
        s_l_, s_ref_ = New('Py_ssize_t'), New('charref')
        o.Stmt('PyString_AsStringAndSize', ref1, ('&', s_ref_), ('&', s_l_))
        cond = CVar(s_l) + ' >= ' + CVar(s_l_)
        cond += ' && 0 == memcmp(' + CVar(s_ref_) + ', ' + CVar(s_ref) + ', ' + CVar(s_l_) + ')'
        o.Stmt(ref, '=', 'PyBool_FromLong', cond) 
        o.Cls(s_l, s_ref, ref0)
        o.Cls(s_l_, s_ref_, ref1)
        return ref

    if head == '_PyString_Contains':
        assert IsStr(TypeExpr(it[1])) #, TypeExpr(it[1]), it[1]
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            ref0 = Expr1(it[1], o)
            s_l, ref = New('Py_ssize_t'), New(None, forcenewg)
            o.Stmt(s_l, '=', 'PyString_GET_SIZE', ref0)
            cond = CVar(s_l) + ' >= ' + str(len(it[2][1]))
            cond += ' && fastsearch( PyString_AS_STRING(' + CVar(ref0) + '), ' + CVar(s_l) + ', ' + Str_for_C(it[2][1]) + ', ' + str(len(it[2][1])) + ', -1, FAST_SEARCH) >= 0'
            Used('fastsearch')
            o.Stmt(ref, '=', 'PyBool_FromLong', cond) 
            o.Cls(s_l, ref0)
            return ref
        ref0 = Expr1(it[1], o)
        ref1 = Expr1(it[2], o)
        s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
        o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
        s_l_, s_ref_ = New('Py_ssize_t'), New('charref')
        o.Stmt('PyString_AsStringAndSize', ref1, ('&', s_ref_), ('&', s_l_))
        ## cond = CVar(s_l) + ' >= ' + CVar(s_l_)
        ## cond += ' && 0 == memcmp(' + CVar(s_ref_) + ', ' + CVar(s_ref) + ', ' + CVar(s_l_) + ')'

        cond = CVar(s_l) + ' >= ' + CVar(s_l_)
        cond += ' && fastsearch(' + CVar(s_ref) + ', ' + CVar(s_l) + ', ' + CVar(s_ref_) + ', ' + CVar(s_l_) + ', -1, FAST_SEARCH) >= 0'
        Used('fastsearch')

        o.Stmt(ref, '=', 'PyBool_FromLong', cond) 
        o.Cls(s_l, s_ref, ref0)
        o.Cls(s_l_, s_ref_, ref1)
        return ref

    if head == '_PyString_Find':
        assert IsStr(TypeExpr(it[1])) #, TypeExpr(it[1]), it[1]
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            ref0 = Expr1(it[1], o)
            s_l, ref = New('Py_ssize_t'), New(None, forcenewg)
            o.Stmt(s_l, '=', 'PyString_GET_SIZE', ref0)
            cond = 'fastsearch( PyString_AS_STRING(' + CVar(ref0) + '), ' + CVar(s_l) + ', ' + Str_for_C(it[2][1]) + ', ' + str(len(it[2][1])) + ', -1, FAST_SEARCH)'
            Used('fastsearch')
            o.Stmt(ref, '=', 'PyInt_FromLong', cond) 
            o.Cls(s_l, ref0)
            return ref
        ref0 = Expr1(it[1], o)
        ref1 = Expr1(it[2], o)
        s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
        o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
        s_l_, s_ref_ = New('Py_ssize_t'), New('charref')
        o.Stmt('PyString_AsStringAndSize', ref1, ('&', s_ref_), ('&', s_l_))
        ## cond = CVar(s_l) + ' >= ' + CVar(s_l_)
        ## cond += ' && 0 == memcmp(' + CVar(s_ref_) + ', ' + CVar(s_ref) + ', ' + CVar(s_l_) + ')'

        cond = 'fastsearch(' + CVar(s_ref) + ', ' + CVar(s_l) + ', ' + CVar(s_ref_) + ', ' + CVar(s_l_) + ', -1, FAST_SEARCH)'
        Used('fastsearch')

        o.Stmt(ref, '=', 'PyInt_FromLong', cond) 
        o.Cls(s_l, s_ref, ref0)
        o.Cls(s_l_, s_ref_, ref1)
        return ref


    if head == '_PyString_RFind':
        assert IsStr(TypeExpr(it[1])) #, TypeExpr(it[1]), it[1]
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            ref0 = Expr1(it[1], o)
            s_l, ref = New('Py_ssize_t'), New(None, forcenewg)
            o.Stmt(s_l, '=', 'PyString_GET_SIZE', ref0)
            cond = 'fastsearch( PyString_AS_STRING(' + CVar(ref0) + '), ' + CVar(s_l) + ', ' + Str_for_C(it[2][1]) + ', ' + str(len(it[2][1])) + ', -1, FAST_RSEARCH)'
            Used('fastsearch')
            o.Stmt(ref, '=', 'PyInt_FromLong', cond) 
            o.Cls(s_l, ref0)
            return ref
        ref0 = Expr1(it[1], o)
        ref1 = Expr1(it[2], o)
        s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
        o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
        s_l_, s_ref_ = New('Py_ssize_t'), New('charref')
        o.Stmt('PyString_AsStringAndSize', ref1, ('&', s_ref_), ('&', s_l_))
        ## cond = CVar(s_l) + ' >= ' + CVar(s_l_)
        ## cond += ' && 0 == memcmp(' + CVar(s_ref_) + ', ' + CVar(s_ref) + ', ' + CVar(s_l_) + ')'

        cond = 'fastsearch(' + CVar(s_ref) + ', ' + CVar(s_l) + ', ' + CVar(s_ref_) + ', ' + CVar(s_l_) + ', -1, FAST_RSEARCH)'
        Used('fastsearch')

        o.Stmt(ref, '=', 'PyInt_FromLong', cond) 
        o.Cls(s_l, s_ref, ref0)
        o.Cls(s_l_, s_ref_, ref1)
        return ref

    if head == '_PyString_Index':
        assert IsStr(TypeExpr(it[1])) #, TypeExpr(it[1]), it[1]
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            ref0 = Expr1(it[1], o)
            s_l, ref = New('Py_ssize_t'), New(None, forcenewg)
            o.Stmt(s_l, '=', 'PyString_GET_SIZE', ref0)
            cond = 'fastsearch( PyString_AS_STRING(' + CVar(ref0) + '), ' + CVar(s_l) + ', ' + Str_for_C(it[2][1]) + ', ' + str(len(it[2][1])) + ', -1, FAST_SEARCH)'
            Used('fastsearch')
            l_3 = New('Py_ssize_t')
            o.Raw('if ((', l_3, ' = ', cond, ') == -1) {')
            o.Raw('PyErr_SetString(PyExc_ValueError, "substring not found");')
            o.Raw('goto ', labl, ';') 
            UseLabl()
            o.Raw('}')
            o.Stmt(ref, '=', 'PyInt_FromLong', l_3) 
            o.Cls(s_l, ref0, l_3)
            return ref
        ref0 = Expr1(it[1], o)
        ref1 = Expr1(it[2], o)
        s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
        o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
        s_l_, s_ref_ = New('Py_ssize_t'), New('charref')
        o.Stmt('PyString_AsStringAndSize', ref1, ('&', s_ref_), ('&', s_l_))
        ## cond = CVar(s_l) + ' >= ' + CVar(s_l_)
        ## cond += ' && 0 == memcmp(' + CVar(s_ref_) + ', ' + CVar(s_ref) + ', ' + CVar(s_l_) + ')'

        cond = 'fastsearch(' + CVar(s_ref) + ', ' + CVar(s_l) + ', ' + CVar(s_ref_) + ', ' + CVar(s_l_) + ', -1, FAST_SEARCH)'
        Used('fastsearch')

        l_3 = New('Py_ssize_t')
        o.Raw('if ((', l_3, ' = ', cond, ') == -1) {')
        o.Raw('PyErr_SetString(PyExc_ValueError, "substring not found");')
        o.Raw('goto ', labl, ';') 
        UseLabl()
        o.Raw('}')
        o.Stmt(ref, '=', 'PyInt_FromLong', l_3) 

        o.Cls(s_l, s_ref, ref0), l_3
        o.Cls(s_l_, s_ref_, ref1)
        return ref


    if head == '_PyString_ctype':
        if TypeExpr(it[1]) == Kl_Char:
            ref0 = Expr1(it[1], o)
            cond = it[2] + ' ( *PyString_AS_STRING ( ' + CVar(ref0) + ' ) )'
            Used('ctype')
            ref = New(None, forcenewg)
            o.Stmt(ref, '=', 'PyBool_FromLong', cond) 
            o.Cls(ref0)
            return ref
        if TypeExpr(it[1]) == Kl_String:
            ref0 = Expr1(it[1], o)
            ind = New('Py_ssize_t')
            isret = New('int')
            o.Raw(isret, ' = 0;')
            o.Raw('for(', ind, ' = 0; ', ind, ' < PyString_GET_SIZE ( ', ref0, ' ); ', ind, ' ++) {')
            cond = it[2] + ' ( PyString_AS_STRING ( ' + CVar(ref0) + ' )[' + CVar(ind) + '] )'
            o.Raw('if (!(',isret, ' = ', cond, ')) break;')
            o.Raw('}')
            Used('ctype')
            ref = New(None, forcenewg)
            o.Stmt(ref, '=', 'PyBool_FromLong', isret) 
            o.Cls(ref0, ind, isret)
            return ref

    if head == 'PyObject_Hash':
        verif(it, o)
        ref1 = Expr1(it[1], o)
        n1 = New('long')  
        o.Stmt(n1, '=', head, ref1)
        Cls1(o, ref1)
        ret = New(typed, forcenewg)  
        o.PushInt(ret, n1)
        Cls1(o, n1)
        return ret
    if head == '_PyObject_Cmp':
        verif(it, o)
        ref1 = Expr1(it[1], o)
        ref2 = Expr1(it[2], o)
        n1 = New('int')  
        o.Stmt('PyObject_Cmp', ref1, ref2, ('&', n1))
        o.Cls(ref1, ref2)
        ret = New(typed, forcenewg)  
        o.PushInt(ret, n1)
        Cls1(o, n1)
        return ret
    if head == '_PyString_EndSwith' and IsStr(TypeExpr(it[1])):
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            ref0 = Expr1(it[1], o)
            s_l, s_ref, ref = New('Py_ssize_t'), New('charref'), New(None, forcenewg)
            o.Stmt('PyString_AsStringAndSize', ref0, ('&', s_ref), ('&', s_l))
            cond = CVar(s_l) + ' >= ' + str(len(it[2][1]))
            s_i2, s_ref2 = New('int'), New('charref')
            o.Stmt(s_i2, '=', s_l, '-', len(it[2][1]))
            o.Stmt(s_ref2, '=', s_ref, '+', s_i2)
            cond += ' && 0 == memcmp(' + Str_for_C(it[2][1]) + ', ' + CVar(s_ref2) + ', ' + str(len(it[2][1])) + ')'
            o.Stmt(ref, '=', 'PyBool_FromLong', cond) 
            o.Cls(s_l, s_ref, ref0, s_i2, s_ref2)
            return ref
        Fatal('', it)
    if head == '_PyList_Pop':
        assert IsList(TypeExpr(it[1]))
        ref0 = Expr1(it[1], o)
        ref = New(None, forcenewg)
        if len(it) == 3:
            if it[2][0] == 'CONST':
                ind1 = New('long')
                if it[2][1] < 0:
                    o.Raw(ind1, ' = PyList_GET_SIZE(', ref0, ') - ', abs(it[2][1]), ';')
                else:    
                    o.Stmt(ind1, '=', it[2][1])
            else:
                o1,ind1 = shortage(generate_ssize_t_expr(it[2]))
                o.extend(o1)
                if not istemptyped(ind1):
                    ind_ = New('long')
                    o.Raw(ind_, ' = ', ind1, ';')
                    ind1 = ind_
                o.Stmt('if (', ind1, '< 0) {')
                o.Raw(ind1, ' += PyList_GET_SIZE(', ref0, ');')
                o.append('}')                        
        elif len(it) == 2:        
            ind1 = New('long')
            o.Raw(ind1, ' = PyList_GET_SIZE(', ref0, ') - 1;')
        o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind1)
        ind2 = New('long')
        o.Stmt(ind2, '=', ind1, '+', 1)
        o.Stmt('PyList_SetSlice', ref0, ind1, ind2, 'NULL')
        o.Cls(ind1, ind2, ref0)
        return ref

    if head == '_PyDict_Get' and IsDict(TypeExpr(it[1])):
        ref0, ref1 = Expr(o, it[1:3])
        ref = New(None, forcenewg)
        if istempref(ref):
            o.Raw(ref, ' =  PyDict_GetItem(', ref0, ', ', ref1, ');')
            o.Raw('if (', ref, ' == 0) {') 
            ref3 = GenExpr(it[3], o, ref)
            if istempref(ref3) and istempref(ref) and ref3 != ref:
                Fatal('Not eq tempref', it, ref3, ref, it[3])
            elif ref3 != ref:
                o.Raw(ref, ' = ', ref3, ';')
                o.INCREF(ref)        
            o.append('} else {')
            o.INCREF(ref)        
            o.append('}')
            if ref3 != ref:
                Cls1(o, ref3)
        else:
            Fatal('', it)
        o.Cls(ref0, ref1)
        return ref

    if head == 'PyObject_GetAttr':
        return generate_GetAttr(it,o, forcenewg, typed)

    if head == 'PyObject_GetAttr3':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('Typed GetAttr3', t, it)
        ref0, ref1 = Expr(o, it[1:3])
        ref = New(None, forcenewg)
        if istempref(ref):
            o.Raw(ref, ' = PyObject_GetAttr(', ref0, ', ', ref1, ');')
            o.Cls(ref0, ref1)
            o.Raw('if (', ref, ' == 0 && PyErr_ExceptionMatches(PyExc_AttributeError)) {')
            o.Raw('PyErr_Clear();')
            ref3 = GenExpr(it[3], o, ref)
            if istempref(ref3) and istempref(ref) and ref3 != ref:
                Fatal('Not eq tempref', it, ref3, ref)
            elif ref3 != ref:
                o.Raw(ref, ' = ', ref3, ';')
                o.INCREF(ref)        
            if ref3 != ref:
                Cls1(o, ref3)
            o.append('}')
        else:
            Fatal('', it)
        return ref

    if head == '@PyInt_FromSsize_t':
        return GenExpr(it[2],o, forcenewg)
        
    if head in ('c_Py_EQ_Int', 'c_Py_NE_Int', 'c_Py_LT_Int', 'c_Py_LE_Int', 'c_Py_GT_Int', 'c_Py_GE_Int'):
        ref = Expr1(it[1], o)
        n = 'NULL'
        t = TypeExpr(it[1])
        if t is not None:
            Debug('typed compare', t, it)
        if type(it[2]) is int:
            int_t = it[2] 
            n = const_to(int_t)   
        elif it[2][0] == 'CONST' and type(it[2][1]) is int:
            int_t = it[2][1]    
            n = const_to(int_t)   
        elif it[2][0] in ('!PY_SSIZE_T',):
            int_t = GenExpr(it[2][1],o, forcenewg, 'Py_ssize_t')
        else:
            Fatal('CMP', it)
        ret = New('int')    
        o.Stmt(ret,'=', head, ref, int_t, n)
        o.Cls(ref, int_t)
        return ret
    if head == 'CHR_BUILTIN':
        t = TypeExpr(it[1])
        if not IsNoneOrInt(t) and t != Kl_IntUndefSize:
            Fatal('Illegal typed CHR', t, it)
        ref = Expr1(it[1],o)
        if ref[0] == 'CONST' and type(ref[1]) is int:
            n = ref[1]
        else:
            n = New('long')
            o.Stmt(n, '=', 'PyInt_AsLong', ref)
        Cls1(o, ref)
        v = []
        if TCmp(it[1], v, ('!PyNumber_And', '?', ('CONST', 255))) or\
           TCmp(it[1], v, ('!PyNumber_And', ('CONST', 255), '?')):
               pass
        else:   
            if type(n) is not int or n < 0 or n > 255:
                o_2 = Out() 
                o_2.Raw('PyErr_SetString(PyExc_ValueError, \"chr() arg not in range(256)\");')
                o_2.Raw('goto ', labl, ';')
                tolabl = append_to_exception(o_2)            
                
                o.Raw('if ( ', n, ' < 0 || ', n, ' >= 256 ) goto ', tolabl, ';')
                UseLabl()
        o.append('{')
        o.Raw('char __s[1];')        
        o.Raw('__s[0] = (unsigned char)', n, ';')
        ref = New(None, forcenewg)
        o.Stmt(ref, '=', 'PyString_FromStringAndSize', '__s', '1')        
        o.append('}')
        Cls1(o, n)
        return ref    
    if head == 'ORD_BUILTIN':
        t = TypeExpr(it[1])
        if not IsStr(t):
            if t is not None:
                Debug('typed ORD', t, it)
        ref = Expr1(it[1],o)
        n = New('long')
        ref2 = New(None, forcenewg)
        if t == Kl_Char:
            o.Raw(n, ' = (long)((unsigned char)*', PyString_AS_STRING(ref), ');')
            o.PushInt(ref2, n)
            o.Cls(n, ref)
            if istempref(ref):
                o.Raw('Py_CLEAR(', ref, ');')
            return ref2 
        if IsStr(t):
            o.Stmt('if (PyString_GET_SIZE(', ref,') == 1) {')
            o.Raw(n, ' = (long)((unsigned char)*', PyString_AS_STRING( ref), ');')
            o.PushInt(ref2, n)
            o.append('} else {') 
            if not is_pypy:
                GenExpr(('!PyCFunction_Call', (load_builtin('ord'),), ('!BUILD_TUPLE', (ref,)), ('NULL',)), o, ref2)
            else:
                GenExpr(('!PyObject_Call', (load_builtin('ord'),), ('!BUILD_TUPLE', (ref,)), ('NULL',)), o, ref2)
            o.append('}')
            o.Cls(n, ref)
            if istempref(ref):
                o.Raw('Py_CLEAR(', ref, ');')
            return ref2 

        o.Stmt('if (PyString_Check(', ref, ') && PyString_GET_SIZE(', ref,') == 1) {')
        o.Raw(n, ' = (long)((unsigned char)*PyString_AS_STRING(', ref, '));')
##        o.Stmt(ref2, '=', 'PyInt_FromLong', Long)
        if not is_pypy:
            o.Stmt('} else if (PyByteArray_Check(', ref, ') && PyByteArray_GET_SIZE(', ref,') == 1) {')
            o.Raw(n, ' = (long)((unsigned char)*PyByteArray_AS_STRING(', ref, '));')
##        o.Stmt(ref2, '=', 'PyInt_FromLong', Long)
        o.Stmt('} else if (PyUnicode_Check(', ref, ') && PyUnicode_GET_SIZE(', ref,') == 1) {')
        o.Raw(n, ' = (long)((wchar_t)*PyUnicode_AS_UNICODE(', ref, '));')
##        o.Stmt(ref2, '=', 'PyInt_FromLong', Long)
        o.append('} else {') 
        ref3 = New()
        if is_pypy:
            GenExpr(('!PyObject_Call', (load_builtin('ord'),), ('!BUILD_TUPLE', (ref,)), ('NULL',)), o, ref3)
        else:
            GenExpr(('!PyCFunction_Call', (load_builtin('ord'),), ('!BUILD_TUPLE', (ref,)), ('NULL',)), o, ref3)
        o.Stmt(n, '=', 'PyInt_AsLong', ref3)
        Cls1(o, ref3)
        o.append('}')
        Cls1(o, ref)
        if istempref(ref):
           o.Raw('Py_CLEAR(', ref, ');') 
        o.PushInt(ref2, n)
        Cls1(o, n) 
        return ref2 
    if head == 'PY_SSIZE_T':
        o1,n = shortage(generate_ssize_t_expr(it[1]))
        o.extend(o1)
        if type(n) is int:
            return ('CONST', n)
        ref = New(None, forcenewg)
        o.PushInt(ref, n)
        Cls1(o, n)
        return ref     
    if head == 'STR_CONCAT':
        return GenExpr_STR_CONCAT(it, o, forcenewg)
    if head == 'LIST_COMPR':
        assert len(it) == 3
        prev_compr = current_co.list_compr_in_progress
        current_co.list_compr_in_progress = True
        ref = generate_list_compr(it[1],it[2],o, forcenewg)  
        current_co.list_compr_in_progress = prev_compr
        return ref
    if head == 'SET_COMPR':
        assert len(it) == 3
        prev_compr = current_co.list_compr_in_progress
        current_co.list_compr_in_progress = True
        ref = generate_set_compr(it[1],it[2],o, forcenewg)  
        current_co.list_compr_in_progress = prev_compr
        return ref
    if head == 'MAP_COMPR':
        assert len(it) == 3
        prev_compr = current_co.list_compr_in_progress
        current_co.list_compr_in_progress = True
        ref = generate_map_compr(it[1],it[2],o, forcenewg)  
        current_co.list_compr_in_progress = prev_compr
        return ref
    if head == 'BOOLEAN':
        o1,logic = shortage(generate_logical_expr(it[1]))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', logic)
        Cls1(o, logic)
        return ref
    if head == '1NOT' and it[1][0] == '!BOOLEAN':
        o1, int_val = shortage(generate_logical_expr(it[1]))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', ConC('!(', int_val, ')'))
        Cls1(o, int_val)
        return ref

    if head in ('_EQ_', '_NEQ_'):
        Fatal('GenExpr', it)
    if head == 'AND_BOOLEAN':
        Fatal('GenExpr', it)
    if head == '1NOT':
        ref1 = Expr1(it[1], o)
        n = New('int')
        o.Stmt(n, '=', 'PyObject_Not', ref1)
        Cls1(o, ref1)
        ref = New(None, forcenewg)
        o.Stmt('if (', n, ') {')
        o.Stmt(ref, '=', 'Py_True')
        o.append('} else {')
        o.Stmt(ref, '=', 'Py_False')
        o.append('}')
        Cls1(o, n)
        o.INCREF(ref)
        return ref
    if head == '$PyDict_SymmetricUpdate':
        if it[1][0] == '!BUILD_MAP':
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyDict_Update', ref1, ref2)
            Cls1(o, ref2)
            return ref1
        Fatal('GenExpr', it)
    if head == 'CLASS_CALC_CONST':
        ref = New(None, forcenewg)
        ref1 = Expr1(it[2], o)
        o.Stmt(ref, '=', 'PyInstance_New', ('CALC_CONST',it[1]), ref1, 'NULL')
        Cls1(o, ref1)
        return ref
    if head == 'CLASS_CALC_CONST_DIRECT':
        ref = New(None, forcenewg)
        o.Stmt(ref, '=', 'PyInstance_NewRaw', ('CALC_CONST',it[1]), 'NULL')
        if it[3][0] == 'CONST':
            tupl = tuple([('CONST', x) for x in it[3][1]])
        else:
            tupl = it[3][1]    
        PushAcc([ref],[ref])
        ref2 = Expr1(('!CALL_CALC_CONST', it[2], ('!BUILD_TUPLE', (ref,) + tupl)), o)
        PopAcc(o, False)
        if ref2 == ('CONST', None) or ref2 == 'Py_None':
            pass
        else:
            o.Raw('assert(', ref2, ' == Py_None);')
        Cls1(o, ref2)
        return ref
    if head == 'CLASS_CALC_CONST_NEW':
        ref = GenExpr(('!PyObject_Call', ('CALC_CONST', it[1]), it[2], ('NULL',)), o, forcenewg)
        return ref
    if head == 'CALL_CALC_CONST':
        return generate_call_calc_const(it,o, forcenewg, typed)
    if head == 'CALL_CALC_CONST_INDIRECT':
        return generate_call_calc_const_indirect(it,o, forcenewg, typed)
            
    if head == 'PyObject_Call':
        if it[3] == 'NULL' or (len(it[3]) == 1 and it[3][0] == 'NULL'):
            return generate_PyObject_Call_nokey(it, o, forcenewg)

    if head.startswith('PyNumber_'):
        return GenNumberExpr(it, o, forcenewg, typed, skip_float)
    if head == '?Raise':
        return generate_raise_zerodivision(it, o)
    if head == 'COND_EXPR':
        o1, logic = shortage(generate_logical_expr(it[1]))
        o.extend(o1)
        ref_prev = None
        if forcenewg is not None:
            assert istempref(forcenewg)
            ref_prev = forcenewg
            o.CLEAR(ref_prev)
        else:
            ref_prev = New()    
        assert ref_prev is not None
        o.Stmt('if (', logic, ') {')
        ref = GenExpr(it[2], o, ref_prev)

        if ref != ref_prev:
            if istempref(ref):
                pprint((ref,ref_prev))
                pprint(it)
            assert not istempref(ref)
            o.Raw(ref_prev, ' = ', ref, ';')
            o.INCREF(ref_prev)        
        o.append('} else {')
        ref = GenExpr(it[3], o, ref_prev)
        if ref != ref_prev:
            assert not istempref(ref)
            o.Raw(ref_prev, ' = ', ref, ';')
            o.INCREF(ref_prev)        
        o.append('}')
        return ref_prev        
                
#
# Base part
#
    return common_call(head, it, o, typed, forcenewg)

def generate_import_name(it, o):
    importer = Expr1(('!PyDict_GetItem', 'bdict', ('CONST', '__import__')),o)
    if current_co.c_name == 'Init_filename':
        loc = 'glob'
    else:
        loc = 'f->f_locals == 0 ? Py_None : f->f_locals'
    if it[2][0] == 'CONST' and it[2][1] == -1:
        it3 = it[3]
        if it3 == ('CONST', None):
            it3 = ('Py_None',)
        tupl = ('!BUILD_TUPLE', ( ('CONST',it[1]), \
                                    ('glob',), \
                                    (loc,),\
                                    it3))  

    else:        
        tupl = ('!BUILD_TUPLE', ( ('CONST',it[1]), \
                                    ('glob',), \
                                    (loc,),\
                                    it[3], it[2]))  
    arg = Expr1(tupl,o)
    ret = Expr1(('!PyEval_CallObject', importer, arg),o )   
    o.Cls(arg, importer)
    return ret

def generate_raise_zerodivision(it, o):
    gen = [Expr1(x, o) if type(x) is tuple and len(x) > 0 else x \
            for i,x in enumerate(it) if i > 2]
    o.Cls(*gen)

    refs = [('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"), 'NULL']
    o.Stmt('_PyEval_DoRaise', refs[0], refs[1], refs[2])
    if refs[0] != 'NULL':
            o.INCREF(refs[0])
    if refs[1] != 'NULL':
        o.INCREF(refs[1])
    if refs[2] != 'NULL':
        o.INCREF(refs[2])        
    o.Cls(*refs)
    o.Stmt('goto', labl)
    UseLabl()
    return ('CONST', None)

def generate_call_calc_const_indirect(it,o, forcenewg, typed):
    d_nm = 'codefunc_' + it[1]
    ret = New(None, forcenewg)
    if it[2] == ('CONST', ()):
        refs = []
    elif it[2][0] == '!BUILD_TUPLE':
        refs = Expr(o, it[2][1])
    elif it[2][0] == 'CONST':
        refs = [('CONST', x) for x in it[2][1]]
    else:
        Fatal('GenExpr', it)
        raise 
    co = N2C(it[1])    
    argcount = co.co_argcount
    assert len(refs) == argcount      
    tupl = (ret, ' = _Call_CompiledWithFrame(', d_nm, ', ', const_to(co), ', ', argcount)
    Used('_Call_CompiledWithFrame')
    for ref in refs:
        tupl = tupl + (', ', ref)
    tupl = tupl + (')',)    
    tupl = ('if ((',) + tupl + (') == 0) goto ', labl, ';') 
    o.Raw(*tupl)
    UseLabl()
    if len(refs) > 0:
        o.Cls(*refs)
    return ret

def append_to_exception(o_2):
    if tuple(o_2) not in current_co.to_exception:
        current_co.to_exception[tuple(o_2)] = New('label')
    return current_co.to_exception[tuple(o_2)]

def generate_from_ceval_binary_subscr(it, o, forcenewg):
    t = TypeExpr(it[1])
    ty_ind = TypeExpr(it[2])
    islist = IsList(t)
    if t is None:
        pass
    elif t[0] == T_NEW_CL_INST and Is3(t[1], 'Derived', ('!LOAD_BUILTIN', 'list')):
        islist = True    
    if it[2][0] == '!PyInt_FromSsize_t':
        if not islist and t is not None:
            verif(it, o)
        ref = Expr1(it[1], o)
        ref1 = New(None, forcenewg)
        if not islist:
            o.Stmt('if (PyList_CheckExact(', ref, ')) {')
        o.Stmt(ref1, '=', 'PyList_GetItem', ref, it[2][1])
        if not islist:
            o.append('} else {')
            ref2 = Expr1(it[2],o)
            o.Stmt(ref1, '=', 'PyObject_GetItem', ref, ref2)
            Cls1(o, ref2)
            o.append('}')
        Cls1(o, ref)
        return ref1
    if it[2][0] == '!@PyInt_FromSsize_t':
        if not islist and t is not None and not IsDict(t) and not IsTuple(t):
            Debug('not islist? is notdict', it, t)
        ref = Expr1(it[1], o)
        ref1 = New(None, forcenewg)
        if IsDict(t):
            ref2 = Expr1(it[2][2], o)
            
            o_2 = Out() 
            tupl = New()
            o_2.Raw('if ((', tupl, ' = PyTuple_Pack(1, ', ref2, ')) == 0) goto ', labl, ';') 
            o_2.Raw('PyErr_SetObject(PyExc_KeyError, ', tupl, ');')
            Cls1(o_2, tupl)            
            o_2.Raw('goto ', labl, ';')
            tolabl = append_to_exception(o_2)            
            
            o.Raw('if ((', ref1, ' = PyDict_GetItem(', ref, ', ', ref2, ')) == 0) goto ', tolabl, ';')
            UseLabl()
            o.INCREF(ref1)
            o.Cls(ref, ref2)
            return ref1

        if IsTuple(t):
            GetTupleItem(o, t, ref1, ref, it[2][1])
##            o.Stmt(ref1, '=', 'PyTuple_GetItem', ref, it[2][1])
            Cls1(o, ref)
            return ref1
        elif expand_BINARY_SUBSCR or islist: 
            if not islist:
                o.Stmt('if (PyList_CheckExact(', ref, ')) {')
            o.Stmt(ref1, '=', 'PyList_GetItem', ref, it[2][1])
            if not islist:
                verif(it, o)
                o.append('} else {')
                ref2 = Expr1(it[2][2],o)
                o.Stmt(ref1, '=', 'PyObject_GetItem', ref, ref2)
                Cls1(o, ref2)
                o.append('}')
        else:    
            verif(it, o)
            ref2 = Expr1(it[2][2],o)
            o.Stmt(ref1, '=', '_c_BINARY_SUBSCR_Int', ref, it[2][1], ref2)
            Cls1(o, ref2)
        Cls1(o, ref)
        return ref1
    if islist:
        ty_ind = TypeExpr(it[2])
        ref0 = Expr1(it[1], o)
        ref1 = GenExpr(it[2], o, None, None, True)
        ref = New(None, forcenewg)
        ind = None
        if ty_ind is None or IsInt(ty_ind):    
            ind = New('long')
        if ty_ind is None:
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        if ty_ind is None or IsInt(ty_ind): 
            if ref1[0] != 'CONST':   
                o.Stmt(ind, '=', 'PyInt_AS_LONG', ref1)
                if IsInt(ty_ind):
                    Cls1(o, ref1)
                o.Stmt('if (', ind, '< 0) {')
                o.Raw(ind, ' += PyList_GET_SIZE(', ref0, ');')
                o.append('}')
                o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind)
                Cls1(o, ind)
            elif ref1[1] >= 0:    
                o.Stmt(ref, '=', 'PyList_GetItem', ref0, ref1[1])
                Cls1(o, ind)
            else: ##if ref1[1] < 0:    
                o.Raw(ind, ' = PyList_GET_SIZE(', ref0, ') + ', ref1[1], ';')
                o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind)
                Cls1(o, ind)
        if ty_ind is None:
            o.append('} else {')
        if not IsInt(ty_ind):
            o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
        if ty_ind is None:
            o.append('}')
        Cls1(o, ref1)
        Cls1(o, ref0)
        return ref
    if IsDict(t):
        ref0 = Expr1(it[1], o)
        ref1 = GenExpr(it[2], o, None, None, True)
        ref = New(None, forcenewg)
        o_2 = Out() 
        tupl = New()
        o_2.Raw('if ((', tupl, ' = PyTuple_Pack(1, ', ref1, ')) == 0) goto ', labl, ';') 
        o_2.Raw('PyErr_SetObject(PyExc_KeyError, ', tupl, ');')
        Cls1(o_2, tupl)            
        o_2.Raw('goto ', labl, ';')
        tolabl = append_to_exception(o_2)
        o.Raw('if ((', ref, ' = PyDict_GetItem(', ref0, ', ', ref1, ')) == 0) goto ', tolabl, ';')
        UseLabl()

        o.INCREF(ref)
        o.Cls(ref0, ref1)
        return ref
    if IsTuple(t):
        ref0 = Expr1(it[1], o)
        ref1 = GenExpr(it[2], o, None, None, True)
        ref = New(None, forcenewg)
        ind = None
        if ty_ind is None or IsInt(ty_ind):   
            if ref1[0] == 'CONST' and type(ref1[1]) is int and ref1[1] >= 0:
                ind = ref1[1] 
            else:
                ind = New('long')
        if ty_ind is None:
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        if ty_ind is None or IsInt(ty_ind):    
            if  type(ind) is not int:
                o.Stmt(ind, '=', 'PyInt_AS_LONG', ref1)
                if IsInt(ty_ind):
                    Cls1(o, ref1)
                o.Stmt('if (', ind, '< 0) {')
                o.Raw(ind, ' += PyTuple_GET_SIZE(',ref0,');')
                o.append('}')
##            Cls1(o, ref1)
            GetTupleItem(o, t, ref, ref0, ind)
##            o.Stmt(ref, '=', 'PyTuple_GetItem', ref0, ind)
            Cls1(o, ind)
        if ty_ind is None:
            o.append('} else {')
        if not IsInt(ty_ind):
            o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
        if ty_ind is None:
            o.append('}')
        Cls1(o, ref1)
        Cls1(o, ref0)
        return ref
    if IsStr(t):
        ty_ind = TypeExpr(it[2])
        ref0 = Expr1(it[1], o)
        ref1 = GenExpr(it[2], o, None, None, True)
        ref = New(None, forcenewg)
        ind = None
        if ty_ind is None or IsInt(ty_ind):    
            ind = New('long')
        if ty_ind is None:
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        if ty_ind is None or IsInt(ty_ind):    
            o.Stmt(ind, '=', 'PyInt_AS_LONG', ref1)
            if IsInt(ty_ind):
                Cls1(o, ref1)
            o.Stmt('if (', ind, '< 0) {')
            if ref0[0] == 'CONST':
                o.Raw(ind, ' += ', len(ref0[1]), ';')
            else:
                o.Raw(ind, ' += PyString_GET_SIZE(',ref0,');')
            o.append('}')

            o_2 = Out() 
            o_2.Raw('PyErr_SetString(PyExc_IndexError, "string index out of range");')
            o_2.Raw('goto ', labl, ';')
            tolabl = append_to_exception(o_2)

            if ref0[0] == 'CONST':
                len_ref0 = len(ref0[1])
                o.Raw('if (', ind, ' < 0 || ', ind, ' >= ',len_ref0,') goto ', tolabl, ';')
            else:    
                o.Raw('if (', ind, ' < 0 || ', ind, ' >= PyString_GET_SIZE(',ref0,')) goto ', tolabl, ';')
            UseLabl()
            ch = ConC('(', PyString_AS_STRING(ref0), ' + ', ind, ')') 
            o.Raw(ref, ' = PyString_FromStringAndSize(', ch, ', 1);')
            Cls1(o, ind)
        if ty_ind is None:
            o.append('} else {')
        if not IsInt(ty_ind):
            o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
        if ty_ind is None:
            o.append('}')
        Cls1(o, ref1)
        Cls1(o, ref0)
        return ref
    verif(it, o)
    t = TypeExpr(it[1]) 
    if t is not None and t[0] in ('NewClassInstance', 'OldClassInstance'):
        Debug('Typed BINARY_SUBSCR not specialised: %s ( %s, %s )' % (it, t, TypeExpr(it[2])))

    ref0 = Expr1(it[1], o)
    ref1 = GenExpr(it[2], o, None, None, True)
    ref = New(None, forcenewg)
    if ref1[0] == 'CONST' and type(ref1[1]) is int:
        o.Raw('if ((', ref, ' = _c_BINARY_SUBSCR_Int ( ', ref0, ' , ', ref1[1], ' , ', ref1, ' )) == 0) goto ', labl, ';')
        UseLabl()
        Used('_c_BINARY_SUBSCR_Int')
    elif ref1[0] == 'FAST' and IsInt(ty_ind) and not current_co.IsCVar(ref1):
        o.Raw('if ((', ref, ' = _c_BINARY_SUBSCR_Int ( ', ref0, ' , PyInt_AS_LONG ( ', ref1, ' ) , ', ref1, ' )) == 0) goto ', labl, ';')
        UseLabl()
        Used('_c_BINARY_SUBSCR_Int')
    else:
        o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
    o.Cls(ref1, ref0)
    return ref        
        
def GetTupleItem(o, t, ref, ref0, ind):
    assert IsTuple(t)
    if type(ind) is int and IsInTupleInd(t, ind):
        o.Stmt(ref, '=', 'PyTuple_GET_ITEM', ref0, ind)
    else:
        o.Stmt(ref, '=', 'PyTuple_GetItem', ref0, ind)        
        
def generate_call_calc_const(it, o, forcenewg, typed, nmtypvar = None):
    d_nm = '_Direct_' + it[1]
    is_const_default = True
    co = N2C(it[1])    
    argcount = co.co_argcount
    is_varargs = co.co_flags & 0x4

    hidden = co.hidden_arg_direct
    typed_arg = co.typed_arg_direct
    ty2 = {}
    for k,v in typed_arg.iteritems():
        if k not in hidden:
            ty2[k] = v
    typed_arg = ty2        

    if it[1] in default_args and default_args[it[1]][0] != 'CONST':
        is_const_default = False
    if it[2] == ('CONST', ()):
        refs = []
    elif it[2][0] == '!BUILD_TUPLE':
        refs = []
        for i, e in enumerate(it[2][1]):
            if i in typed_arg and IsCType(typed_arg[i]) and IsCVar(e) and \
                    Type2CType(typed_arg[i]) == Type2CType(TypeExpr(e)):
                ref_0 = CVarName(e)
            elif i in typed_arg and typed_arg[i][0] is int: 
                if e[0] == 'CONST':
                    ref_0 = e[1]
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('long')
                    o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is float:
                if e[0] == 'CONST':
                    ref_0 = e[1]
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('double')
                    o.Raw(typ3, ' = PyFloat_AS_DOUBLE ( ', ref_0, ' );')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is bool:
                if e[0] == 'CONST':
                    if e[1]:
                        ref_0 = 1
                    else:
                        ref_0 = 0  
                else:    
                    typ3 = New('int')
                    ref_0 = Expr1(e, o)
                    o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1:
                ref_0 = Expr1(e, o)
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', PyString_AS_STRING (ref_0), ';')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            else:        
                ref_0 = Expr1(e, o)
            refs.append(ref_0)
    elif it[2][0] == 'CONST':
        refs = []
        for i, e in enumerate(it[2][1]):
            ref_0 = ('CONST', e)
            if i in typed_arg and typed_arg[i][0] is int:
                ref_0 = ref_0[1]
            elif i in typed_arg and typed_arg[i][0] is float:
                ref_0 = ref_0[1]
            elif i in typed_arg and typed_arg[i][0] is bool:
                if ref_0[1]:
                    ref_0 = 1
                else:
                    ref_0 = 0    
            elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1:
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', PyString_AS_STRING(ref_0), ';')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            refs.append(ref_0)
    else:
        Fatal('GenExpr', it)
    if not is_varargs:
        if argcount != len(refs):
            if argcount > len(refs):
                if it[1] in default_args:
                    if is_const_default:
                        _refs2 = [('CONST', x) for x in default_args[it[1]][1]]
                    else:
                        _refs2 = [Expr1(x, o) for x in default_args[it[1]][1]]
                    add_args = argcount - len(refs)
                    pos_args = len(_refs2) - add_args
                    len_refs = len(refs)
                    for i1, ref_0 in enumerate(_refs2[pos_args:]):
                        i = i1 + len_refs
                        if i in typed_arg and typed_arg[i][0] is int:
                            if ref_0[0] == 'CONST':
                                ref_0 = ref_0[1]
                            else:    
                                typ3 = New('long')
                                o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                                Cls1(o, ref_0)
                                ref_0 = typ3
                        elif i in typed_arg and typed_arg[i][0] is bool:
                            if ref_0[0] == 'CONST':
                                if ref_0[1]:
                                    ref_0 = 1
                                else:
                                    ref_0 = 0  
                            else:    
                                typ3 = New('int')
                                o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                                Cls1(o, ref_0)
                                ref_0 = typ3
                        elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1:
                            if ref_0[0] == 'CONST':
                                ref_0 = charhex(ref_0[1])
                            else:    
                                typ3 = New('char')
                                o.Raw(typ3, ' = *', PyString_AS_STRING(ref_0), ';')
                                Cls1(o, ref_0)
                                ref_0 = typ3
                        refs.append(ref_0)
    else: 
        assert len(hidden) == 0
        lenrefs = len(refs)
        if argcount > len(refs):
##            print argcount, len(refs), refs, default_args[it[1]][1]
            if it[1] in default_args:
                if is_const_default:
                    _refs2 = [('CONST', x) for x in default_args[it[1]][1]]
                else:
                    print '/111 !!', 'Strange default value', default_args[it[1]]
                    _refs2 = [Expr1(x, o) for x in default_args[it[1]]]
                add_args = argcount - len(refs)
                pos_args = len(_refs2) - add_args
                refs = refs + _refs2[pos_args:]
        rargs = refs[:argcount]
        rtupl = refs[argcount:]
        isconst = all([x[0] == 'CONST' for x in rtupl])
        if isconst:
            rtupl2 = Expr1(('CONST', tuple([x[1] for x in rtupl])), o)
        else:    
            rtupl2 = Expr1(('!BUILD_TUPLE', tuple(rtupl)), o)
        argcount += 1
        
        for i, e in enumerate(rargs):
            if i < lenrefs:
                continue
            if i in typed_arg and IsCType(typed_arg[i]) and IsCVar(e) and \
                    Type2CType(typed_arg[i]) == Type2CType(TypeExpr(e)):
                ref_0 = CVarName(e)
            elif i in typed_arg and typed_arg[i][0] is int and type(e) is tuple: 
                if e[0] == 'CONST':
                    ref_0 = e[1]
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('long')
                    o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is float and type(e) is tuple:
                if e[0] == 'CONST':
                    ref_0 = e[1]
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('double')
                    o.Raw(typ3, ' = PyFloat_AS_DOUBLE ( ', ref_0, ' );')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is bool and type(e) is tuple:
                if e[0] == 'CONST':
                    if e[1]:
                        ref_0 = 1
                    else:
                        ref_0 = 0  
                else:    
                    typ3 = New('int')
                    ref_0 = Expr1(e, o)
                    o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1 and type(e) is tuple:
                ref_0 = Expr1(e, o)
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', PyString_AS_STRING (ref_0), ';')
                    Cls1(o, ref_0)
                    ref_0 = typ3
            else:        
                ref_0 = e 
            rargs[i] = ref_0
        
        refs = rargs + [rtupl2]
    ## if len(refs) != argcount:
        ## pprint(('// 1', refs, it, current_co.co_name))
    assert len(refs) == argcount      
    _refs2 = []
    for i,x in enumerate(refs):              
        if i not in hidden:
            _refs2.append(x)
    co_call = N2C(it[1])        
    if not co_call.IsRetVoid() and not co_call.IsRetBool() and not co_call.IsRetInt() and not co_call.IsRetFloat() and not co_call.IsRetChar():        
        ref = New(None, forcenewg)
        tupl = (ref, '=', d_nm) + tuple(_refs2)
        o.Stmt(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        return ref
    elif co_call.IsRetVoid():
        tupl = (d_nm,) + tuple(_refs2)
        li = ['if (',d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(') == -1) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)     
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        return ('CONST', None)
    elif co_call.IsRetBool():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('int')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.Raw(ref, ' = PyBool_FromLong(', logical, ');')
            Cls1(o, logical)
            return ref
        return
    elif co_call.IsRetInt():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('long')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1 && PyErr_Occurred()) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.PushInt(ref, logical)
            Cls1(o, logical)
            return ref
        return
    elif co_call.IsRetFloat():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('double')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1 && PyErr_Occurred()) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.Raw(ref, ' = PyFloat_FromDouble (', logical, ');')
            Cls1(o, logical)
            return ref
        return
    elif co_call.IsRetChar():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('char')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1 && PyErr_Occurred()) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.Raw(ref, ' = PyString_FromStringAndSize (&', logical, ', 1);')
            Cls1(o, logical)
            return ref
        return
    Fatal('')
    return None

def GenExpr_STR_CONCAT(it, o, forcenewg):
    args = it[1:]
    isstr = [IsStr(TypeExpr(x)) for x in args]
    if all(isstr):
        refs = [Expr1(x, o) for x in args]
        ## l_const = sum([len(x[1]) for x in args if x[0] == 'CONST' and type(x[1]) is str])
        l_vals = []
        for i, x in enumerate(args):
            ta = TypeExpr(x)
            if IsChar(ta):
                l_vals.append(1)
            elif x[0] != 'CONST' or type(x[1]) is not str:
                r0 = New('int')
                l_vals.append(r0)
                o.Raw(r0, ' = PyString_GET_SIZE ( ', refs[i], ' );')
            else:
                l_vals.append(len(x[1]))
        ref = New(None, forcenewg)
        var_len = ' + '.join([CVar(x) for x in l_vals])
        ## if l_const != 0:
            ## var_len = var_len + ' + ' + str(l_const)
        o.Raw(ref, ' = PyString_FromStringAndSize(NULL, ', var_len, ');')
        cref = New('charref')
        o.Raw(cref, ' = ', PyString_AS_STRING(ref), ';')
        for i, x in enumerate(args):
            if l_vals[i] == 0:
                pass
            elif l_vals[i] == 1:
                o.Raw('*', cref, '++ = *', PyString_AS_STRING(refs[i]), ';')
            elif l_vals[i] == 2:
                o.Raw('*', cref, '++ = ', PyString_AS_STRING(refs[i]), '[0];')
                o.Raw('*', cref, '++ = ', PyString_AS_STRING(refs[i]), '[1];')
            elif l_vals[i] == 3:
                o.Raw('*', cref, '++ = ', PyString_AS_STRING(refs[i]), '[0];')
                o.Raw('*', cref, '++ = ', PyString_AS_STRING(refs[i]), '[1];')
                o.Raw('*', cref, '++ = ', PyString_AS_STRING(refs[i]), '[2];')
            else:    
                o.Raw('memcpy(', cref, ', ', PyString_AS_STRING(refs[i]), ', ', l_vals[i], ');')
                if i == len(args) - 1:
                    pass
                else:
                    o.Raw(cref, ' += ', l_vals[i], ';')
        o.Cls(*refs)            
        o.Cls(*l_vals)            
        Cls1(o, cref)
        return ref    
    if len(it) > 4 and len(it) <= 64:
        return GenExpr(('!STR_CONCAT_N', len(it)-1) + it[1:], o, forcenewg)
    elif len(it) == 4:
        return GenExpr(('!STR_CONCAT3', it[1], it[2], it[3]), o, forcenewg)
    elif len(it) == 3:
        return GenExpr(('!STR_CONCAT2', it[1], it[2]), o, forcenewg)
    elif len(it) > 64:
        return GenExpr(('!STR_CONCAT_N', len(it[1:63])) + it[1:63] + ((('!STR_CONCAT',) + it[63:]),), o, forcenewg)
    else:
        Fatal('GenExpr', it)

def call_fastcall(it, o, forcenewg):
    ## is_const_default = True
    ref1 = Expr1(it[1], o)
    if it[2] == ('CONST', ()):
        refs = []
    elif it[2][0] == '!BUILD_TUPLE':
        refs = Expr(o, it[2][1])
    elif it[2][0] == 'CONST':
        refs = [('CONST', x) for x in it[2][1]]
    else:
        Fatal('GenExpr call fastcall', it)
    ref = New(None, forcenewg)
    if len(refs) == 0:
        tupl = (ref, ' = FastCall0(', ref1, ')')
        Used('FastCall0')
    else:    
        tupl = (ref, ' = FastCall(', len(refs), ', ', ref1)
        Used('FastCall')
        for _r in refs:
            tupl = tupl + (', ', _r)
        tupl = tupl + (')',)    
    tupl = ('if ((',) + tupl + (') == 0) goto ', labl, ';') 
    o.Raw(*tupl)
    UseLabl()
    if len(refs) > 0:
        o.Cls(*refs)
    Cls1(o, ref1)    
    return ref

def generate_PyObject_Call_nokey(it, o, forcenewg):
    if it[1][0] == '!LOAD_GLOBAL' and it[1][1] in d_built:
        skip_built = False
        if it[2][0] == '!BUILD_TUPLE':
            args = it[2][1]
        elif it[2][0] == 'CONST':
            args = [('CONST', x) for x in it[2][1]]
        else:
            skip_built = True
        if not skip_built:    
            cm = attempt_direct_builtin(it[1][1],args, it[2])
            if cm is not None:
                proc = Expr1(it[1], o)   
                o.Stmt('if (', proc, '==', load_builtin(it[1][1]), ') {')
                ref = GenExpr(cm, o,forcenewg)
                o.append('} else {')
                tupl = Expr1(it[2], o)
                o.Stmt(ref, '=', 'FirstCFunctionCall', proc, tupl, ('NULL',))
                Cls1(o, tupl)
                o.append('}')
                Cls1(o, proc)
                return ref
            
    if it[1][0] == '!LOAD_BUILTIN' and it[2][0] == '!BUILD_TUPLE' and \
       len(it[2][1]) == 1 and it[2][1][0][0] == '!LIST_COMPR' and it[1][1] in ('all', 'any'):
            prev_compr = current_co.list_compr_in_progress
            current_co.list_compr_in_progress = True
            it1 = it[2][1][0]
            
            logical = generate_func_list_compr(it1[1],it1[2],o, it[1][1]) 
            current_co.list_compr_in_progress = prev_compr
            ref = New(None, forcenewg)
            o.Stmt(ref, '=', 'PyBool_FromLong', logical)
            o.Cls(logical)
            return ref

    s = save_tempgen()    
    o2 = Out()    
    proc = GenExpr(it[1],o2)
    o2.Cls(proc)
    restore_tempgen(s)
 
    ## if it[1][0] == '!PyObject_GetAttr' and it[1][2][0] == 'CONST' and it[1][2][1] in ('startswith', 'endswith'):
        ## it1 = it[1][1]
        ## t1 = TypeExpr(it1)
        ## meth = it[1][2][1]
        ## if it[2][0] == 'CONST' and type(it[2][1]) is tuple and len(it[2][1]) == 1 and t not ype(it[2][1][0]) is str:
            ## it2 = it[2][1][0]
            ## if type(t1) is not tuple or t1[0] is str:
                ## r1 = GenExpr(
    if TypeExpr(it[1]) != Kl_BuiltinFunction and not is_mkfunc_const(proc, it[1]) and \
       it[2][0] in ('!BUILD_TUPLE', 'CONST') and len(it[2][1]) < 15 and it[1][0] != '!LOAD_BUILTIN' and not is_pypy:
        return call_fastcall(it, o, forcenewg) 
    ref = New(None, forcenewg)
    tupl = GenExpr(it[2], o)   
    variant = not is_mkfunc_const(proc, it[1])
    proc = GenExpr(it[1], o)
 
    t = TypeExpr(it[1])
    if t == Kl_BuiltinFunction and not is_pypy:
        o.Stmt(ref, '=', 'PyCFunction_Call', proc, tupl, ('NULL',))
    elif variant:    
        if it[1][0] == '!LOAD_BUILTIN':
            if it[1][1] in d_built and type(d_built[it[1][1]]) == type(len) and not is_pypy:
                o.Stmt(ref, '=', 'PyCFunction_Call', proc, tupl, ('NULL',))
            else:    
                Debug('+Call PyObject_Call builtin (variant)', it[1], TypeExpr(it[1]))
                o.Stmt(ref, '=', 'PyObject_Call', proc, tupl, ('NULL',))
        else:        
            o.Stmt(ref, '=', 'FirstCFunctionCall', proc, tupl, ('NULL',))
    else:
        o.Stmt(ref, '=', 'PyObject_Call', proc, tupl, ('NULL',))
    o.Cls(proc, tupl)
    return ref
    
def common_call(head, it, o, typed, forcenewg):
    verif(it, o)
    if head == '_PyEval_ApplySlice':
        t0 = TypeExpr(it[1])
        t1 = TypeExpr(it[2])
        t2 = TypeExpr(it[3])
        if it[2] == 'NULL' and IsInt(t2):
            ref0 = Expr1(it[1], o)
            o2,ind2 = shortage(generate_ssize_t_expr(it[3]))
            o.extend(o2)
            ref = New(None, forcenewg)
            if IsStr(t0):
                o.Raw('if ( ', ind2, ' >= 0 && ', ind2, ' <= PyString_GET_SIZE ( ', ref0, ' ) ) {')
                o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) , ', ind2, ' );')
                o.Raw('} else if ( ', ind2, ' < 0 && ', ind2, ' >= -PyString_GET_SIZE ( ', ref0, ' ) ) {')
                o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) , PyString_GET_SIZE ( ', ref0, ' ) - ', ind2, ' );')
                o.Raw('} else {')
                o.Raw(ref, ' = ', ('CONST', ''), ';')
                o.INCREF(ref)
                o.Raw('}')
            else:
                o.Stmt(ref, '=', 'PySequence_GetSlice', ref0, '0', ind2)
            o.Cls(ind2, ref0)
            return ref
        if it[3] == 'NULL' and IsInt(t1):
            ref0 = Expr1(it[1], o)
            o1,ind1 = shortage(generate_ssize_t_expr(it[2]))
            o.extend(o1)
            ref = New(None, forcenewg)
            if IsStr(t0):
                o.Raw('if ( ', ind1, ' >= 0 && ', ind1, ' <= PyString_GET_SIZE ( ', ref0, ' ) ) {')
                o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) + ', ind1, ' , PyString_GET_SIZE ( ', ref0, ' ) - ', ind1, ' );')
                o.Raw('} else if ( ', ind1, ' < 0 && ', ind1, ' >= -PyString_GET_SIZE ( ', ref0, ' ) ) {')
                o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) + ( PyString_GET_SIZE ( ', ref0, ' ) + ', ind1, ' ) , - ', ind1, ' );')
                o.Raw('} else {')
                o.Raw(ref, ' = ', ('CONST', ''), ';')
                o.INCREF(ref)
                o.Raw('}')
            else:
                o.Stmt(ref, '=', 'PySequence_GetSlice', ref0, ind1, 'PY_SSIZE_T_MAX')
            o.Cls(ind1, ref0)
            return ref  
        elif IsInt(t1) and IsInt(t2):      
            ref0 = Expr1(it[1], o)
            o1,ind1 = shortage(generate_ssize_t_expr(it[2]))
            o.extend(o1)
            o2,ind2 = shortage(generate_ssize_t_expr(it[3]))
            o.extend(o2)
            ref = New(None, forcenewg)
            assert ind1 != ind2
            o.Stmt(ref, '=', 'PySequence_GetSlice', ref0, ind1, ind2)
            o.Cls(ind1, ind2, ref0)
            return ref              
        it1 = Expr1(it[1], o)
        it2 = it[2]
        if it2 != 'NULL':
            it2 = GenExpr(it2,o, None,None, True)
        it3 = it[3]
        if it3 != 'NULL':
            it3 = GenExpr(it3,o, None,None, True)
        gen = [ it1, it2, it3]
    else:
        gen = [Expr1(x, o) if type(x) is tuple and len(x) > 0 else x \
                    for i,x in enumerate(it) if i > 0]
    if head == '_PyInt_Format':
        gen[0] = ('TYPE_CONVERSION', '(PyIntObject *)', gen[0])      
    if head == '_PyList_Extend':
        gen[0] = ('TYPE_CONVERSION', '(PyListObject *)', gen[0])      
    newg = New(typed, forcenewg)  
    args = (newg, '=', head)  + tuple(gen)       
    o.Stmt(*args)
    o.Cls(*gen)
    return newg   

def GenNumberExpr(it, o, forcenewg, typed, skip_float):
    head = it[0]
    if (head == '!PyNumber_Lshift' or head == '!PyNumber_InPlaceLshift'):
        if it[2][0] == 'CONST' and type(it[2][1]) is int and it[2][1] >= 1 and it[2][1] <= 31:
            shif = it[2][1]
            t1 = TypeExpr(it[1])
            if IsShort(t1) and shif < 16:
                if it[1][0] == '!@PyInt_FromSsize_t':
                    ref1 = None
                    n1 = New('long')
                    o.Raw(n1, ' = ', it[1][1], ';')
                else:    
                    ref1 = Expr1(it[1], o)
                    n1 = New('long')
                    o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                    Cls1(o, ref1)
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
#                o.Raw(n1, ' = ', n1, ' << ', it[2][1], ';')
                o.PushInt(new, ConC('(', n1, ' << ', it[2][1], ')'))
#                o.PushInt(new, n1)
                Cls1(o, n1)
                return new
            elif IsInt(t1):
                if it[1][0] == '!@PyInt_FromSsize_t':
                    ref1 = None
                    n1 = New('long')
                    o.Raw(n1, ' = ', it[1][1], ';')
                else:    
                    ref1 = Expr1(it[1], o)
                    n1 = New('long')
                    o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.Raw('if (', n1, ' < (INT_MAX >> ', it[2][1], ') && ', n1, ' >= 0) {')
##                o.Raw(n1, ' = ', n1, ' << ', it[2][1], ';')
                o.PushInt(new, ConC('(', n1, ' << ', it[2][1], ')'))
                Cls1(o, n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                Cls1(o, ref1)
                return new
            elif IsIntUndefSize(t1) or t1 is None:
                ref1 = Expr1(it[1], o)
                n1 = New('long')
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && (', n1, ' = PyInt_AS_LONG ( ', ref1, ' )) < (INT_MAX >> ', it[2][1], ') && ', n1, ' >= 0) {')
#                o.Raw('if (', n1, ' < (INT_MAX >> ', it[2][1], ') && ', n1, ' >= 0) {')
##                o.Raw(n1, ' = ', n1, ' << ', it[2][1], ';')                
                o.PushInt(new, ConC('(', n1, ' << ', it[2][1], ')'))
                Cls1(o, n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                Cls1(o, ref1)
                return new 
        if it[1] == ('CONST', 1) and type(it[1][1]) is int:    
            t2 = TypeExpr(it[2])
            if IsInt(t2):
                ref1 = Expr1(it[2], o)
                n1 = New('long')
                o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 

                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    

                o.Raw('if (', n1, ' < LONG_BIT) {')
#                o.Raw(n1, ' = 0x1 << ', n1, ';')
                o.PushInt(new, ConC('(0x1 << ', n1, ')'))
                Cls1(o, n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', it[1], ', ', ref1, ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                Cls1(o, ref1)
                return new
            elif IsIntUndefSize(t2) or t2 is None:
                ref1 = Expr1(it[2], o)
                n1 = New('long')
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && (', n1, ' = PyInt_AS_LONG ( ', ref1, ' )) < LONG_BIT) {')
                o.PushInt(new, ConC('(0x1 << ', n1, ')'))
                Cls1(o, n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', it[1], ', ', ref1, ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                Cls1(o, ref1)
                return new
                
##        pprint(('Lshift', TypeExpr(it[1]), TypeExpr(it[2]), it))
    if head == '!PyNumber_Rshift' or head == '!PyNumber_InPlaceRshift':
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if it[2][0] == 'CONST' and type(it[2][1]) is int and (31 >= it[2][1] >= 1) and IsInt(t1) and not is_pypy:
            if it[1][0] == '!@PyInt_FromSsize_t':
                ref1 = None
                n1 = New('long')
                o.Raw(n1, ' = ', it[1][1], ';')
            else:    
                ref1 = Expr1(it[1], o)
                n1 = New('long')
                o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                Cls1(o, ref1)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(n1, ' = Py_ARITHMETIC_RIGHT_SHIFT(long, ', n1, ', ', it[2][1], ');')
            o.PushInt(new, n1)
            Cls1(o, n1)
            return new
        if it[2][0] == 'CONST' and type(it[2][1]) is int and (31 >= it[2][1] >= 1) and t1 is None and not is_pypy:
            ref1 = Expr1(it[1], o)
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            n1 = New('long')
            o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(n1, ' = Py_ARITHMETIC_RIGHT_SHIFT(long, ', n1, ', ', it[2][1], ');')
            o.PushInt(new, n1)
            Cls1(o, n1)
            o.append('} else {')
            o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
            UseLabl()
            o.append('}')
            Cls1(o, ref1)
            return new
        Debug('Uneffoicienr rshift(%s, %s) -- %s >> %s' % (t1,t2, it[1], it[2]))

    if head == '!PyNumber_Multiply' or head == '!PyNumber_InPlaceMultiply':
        ref = GenMultNew1(head,it,o,forcenewg, skip_float)
        if ref is not None:
            return ref

    if head in ('!PyNumber_And', '!PyNumber_InPlaceAnd', \
                '!PyNumber_Or', '!PyNumber_InPlaceOr', \
                '!PyNumber_Xor', '!PyNumber_InPlaceXor') or\
       (head == '!PyNumber_Lshift' and it[1][0] == '!ORD_BUILTIN' and \
       it[2][0] == 'CONST' and 0 <= it[2][1] <= 24):
        ref1, ref2 = Expr(o, it[1:3])
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        check = True    
        skip_int = not_int_op(ref1, ref2, it[1], it[2])
        if not skip_int:
            t1 = TypeExpr(it[1])
            t2 = TypeExpr(it[2])
            check = not IsInt(t1) or not IsInt(t2)
            if it[1][0] != 'CONST' and it[2][0] != 'CONST':
                if check:
                    if IsInt(t1):
                        o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
                    elif IsInt(t2):
                        o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
                    else:
                        o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
                n1 = 'PyInt_AS_LONG ( ' + CVar(ref1) + ' )'
                n2 = 'PyInt_AS_LONG ( ' + CVar(ref2) + ' )'
            elif it[1][0] == 'CONST' and it[2][0] != 'CONST' and type(it[1][1]) is int:
                if check:
                    o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
                n1 = str(it[1][1])
                n2 = 'PyInt_AS_LONG ( ' + CVar(ref2) + ' )'
            elif it[1][0] != 'CONST' and it[2][0] == 'CONST' and type(it[2][1]) is int:
                if check:
                    o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
                n1 = 'PyInt_AS_LONG ( ' + CVar(ref1) + ' )'
                n2 = str(it[2][1])
            else:
                skip_int = True
        op = '???'
        if not skip_int:
            if head == '!PyNumber_And' or head == '!PyNumber_InPlaceAnd':
                op = '&'
            elif head == '!PyNumber_Or' or head == '!PyNumber_InPlaceOr':
                op = '|'
            elif head == '!PyNumber_Xor' or head == '!PyNumber_InPlaceXor':
                op = '^'
            elif head == '!PyNumber_Rshift' or head == '!PyNumber_InPlaceRshift':
                op = '>>'
            elif head == '!PyNumber_Lshift' or head == '!PyNumber_InPlaceLshift':
                op = '<<'
            o.PushInt(new, ConC(n1, ' ', op, ' ', n2))
        if check and not skip_int:
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
        elif check and skip_int:    
            verif(it, o)
            o.Stmt(new, '=', head[1:], ref1, ref2)
        elif not check and not skip_int:
            pass
        else:
            verif(it, o)
            o.Stmt(new, '=', head[1:], ref1, ref2)
        o.Cls(ref1, ref2)
        return new
    
    arifm = ('!PyNumber_Multiply', '!PyNumber_Divide', '!PyNumber_Add', '!PyNumber_Subtract')
    if head in arifm and IsFloat(TypeExpr(it)):
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        fl = GenFloatExpr(it,o)
        o.Stmt(new, '=', 'PyFloat_FromDouble', fl)
        Cls1(o, fl)
        return new  
    if head == '!PyNumber_Multiply':
        t = TypeExpr(it)
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        is1 = IsInt(t1)
        is2 = IsInt(t2)
        ref1 = None
        ref2 = None
        if is1:
            if IsCVar(it[1]):
                l1 = CVarName(it[1])
                if not is2:
                    ref1 = GenExpr(it[1], o, None, None, skip_float)
            else:
                ref1 = GenExpr(it[1], o, None, None, skip_float)
                if IsList(t2) or IsTuple(t2) or IsStr(t2):
                    l1 = None
                else:
                    l1 = New('long')        
                    o.Raw(l1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
        else:
            l1 = -999
            ref1 = GenExpr(it[1], o, None, None, skip_float)
        if is2:
            if IsCVar(it[2]):
                l2 = CVarName(it[2])
                if not is1:
                    ref2 = GenExpr(it[2], o, None, None, skip_float)
            else:
                ref2 = GenExpr(it[2], o, None, None, skip_float)
                if IsList(t1) or IsTuple(t1) or IsStr(t1):
                    l2 = None
                else:
                    l2 = New('long')        
                    o.Raw(l2, ' = PyInt_AS_LONG ( ', ref2, ' );')  
        else:
            l2 = -999
            ref2 = GenExpr(it[2], o, None, None, skip_float)

        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()      
        if skip_float is None:
            skip_float = False
        if it[1][0] == '!BUILD_LIST' or it[1][0] == '!BUILD_TUPLE' or it[1][0] == '!ORD_BUILTIN' or it[1][0] == '!PyNumber_Xor' or it[2][0] == '!PyNumber_Xor':    
            skip_float = True
        if not skip_float:
            if not_float_op(ref1,ref2):
                skip_float = True    
        if is1 and is2:
            skip_float = True
        if IsStr(t1) or IsList(t1) or IsTuple(t1) or IsStr(t2) or IsList(t2) or IsTuple(t2):
            skip_float = True
        skip_int = not_int_op(ref1, ref2, it[1], it[2])
        if skip_int and typed == 'Py_ssize_t':
            skip_int = False
        if not skip_float:    
            bin_arg_float(o, ref1, ref2, True, t1, t2)
            r1 = ref1
            r2 = ref2
            if r1[0] == 'CONST':
                r1 = r1[1]
            elif is1:
                r1 = ConC('(double)', l1)   
            else:
                r1 = ConC('PyFloat_AS_DOUBLE(', r1, ')')   
            if r2[0] == 'CONST':
                r2 = r2[1]
            elif is2:
                r2 = ConC('(double)', l2)   
            else:
                r2 = ConC('PyFloat_AS_DOUBLE(', r2, ')')   
            o.Raw(new, ' = PyFloat_FromDouble(', r1, ' * ', r2, ');')
        if not skip_int and skip_float and is1 and is2:
            if IsInt(t):
                o.PushInt(new, ConC(l1, ' * ', l2))
            else:
                o.Raw('if (!', l1, ' || !', l2, ' || (', l1, ' * ', l2, ') / ', l2, ' == ', l1, ') {')
                o.PushInt(new, ConC(l1, ' * ', l2))
                o.append('} else {')
                if IsCVar(it[1]):
                    ref1 = GenExpr(it[1], o, None, None, skip_float)
                if IsCVar(it[2]):
                    ref2 = GenExpr(it[2], o, None, None, skip_float)
                o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', ref2, ');')
                if IsCVar(it[1]):
                    o.Cls(ref1)
                if IsCVar(it[2]):
                    o.Cls(ref2)
                o.append('}')
            o.Cls(l1, l2)
            o.Cls(ref1, ref2)
            return new
        elif not skip_int:
            if not skip_float:
                if not is1 and not is2:
                    o.Raw('} else if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
                elif not is1 and is2:    
                    o.Raw('} else if (PyInt_CheckExact( ', ref1, ' )) {')
                elif is1 and not is2:    
                    o.Raw('} else if (PyInt_CheckExact( ', ref2, ' )) {')
                else:    
                    o.append('} else if (1) {')
            else:
                if not is1 and not is2:
                    o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
                elif not is1 and is2:    
                    o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
                elif is1 and not is2:    
                    o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
                else:    
                    o.append('if (1) {')
            if not is1:        
                l1 = New('long')        
                o.Raw(l1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
            if not is2:    
                l2 = New('long')        
                o.Raw(l2, ' = PyInt_AS_LONG ( ', ref2, ' );') 
            if IsInt(t):
                o.PushInt(new, ConC(l1, ' * ', l2))
            else:
                o.Raw('if (!', l1, ' || !', l2, ' || (', l1, ' * ', l2, ') / ', l2, ' == ', l1, ') {')
                o.PushInt(new, ConC(l1, ' * ', l2))
                o.append('} else {')
                o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', ref2, ');')
                o.append('}')
            o.Cls(l1, l2)
            o.append('} else {')
        else:    
            if not skip_float:    
                o.append('} else {')
            else:    
                o.append('{')
        o.Stmt(new, '=', head[1:], ref1, ref2)
        o.append('}')
        o.Cls(ref1, ref2)
        return new

    if head in ('!PyNumber_Divide', '!PyNumber_Remainder'):
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if IsInt(t1) and IsInt(t2):
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            n1,n2,n3 = None,None,None
            n3 = New('long')
                
            if ref1[0] == 'CONST':
                n1 = ref1[1]
            elif ref1[0] == 'FAST' and not current_co.IsCVar(ref1):
                n1 = ConC('PyInt_AS_LONG ( ', ref1, ' )')
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            if ref2[0] == 'CONST':
                n2 = ref2[1]
            elif ref2[0] == 'FAST' and not current_co.IsCVar(ref2):
                n2 = ConC('PyInt_AS_LONG ( ', ref2, ' )')
            else:
                n2 = New('long')
                o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
            if head == '!PyNumber_Divide':
                o.Raw(n3, ' = ', n1, ' / ', n2, ';')
            elif head == '!PyNumber_Remainder':    
                o.Raw(n3, ' = ', n1, ' % ', n2, ';')
            else:
                Fatal('', it)   
            o.PushInt(new, n3)
            o.Cls(n1, n2, n3, ref1, ref2)
            return new

        if IsInt(t1) and IsFloat(t2) and \
                head == '!PyNumber_Divide':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            n1,n2,n3 = None,None,None
            n3 = New('double')
                
            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            if ref2[0] == 'CONST':
                n2 = str(ref2[1])
            else:
                n2 = New('double')
                o.Stmt(n2, '=', 'PyFloat_AsDouble', ref2)
            o.Stmt(n3, '=', n1, '/', n2)
            o.Stmt(new, '=', 'PyFloat_FromDouble', n3)
            o.Cls(n1, n2, n3, ref1, ref2)
            return new
        
        if ( t1 is None or t1 == Kl_IntUndefSize ) and ( t2 is None or t2 == Kl_IntUndefSize ) and head =='!PyNumber_Divide':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) / PyInt_AS_LONG ( ', ref2, ' )'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            o.Cls(ref1, ref2)
            return new
        if ( t1 is None or t1 == Kl_IntUndefSize ) and ( t2 is None or t2 == Kl_IntUndefSize ) and head =='!PyNumber_Remainder':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) % PyInt_AS_LONG ( ', ref2, ' )'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            o.Cls(ref1, ref2)
            return new
        if ( t1 is None or t1 == Kl_IntUndefSize ) and IsInt(t2) and head =='!PyNumber_Remainder':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if ref2[0] == 'CONST':
                o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) % ', ref2[1]))
            else:    
                o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) % PyInt_AS_LONG ( ', ref2, ' )'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            o.Cls(ref1, ref2)
            return new        
        if ( t1 is None or t1 == Kl_IntUndefSize ) and IsInt(t2) and head =='!PyNumber_Divide':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if ref2[0] == 'CONST':
                o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) / ', ref2[1]))
            else:    
                o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) / PyInt_AS_LONG ( ', ref2, ' )'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            o.Cls(ref1, ref2)
            return new       
    if head == '!PyNumber_Power':
        if it[2] == ('CONST', 2) and it[3] == 'Py_None':
            ref1 = Expr1(it[1], o)
            ref2 = GenExpr(('!PyNumber_Multiply', ref1, ref1), o, forcenewg, typed, skip_float)
            Cls1(o, ref1)
            return ref2
        if IsInt(TypeExpr(it[1])) and IsFloat(TypeExpr(it[2])) and it[3] == 'Py_None':
            ref1 = Expr1(it[1], o)
            dbl = Expr1(it[2], o)
            fl = New('double')
            if dbl[0] != 'CONST':
                o.Stmt(fl, '=', 'PyFloat_AsDouble', dbl)
            else:    
                o.Raw(fl, ' = ', str(dbl[1]), ';')
            o.Raw(fl, ' = pow( (double) PyInt_AsLong(', ref1, '), ', fl, ');')
            ref3 = New()
            o.Raw(ref3, ' = PyFloat_FromDouble( ', fl, ' );')
            o.Cls(ref1, dbl, fl)
            return ref3
            
    if head == '!PyNumber_Add' and IsInt(TypeExpr(it[1])) and IsBool(TypeExpr(it[2])):        
        if it[1][0] == 'CONST':
            r2 = Expr1(it[2],o)
            add = New('long')
            o, add = ToTrue(o,add,r2, it[2])            
            n1 = str(it[1][1])
            o.Stmt(add, '=', add, '+', n1)
            new = New(None, forcenewg)
            o.PushInt(new, add)
            o.Cls(add, n1)
            return new
        r1,r2 = Expr(o, it[1:])
        n1 = New('long')
        o.Stmt(n1, '=', 'PyInt_AS_LONG', r1)
        add = New('int')
        o.Stmt(add, '=', 'PyObject_IsTrue', r2)
        o.Stmt(n1, '=', n1, '+', add)
        new = New(None, forcenewg)
        o.PushInt(new, n1)
        o.Cls(r1,r2, add, n1)
        return new
        
    if head in ('!PyNumber_Subtract', '!PyNumber_Add', '!PyNumber_InPlaceSubtract', '!PyNumber_InPlaceAdd'):
        return GenPlusMinusNew(head[1:],it,o,forcenewg, skip_float)

    if head in ('!PyNumber_Negative',):
        if len(it) > 3:
            Fatal('GenNumberExpr', it)
        t = TypeExpr(it) 
        t1 = TypeExpr(it[1])    
        ref1 = GenExpr(it[1], o, None, None, skip_float)
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
            
        n1,n2,n3 = None,None, None
        canbeint = IsNoneOrInt(t1)
        canbefloat = t1 in (None, Kl_Float) and not skip_float
        ## act = [] 
        onlyint = False
        onlyfloat = False
        
        if canbeint:
            cmp = IsInt(t1)
            n3 = New('long')
            
            if not cmp:
                o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            else:
                onlyint = True

            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            
            o.Stmt(n3, '=', 0, '-', n1)
            o.PushInt(new, n3)
            o.Cls(n1, n3)
        if canbefloat and not onlyint:
            cmp = t1 in (Kl_Float,)
            if canbeint:
                pre = '} else '
            else:
                pre = ''     
            if not cmp:
                o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
                t1 = Kl_Float
            else:
                if canbeint:
                    o.append(pre + 'if (1) {')
                else:
                    onlyfloat = True    
            if IsFloat(t1):
                s1 = 'PyFloat_AS_DOUBLE('+ CVar(ref1)+')'    
            elif IsInt(t1):
                s1 = '(double)PyInt_AS_LONG ( '+ CVar(ref1)+' )'    
            else:    
                s1 = 'PyFloat_AsDouble('+ CVar(ref1)+')'    
            if ref1[0] == 'CONST':
                s1 = '((double)' + str(ref1[1]) +')'
            o.Raw(new, ' = PyFloat_FromDouble(-(', s1, '));')
        if onlyint and t != Kl_Short:
            pass
        elif onlyint or onlyfloat:
            pass
        else:
            if canbeint:
                o.append('} else {')
                o.Stmt(new, '=', head[1:], ref1)
                o.append('}')
            elif canbefloat:    
                o.append('} else {')
                o.Stmt(new, '=', head[1:], ref1)
                o.append('}')
            else:
                o.Stmt(new, '=', head[1:], ref1)
        Cls1(o, ref1)
        return new
                
#
# Base part
#   
    return common_call(head[1:], it, o, typed, forcenewg)


def to_double_0(o, ref2, n2, v2):
    n2 = v2[1].strip()
    del o[-1]
    l = len(o)
    Cls1(o, ref2)
    if len(o) > l:
        assert len(o) == l + 1
        del o[-1]
    if is_not_active_typed(n2) and n2.startswith('double_'):
        n2 = reactivate_typed(n2)
    elif n2.startswith('Loc_'):
        pass
    elif len(o) > 0 and n2.startswith('double_') and (n2 + ' = ') in o[-1]:
        _n = New('double')
        o[-1] = o[-1].replace(n2 + ' = ', ConC(_n) + ' = ')
        assert (ConC(_n) + ' = ') in o[-1]
        n2 = _n
    else: 
        _n = New('double')
        if CVar(_n) != n2:
            o.Raw(_n, ' = ', n2, ';')
            n2 = _n
    return n2

def to_long_0(o, ref2, n2, v2):
    n2 = v2[1].strip()
    del o[-1]
    l = len(o)
    Cls1(o, ref2)
    if len(o) > l:
        assert len(o) == l + 1
        del o[-1]
    if is_not_active_typed(n2) and n2.startswith('long_'):
        n2 = reactivate_typed(n2)
    elif n2.startswith('Loc_'):
        pass
    elif len(o) > 0 and (n2.startswith('Py_ssize_t_') or n2.startswith('long_')) and (n2 + ' = ') in o[-1]:
        _n = New('long')
        o[-1] = o[-1].replace(n2 + ' = ', ConC(_n) + ' = ')
        assert (ConC(_n) + ' = ') in o[-1]
        n2 = _n
    else: 
        _n = New('long')
        if CVar(_n) != n2:
            o.Raw(_n, ' = ', n2, ';')
            n2 = _n
    return n2

def to_long(o, ref2, n2):
    if not istempref(ref2) and ref2[0] != 'CONST':
##        print ConC(ref2)
        n2 = New('long')
        o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
        return ref2, n2
    v2 = []
    tail = []
    while len(o) > 0 and (o[-1].startswith('CLEARTEMP') or o[-1].startswith('Py_CLEAR')):
        tail = [o[-1]] + tail
        del o[-1]
    if len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyInt_FromLong ( ', '*', ' )) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    ## elif len(o) > 0 and 'PyInt_From' in o[-1]:
        ## Fatal('Not recognised', o1, ref2)
    else:  
        n2 = New('long')
        o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
    o.extend(tail)
    return ref2, n2    

def can_be_to_long(o, ref2, n2):
    v2 = []
    tail = []
    while len(o) > 0 and (o[-1].startswith('CLEARTEMP') or o[-1].startswith('Py_CLEAR')):
        tail = [o[-1]] + tail
        del o[-1]
    if len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyInt_FromLong ( ', '*', ' )) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyInt_FromLong(', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyInt_FromLong( ', '*', ' )) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    elif len(o) > 0 and 'PyInt_From' in o[-1]:
        Fatal('Not recognised', o, ref2)
    ## else:
        ## pprint(o)
    o.extend(tail)
    return ref2, n2 

def can_be_to_double(o, ref2, n2):
    v2 = []
    tail = []
    while len(o) > 0 and (o[-1].startswith('CLEARTEMP') or o[-1].startswith('Py_CLEAR')):
        tail = [o[-1]] + tail
        del o[-1]
    if len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyFloat_FromDouble (', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_double_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyFloat_FromDouble ( ', '*', ' )) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_double_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyFloat_FromDouble(', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_double_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyFloat_FromDouble(', '*', ')) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_double_0(o, ref2, n2, v2)
    elif len(o) > 0 and 'PyInt_From' in o[-1]:
        Fatal('Not recognised', o, ref2)
    ## else:
        ## pprint(o)
    o.extend(tail)
    return ref2, n2 


sequence_op = ('!PyList_GetSlice', '!PyTuple_GetSlice', '!PySequence_GetSlice', '!_PyEval_ApplySlice', '!BUILD_LIST', '!BUILD_TUPLE')

def IsNotIntFloat(t):
    return IsStr(t) or IsTuple(t) or IsList(t) or IsLong(t) or ( t is not None and (is_old_class_inst(t) or is_old_class_typ(t))) or (IsNot(t, Kl_Int) and IsNot(t, Kl_Float))

def is_not_int_float(it):
    if type(it) is tuple:
        if it[0] in sequence_op:
            return True
        if it[0] == 'CONST' and type(it[1]) in (list, tuple, str, long): 
            return True
        if IsNotIntFloat(TypeExpr(it)):    
            return True   
##    pprint(it)    
    return False

def GenMultNew1(head,it,o,forcenewg, skip_float):
    revert = False
    if it[1][0] == 'CONST' and type(it[1][1]) is int and head == '!PyNumber_Multiply':
        it = (it[0], it[2], it[1])
        revert = True
    t = TypeExpr(it) 
    t1 = TypeExpr(it[1]) 
    t2 = TypeExpr(it[2]) 

    n1,n2,n3 = None,None,None
    f1, f2 = None, None
    ## canbeint = CanBeInt(t1,t2)
    ## canbefloat = CanBeFloat(t1,t2) and not skip_float
    ## if is_not_int_float(it) or IsStr(t1) or IsTuple(t1) or IsList(t1) or IsStr(t2) or IsTuple(t2) or IsList(t2):
        ## canbeint = False
        ## canbefloat = False
    
    if IsChar(t1) and IsInt(t2):
        ref1 = Expr1(it[1], o)
        n1 = New('char')
        o.Raw(n1, ' = PyString_AS_STRING ( ', ref1, ' )[0];') 
        o.Cls(n1)
        ref2 = Expr1(it[2], o)
        n2 = New('long')
        assert istempref(ref2)
        o.Raw(n2, ' = PyInt_AS_LONG ( ', ref2, ' );') 
        o.Cls(ref2)
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.Raw(new, ' = PyString_FromStringAndSize (NULL, ', n2, ');')
        n3 = New('int')
        s1 = New('charref')
        o.Raw(s1, ' = PyString_AS_STRING ( ', new, ' );')
        o.Raw('for (', n3, ' = 0;', n3, ' < ', n2, ';', n3, ' ++) {')
        o.Raw(s1, '[', n3, '] = ', n1, ';')
        o.Raw('}')
        o.Cls(n1, n2, n3, s1)
        return new
    if IsChar(t2) and IsInt(t1) and it[2][0] == 'CONST':
        ref1 = Expr1(it[1], o)
        n1 = New('long')
        assert istempref(ref1)
        o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
        o.Cls(ref1)
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.Raw(new, ' = PyString_FromStringAndSize (NULL, ', n1, ');')
        h =  charhex(it[2][1]) 
        o.Raw('memset (PyString_AS_STRING ( ', new, ' ), ', h, ', ', n1, ');')
        o.Cls(n1)
        return new
             
    if it[2][0] == 'CONST' and type(it[2][1]) is int and IsInt(t1):
        if it[1][0] == '!@PyInt_FromSsize_t' and not current_co.IsCVar(it[1][2]):
            ref1 = it[1][2]
            n1 = New('long')
            o.Raw(n1, ' = ', it[1][1], ';')
        else:    
            ref1 = Expr1(it[1], o)
            n1 = New('long')
            o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        n2 = New('long')    
        o.Raw(n2, ' = ',n1, ' * ', it[2][1], ';')
        if IsInt(t):
            o.PushInt(new, n2)
        else:
            o.Raw('if (', n2, ' / ', it[2][1], ' == ', n1, ') {')
            o.PushInt(new, n2)
            o.append('} else {')
            if not revert:
                o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', it[2], ');')
            else:    
                o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', it[2], ', ', ref1, ');')
            o.append('}')
        Cls1(o, ref1)
        o.Cls(n1, n2)
        return new
    if it[2][0] == 'CONST' and type(it[2][1]) is int and (t1 is None or IsIntUndefSize(t1)):
        if it[2][1] == 0:
            ref1 = Expr1(it[1], o)
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(new, ' = ', it[2], ';')
            o.INCREF(new)
            o.append('} else {')
            if not revert:
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', ref1, ' , ', it[2], ' )) == 0) goto ', labl, ';')
            else:    
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', it[2], ' , ', ref1, ' )) == 0) goto ', labl, ';')
            UseLabl()
            o.append('}')
            Cls1(o, ref1)
            return new

        if it[2][1] == 1:
            ref1 = Expr1(it[1], o)
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(new, ' = ', ref1, ';')
            if istempref(ref1):
                o.Raw(ref1, ' = 0;')
            else:
                o.INCREF(new)      
            o.append('} else {')
            if not revert:
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', ref1, ' , ', it[2], ' )) == 0) goto ', labl, ';')
            else:    
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', it[2], ' , ', ref1, ' )) == 0) goto ', labl, ';')
            UseLabl()
            Cls1(o, ref1)
            o.append('}')
            return new

        ref1 = Expr1(it[1], o)
        n1 = New('long')
        o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && ((', n1, ' = PyInt_AS_LONG ( ', ref1, ' )), ', n1, ' == ((', n1, ' * ', it[2][1], ') / ', it[2][1], '))) {')
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.PushInt(new, ConC(n1, ' * ', it[2][1]))
        o.append('} else {')
        if not revert:
            o.Raw('if ((', new, ' = ', head[1:], ' ( ', ref1, ' , ', it[2], ' )) == 0) goto ', labl, ';')
        else:    
            o.Raw('if ((', new, ' = ', head[1:], ' ( ', it[2], ' , ', ref1, ' )) == 0) goto ', labl, ';')
        UseLabl()
        o.append('}')
        Cls1(o, ref1)
        Cls1(o, n1)
        return new

def GenPlusMinusNew(head,it,o,forcenewg, skip_float):
    if len(it) > 3:
        Fatal('GenNumberExpr', it) 
    t = TypeExpr(it) 
    t1 = TypeExpr(it[1]) 
    t2 = TypeExpr(it[2]) 

    n1,n2,n3 = None,None,None
    f1, f2 = None, None
    o1 = Out()
    o2 = Out()
    o_old = o
    o = Out()
    canbeint = CanBeInt(t1,t2)
    canbefloat = CanBeFloat(t1,t2) and not skip_float
    if is_not_int_float(it) or IsStr(t1) or IsTuple(t1) or IsList(t1) or IsStr(t2) or IsTuple(t2) or IsList(t2):
        canbeint = False
        canbefloat = False
    ## act = [] 
    can_else = True  
    ## incref1 = False
    ## incref2 = False
    if IsCVar(it[1]) and IsInt(t1):
        n1 = CVarName(it[1])
        ref1 = None
    else:    
        ref1 = GenExpr(it[1], o1, None, None, skip_float)
        if canbeint and IsInt(t1) and istempref(ref1):
            ref1, n1 = can_be_to_long(o1, ref1, n1)        
        elif canbefloat and IsFloat(t1) and istempref(ref1):
            ref1, f1 = can_be_to_double(o1, ref1, f1)        
        ## if n1 is None and len(o1) > 0 and o1[-1].startswith('Py_INCREF'):
            ## del o1[-1]
            ## incref1 = True
    if IsCVar(it[2]) and IsInt(t2):
        n2 = CVarName(it[2])
        ref2 = None
    else:    
        ref2 = GenExpr(it[2], o2, None, None, skip_float)
        if canbeint and IsInt(t2) and istempref(ref2):
            ref2, n2 = can_be_to_long(o2, ref2, n2) 
        elif canbefloat and IsFloat(t2) and istempref(ref2):
            ref2, f2 = can_be_to_double(o2, ref2, f2) 
        ## if n2 is None and len(o2) > 0 and o2[-1].startswith('Py_INCREF'):
            ## del o2[-1]
            ## incref2 = True
    if ref1 == ('CONST', None):
        return ref1
    if ref2 == ('CONST', None):
        return ref2
    if forcenewg is not None:
        new = forcenewg
    else:
        new = New()    
    if canbeint:
        cmp = (IsInt(t1), IsInt(t2))
##        nooverflow = IsShort(t1) and IsShort(t2)
           
        if cmp == (False, False):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
        elif cmp == (True, False):
            o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
        elif cmp == (False, True):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        else:
            if IsShort(t1) and IsShort(t2) and not canbefloat:
                can_else = False
            elif IsInt(t1) and IsShort(t2) and IsInt(t) and not canbefloat:
                can_else = False
            elif IsInt(t2) and IsShort(t1) and IsInt(t) and not canbefloat:
                can_else = False
            else:
                o.append('if (1) {')

        if n1 is not None:
            pass
        elif ref1 is None:
            pass
        elif ref1[0] == 'CONST':
            n1 = ref1[1]
        else:
            n1 = New('long')
            o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
        if n2 is not None:
            pass
        elif ref2 is None:
            pass
        elif ref2[0] == 'CONST':
            n2 = ref2[1]
        else:
            n2 = New('long')
            o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
            
        nlabel = New('label')
        if head in ('PyNumber_Add', 'PyNumber_InPlaceAdd'):
            if not can_else:
                n3 = '(' + ConC(n1, ' + ', n2) + ')'
            else:
                n3 = New('long')
                o.Raw(n3, ' = ', n1, ' + ', n2, ';')
                o.Stmt('if ((', n3, '^', n1, ') < 0 && (', n3, '^', n2, ') < 0) goto', nlabel, ';')
        else:   
            if not can_else:
                n3 = '(' + ConC(n1, ' - ', n2) + ')'
            else:
                n3 = New('long')
                o.Raw(n3, ' = ', n1, ' - ', n2, ';')
                o.Stmt('if ((', n3, '^', n1, ') < 0 && (', n3, '^~', n2, ') < 0) goto', nlabel, ';')
        o.PushInt(new, n3)
        o.Cls(n3)
    if canbefloat:
        cmp = (IsIntOrFloat(t1), IsIntOrFloat(t2))
        if canbeint:
            pre = '} else '
        else:
            pre = ''     
        if cmp == (False, False):
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ') && PyFloat_CheckExact(', ref2, ')) {')
            t1 = Kl_Float
            t2 = Kl_Float
        elif cmp == (True, False):
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref2, ')) {')
            t2 = Kl_Float
        elif cmp == (False, True):
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
            t1 = Kl_Float
        else:
            o.append(pre + 'if (1) {')
        if f1 is not None:
            s1 = f1
        elif IsFloat(t1):
            s1 = 'PyFloat_AS_DOUBLE('+ CVar(ref1)+')'    
        elif IsInt(t1):
            s1 = '(double)PyInt_AS_LONG ( '+ CVar(ref1)+' )'    
        else:    
            s1 = 'PyFloat_AsDouble('+ CVar(ref1)+')'    
        if f2 is not None:
            s2 = f2
        elif IsFloat(t2):
            s2 = 'PyFloat_AS_DOUBLE('+ CVar(ref2)+')'    
        elif IsInt(t2):
            s2 = '(double)PyInt_AS_LONG ( '+ CVar(ref2)+' )'    
        else:    
            s2 = 'PyFloat_AsDouble('+ CVar(ref2)+')'    
        if ref1 is None and n1 is not None:
            s1 = '((double)' + ConC(n1) +')'
        elif ref1 is None and f1 is not None:
            s1 = ConC(f1) 
        elif ref1[0] == 'CONST':
            s1 = '((double)' + str(ref1[1]) +')'
        if ref2 is None and n2 is not None:
            s2 = '((double)' + ConC(n2) +')'
        elif ref2 is None and f2 is not None:
            s2 = ConC(f2)
        elif ref2[0] == 'CONST':
            s2 = '((double)' + str(ref2[1]) +')'
        if head in ('PyNumber_Add', 'PyNumber_InPlaceAdd'):
            o.Raw(new, ' = PyFloat_FromDouble(', s1, ' + ', s2, ');')
        else:    
            o.Raw(new, ' = PyFloat_FromDouble(', s1, ' - ', s2, ');')
    _1 = False
    _2 = False
    if canbeint:
        if not canbefloat and not can_else:
            pass ##o.append('}')
        else:   
            o.Stmt('} else {', nlabel, ':') 
            if ref1 is None:
                ref1 = New()
                o.PushInt(ref1, n1)
                _1 = True
            if ref2 is None:
                ref2 = New()
                o.PushInt(ref2, n2)
                _2 = True
            o.Stmt(new, '=', head, ref1, ref2)
            if _1:
                o.Cls(ref1)
            if _2:
                o.Cls(ref2)
            o.append('}')
    elif canbefloat:    
        o.append('} else {')
        if ref1 is None and f1 is None:
            ref1 = New()
            o.PushInt(ref1, n1)
            _1 = True
        if ref2 is None and f2 is None :
            ref2 = New()
            o.PushInt(ref2, n2)
            _2 = True
        if ref1 is None and f1 is not None:
            ref1 = New()
            o.PushFloat(ref1, f1)
            _1 = True
        if ref2 is None and f2 is not None :
            ref2 = New()
            o.PushFloat(ref2, f2)
            _2 = True
        o.Stmt(new, '=', head, ref1, ref2)
        if _1:
            o.Cls(ref1)
        if _2:
            o.Cls(ref2)
        o.append('}')
    else:
        verif(it, o)
        if ref1 is None:
            ref1 = New()
            o.PushInt(ref1, n1)
            _1 = True
        if ref2 is None:
            ref2 = New()
            o.PushInt(ref2, n2)
            _2 = True
        o.Stmt(new, '=', head, ref1, ref2)
        if _1:
            o.Cls(ref1)
        if _2:
            o.Cls(ref2)

    o.Cls(ref1, ref2, n1, n2, f1, f2)
    _o = Out()
    ## if 'PyInt_From' in repr(o1) or 'PyInt_From' in repr(o2) :
        ## pprint((o1, o2, o))
##    pprint( o1[o1+o2+o)
    _o.extend(o1 + o2 + o)
    v2 = []
    ## o_old.extend(o)
    ## return new
##    if  True: ###len(o1) == 1 and len(o2) == 0 and it[2][0] == 'CONST' and type(it[2][1]) is int and len(o) == 2:
    if TxMatch(_o, 0, """
            long_$8 = $11;
            long_$9 = long_$8 $12 $14;
            temp[$0] = PyInt_FromLong ( long_$9 ); 
            """, v2):
                v2[11].strip()
                TxRepl(_o, 0, """temp[$0] = PyInt_FromLong ( (($11) $12 $14) );""", v2)
                o_old.extend(_o)
                return new
    if TxMatch(_o, 0, """
            if ((Py_ssize_t_$8 = $11) == -1) goto label_$15;
            long_$9 =  Py_ssize_t_$8  $12 $14;
            temp[$0] = PyInt_FromLong ( long_$9 ); 
            """, v2):
                v2[11].strip()
                TxRepl(_o, 0, """if ((Py_ssize_t_$8 = $11) == -1) goto label_$15;
                       temp[$0] = PyInt_FromLong ( Py_ssize_t_$8 $12 $14 );""", v2)
                o_old.extend(_o)
                return new   
    if TxMatch(_o, 0, (
        'if ((Py_ssize_t_$5 = $11) == -1) goto label_$0;',
        'temp[$1] = PyInt_FromLong ( Py_ssize_t_$5 );',
        'if (1) {',
        'long_$8 = PyInt_AS_LONG ( temp[$1] );',
        'long_$7 = $12 $19 long_$8;',
        'if ($14) goto label_$15 ;',
        'temp[$2] = PyInt_FromLong ( long_$7 );',
        '} else { label_$15 :;',
        'temp[$3] = PyInt_FromLong ( $12 );',
        'if ((temp[$2] = PyNumber_$18 ( temp[$3] , temp[$1] )) == 0) goto label_$0;',
        'CLEARTEMP($3);',
        '}',
        'CLEARTEMP($1);'), v2):         
                TxRepl(_o, 0, (
                    'if ((Py_ssize_t_$5 = $11) == -1) goto label_$0;',
                    'if (1) {',
                    'long_$8 = Py_ssize_t_$5;',
                    'long_$7 = $12 $19 long_$8;',
                    'if ($14) goto label_$15 ;',
                    'temp[$2] = PyInt_FromLong ( long_$7 );',
                    '} else { label_$15 :;',
                    'temp[$1] = PyInt_FromLong ( Py_ssize_t_$5 );',
                    'temp[$3] = PyInt_FromLong ( $12 );',
                    'if ((temp[$2] = PyNumber_$18 ( temp[$3] , temp[$1] )) == 0) goto label_$0;',
                    'CLEARTEMP($3);',
                    'CLEARTEMP($1);',
                    '}'), v2)
                o_old.extend(_o)
                return new       
    if TxMatch(_o, 0, (
        'temp[$0] = PyInt_FromLong ( $11 );',
        'if (PyInt_CheckExact( $17 )) {',
        'long_$8 = PyInt_AS_LONG ( temp[$0] );',
        'long_$9 = PyInt_AS_LONG ( $17 );',
        'long_$7 = long_$8 $15 long_$9;',
        'if ($12) goto label_$14 ;',
        'temp[$1] = PyInt_FromLong ( long_$7 );',
        '} else if (PyFloat_CheckExact( $17 )) {',
        'temp[$1] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) $15 PyFloat_AS_DOUBLE($17));',
        '} else { label_$14 :;',
        'if ((temp[$1] = PyNumber_$18 ( temp[$0] , $17 )) == 0) goto label_$10;',
        '}',
        'CLEARTEMP($0);'), v2) and v2[11] != 'long_' + v2[7] and v2[11] != 'long_' + v2[9]:         
                TxRepl(_o, 0, (
                    'if (PyInt_CheckExact( $17 )) {',
                    'long_$8 = $11;',
                    'long_$9 = PyInt_AS_LONG ( $17 );',
                    'long_$7 = long_$8 $15 long_$9;',
                    'if ($12) goto label_$14 ;',
                    'temp[$1] = PyInt_FromLong ( long_$7 );',
                    '} else if (PyFloat_CheckExact( $17 )) {',
                    'temp[$1] = PyFloat_FromDouble((double)($11) $15 PyFloat_AS_DOUBLE($17));',
                    '} else { label_$14 :;',
                    'temp[$0] = PyInt_FromLong ( $11 );',
                    'if ((temp[$1] = PyNumber_$18 ( temp[$0] , $17 )) == 0) goto label_$10;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                o_old.extend(_o)
                return new  

    if TxMatch(_o, 0, (
        'if ((Py_ssize_t_$5 = PyObject_Size ( GETLOCAL(refs) )) == -1) goto label_$10;',
        'temp[$0] = PyInt_FromLong ( Py_ssize_t_$5 );',
        'if (PyInt_CheckExact( $15 )) {',
        'long_$8 = PyInt_AS_LONG ( $15 );',
        'long_$9 = PyInt_AS_LONG ( temp[$0] );',
        'long_$7 = long_$8 $12 long_$9;',
        'if ($11) goto label_$13 ;',
        'temp[1] = PyInt_FromLong ( long_$7 );',
        '} else if (PyFloat_CheckExact( $15 )) {',
        'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($15) $12 (double)PyInt_AS_LONG ( temp[$0] ));',
        '} else { label_$13 :;',
        'if ((temp[$1] = PyNumber_$14 ( $15 , temp[$0] )) == 0) goto label_$10;',
        '}',
        'CLEARTEMP($0);'), v2):         
                TxRepl(_o, 0, (
                    'if ((Py_ssize_t_$5 = PyObject_Size ( GETLOCAL(refs) )) == -1) goto label_$10;',
                    'if (PyInt_CheckExact( $15 )) {',
                    'long_$8 = PyInt_AS_LONG ( $15 );',
                    'long_$9 = Py_ssize_t_$5;',
                    'long_$7 = long_$8 $12 long_$9;',
                    'if ($11) goto label_$13 ;',
                    'temp[1] = PyInt_FromLong ( long_$7 );',
                    '} else if (PyFloat_CheckExact( $15 )) {',
                    'temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($15) $12 (double)Py_ssize_t_$5);',
                    '} else { label_$13 :;',
                    'temp[$0] = PyInt_FromLong ( Py_ssize_t_$5 );',
                    'if ((temp[$1] = PyNumber_$14 ( $15 , temp[$0] )) == 0) goto label_$10;',
                    'CLEARTEMP($0);',
                    '}'), v2)
                o_old.extend(_o)
                return new  
    ## dsc1 = parse_code_type(o1)        
    ## dsc2 = parse_code_type(o2)        
    if len(o1) == 0 and len(o2) > 0 and 'PyInt_FromLong' in o2[-1]:
        ## v3 = []
        o2_1 = Out()
        o2_1.extend(o2)
        o2_1.extend(o)
        if TxMatch(o2_1, len(o2_1) - (len(o) + 1), """
                temp[$0] = PyInt_FromLong ( $4 );
                if (PyInt_CheckExact( $11 )) {
                long_$5 = PyInt_AS_LONG ( $11 );
                long_$6 = PyInt_AS_LONG ( temp[$0] );
                long_$2 = long_$5 $15 long_$6;
                if ($12) goto label_$7 ;
                temp[$1] = PyInt_FromLong ( long_$2 );
                } else if (PyFloat_CheckExact( $11 )) {
                temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) $15 (double)PyInt_AS_LONG ( temp[$0] ));
                } else { label_$7 :;
                if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2) and v2[4] != 'long_' + v2[5] and v2[4] != 'long_' + v2[2]:
                    TxRepl(o2_1, 0, """
                        if (PyInt_CheckExact( $11 )) {
                        long_$5 = PyInt_AS_LONG ( $11 );
                        long_$6 = $4;
                        long_$2 = long_$5 $15 long_$6;
                        if ($12) goto label_$7 ;
                        temp[$1] = PyInt_FromLong ( long_$2 );
                        } else if (PyFloat_CheckExact( $11 )) {
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) $15 (double)($4));
                        } else { label_$7 :;
                        temp[$0] = PyInt_FromLong ( $4 );
                        if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new
        if TxMatch(o2_1, len(o2_1) - (len(o) + 1), """
                temp[$0] = PyInt_FromLong ( $4 );
                if (PyInt_CheckExact( $11 )) {
                long_$5 = PyInt_AS_LONG ( $11 );
                long_$6 = PyInt_AS_LONG ( temp[$0] );
                long_$2 = long_$5 $15 long_$6;
                if ($12) goto label_$7 ;
                temp[$1] = PyInt_FromLong ( long_$2 );
                } else { label_$7 :;
                if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2) and v2[4] != 'long_' + v2[5] and v2[4] != 'long_' + v2[2]:
                    TxRepl(o2_1, 0, """
                        if (PyInt_CheckExact( $11 )) {
                        long_$5 = PyInt_AS_LONG ( $11 );
                        long_$6 = $4;
                        long_$2 = long_$5 $15 long_$6;
                        if ($12) goto label_$7 ;
                        temp[$1] = PyInt_FromLong ( long_$2 );
                        } else { label_$7 :;
                        temp[$0] = PyInt_FromLong ( $4 );
                        if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new
        if TxMatch(o2_1, len(o2_1) - (len(o) + 1), """
                temp[$0] = PyInt_FromLong ( $4 );
                if (1) {
                long_$5 = PyInt_AS_LONG ( $11 );
                long_$6 = PyInt_AS_LONG ( temp[$0] );
                long_$2 = long_$5 $15 long_$6;
                if ($12) goto label_$7 ;
                temp[$1] = PyInt_FromLong ( long_$2 );
                } else { label_$7 :;
                if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2) and v2[4] != 'long_' + v2[5] and v2[4] != 'long_' + v2[2]:
                    TxRepl(o2_1, 0, """
                        if (1) {
                        long_$5 = PyInt_AS_LONG ( $11 );
                        long_$6 = $4;
                        long_$2 = long_$5 $15 long_$6;
                        if ($12) goto label_$7 ;
                        temp[$1] = PyInt_FromLong ( long_$2 );
                        } else { label_$7 :;
                        temp[$0] = PyInt_FromLong ( $4 );
                        if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new    
    if len(o2) == 0 and len(o1) == 5:
        ## v3 = []
        o2_1 = Out()
        o2_1.extend(o1)
        o2_1.extend(o)
        if TxMatch(o2_1, 0, """        
            if ($10) {
            temp[$4] = PyInt_FromLong ( $11 );
            } else {
            if ((temp[$4] = $12) == 0) goto label_$0;
            }
            if (PyInt_CheckExact( temp[$4] )) {
            long_$3 = PyInt_AS_LONG ( temp[$4] );
            long_$2 = long_$3 $17 $13;
            if ($14) goto label_$15 ;
            temp[$5] = PyInt_FromLong ( long_$2 );
            } else { label_$15 :;
            if ((temp[$5] = $16) == 0) goto label_$0;
            }
            CLEARTEMP($4);
                """, v2):
                    TxRepl(o2_1, 0, """
                        if ($10) {
                        long_$3 = $11;
                        long_$2 = long_$3 $17 $13;
                        if ($14) goto label_$15 ;
                        temp[$5] = PyInt_FromLong ( long_$2 );
                        } else { label_$15 :;
                        if ((temp[$4] = $12) == 0) goto label_$0;
                        if ((temp[$5] = $16) == 0) goto label_$0;
                        CLEARTEMP($4);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new 
    if len(o1) == 8 and len(o2) == 8:
        ## v3 = []
        o2_1 = Out()
        o2_1.extend(o1)
        o2_1.extend(o2)
        o2_1.extend(o)
        if TxMatch(o2_1, 0, """
            if ($10) {
            if (($12) goto label_$11;
            temp[$0] = PyInt_FromLong ( $14 );
            } else {
            $16
            if ((temp[$0] = $17) == 0) goto label_$11;
            CLEARTEMP($18);
            if ($10) {
            if ($13) goto label_$11;
            temp[$1] = PyInt_FromLong ( $15 );
            } else {
            $19
            if ((temp[$1] = $9) == 0) goto label_$11;
            CLEARTEMP($8);
            """,  v2):
                    TxRepl(o2_1, 0, """
                        if ($10) {
                        if (($12) goto label_$11;
                        temp[$0] = PyInt_FromLong ( $14 );
                        if ($13) goto label_$11;
                        temp[$1] = PyInt_FromLong ( $15 );
                        } else {
                        $16
                        if ((temp[$0] = $17) == 0) goto label_$11;
                        CLEARTEMP($18);
                        $19
                        if ((temp[$1] = $9) == 0) goto label_$11;
                        CLEARTEMP($8);
                        }
                        """, v2)      
##                    pprint(o2_1)                                   
                    o_old.extend(o2_1)
                    return new 
    _o = o1 + o2 + o 
    ## if IsTuple(t1) and IsTuple(t2) and it[1][0] in ('!BUILD_TUPLE', 'CONST') and it[2][0] in ('!BUILD_TUPLE', 'CONST'):
        ## pprint(it)
        ## print
    ## oo = "".join(o1 + o2)
    ## if (len(o1) != 0 or len(o2) != 0) and not IsTuple(t1) and not IsList(t1) and not IsTuple(t2) and not IsList(t2) and not IsStr(t1) and not IsStr(t2) and 'PyInt_FromLong' in oo:
        ## print '{'
        ## _o = o1 + o2 + o
        ## optimize(o1)
        ## optimize(o2)
        ## optimize(o)
        ## pprint((o1, o2, o))
        ## ## print ':'
        ## ## pprint(_o)
        ## ## optimize(_o)
        ## ## print ':'
        ## ## pprint(_o)
        ## print '}'
    o_old.extend(_o)
    return new
 
 
def CanBeFloat(t1, t2):
    if IsNoneOrIntOrFloat(t1) and IsNoneOrIntOrFloat(t2):
        if t1 == Kl_IntUndefSize and t2 == Kl_IntUndefSize:
            return False
        if IsInt(t1) and IsInt(t2):
            return False
        if IsInt(t1) and t2 == Kl_IntUndefSize:
            return False
        if IsInt(t2) and t1 == Kl_IntUndefSize:
            return False
        if (not IsInt(t1) or not IsInt(t2)):
           return True
    ## print 'Not float', t1, t2   
    return False   
   
def CanBeInt(t1, t2):
    if (t1 is None or IsInt(t1) or IsIntUndefSize(t1)) and (t2 is None or IsInt(t2) or IsIntUndefSize(t2)):
           return True
    return False   

arifm = ('!PyNumber_Multiply', '!PyNumber_Divide', '!PyNumber_Add', '!PyNumber_Subtract')

def genHalfFloat(it1, o):
    t1 = TypeExpr(it1)
    if it1[0] == 'CONST' and type(it1[1]) is int:
        return repr(float(it1[1]))
    if it1[0] == 'CONST' and type(it1[1]) is float:
        return repr(it1[1])
    if IsFloat(t1) and IsCVar(it1):
        return CVarName(it1)
    if IsInt(t1) and IsCVar(it1):
        return '((double)' + CVarName(it1) + ')'
    elif it1[0] in arifm and IsFloat(t1):
        return GenFloatExpr(it1, o)
    elif it1[0] == '!PyObject_Call' and it1[1][0] == 'CALC_CONST':
        t = it1[1][1]    
        if type(t) is tuple and len(t) == 2:
            t = (Val3(t[0], 'ImportedM'), t[1])
            if t in CFuncFloatOfFloat:
                if it1[2][0] == 'CONST':
                    s0 = repr(float(it1[2][1][0]))
                else:    
                    s0 = genHalfFloat(it1[2][1][0], o)
                s1 = New('double')
                o.Raw(s1, ' = ', CFuncFloatOfFloat[t], ' ( ', s0, ' );')
                Cls1(o, s0)
                return s1
        t = Val3(t, 'ImportedM')
        if t in CFuncFloatOfFloat:
            if it1[2][0] == 'CONST':
                s0 = repr(float(it1[2][1][0]))
            else:    
                s0 = genHalfFloat(it1[2][1][0], o)
            s1 = New('double')
            o.Raw(s1, ' = ', CFuncFloatOfFloat[t], ' ( ', s0, ' );')
            Cls1(o, s0)
            return s1
    ref1 = Expr1(it1, o)
    if IsFloat(t1):
        s1 = New('double')
        o.Stmt(s1, '=', 'PyFloat_AsDouble', ref1)
        Cls1(o, ref1)
        return s1    
    if IsInt(t1):
        s1 = New('double')
        o.Raw(s1, ' = (double)PyInt_AsLong ( ', ref1, ' );')
        Cls1(o, ref1)
        return s1    
    ref2 = New()
    o.Stmt(ref2, '=', 'PyNumber_Float', ref1)
    Cls1(o, ref1)
    s1 = New('double')
    o.Stmt(s1, '=', 'PyFloat_AsDouble', ref2)
    Cls1(o, ref2)
    return s1    
    
def GenFloatExpr(it, o):
    arifm = {'!PyNumber_Multiply':0, '!PyNumber_Divide':1, '!PyNumber_Add':2, '!PyNumber_Subtract':3}
    if it[0] in arifm and IsFloat(TypeExpr(it)):
        op4 = ('*', '/', '+', '-')
        op = op4[arifm[it[0]]]
        s1 = genHalfFloat(it[1], o)
        s2 = genHalfFloat(it[2], o)
        new = New('double')
        o.Raw(new, ' = ', s1, ' ', op, ' ', s2, ';')  
        o.Cls(s1, s2)    
        return new  
    Fatal('', it)

def not_float_op(ref1,ref2):
    l1 = isconstref(ref1) 
    l2 = isconstref(ref2)
    l1_0 = True
    l2_0 = True 
    if l1:
        l1_0 = type(ref1[1]) is float    
    if l2:
        l2_0 = type(ref2[1]) is float    
    if not l1_0 or not l2_0:
        return True
    return False    

def not_int_op(ref1,ref2, e1,e2):
    l1 = isconstref(ref1) 
    l2 = isconstref(ref2)
    l1_0 = True
    l2_0 = True 
    if l1:
        l1_0 = type(ref1[1]) is int    
    if l2:
        l2_0 = type(ref2[1]) is int    
    if not IsNoneOrInt(TypeExpr(e1)):
        return True    
    if not IsNoneOrInt(TypeExpr(e2)):
        return True    
    if not l1_0 or not l2_0:
        return True
    return False    

def bin_arg_float(o, ref1, ref2, first, t1 = None, t2 = None):
    l1 = isconstref(ref1) 
    l2 = isconstref(ref2) 
    if l1:
        l1_0 = type(ref1[1]) is float    
    if l2:
        l2_0 = type(ref2[1]) is float    
    if not first:
        pre = '} else '
    else:
        pre = ''        
    if not l1 and not l2:
        if IsInt(t1) and IsInt(t2):
            o.append(pre + 'if (0) {')
        elif not IsInt(t1) and IsInt(t2):    
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
        elif not IsInt(t2) and IsInt(t2):    
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref2, ')) {')
        else:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ') && PyFloat_CheckExact(', ref2, ')) {')
    elif l1 and l2:
        if l1_0 and l2_0:
            o.append(pre + 'if (1) {')
        else:        
            o.append(pre + 'if (0) {')
    elif l1:    
        if l1_0:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref2, ')) {')
        else:        
            o.append(pre + 'if (0) {')
    elif l2:    
        if l2_0:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
        else:        
            o.append(pre + 'if (0) {')
    else:
        Fatal('bin_arg_float', ref1, ref2, first)
    return None    

type_recode = {'int': 'PyInt_Type','long':'PyLong_Type',\
               'float':'PyFloat_Type', 'bool':'PyBool_Type',\
               'object':'PyBaseObject_Type', 'unicode':'PyUnicode_Type',\
               'complex':'PyComplex_Type'}

def calc_range_1(tupl):
    try:
        l = range(*tupl[1])
        if len(l) < 16:
            ll = [('CONST', x) for x in l]
            return ('!BUILD_LIST', tuple(ll))
    except:
        pass   
    return None 

def attempt_direct_builtin(nm_builtin, args, tupl):
    if nm_builtin == 'range' and tupl[0] == 'CONST':
        l = calc_range_1(tupl)
        if l is not None:
            return l
    if nm_builtin == 'chr'  and len(args) == 1:
        return ('!CHR_BUILTIN', args[0])
    if nm_builtin == 'ord'  and len(args) == 1:
        return ('!ORD_BUILTIN', args[0], tupl) 
    if nm_builtin in type_recode:
        if nm_builtin == 'int' and len(args) == 1:
            return ('!PyNumber_Int', args[0])
        if nm_builtin == 'long' and len(args) == 1:
            return ('!PyNumber_Long', args[0])
        if nm_builtin == 'float' and len(args) == 1:
            return ('!PyNumber_Float', args[0])
        typ = type_recode[nm_builtin]
        return  ('!' + typ + '.tp_new', '&' + typ, tupl, 'NULL')
    if nm_builtin == 'dir' and len(args) == 1:
        return ('!PyObject_Dir', args[0])
    if nm_builtin == 'bin' and len(args) == 1:
        return ('!PyNumber_ToBase', args[0], 2)
    if nm_builtin == 'id' and len(args) == 1:
        return ('!PyLong_FromVoidPtr', args[0])
    if nm_builtin == 'set' and len(args) == 0:
        return ('!PySet_New', 'NULL')
    if nm_builtin == 'set' and len(args) == 1:
        return ('!PySet_New', args[0])
    if nm_builtin == 'len' and len(args) == 1:
        t = TypeExpr(args[0])
        if IsList(t):
            return ('!PY_SSIZE_T', ('!PyList_GET_SIZE', args[0]))
        if IsTuple(t):
            return ('!PY_SSIZE_T', ('!PyTuple_GET_SIZE', args[0]))
        if IsDict(t):
            return ('!PY_SSIZE_T', ('!PyDict_Size', args[0]))
        if t == Kl_Set:
            return ('!PY_SSIZE_T', ('!PySet_Size', args[0]))
        if IsStr(t):
            return ('!PY_SSIZE_T', ('!PyString_GET_SIZE', args[0]))
        return ('!PY_SSIZE_T', ('!PyObject_Size', args[0]))
    if nm_builtin == 'repr' and len(args) == 1:
        return ('!PyObject_Repr', args[0])
    if nm_builtin == 'str' and len(args) == 1: # test_compile not pass
        if IsInt(TypeExpr(args[0])):
            return ('!PyInt_Type.tp_str', args[0])
        return ('!PyObject_Str', args[0])
    if nm_builtin == 'bytes' and len(args) == 1:
        return ('!PyObject_Str', args[0])
    if nm_builtin == 'unicode' and len(args) == 1:
        return ('!PyObject_Unicode', args[0])
    if nm_builtin == 'type' and len(args) == 1:
        return ('!PyObject_Type', args[0])
    if nm_builtin == 'dir' and len(args) == 1:
        return ('!PyObject_Dir', args[0])
    if nm_builtin == 'iter' and len(args) == 1:
        return ('!PyObject_GetIter', args[0])
### !!!!!!  replace to direct call !!!!!!    
    if nm_builtin == 'hash' and len(args) == 1:
        return ('!PyObject_Hash', args[0])
    if nm_builtin == 'cmp' and len(args) == 2:
        return ('!_PyObject_Cmp', args[0], args[1])
    if nm_builtin == 'unicode' and len(args) == 1:
        return ('!PyObject_Unicode', args[0])
    if nm_builtin == 'abs' and len(args) == 1:
        return ('!PyNumber_Absolute', args[0])
    if nm_builtin == 'format' and len(args) == 1:
        return ('!PyObject_Format', args[0], 'NULL')
    if nm_builtin == 'format' and len(args) == 2:
        return ('!PyObject_Format', args[0], args[1])
    if nm_builtin == 'tuple' and len(args) == 1:
        if IsList(TypeExpr(args[0])):
            if args[0][0] == '!BUILD_LIST':
                return TupleFromArgs(args[0][1])
            return ('!PyList_AsTuple', args[0])
        return ('!PySequence_Tuple', args[0])
    if nm_builtin == 'list' and len(args) == 1:
        return ('!PySequence_List', args[0])
    if nm_builtin == 'pow' and len(args) == 2:
        return ('!PyNumber_Power', args[0], args[1], 'Py_None')
    if nm_builtin == 'pow' and len(args) == 3:
        return ('!PyNumber_Power', args[0], args[1], args[2])
    if nm_builtin == 'hasattr' and len(args) == 2:
        return ('!BOOLEAN',('!PyObject_HasAttr', args[0], args[1]))
    if nm_builtin == 'isinstance' and len(args) == 2:
        return ('!BOOLEAN',('!PyObject_IsInstance', args[0], args[1]))
    if nm_builtin == 'issubclass' and len(args) == 2:
        return ('!BOOLEAN',('!PyObject_IsSubclass', args[0], args[1]))
    if nm_builtin == 'getattr' and len(args) == 2:
        return ('!PyObject_GetAttr', args[0], args[1])
    return None

def generate_and_or_jumped_stacked(it, o, prevref, is_and, n):
##    leno = len(o)
    ref1 = GenExpr(it[0], o, prevref)
    assert istempref(prevref)
    if prevref != ref1:
        if n == 0:
            if istempref(ref1):
                Fatal('and_or_jumped_stacked', it)
        else:    
            o.CLEAR(prevref)
        o.Raw(prevref, ' = ', ref1, ';')
        if istempref(ref1):
            assert n != 0
            o.Raw(ref1, ' = NULL;')
        else:    
            o.INCREF(prevref)
    if len(it) == 1:
        return ref1
    assert is_and in (True, False)
    or_and = New('int')

    _prevlast1_1 = ConC('if ((', prevref, ' = PyBool_FromLong (')
    _prevlast2_1 = ')) == 0) goto label_0;'

    if len(o) >= 1 and \
       o[-1].startswith(_prevlast1_1) and o[-1].endswith(_prevlast2_1):
        intlast = o[-1][len(_prevlast1_1):-len(_prevlast2_1)]
        if is_and:    
            o.Raw(or_and, ' = ', intlast, ';')
        else:    
            o.Raw(or_and, ' = !', intlast, ';')
    else:        
        if is_and:    
            o.Stmt(or_and, '=', 'PyObject_IsTrue', prevref)
        else:    
            o.Stmt(or_and, '=', 'PyObject_Not', prevref)
    o.Stmt('if (', or_and, ') {')
    o.CLEAR(prevref)
    generate_and_or_jumped_stacked(it[1:], o, prevref, is_and, n + 1)
    o.append('}')
    Cls1(o, or_and)
##    pprint((o[leno:], it, prevref, is_and, n))
    return prevref  

def tag_in_expr(tag, expr):
    if type(expr) is tuple and len(expr) > 0 and type(expr[0]) is str:
        if expr[0] == tag:
            return True
        if expr[0] == 'CONST':
            return False
        for r in expr:
            if tag_in_expr(tag, r):
                return True
        return False
    if type(expr) is list:
        for r in expr:
            if tag_in_expr(tag, r):
                return True
        return False
    if type(expr) is tuple:
        for r in expr:
            if tag_in_expr(tag, r):
                return True
        return False
    return False

def New(type=None, forcenewg=None):
    if forcenewg is not None:
        return forcenewg
    if type is None:
        return newgen(forcenewg)
    else:
        return new_typed(type, forcenewg)

traced_tempgen=[]

def newgen(forcenewg=None):
    global tempgen, traced_tempgen
    if forcenewg is not None:
        assert not tempgen[forcenewg[1]]
        return forcenewg  
    n = None  
    for i, f in enumerate(tempgen):
        if f:
            tempgen[i] = not f
            n = ('PY_TEMP',i)
            break
    if n is None:
        tempgen.append(False)
        n = ('PY_TEMP',len(tempgen)-1)
    if len(traced_tempgen) > 0:
        dict_tempgen = traced_tempgen[-1]
        dict_tempgen[n] = True
    return n    
def save_tempgen():
    return tempgen[:]
def restore_tempgen(_tempgen):
    tempgen[:] = _tempgen
def clearref(o,g, fictive=False):
    global tempgen
    global g_refs2
    if g in g_refs2:
        return
    if type(g) is tuple and g[0] == 'PY_TEMP' and g[1] < len(tempgen) and g[1] >= 0 and \
       not tempgen[g[1]]:
            if fictive:
                tempgen[g[1]] = True
                return
            tempgen[g[1]] = True
            o.Stmt('CLEARREF', g)   
            
def istempref(g):
    global tempgen
    if type(g) is tuple and len(g) == 2 and g[0] == 'PY_TEMP':
        i = g[1]
        if i >= 0 and i < len(tempgen):
            return True
    return False    

def isconstref(ref):
    return type(ref) is tuple and len(ref) > 1 and ref[0] == 'CONST'

def new_typed(type, forcenewg=None):
    global typed_gen
    if forcenewg is not None:
        assert forcenewg[0] == 'TYPED_TEMP' 
        return forcenewg        
    for i, (f, t) in enumerate(typed_gen):
        if f and t == type:
            typed_gen[i] = (not f, t)
            return ('TYPED_TEMP', i)
    typed_gen.append((False, type))
    return ('TYPED_TEMP', len(typed_gen)-1)
    
def clear_typed(g):
    global typed_gen
    if type(g) is tuple and g[0] == 'TYPED_TEMP' and g[1] < len(typed_gen) and g[1] >= 0 and \
       not typed_gen[g[1]][0]:
           typed_gen[g[1]] = (True, typed_gen[g[1]][1])

def is_not_active_typed(s):
    global typed_gen
    for i, v in enumerate(typed_gen):
       if v[0] and s == (v[1] + '_' + str(i).strip()):
           return True
    return False

def reactivate_typed(s):
    global typed_gen
    for i, v in enumerate(typed_gen):
       if v[0] and s == (v[1] + '_' + str(i).strip()):
           typed_gen[i] = (False, v[1])
           return ('TYPED_TEMP', i)
    assert False

def istemptyped(g):
    global typed_gen
    if type(g) is tuple and len(g) == 2 and g[0] == 'TYPED_TEMP':
        i = g[1]
        if type(i) is int and i >= 0 and i < len(typed_gen):
            return True
    return False

def IsCalcConst(g):
    return g[0] == 'CALC_CONST'

def CVar(g):
    global typed_gen
    if type(g) is tuple:
        len_g = len(g)
        if len_g == 2 and g[0] == '&' and istempref(g[1]):
            return '(temp + ' + str(g[1][1]) + ')'
        if len_g == 2 and g[0] == '&' and istemptyped(g[1]):
            return '&' + CVar(g[1])
        if istempref(g):
            return 'temp[' + str(g[1]) + ']'
        if istemptyped(g):
            return typed_gen[g[1]][1] + '_' + str(g[1])
        if g[0] == 'CALC_CONST':
            return 'calculated_const[' + str(calculated_const[g[1]]) + ']' #calc_const_to(g[1])
        if g[0] == 'CONST':
            return const_to(g[1])
        if g[0] == 'BUILTIN':
            return load_builtin(g[1])
        if g[0] == 'CODEFUNC':
            return '(PyObject *)code_' + g[1]
        if g[0] == 'TYPE_CONVERSION':
            return g[1] + ' ' +  CVar(g[2])
        if len(g) == 1:
            return g[0]
        if g[0] == 'FAST':
            assert not current_co.IsCVar(g)
            return 'GETLOCAL(' + nmvar_to_loc(g[1]) + ')'
        ## if g[0] == '2FAST':
            ## assert g[1][0] == 'N' and g[1][1:].isdigit()
            ## return CVar_get_2FAST(g[1]) #'GETLOCAL(' + nmvar_to_loc(g[1]) + ')'
        if g[0] == '!LOAD_GLOBAL' and build_executable and g[1] not in d_built and\
           g[1][0] != '_' and not redefined_all  and not global_used_at_generator(g[1]):
            add_fast_glob(g[1])
            return 'GETSTATIC(' + g[1] + ')'
        if g[0] == 'LOAD_CLOSURE':
            return 'GETFREEVAR(' + g[1] + ')'


    if type(g) is int:
        return str(g)
    if type(g) is float:
        return str(g)
    if g is None:
        return 'Py_None'
    return g

dict_global_used_at_generator = {}
def global_used_at_generator(nm):
    if nm in dict_global_used_at_generator:
        return bool(dict_global_used_at_generator[nm])
    load_ = ('!LOAD_GLOBAL', nm)
    stor_ = ('STORE_GLOBAL', nm)
    dele_ = ('DELETE_GLOBAL', nm)
    load = repr(load_)
    stor = repr(stor_)
    dele = repr(dele_)
    for co in all_co.itervalues():
        if not co.can_be_codefunc():
            scmds = repr(co.cmds[1])
            if load in scmds or stor in scmds or dele in scmds:
                dict_global_used_at_generator[nm] = True
                return True
    dict_global_used_at_generator[nm] = False        
    return False    
    

def load_builtin(c):
    global loaded_builtin
    assert c in d_built
    if c in loaded_builtin:
        return 'loaded_builtin[' + str(loaded_builtin.index(c)) + ']'
    loaded_builtin.append(c)    
    return 'loaded_builtin[' + str(loaded_builtin.index(c)) + ']'
 
def generate_builtin(first2, first3):
    if len(loaded_builtin) == 0:
        return
    first2.print_to('static PyObject * loaded_builtin[' + str(len(loaded_builtin)) + '];')
    first3.print_to('static void load_builtin(void){')
    for i, c in enumerate(loaded_builtin):
        first3.print_to(ConC('loaded_builtin[',i,'] = PyDict_GetItemString(bdict, "' + str(c) + '");' ))
        first3.print_to(('if (loaded_builtin[' + str(i) + '] == 0) {printf("no builtin %s\\n");}') %c)
    first3.print_to('}')

def generate_calculated_consts(first2):
    if len(calculated_const) > 0:
        first2.print_to('static PyObject * calculated_const[' + str(len(calculated_const)) + '];')

def expand_const():
    const_to(filename)
    for k in _n2c.keys():
        const_to(k)
    i = 0
    while i < len(consts):
        assert type(i) is int
        c,type_c = consts[i]    
        if type(c) is tuple:
            [const_to(x) for x in c]
        elif type(c) is code_extended:
            if not c.can_be_codefunc() or full_pycode:
                const_to(c.co_code)
                const_to(c.co_consts)
                const_to(c.co_lnotab)
            else:   
                const_to("\x00")
                const_to(c.co_consts[:1])    
            const_to(c.co_name)
            const_to(c.co_names)
            const_to(tuple(c.co_varnames))
            const_to(c.co_freevars)
            const_to(c.co_cellvars)
        i += 1    
                        
def generate_consts(first2, first3):
    const_to(())
    expand_const()
    for i, (c,type_c) in enumerate(consts):
        if type(c) is str: 
            create_chars_const(first2, i, c)
        if type(c) is long:
            if c <= 30000 and c >= -30000:
                pass
            elif c > 0: 
                c = str(c)
                create_chars_const(first2, i, c)
            else: 
                c = str(-c)
                create_chars_const(first2, i, c)
        if type(c) is unicode:
            s = ''
            for j,code in enumerate(c):
                s += str(ord(code))
                if j < len(c)-1:
                    s += ','
            lenc = len(c)
            if lenc == 0:
                lenc = 1
                s = '0'
            first3.print_to('static wchar_t const_unicode_' + str(i) + \
                        '[' + str(lenc) + '] = {' + s + '};')
    first2.print_to('static PyObject * consts[' + str(len(consts)) + '];')
    first3.print_to('static void init_consts(void){')
    change_ob = False
  
    for i, (c,type_c) in enumerate(consts):
        if type(c) is tuple:
            codes = [(j,c1) for j,c1 in enumerate(c) if type(c1) is code_extended]
            for j, c1 in codes:
                change_ob = True
    if change_ob:            
        first3.print_to('int __ob;')
    for i, (c,type_c) in enumerate(consts):
        if type(c) is code_extended or type(c) is types.CodeType:
            first3.print_to('consts[' + str(i) + '] = Py_None;')
        elif type(c) is bool :    
            if c:
                first3.print_to('consts[' + str(i) + '] = Py_True;')
            else:    
                first3.print_to('consts[' + str(i) + '] = Py_False;')
            first3.print_to('Py_INCREF(consts[' + str(i) + ']);')
        elif type(c) is long:
            if c <= 30000 and c >= -30000:
                first3.print_to('consts[' + str(i) + '] = PyLong_FromLong(' + str(c) + ');')
            elif (c >> 31) <= 1 and (c >> 31) >= 0:
                first3.print_to('consts[' + str(i) + '] = PyLong_FromLong(' + str(c) + 'l);')
            elif c > 0:    
                if need_str_name(i, c):
                    first3.print_to('consts[' + str(i) + '] = PyLong_FromString(const_string_' + str(i) + ',NULL,10);')
                else:    
                    first3.print_to('consts[' + str(i) + '] = PyLong_FromString(' + generate_chars_literal(c) + ',NULL,10);')
            else:
                if need_str_name(i, -c):
                    first3.print_to('consts[' + str(i) + '] = PyNumber_Negative(PyLong_FromString(const_string_' + str(i) + ',NULL,10));')
                else:    
                    first3.print_to('consts[' + str(i) + '] = PyNumber_Negative(PyLong_FromString(' + generate_chars_literal(-c) + ',NULL,10));')
        elif type(c) is int:
            first3.print_to('consts[' + str(i) + '] = PyInt_FromLong (' + str(c) + 'L);')
        elif type(c) is float:
            if hasattr(math, 'isnan') and math.isnan(c):
                if not '-' in str(c):
                    first3.print_to('consts[' + str(i) + '] = PyFloat_FromDouble(Py_NAN);')
                else:    
                    first3.print_to('consts[' + str(i) + '] = PyFloat_FromDouble(-Py_NAN);')
            elif hasattr(math, 'isinf') and math.isinf(c):
                if not '-' in str(c):
                    first3.print_to('consts[' + str(i) + '] = PyFloat_FromDouble(Py_HUGE_VAL);')
                else:
                    first3.print_to('consts[' + str(i) + '] = PyFloat_FromDouble(-Py_HUGE_VAL);')
            else:    
                first3.print_to('consts[' + str(i) + '] = PyFloat_FromDouble(' + repr(c) + ');')
        elif type(c) is complex:
            first3.print_to('consts[' + str(i) + '] = PyComplex_FromDoubles(' + str(c.real) + ', ' + str(c.imag) + ');')
        elif type(c) is str: # and '"' not in c and '\n' not in c:
            if need_str_name(i, c):
                first3.print_to('consts[' + str(i) + '] = PyString_FromStringAndSize(const_string_' + str(i) + ', '+str(len(c))+');')
            else:    
                first3.print_to('consts[' + str(i) + '] = PyString_FromStringAndSize(' + generate_chars_literal(c) + ', '+str(len(c))+');')
        elif type(c) is unicode: # and '"' not in c and '\n' not in c:
            first3.print_to('consts[' + str(i) + '] = PyUnicode_FromWideChar(const_unicode_' + str(i) + ', '+str(len(c))+');')
        elif type(c) is types.EllipsisType:
            first3.print_to('consts[' + str(i) + '] = &_Py_EllipsisObject;')
            first3.print_to('Py_INCREF(consts[' + str(i) + ']);')
        elif type(c) is tuple:
            li = [const_to(x) for x in c]
            if len (li) == 0:
                first3.print_to('consts[' + str(i) + '] = PyTuple_Pack(0);')
                first3.print_to('empty_tuple = consts[' + str(i) + '];')
            else:    
                s = 'consts[' + str(i) + '] = PyTuple_Pack(' + str(len(li)) + ''.join([', ' + str(x) for x in li]) + ');'
                
                ## for j,it in enumerate(li):
                    ## s +=  str(it) 
                    ## if j < len(li) - 1:
                        ## s += ', '
                ## s += ');'        
                first3.print_to(s)
        elif c in d_built_inv:
            nm = d_built_inv[c]
            first3.print_to('consts[' + str(i) + '] = ' + load_builtin(nm) + ';')
            first3.print_to('Py_INCREF(consts[' + str(i) + ']);')
        else:
            Fatal('', type(c), c)
    for i, (c,type_c) in enumerate(consts):
        if type(c) is code_extended  or type(c) is types.CodeType:
            if type(c) is types.CodeType:
                c = all_co[c]
            nm = c.c_name
            co = c    
            if nm == '':
                Fatal('', c)
            if not co.can_be_codefunc() or (hasattr(co, 'no_codefunc') and co.no_codefunc) or co.can_be_cfunc(): ##co.co_flags & CO_GENERATOR:
                first3.print_to('consts[' + str(i) + '] = (PyObject *)PyCode_New(' +\
                    str(co.co_argcount) +', ' +\
                    str(co.co_nlocals) +', ' +\
                    str(co.co_stacksize) +', ' +\
                    str(co.co_flags) +', ' +\
                    const_to(co.co_code) +', ' +\
                    const_to(co.co_consts) +', ' +\
                    const_to(co.co_names) +', ' +\
                    const_to(tuple(co.co_varnames)) +', ' +\
                    const_to(co.co_freevars) +', ' +\
                    const_to(co.co_cellvars) +', ' +\
                    const_to(filename) +', ' +\
                    const_to(co.co_name) +', ' +\
                    str(co.co_firstlineno) +', ' +\
                    const_to(co.co_lnotab) +');')
            elif full_pycode:        
                first3.print_to('consts[' + str(i) + '] = (PyObject *)Py2CCode_New(' +\
                    str(co.co_argcount) +', ' +\
                    str(co.co_nlocals) +', ' +\
                    str(max(co.co_stacksize, co.new_stacksize)) +', ' +\
                    str(co.co_flags) +', ' +\
                    const_to(co.co_code) +', ' +\
                    const_to(co.co_consts) +', ' +\
                    const_to(co.co_names) +', ' +\
                    const_to(tuple(co.co_varnames)) +', ' +\
                    const_to(co.co_freevars) +', ' +\
                    const_to(co.co_cellvars) +', ' +\
                    const_to(filename) +', ' +\
                    const_to(c.co_name) +', ' +\
                    str(co.co_firstlineno) +', ' +\
                    const_to(co.co_lnotab) +', codefunc_' + nm +');')
            else:
                first3.print_to('consts[' + str(i) + '] = (PyObject *)Py2CCode_New(' +\
                    str(co.co_argcount) +', ' +\
                    str(co.co_nlocals) +', ' +\
                    str(max(co.co_stacksize,co.new_stacksize)) +', ' +\
                    str(co.co_flags) +', ' +\
                    const_to("\x00") +', ' +\
                    const_to(co.co_consts[:1]) +', ' +\
                    const_to(co.co_names) +', ' +\
                    const_to(tuple(co.co_varnames)) +', ' +\
                    const_to(co.co_freevars) +', ' +\
                    const_to(co.co_cellvars) +', ' +\
                    const_to(filename) +', ' +\
                    const_to(c.co_name) +', ' +\
                    str(co.co_firstlineno) +', ' +\
                    const_to("\x00") +', codefunc_' + nm +');')

            ## first3.print_to('assert (' +    const_to(co.co_names)  + ' != NULL);')
            ## first3.print_to('assert (' +    const_to(tuple(co.co_varnames))  + ' != NULL);')
            ## first3.print_to('assert (' +    const_to(co.co_freevars)  + ' != NULL);')
            ## first3.print_to('assert (' +    const_to(co.co_cellvars)  + ' != NULL);')
            ## first3.print_to('assert (' +    const_to(filename)  + ' != NULL);')
            ## first3.print_to('assert (' +    const_to(co.co_name)  + ' != NULL);')
    for i, (c,type_c) in enumerate(consts):
        if type(c) is tuple:
            codes = [(j,c1) for j,c1 in enumerate(c) if type(c1) is code_extended]
            for j, c1 in codes:
                s1 = const_to(c1)
                s_inc = 'Py_INCREF(' + s1 + ');'
                s2 = const_to(c)
                s_set = 'PyTuple_SetItem(' + s2 + ', ' + str(j) + ', ' + s1 + ');'
                first3.print_to(s_inc)
                first3.print_to('__ob = (' +s2 +')->ob_refcnt;')
                first3.print_to('(' +s2 +')->ob_refcnt = 1;')
                first3.print_to(s_set)
                first3.print_to('(' +s2 +')->ob_refcnt = __ob;')
    first3.print_to('}')

visibl = set('-=+_~!@#$%^&*()[]{};:/?.>,< ')
def is_c(c):
    for _c in c:
        if _c.isalnum() or _c in visibl:
            pass
        else:
            return False
    return True

def is_c_2(c):
    for _c in c:
        if _c.isalnum() or _c in visibl or _c in '\n\r\t':
            pass
        else:
            return False
    return True

def str_to_c_2(s):
    s2 = ''
    for c in s:
        if c.isalnum() or c in visibl:
            s2 += c
        elif c == '\n':
            s2 += '\\n'    
        elif c == '\r':
            s2 += '\\r'    
        elif c == '\t':
            s2 += '\\t'
        else:
            assert False
    return s2                

def generate_chars_literal(c):
    ## s = ''
    ## for j,code in enumerate(c):
        ## s += str(ord(code))
        ## if j < len(c)-1:
            ## s += ','
    if type(c) is int:
        return '"' + str(c) + '"'
    if type(c) is long:
        return '"' + str(c) + 'l"'
    if is_c(c):
        return '"' + c + '"'
    elif is_c_2(c):
        return '"' + str_to_c_2(c) + '"'
    else:            
        return Str_for_C(c)
    
def need_str_name(i, c):
    if i in predeclared_chars:
        return True
    if type(c) is int or type(c) is long:
        return False
    if is_c(c) or is_c_2(c):
        return False
    return True
    
def create_chars_const(first2, i, c):
    if is_c(c):
        if i in predeclared_chars:
            first2.print_to('static char const_string_' + str(i) + \
                    '[' + str(len(c)+1) + '] = "' + c + '";')
    elif is_c_2(c):
        if i in predeclared_chars:
            first2.print_to('static char const_string_' + str(i) + \
                    '[' + str(len(c)+1) + '] = "' + str_to_c_2(c) + '";')
    else:     
        s = ''       
        for j,code in enumerate(c):
            s += str(ord(code))
            if j < len(c)-1:
                s += ','
        first2.print_to('static char const_string_' + str(i) + \
                '[' + str(len(c)) + '] = {' + s + '};')

def print_to(c_f,v):
    print >> c_f, v

def index_const_to(c):
    global consts
    global consts_dict
    
    const_to(c)
    c_ = c,const_type(c)    
    if c_ in consts_dict:
        i = consts_dict[c_]
        return i
    Fatal('',c)
    return -1
    
def const_to(c):
    global consts
    global consts_dict
    
    if type(c) is code_extended:
        ## if c.c_name == 'isreadable':
            ## Fatal('isreadable', c)
        return const_to(c.co_original)
    if type(c) is tuple and len(c) > 0 and type(c[0]) is tuple and len(c[0]) > 0 and c[0][0] == '!':
        Fatal('', c)
    if c is None:
        return 'Py_None'
    c_ = c,const_type(c)    
    if c_ in consts_dict:
        i = consts_dict[c_]
        return 'consts[' + str(i) + ']'
    if type(c) is tuple:
        [const_to(x) for x in c]
    if type(c_[0]) is float:
        for i, (cc, cc_typ) in enumerate(consts):
            if type(cc) is float and hasattr(math, 'isinf') and math.isinf(cc) and  math.isinf(c_[0]) and str(cc) == str(c_[0]):
                return 'consts[' + str(i) + ']'
            if type(cc)  is float and hasattr(math, 'isnan') and math.isnan(cc) and  math.isnan(c_[0]) and str(cc) == str(c_[0]):
                return 'consts[' + str(i) + ']'
    consts.append(c_)   
    consts_dict[c_] = len(consts) - 1 
    return 'consts[' + str(len(consts)-1) + ']'

def const_type(c):
    if type(c) is tuple:
        return tuple([const_type(x) for x in c])
    if type(c) in (float, complex):
        return type(c) , repr(c)
    return type(c)
 
def pregenerate_code_objects():
    for co in _n2c.values():
        if not co.can_be_codefunc() or full_pycode: ##co.co_flags & CO_GENERATOR:
            const_to(co.co_code)
            const_to(co.co_consts)
            const_to(co.co_lnotab)
        else:
            const_to(co.co_consts[:1])    
        const_to(co.co_name)
        const_to(co.co_names)
        const_to(tuple(co.co_varnames))
        const_to(co.co_freevars)
        const_to(co.co_cellvars)
        const_to(co)

def calc_const_to(k):
    global calculated_const
    if k in calculated_const:
        return ('CALC_CONST', k)
    calculated_const[k] = len(calculated_const) 
    return ('CALC_CONST', k)
            
if __name__ == "__main__":
    ## import profile
    ## profile.runctx('main()', globals(), locals())    
    main ()

